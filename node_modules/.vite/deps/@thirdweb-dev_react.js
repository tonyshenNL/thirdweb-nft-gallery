import {
  frameWallet
} from "./chunk-KFREWXBE.js";
import {
  bloctoWallet
} from "./chunk-WUY6LIJZ.js";
import {
  ConnectModalInline,
  ConnectWallet,
  ExportLocalWallet,
  FadeIn,
  GoogleIcon,
  MediaRenderer,
  NetworkSelector,
  OTPInput,
  ThirdwebNftMedia,
  ThirdwebProvider,
  Web3Button,
  defaultTokens,
  openGoogleSignInWindow,
  paperWallet,
  shortenAddress,
  useBloctoWallet,
  useCoinbaseWallet,
  useFrameWallet,
  useInstalledWallets,
  useMetamask,
  usePaperWallet,
  usePaperWalletUserEmail,
  useRainbowWallet,
  useResolvedMediaType,
  useScreenContext,
  useTrustWallet,
  useWalletConnect,
  useWalletConnectV1
} from "./chunk-3TGQQHTB.js";
import {
  walletConnectV1
} from "./chunk-ODYM6H6C.js";
import {
  magicLink
} from "./chunk-JGT2NP66.js";
import {
  InputSelectionUI,
  emailIcon
} from "./chunk-3PNB5EFA.js";
import {
  safeWallet
} from "./chunk-W2VAAX55.js";
import {
  FormFieldWithIconButton,
  HeadlessConnectUI,
  coinbaseWallet,
  defaultWallets,
  metamaskWallet,
  phantomWallet,
  rainbowWallet,
  require_copy_to_clipboard,
  trustWallet,
  wait,
  walletConnect,
  zerionWallet
} from "./chunk-KUO4FX23.js";
import {
  Button,
  Container,
  ExclamationTriangleIcon,
  EyeClosedIcon,
  EyeOpenIcon,
  Label,
  Line,
  ModalConfigCtx,
  ModalDescription,
  ModalHeader,
  ModalTitle,
  PinBottomIcon,
  PlusIcon,
  Spacer,
  Spinner,
  Text,
  TextDivider,
  ThirdwebAuthProvider,
  ThirdwebConfigProvider,
  ThirdwebConnectedWalletProvider,
  ThirdwebProviderCore,
  ThirdwebSDKProvider,
  ThirdwebThemeContext,
  UploadIcon,
  WalletEntryButton,
  __DEV__,
  compilerMetadata,
  contractType,
  darkTheme,
  fontSize,
  getErc1155,
  getErc20,
  getErc721,
  getErcs,
  iconSize,
  invalidateContractAndBalances,
  isMobile,
  lightTheme,
  newStyled,
  radius,
  reservedScreens,
  resolveMimeType,
  shouldNeverPersistQuery,
  spacing,
  useAcceptDirectListingOffer,
  useAccountAdmins,
  useAccountAdminsAndSigners,
  useAccountSigners,
  useAccounts,
  useAccountsForAddress,
  useActiveChain,
  useActiveClaimCondition,
  useActiveClaimConditionForWallet,
  useActiveListings,
  useAddAdmin,
  useAddress,
  useAirdropNFT,
  useAllRoleMembers,
  useAppURI,
  useAuctionWinner,
  useAuth,
  useBalance,
  useBatchesToReveal,
  useBidBuffer,
  useBurnNFT,
  useBurnToken,
  useBuyDirectListing,
  useBuyNow,
  useCancelDirectListing,
  useCancelEnglishAuction,
  useCancelListing,
  useChain,
  useChainId,
  useClaimConditions,
  useClaimIneligibilityReasons,
  useClaimNFT,
  useClaimToken,
  useClaimedNFTSupply,
  useClaimedNFTs,
  useClaimerProofs,
  useCompilerMetadata,
  useConnect,
  useConnectedWallet,
  useConnectionStatus,
  useContract,
  useContractEvents,
  useContractMetadata,
  useContractMetadataUpdate,
  useContractRead,
  useContractType,
  useContractWrite,
  useCreateAccount,
  useCreateAuctionListing,
  useCreateDirectListing,
  useCreateSessionKey,
  useCreateWalletInstance,
  useDelayedRevealLazyMint,
  useDirectListing,
  useDirectListings,
  useDirectListingsCount,
  useDisconnect,
  useENS,
  useEdition,
  useEditionDrop,
  useEnglishAuction,
  useEnglishAuctionWinningBid,
  useEnglishAuctions,
  useEnglishAuctionsCount,
  useExecuteAuctionSale,
  useGrantRole,
  useIsAccountDeployed,
  useIsAddressRole,
  useIsWalletModalOpen,
  useLazyMint,
  useListing,
  useListings,
  useListingsCount,
  useLogin,
  useLogout,
  useMakeBid,
  useMakeOffer,
  useMarketplace,
  useMetadata,
  useMinimumNextBid,
  useMintNFT,
  useMintNFTSupply,
  useMintToken,
  useMultiwrap,
  useNFT,
  useNFTBalance,
  useNFTCollection,
  useNFTDrop,
  useNFTs,
  useNetwork,
  useNetworkMismatch,
  useOffers,
  useOwnedNFTs,
  usePack,
  usePlatformFees,
  usePrimarySaleRecipient,
  useReadonlySDK,
  useRemoveAdmin,
  useResetClaimConditions,
  useRevealLazyMint,
  useRevokeRole,
  useRevokeSessionKey,
  useRoleMembers,
  useRoyaltySettings,
  useSDK,
  useSDKChainId,
  useSetAllRoleMembers,
  useSetAppURI,
  useSetClaimConditions,
  useSetConnectedWallet,
  useSetConnectionStatus,
  useSetIsWalletModalOpen,
  useSetSharedMetadata,
  useSharedMetadata,
  useSignatureDrop,
  useSigner,
  useSplit,
  useStorage,
  useStorageUpload,
  useSupportedChains,
  useSupportedWallet,
  useSwitchAccount,
  useSwitchChain,
  useThirdwebAuthContext,
  useThirdwebConfigContext,
  useThirdwebConnectedWalletContext,
  useToken,
  useTokenBalance,
  useTokenDecimals,
  useTokenDrop,
  useTokenSupply,
  useTotalCirculatingSupply,
  useTotalCount,
  useTransferBatchToken,
  useTransferNFT,
  useTransferToken,
  useUnclaimedNFTSupply,
  useUnclaimedNFTs,
  useUpdateMetadata,
  useUpdatePlatformFees,
  useUpdatePrimarySaleRecipient,
  useUpdateRoyaltySettings,
  useUser,
  useValidDirectListings,
  useValidEnglishAuctions,
  useVote,
  useWallet,
  useWalletConfig,
  useWalletContext,
  useWallets,
  useWatchTransactions,
  useWinningBid
} from "./chunk-77ST2LM4.js";
import {
  BloctoWallet,
  CoinbaseWallet,
  EmbeddedWallet,
  FrameWallet,
  InjectedWallet,
  LocalWallet,
  MagicLink,
  MetaMaskWallet,
  PaperWallet,
  PhantomWallet,
  RainbowWallet,
  SafeWallet,
  SignerWallet,
  SmartWallet,
  TrustWallet,
  WalletConnect,
  ZerionWallet
} from "./chunk-QRSXBYV7.js";
import "./chunk-5TYC53HJ.js";
import "./chunk-NKSPCSHP.js";
import "./chunk-UR5JE42V.js";
import "./chunk-57S6E3JR.js";
import "./chunk-OKRZ7UBF.js";
import "./chunk-DVVEOT7N.js";
import "./chunk-3FKSJEH3.js";
import "./chunk-JWNZQLNB.js";
import "./chunk-522SDZSD.js";
import "./chunk-5MPA7Y63.js";
import "./chunk-M374DORU.js";
import "./chunk-7YNDDNAN.js";
import "./chunk-RZA7Z4CS.js";
import "./chunk-XTQZUD4R.js";
import "./chunk-W5MZI3DU.js";
import "./chunk-BTCHSOHK.js";
import "./chunk-GOBHKFVA.js";
import "./chunk-YVNWQO32.js";
import "./chunk-M52NFQDC.js";
import "./chunk-SXLQGVQL.js";
import "./chunk-335TEGGE.js";
import "./chunk-ELOBOROZ.js";
import {
  require_browser
} from "./chunk-RAQNHAFI.js";
import {
  APPROVED_IMPLEMENTATIONS,
  ContractDeployer,
  EditionMetadataInputOrUriSchema,
  EditionMetadataInputSchema,
  EditionMetadataOutputSchema,
  EditionMetadataWithOwnerOutputSchema,
  LOCAL_NODE_PKEY,
  OptionalPropertiesInput,
  ProposalState,
  SUPPORTED_CHAIN_IDS,
  ThirdwebSDK,
  TokenMintInputSchema,
  UserWallet,
  checkClientIdOrSecretKey,
  checkVerificationStatus,
  computeCloneFactoryAddress,
  computeNativeTokenAddress,
  convertParamValues,
  deployContractDeterministicRaw,
  deployCreate2Factory,
  directDeployDeterministic,
  directDeployDeterministicPublished,
  directDeployDeterministicWithUri,
  extractFunctionParamsFromAbi,
  getAllDetectedExtensionNames,
  getAllDetectedFeatureNames,
  getApprovedImplementation,
  getBlock,
  getBlockNumber,
  getBlockWithTransactions,
  getCachedAbiForContract,
  getChainId,
  getContract,
  getContractFromAbi,
  getDefaultTrustedForwarders,
  getDeployArguments,
  getEncodedConstructorParamsForThirdwebContract,
  getRpcUrl,
  getThirdwebContractAddress,
  getTrustedForwarders,
  isVerifiedOnEtherscan,
  matchesPrebuiltAbi,
  predictAddressDeterministic,
  predictAddressDeterministicPublished,
  predictAddressDeterministicWithUri,
  predictThirdwebContractAddress,
  toDisplayValue,
  toEther,
  toUnits,
  verify,
  verifyThirdwebPrebuiltImplementation,
  watchBlock,
  watchBlockNumber,
  watchBlockWithTransactions,
  watchTransactions
} from "./chunk-IMOUKQFE.js";
import "./chunk-4AECB7WU.js";
import "./chunk-EN6OYJQI.js";
import "./chunk-QFON7SJB.js";
import "./chunk-YVVOYWOS.js";
import "./chunk-VP554X2I.js";
import "./chunk-7DCR5SHS.js";
import "./chunk-LUVJIMOL.js";
import "./chunk-OJYKRRB6.js";
import "./chunk-L522MT4Y.js";
import "./chunk-3WUVUY2B.js";
import "./chunk-IH4C6MBP.js";
import "./chunk-DIF3NZXX.js";
import "./chunk-DJYJ43V7.js";
import {
  TokenERC20History
} from "./chunk-CMG463H5.js";
import {
  StandardErc20
} from "./chunk-C2U4PZIV.js";
import {
  VoteType
} from "./chunk-OSDE57YG.js";
import {
  hasERC20Allowance
} from "./chunk-USBGSO3Z.js";
import {
  StandardErc721
} from "./chunk-TSMZWANX.js";
import {
  require_jsx_runtime
} from "./chunk-7AFDRFCP.js";
import {
  DropErc1155History
} from "./chunk-KCWMMULV.js";
import {
  PAPER_API_URL,
  PaperCheckout,
  createCheckoutLinkIntent,
  fetchRegisteredCheckoutId,
  parseChainIdToPaperChain
} from "./chunk-3KSXCWDR.js";
import {
  StandardErc1155
} from "./chunk-LNFR5WGZ.js";
import {
  ListingType,
  MarketplaceAuction,
  MarketplaceDirect
} from "./chunk-RP2SQVHU.js";
import {
  ALL_ROLES,
  AbiObjectSchema,
  AbiSchema,
  AbiTypeSchema,
  Account,
  AccountFactory,
  AddressOrEnsSchema,
  AddressSchema,
  AdminRoleMissingError,
  AssetNotFoundError,
  AuctionAlreadyStartedError,
  AuctionHasNotEndedError,
  BYOCContractMetadataSchema,
  BaseSignaturePayloadInput,
  BigNumberSchema,
  BigNumberTransformSchema,
  BigNumberishSchema,
  COMMON_FACTORY,
  CONTRACTS_MAP,
  CONTRACT_ADDRESSES,
  CREATE2_FACTORY_BYTECODE,
  CallOverrideSchema,
  ChainId,
  ChainIdToAddressSchema,
  ClaimConditionInputArray,
  ClaimConditionInputSchema,
  ClaimConditionMetadataSchema,
  ClaimConditionOutputSchema,
  ClaimEligibility,
  CommonContractOutputSchema,
  CommonContractSchema,
  CommonPlatformFeeSchema,
  CommonPrimarySaleSchema,
  CommonRoyaltySchema,
  CommonSymbolSchema,
  CommonTrustedForwarderSchema,
  CompilerMetadataFetchedSchema,
  ContractAppURI,
  ContractEncoder,
  ContractEvents,
  ContractInfoSchema,
  ContractInterceptor,
  ContractMetadata,
  ContractOwner,
  ContractPlatformFee,
  ContractPrimarySale,
  ContractPublishedMetadata,
  ContractRoles,
  ContractRoyalty,
  CurrencySchema,
  CurrencyValueSchema,
  CustomContractDeploy,
  CustomContractInput,
  CustomContractOutput,
  CustomContractSchema,
  CustomFactoryInput,
  DEPLOYER_ABI,
  DEPLOYER_BYTECODE,
  DelayedReveal,
  DeployTransaction,
  DeployTypeInput,
  DeploymentNetworkInput,
  DropClaimConditions,
  DropErc1155ClaimConditions,
  DuplicateFileNameError,
  DuplicateLeafsError,
  EditionDropInitializer,
  EditionInitializer,
  EndDateSchema,
  Erc1155,
  Erc1155BatchMintable,
  Erc1155Burnable,
  Erc1155Enumerable,
  Erc1155LazyMintable,
  Erc1155Mintable,
  Erc1155SignatureMintable,
  Erc20,
  Erc20BatchMintable,
  Erc20Burnable,
  Erc20ClaimableWithConditions,
  Erc20Droppable,
  Erc20Mintable,
  Erc20SignatureMintable,
  Erc721,
  Erc721BatchMintable,
  Erc721Burnable,
  Erc721Claimable,
  Erc721ClaimableWithConditions,
  Erc721Enumerable,
  Erc721LazyMintable,
  Erc721Mintable,
  Erc721Supply,
  Erc721TieredDrop,
  Erc721WithQuantitySignatureMintable,
  EventType,
  ExtensionNotImplementedError,
  ExtraPublishMetadataSchemaInput,
  ExtraPublishMetadataSchemaOutput,
  FactoryDeploymentSchema,
  FetchError,
  FileNameMissingError,
  FullPublishMetadataSchemaInput,
  FullPublishMetadataSchemaOutput,
  FunctionDeprecatedError,
  GAS_LIMIT_FOR_DEPLOYER,
  GasCostEstimator,
  GenericRequest,
  InterfaceId_IERC1155,
  InterfaceId_IERC721,
  InvalidAddressError,
  LINK_TOKEN_ADDRESS,
  ListingNotFoundError,
  MarketplaceInitializer,
  MarketplaceV3DirectListings,
  MarketplaceV3EnglishAuctions,
  MarketplaceV3Initializer,
  MarketplaceV3Offers,
  MerkleSchema,
  MintRequest1155,
  MintRequest20,
  MintRequest721,
  MintRequest721withQuantity,
  MissingOwnerRoleError,
  MissingRoleError,
  MultiwrapInitializer,
  NATIVE_TOKENS,
  NATIVE_TOKEN_ADDRESS,
  NFTCollectionInitializer,
  NFTDropInitializer,
  NotEnoughTokensError,
  NotFoundError,
  OZ_DEFENDER_FORWARDER_ADDRESS,
  PREBUILT_CONTRACTS_APPURI_MAP,
  PREBUILT_CONTRACTS_MAP,
  PackInitializer,
  PartialClaimConditionInputSchema,
  PermissionSnapshotSchema,
  PreDeployMetadata,
  PreDeployMetadataFetchedSchema,
  ProfileSchemaInput,
  ProfileSchemaOutput,
  PublishedContractSchema,
  QuantityAboveLimitError,
  RawDateSchema,
  RestrictedTransferError,
  RouterTypeInput,
  SIGNATURE,
  SUPPORTED_FEATURES,
  Signature1155PayloadInput,
  Signature1155PayloadInputWithTokenId,
  Signature1155PayloadOutput,
  Signature20PayloadInput,
  Signature20PayloadOutput,
  Signature721PayloadInput,
  Signature721PayloadOutput,
  Signature721WithQuantityInput,
  Signature721WithQuantityOutput,
  SignatureDropInitializer,
  SignerPermissionRequest,
  SignerPermissionsSchema,
  SnapshotEntryInput,
  SnapshotEntryWithProofSchema,
  SnapshotInfoSchema,
  SnapshotInputSchema,
  SnapshotSchema,
  SplitInitializer,
  StartDateSchema,
  StaticJsonRpcBatchProvider,
  Status,
  THIRDWEB_DEPLOYER,
  TokenDropInitializer,
  TokenInitializer,
  Transaction,
  TransactionError,
  UploadError,
  VoteInitializer,
  WrongListingTypeError,
  approveErc20Allowance,
  assertEnabled,
  biconomySendFunction,
  cleanCurrencyAddress,
  computeDeploymentAddress,
  computeDeploymentInfo,
  computeEOAForwarderAddress,
  computeForwarderAddress,
  constructAbiFromBytecode,
  convertToReadableQuantity,
  createSnapshot,
  createTransactionBatches,
  defaultGaslessSendFunction,
  defenderSendFunction,
  deployContractDeterministic,
  deployWithThrowawayDeployer,
  detectContractFeature,
  detectFeatures,
  detectFeaturesFromBytecode,
  encodeConstructorParamsForImplementation,
  estimateGasForDeploy,
  extractCommentFromMetadata,
  extractConstructorParams,
  extractConstructorParamsFromAbi,
  extractEventsFromAbi,
  extractFunctions,
  extractFunctionsFromAbi,
  extractIPFSHashFromBytecode,
  extractMinimalProxyImplementationAddress,
  fetchAbiFromAddress,
  fetchAndCacheDeployMetadata,
  fetchContractMetadata,
  fetchContractMetadataFromAddress,
  fetchCurrencyMetadata,
  fetchCurrencyValue,
  fetchExtendedReleaseMetadata,
  fetchPreDeployMetadata,
  fetchPublishedContractFromPolygon,
  fetchRawPredeployMetadata,
  fetchSnapshotEntryForAddress,
  fetchSourceFilesFromMetadata,
  getAllDetectedExtensions,
  getAllDetectedExtensionsFromBytecode,
  getAllDetectedFeatures,
  getChainIdFromNetwork,
  getChainIdOrName,
  getChainProvider,
  getContractAddressByChainId,
  getContractName,
  getContractPublisherAddress,
  getContractTypeForRemoteName,
  getCreate2FactoryAddress,
  getCreate2FactoryDeploymentInfo,
  getDefaultGasOverrides,
  getDeploymentInfo,
  getDynamicFeeData,
  getGasPrice,
  getInitBytecodeWithSalt,
  getKeylessTxn,
  getMultichainRegistryAddress,
  getNativeTokenByChainId,
  getPolygonGasPriorityFee,
  getProviderFromRpcUrl,
  getRoleHash,
  getSaltHash,
  getSignerAndProvider,
  getSupportedChains,
  hasFunction,
  hasMatchingAbi,
  includesErrorMessage,
  isChainConfig,
  isContractDeployed,
  isDowngradeVersion,
  isEIP155Enforced,
  isExtensionEnabled,
  isFeatureEnabled,
  isIncrementalVersion,
  isNativeToken,
  isProvider,
  isSigner,
  joinABIs,
  matchesAbiFromBytecode,
  normalizeAmount,
  normalizePriceValue,
  parseRevertReason,
  prepareGaslessRequest,
  resolveAddress,
  resolveContractUriAndBytecode,
  resolveContractUriFromAddress,
  resolveEns,
  resolveImplementation,
  setErc20Allowance,
  setSupportedChains,
  toSemver,
  toWei
} from "./chunk-PDTS4OI3.js";
import "./chunk-KPMLBYIV.js";
import "./chunk-QJWU7UES.js";
import "./chunk-F44DUYBV.js";
import "./chunk-LMS4WD7T.js";
import {
  init_lib7 as init_lib
} from "./chunk-FSHZLPV2.js";
import "./chunk-LXGF3WSV.js";
import "./chunk-HBS2L7KZ.js";
import "./chunk-JCGZRZHH.js";
import "./chunk-2LHQRALI.js";
import "./chunk-D2OR6HFD.js";
import {
  require_react
} from "./chunk-AC6AORDV.js";
import {
  init_shim
} from "./chunk-DLIX7YGU.js";
import {
  __toESM
} from "./chunk-EUIKE2YQ.js";

// node_modules/@thirdweb-dev/react/dist/thirdweb-dev-react.browser.esm.js
init_shim();
var import_react3 = __toESM(require_react());
var import_jsx_runtime = __toESM(require_jsx_runtime());

// node_modules/@thirdweb-dev/react/dist/useSafe-17873824.browser.esm.js
init_shim();
var import_react = __toESM(require_react());
function useSafe() {
  const connect = useConnect();
  return (0, import_react.useCallback)(async (connectProps) => {
    const {
      safeWallet: safeWallet2
    } = await import("./safeWallet-1c3642a3.browser.esm-6B2RCXZY.js");
    return connect(safeWallet2(), connectProps);
  }, [connect]);
}

// node_modules/@thirdweb-dev/react/dist/useMagic-1082ce04.browser.esm.js
init_shim();
var import_react2 = __toESM(require_react());
function useMagic() {
  const connect = useConnect();
  return (0, import_react2.useCallback)(async (options) => {
    const {
      magicLink: magicLink2
    } = await import("./magicLink-a4683714.browser.esm-U7KJQPZ5.js");
    return connect(magicLink2(options), options);
  }, [connect]);
}

// node_modules/@thirdweb-dev/react/dist/thirdweb-dev-react.browser.esm.js
var import_copy_to_clipboard = __toESM(require_copy_to_clipboard());
init_lib();
var import_qrcode = __toESM(require_browser());
function useSmartWallet() {
  const connect = useConnect();
  return (0, import_react3.useCallback)(async (wallet, options) => {
    const {
      smartWallet: smartWallet2
    } = await Promise.resolve().then(function() {
      return smartWallet$1;
    });
    return connect(smartWallet2(wallet, options), options);
  }, [connect]);
}
var EmbeddedWalletFormUI = (props) => {
  const createWalletInstance = useCreateWalletInstance();
  const setConnectionStatus = useSetConnectionStatus();
  const setConnectedWallet = useSetConnectedWallet();
  const googleLogin = async () => {
    try {
      const embeddedWallet2 = createWalletInstance(props.walletConfig);
      setConnectionStatus("connecting");
      const googleWindow = openGoogleSignInWindow();
      if (!googleWindow) {
        throw new Error("Failed to open google login window");
      }
      await embeddedWallet2.connect({
        loginType: "headless_google_oauth",
        openedWindow: googleWindow,
        closeOpenedWindow: (openedWindow) => {
          openedWindow.close();
        }
      });
      setConnectedWallet(embeddedWallet2);
    } catch (e) {
      setConnectionStatus("disconnected");
      console.error(e);
    }
  };
  return (0, import_jsx_runtime.jsxs)("div", {
    children: [(0, import_jsx_runtime.jsxs)(SocialButton, {
      variant: "secondary",
      fullWidth: true,
      onClick: () => {
        googleLogin();
        props.onSelect({
          google: true
        });
      },
      children: [(0, import_jsx_runtime.jsx)(GoogleIcon, {
        size: iconSize.md
      }), "Sign in with Google"]
    }), (0, import_jsx_runtime.jsx)(Spacer, {
      y: "lg"
    }), (0, import_jsx_runtime.jsx)(TextDivider, {
      children: (0, import_jsx_runtime.jsx)("span", {
        children: "OR"
      })
    }), (0, import_jsx_runtime.jsx)(Spacer, {
      y: "lg"
    }), (0, import_jsx_runtime.jsx)(InputSelectionUI, {
      onSelect: (email) => props.onSelect({
        email
      }),
      placeholder: "Enter your email address",
      name: "email",
      type: "email",
      errorMessage: (_input) => {
        const input = _input.replace(/\+/g, "");
        const emailRegex = /^([a-z0-9_\.-]+)@([\da-z\.-]+)\.([a-z\.]{2,})$/g;
        const isValidEmail = emailRegex.test(input);
        if (!isValidEmail) {
          return "Invalid email address";
        }
      },
      emptyErrorMessage: "email address is required",
      showOrSeparator: props.showOrSeparator
    })]
  });
};
var EmbeddedWalletFormUIScreen = (props) => {
  const isCompact = props.modalSize === "compact";
  return (0, import_jsx_runtime.jsxs)(Container, {
    fullHeight: true,
    flex: "column",
    p: "lg",
    animate: "fadein",
    style: {
      minHeight: "250px"
    },
    children: [(0, import_jsx_runtime.jsx)(ModalHeader, {
      onBack: props.onBack,
      title: "Sign in"
    }), isCompact ? (0, import_jsx_runtime.jsx)(Spacer, {
      y: "xl"
    }) : null, (0, import_jsx_runtime.jsx)(Container, {
      expand: true,
      flex: "column",
      center: "y",
      p: isCompact ? void 0 : "lg",
      children: (0, import_jsx_runtime.jsx)(EmbeddedWalletFormUI, {
        walletConfig: props.walletConfig,
        onSelect: props.onSelect,
        showOrSeparator: false
      })
    })]
  });
};
var SocialButton = newStyled(Button)`
  display: flex;
  justify-content: center;
  gap: ${spacing.sm};
`;
var EmbeddedWalletGoogleLogin = (props) => {
  const {
    goBack,
    modalSize
  } = props;
  const createWalletInstance = useCreateWalletInstance();
  const setConnectionStatus = useSetConnectionStatus();
  const setConnectedWallet = useSetConnectedWallet();
  const connectionStatus = useConnectionStatus();
  const googleLogin = async () => {
    try {
      const embeddedWallet2 = createWalletInstance(props.walletConfig);
      setConnectionStatus("connecting");
      const googleWindow = openGoogleSignInWindow();
      if (!googleWindow) {
        throw new Error("Failed to open google login window");
      }
      await embeddedWallet2.connect({
        loginType: "headless_google_oauth",
        openedWindow: googleWindow,
        closeOpenedWindow: (openedWindow) => {
          openedWindow.close();
        }
      });
      setConnectedWallet(embeddedWallet2);
      props.close();
    } catch (e) {
      setConnectionStatus("disconnected");
      console.error("Error logging into google", e);
    }
  };
  const closeModal = props.close;
  (0, import_react3.useEffect)(() => {
    if (connectionStatus === "connected") {
      closeModal();
    }
  }, [connectionStatus, closeModal]);
  return (0, import_jsx_runtime.jsx)(Container, {
    animate: "fadein",
    flex: "column",
    fullHeight: true,
    children: (0, import_jsx_runtime.jsxs)(Container, {
      flex: "column",
      expand: true,
      p: "lg",
      style: {
        paddingBottom: 0
      },
      children: [(0, import_jsx_runtime.jsx)(ModalHeader, {
        title: (0, import_jsx_runtime.jsxs)(Container, {
          flex: "row",
          center: "both",
          gap: "xs",
          children: [(0, import_jsx_runtime.jsx)(GoogleIcon, {
            size: iconSize.md
          }), (0, import_jsx_runtime.jsx)(ModalTitle, {
            children: " Sign in "
          })]
        }),
        onBack: goBack
      }), modalSize === "compact" ? (0, import_jsx_runtime.jsx)(Spacer, {
        y: "xl"
      }) : null, (0, import_jsx_runtime.jsxs)(Container, {
        flex: "column",
        center: "both",
        expand: true,
        style: {
          textAlign: "center",
          minHeight: "250px"
        },
        children: [connectionStatus === "connecting" && (0, import_jsx_runtime.jsxs)(Container, {
          animate: "fadein",
          children: [(0, import_jsx_runtime.jsx)(Text, {
            color: "primaryText",
            multiline: true,
            style: {
              maxWidth: "250px"
            },
            children: "Select your Google account in the pop-up"
          }), (0, import_jsx_runtime.jsx)(Spacer, {
            y: "xl"
          }), (0, import_jsx_runtime.jsx)(Container, {
            center: "x",
            flex: "row",
            children: (0, import_jsx_runtime.jsx)(Spinner, {
              size: "lg",
              color: "accentText"
            })
          }), (0, import_jsx_runtime.jsx)(Spacer, {
            y: "xxl"
          })]
        }), connectionStatus === "disconnected" && (0, import_jsx_runtime.jsxs)(Container, {
          animate: "fadein",
          children: [(0, import_jsx_runtime.jsx)(Text, {
            color: "danger",
            children: "Failed to sign in"
          }), (0, import_jsx_runtime.jsx)(Spacer, {
            y: "lg"
          }), (0, import_jsx_runtime.jsxs)(Button, {
            variant: "primary",
            onClick: googleLogin,
            children: [" ", "Retry", " "]
          }), (0, import_jsx_runtime.jsx)(Spacer, {
            y: "xxl"
          })]
        })]
      })]
    })
  });
};
var EmbeddedWalletOTPLoginUI = (props) => {
  const email = props.selectionData;
  const [otpInput, setOtpInput] = (0, import_react3.useState)("");
  const {
    createWalletInstance,
    setConnectedWallet,
    setConnectionStatus
  } = useWalletContext();
  const [wallet, setWallet] = (0, import_react3.useState)(null);
  const isWideModal = props.modalSize === "wide";
  const [verifyStatus, setVerifyStatus] = (0, import_react3.useState)("idle");
  const [sendEmailOtpStatus, setSendEmailOtpStatus] = (0, import_react3.useState)("sending");
  const sendEmail = (0, import_react3.useCallback)(async () => {
    setOtpInput("");
    setVerifyStatus("idle");
    setSendEmailOtpStatus("sending");
    try {
      const _wallet = createWalletInstance(props.walletConfig);
      setWallet(_wallet);
      const _embeddedWalletSdk = await _wallet.getEmbeddedWalletSDK();
      await _embeddedWalletSdk.auth.sendEmailLoginOtp({
        email
      });
      setSendEmailOtpStatus("sent");
    } catch (e) {
      console.error(e);
      setVerifyStatus("idle");
      setSendEmailOtpStatus("error");
    }
  }, [createWalletInstance, email, props.walletConfig]);
  const handleSubmit = (otp) => {
    if (sendEmailOtpStatus !== "sent" || otp.length !== 6) {
      return;
    }
    verifyCodes(otp);
  };
  const verifyCodes = async (otp) => {
    setVerifyStatus("idle");
    if (!wallet) {
      return;
    }
    try {
      setVerifyStatus("verifying");
      setConnectionStatus("connecting");
      await wallet.connect({
        loginType: "headless_email_otp_verification",
        email,
        otp
      });
      setConnectedWallet(wallet);
      setVerifyStatus("valid");
      props.close();
    } catch (e) {
      setVerifyStatus("invalid");
      console.error(e);
    }
  };
  const emailSentOnMount = (0, import_react3.useRef)(false);
  (0, import_react3.useEffect)(() => {
    if (!emailSentOnMount.current) {
      emailSentOnMount.current = true;
      sendEmail();
    }
  }, [sendEmail]);
  return (0, import_jsx_runtime.jsxs)(Container, {
    fullHeight: true,
    flex: "column",
    animate: "fadein",
    children: [(0, import_jsx_runtime.jsx)(Container, {
      p: "lg",
      children: (0, import_jsx_runtime.jsx)(ModalHeader, {
        title: "Sign in",
        onBack: props.goBack
      })
    }), (0, import_jsx_runtime.jsx)(Container, {
      expand: true,
      flex: "column",
      center: "y",
      children: (0, import_jsx_runtime.jsxs)("form", {
        onSubmit: (e) => {
          e.preventDefault();
        },
        children: [(0, import_jsx_runtime.jsxs)("div", {
          style: {
            textAlign: "center"
          },
          children: [!isWideModal && (0, import_jsx_runtime.jsx)(Spacer, {
            y: "xl"
          }), (0, import_jsx_runtime.jsx)(Text, {
            children: "Enter the OTP sent to"
          }), (0, import_jsx_runtime.jsx)(Spacer, {
            y: "sm"
          }), (0, import_jsx_runtime.jsx)(Text, {
            color: "primaryText",
            children: email
          }), (0, import_jsx_runtime.jsx)(Spacer, {
            y: "xxl"
          })]
        }), (0, import_jsx_runtime.jsx)(OTPInput, {
          isInvalid: verifyStatus === "invalid",
          digits: 6,
          value: otpInput,
          setValue: (value) => {
            setOtpInput(value);
            setVerifyStatus("idle");
            handleSubmit(value);
          },
          onEnter: () => {
            handleSubmit(otpInput);
          }
        }), verifyStatus === "invalid" && (0, import_jsx_runtime.jsxs)(FadeIn, {
          children: [(0, import_jsx_runtime.jsx)(Spacer, {
            y: "md"
          }), (0, import_jsx_runtime.jsx)(Text, {
            size: "sm",
            color: "danger",
            center: true,
            children: "Invalid OTP"
          })]
        }), (0, import_jsx_runtime.jsx)(Spacer, {
          y: "xxl"
        }), (0, import_jsx_runtime.jsx)(Container, {
          px: isWideModal ? "xxl" : "lg",
          children: verifyStatus === "verifying" ? (0, import_jsx_runtime.jsx)(import_jsx_runtime.Fragment, {
            children: (0, import_jsx_runtime.jsx)(Container, {
              flex: "row",
              center: "x",
              animate: "fadein",
              children: (0, import_jsx_runtime.jsx)(Spinner, {
                size: "lg",
                color: "accentText"
              })
            })
          }) : (0, import_jsx_runtime.jsx)(Container, {
            animate: "fadein",
            children: (0, import_jsx_runtime.jsx)(Button, {
              onClick: () => handleSubmit(otpInput),
              variant: "accent",
              type: "submit",
              style: {
                width: "100%"
              },
              children: "Verify"
            })
          }, "btn-container")
        }), (0, import_jsx_runtime.jsx)(Spacer, {
          y: "xxl"
        }), !isWideModal && (0, import_jsx_runtime.jsx)(Line, {}), (0, import_jsx_runtime.jsxs)(Container, {
          p: isWideModal ? void 0 : "lg",
          children: [sendEmailOtpStatus === "error" && (0, import_jsx_runtime.jsxs)(import_jsx_runtime.Fragment, {
            children: [(0, import_jsx_runtime.jsx)(Text, {
              size: "sm",
              center: true,
              color: "danger",
              children: "Failed to send OTP"
            }), (0, import_jsx_runtime.jsx)(Spacer, {
              y: "md"
            })]
          }), sendEmailOtpStatus === "sending" && (0, import_jsx_runtime.jsxs)(Container, {
            flex: "row",
            center: "both",
            gap: "xs",
            style: {
              textAlign: "center"
            },
            children: [(0, import_jsx_runtime.jsx)(Text, {
              size: "sm",
              children: "Sending OTP"
            }), (0, import_jsx_runtime.jsx)(Spinner, {
              size: "xs",
              color: "secondaryText"
            })]
          }), sendEmailOtpStatus === "sent" && (0, import_jsx_runtime.jsx)(LinkButton, {
            onClick: sendEmail,
            type: "button",
            children: "Resend OTP"
          })]
        })]
      })
    })]
  });
};
var LinkButton = newStyled.button`
  all: unset;
  color: ${(p) => p.theme.colors.accentText};
  font-size: ${fontSize.sm};
  cursor: pointer;
  text-align: center;
  font-weight: 500;
  width: 100%;
  &:hover {
    color: ${(p) => p.theme.colors.primaryText};
  }
`;
var embeddedWallet = (config) => {
  return {
    category: "socialLogin",
    id: EmbeddedWallet.id,
    recommended: config == null ? void 0 : config.recommended,
    meta: {
      ...EmbeddedWallet.meta,
      name: "Email",
      iconURL: emailIcon
    },
    create(options) {
      return new EmbeddedWallet({
        ...options,
        ...config,
        clientId: (options == null ? void 0 : options.clientId) ?? ""
      });
    },
    selectUI(props) {
      return (0, import_jsx_runtime.jsx)(EmbeddedWalletSelectionUI, {
        ...props
      });
    },
    connectUI(props) {
      return (0, import_jsx_runtime.jsx)(EmbeddedWalletConnectUI, {
        ...props
      });
    }
  };
};
var EmbeddedWalletSelectionUI = (props) => {
  const screen = useScreenContext();
  if (props.modalSize === "wide" || screen !== reservedScreens.main && props.modalSize === "compact") {
    return (0, import_jsx_runtime.jsx)(WalletEntryButton, {
      walletConfig: props.walletConfig,
      selectWallet: () => {
        props.onSelect(void 0);
      }
    });
  }
  return (0, import_jsx_runtime.jsx)("div", {
    children: (0, import_jsx_runtime.jsx)(EmbeddedWalletFormUI, {
      showOrSeparator: props.supportedWallets.length > 1,
      onSelect: props.onSelect,
      walletConfig: props.walletConfig
    })
  });
};
var EmbeddedWalletConnectUI = (props) => {
  const [loginType, setLoginType] = (0, import_react3.useState)(props.selectionData);
  if (loginType) {
    const handleBack = () => {
      if (props.modalSize === "wide") {
        setLoginType(void 0);
      } else {
        props.goBack();
      }
    };
    if ("email" in loginType) {
      return (0, import_jsx_runtime.jsx)(EmbeddedWalletOTPLoginUI, {
        ...props,
        selectionData: loginType.email,
        goBack: handleBack
      });
    } else {
      return (0, import_jsx_runtime.jsx)(EmbeddedWalletGoogleLogin, {
        ...props,
        goBack: handleBack
      });
    }
  }
  return (0, import_jsx_runtime.jsx)(EmbeddedWalletFormUIScreen, {
    modalSize: props.modalSize,
    onSelect: (_loginType) => {
      setLoginType(_loginType);
    },
    walletConfig: props.walletConfig,
    onBack: props.goBack
  });
};
function useLocalWalletInfo(localWalletConfig, persist) {
  const [walletData, setWalletData] = (0, import_react3.useState)("loading");
  const createWalletInstance = useCreateWalletInstance();
  const [localWallet2, setLocalWallet] = (0, import_react3.useState)(null);
  (0, import_react3.useEffect)(() => {
    const wallet = createWalletInstance(localWalletConfig);
    setLocalWallet(wallet);
    if (persist) {
      wallet.getSavedData().then((data) => {
        setWalletData(data);
      });
    }
  }, [createWalletInstance, localWalletConfig, persist]);
  return {
    setLocalWallet,
    localWallet: localWallet2,
    walletData,
    meta: localWalletConfig.meta,
    persist
  };
}
var DragNDrop = (props) => {
  const [error, setError] = (0, import_react3.useState)(false);
  const [uploaded, setUploaded] = (0, import_react3.useState)();
  const [isDragging, setIsDragging] = (0, import_react3.useState)(false);
  const dragIn = (e) => {
    setError(false);
    setUploaded(void 0);
    setIsDragging(true);
    e.preventDefault();
    e.stopPropagation();
  };
  const dragOut = (e) => {
    setIsDragging(false);
    e.preventDefault();
    e.stopPropagation();
  };
  const handleFileUpload = (file) => {
    if (file.type !== props.accept) {
      setError(true);
    } else {
      setUploaded(file);
      props.onUpload(file);
    }
  };
  const drop = (e) => {
    setIsDragging(false);
    e.preventDefault();
    e.stopPropagation();
    if (e.dataTransfer.files && e.dataTransfer.files.length > 0) {
      const fileContent = e.dataTransfer.files[0];
      if (fileContent) {
        handleFileUpload(fileContent);
        e.dataTransfer.clearData();
      }
    }
  };
  const message = isMobile() ? "Click to Upload" : "Drop your file here or click to upload";
  return (0, import_jsx_runtime.jsx)("div", {
    onDragEnter: dragIn,
    onDragLeave: dragOut,
    onDragOver: (e) => {
      setIsDragging(true);
      e.preventDefault();
      e.stopPropagation();
    },
    onClick: () => {
      setError(false);
    },
    onDrop: drop,
    style: {
      cursor: "pointer"
    },
    children: (0, import_jsx_runtime.jsxs)("label", {
      htmlFor: "file-upload",
      children: [(0, import_jsx_runtime.jsx)("input", {
        id: "file-upload",
        type: "file",
        accept: props.accept,
        multiple: false,
        style: {
          display: "none"
        },
        onChange: (e) => {
          if (e.target.files && e.target.files[0]) {
            handleFileUpload(e.target.files[0]);
          }
        }
      }), (0, import_jsx_runtime.jsx)(DropContainer, {
        "data-error": error,
        "data-is-dragging": isDragging,
        children: !uploaded ? (0, import_jsx_runtime.jsxs)(import_jsx_runtime.Fragment, {
          children: [" ", (0, import_jsx_runtime.jsx)(UploadIconSecondary, {
            width: iconSize.lg,
            height: iconSize.lg
          }), (0, import_jsx_runtime.jsx)(Spacer, {
            y: "md"
          }), (0, import_jsx_runtime.jsxs)(Text, {
            color: "primaryText",
            weight: 600,
            center: true,
            multiline: true,
            children: [" ", message]
          }), (0, import_jsx_runtime.jsx)(Spacer, {
            y: "lg"
          }), error ? (0, import_jsx_runtime.jsxs)(Text, {
            color: "danger",
            size: "sm",
            children: [" ", "Please upload a ", props.extension, " file", " "]
          }) : (0, import_jsx_runtime.jsxs)(Text, {
            size: "sm",
            children: [" ", props.extension, " "]
          })]
        }) : (0, import_jsx_runtime.jsxs)(import_jsx_runtime.Fragment, {
          children: [(0, import_jsx_runtime.jsxs)(Text, {
            weight: 600,
            color: "primaryText",
            center: true,
            multiline: true,
            children: [uploaded.name, " uploaded successfully"]
          }), (0, import_jsx_runtime.jsx)(Spacer, {
            y: "md"
          }), (0, import_jsx_runtime.jsx)(Container, {
            color: "success",
            children: (0, import_jsx_runtime.jsx)(CheckCircleIcon, {
              size: iconSize.xl
            })
          })]
        })
      })]
    })
  });
};
var UploadIconSecondary = newStyled(UploadIcon)`
  color: ${(props) => props.theme.colors.secondaryIconColor};
  transition:
    transform 200ms ease,
    color 200ms ease;
`;
var DropContainer = newStyled.div`
  border: 2px solid ${(p) => p.theme.colors.borderColor};
  border-radius: ${radius.md};
  padding: ${spacing.xl} ${spacing.md};
  display: flex;
  align-items: center;
  flex-direction: column;
  cursor: pointer;
  transition: border-color 200ms ease;

  &:hover,
  &[data-is-dragging="true"] {
    border-color: ${(p) => p.theme.colors.accentText};
    svg {
      color: ${(p) => p.theme.colors.accentText};
    }
  }

  &[data-error="true"] {
    border-color: ${(p) => p.theme.colors.danger};
  }
`;
var CheckCircleIcon = (props) => (0, import_jsx_runtime.jsxs)("svg", {
  width: props.size,
  height: props.size,
  viewBox: "0 0 38 38",
  fill: "none",
  xmlns: "http://www.w3.org/2000/svg",
  children: [(0, import_jsx_runtime.jsx)("path", {
    d: "M35.6666 17.4671V19.0004C35.6645 22.5945 34.5008 26.0916 32.3488 28.9701C30.1969 31.8487 27.1721 33.9546 23.7255 34.9736C20.279 35.9926 16.5954 35.8703 13.224 34.6247C9.85272 33.3792 6.97434 31.0773 5.01819 28.0622C3.06203 25.0472 2.1329 21.4805 2.36938 17.8943C2.60586 14.308 3.99526 10.8943 6.33039 8.16221C8.66551 5.43012 11.8212 3.52606 15.3269 2.734C18.8326 1.94194 22.5004 2.30432 25.7833 3.76709",
    stroke: "currentColor",
    strokeWidth: "3.33333",
    strokeLinecap: "round",
    strokeLinejoin: "round"
  }), (0, import_jsx_runtime.jsx)("path", {
    d: "M35.6667 5.66699L19 22.3503L14 17.3503",
    stroke: "currentColor",
    strokeWidth: "3.33333",
    strokeLinecap: "round",
    strokeLinejoin: "round"
  })]
});
var ImportLocalWallet = (props) => {
  const [jsonString, setJsonString] = (0, import_react3.useState)();
  const {
    setLocalWallet,
    meta
  } = useLocalWalletInfo(props.localWalletConf, props.persist);
  const createWalletInstance = useCreateWalletInstance();
  const [password, setPassword] = (0, import_react3.useState)("");
  const [isWrongPassword, setIsWrongPassword] = (0, import_react3.useState)(false);
  const [showPassword, setShowPassword] = (0, import_react3.useState)(false);
  const [importedAddress, setImportedAddress] = (0, import_react3.useState)();
  const {
    setConnectedWallet,
    setConnectionStatus
  } = useWalletContext();
  const handleImport = async () => {
    const localWallet2 = createWalletInstance(props.localWalletConf);
    if (!localWallet2 || !jsonString) {
      throw new Error("Invalid state");
    }
    try {
      await localWallet2.import({
        encryptedJson: jsonString,
        password
      });
    } catch (e) {
      console.error(e);
      setIsWrongPassword(true);
      return;
    }
    setConnectionStatus("connecting");
    await localWallet2.connect();
    await localWallet2.save({
      strategy: "encryptedJson",
      password
    });
    setConnectedWallet(localWallet2);
    setLocalWallet(localWallet2);
    props.onConnect();
  };
  return (0, import_jsx_runtime.jsxs)(Container, {
    children: [(0, import_jsx_runtime.jsx)(Container, {
      p: "lg",
      children: (0, import_jsx_runtime.jsx)(ModalHeader, {
        onBack: props.goBack,
        title: "Import Wallet",
        imgSrc: meta.iconURL
      })
    }), (0, import_jsx_runtime.jsx)(Line, {}), (0, import_jsx_runtime.jsxs)(Container, {
      p: "lg",
      children: [(0, import_jsx_runtime.jsx)(ModalDescription, {
        sm: true,
        children: "The application can authorize any transactions on behalf of the wallet without any approvals."
      }), (0, import_jsx_runtime.jsx)(Spacer, {
        y: "xs"
      }), (0, import_jsx_runtime.jsx)(ModalDescription, {
        sm: true,
        children: "We recommend only connecting to trusted applications."
      }), (0, import_jsx_runtime.jsx)(Spacer, {
        y: "lg"
      }), (0, import_jsx_runtime.jsx)(DragNDrop, {
        extension: "JSON",
        accept: "application/json",
        onUpload: (file) => {
          const reader = new FileReader();
          reader.onload = (event) => {
            var _a, _b;
            setJsonString((_a = event.target) == null ? void 0 : _a.result);
            const obj = JSON.parse((_b = event.target) == null ? void 0 : _b.result);
            setImportedAddress(obj.address);
          };
          reader.readAsText(file, "utf-8");
        }
      }), (0, import_jsx_runtime.jsx)(Spacer, {
        y: "lg"
      }), (0, import_jsx_runtime.jsxs)("form", {
        onSubmit: (e) => {
          e.preventDefault();
          handleImport();
        },
        children: [jsonString && (0, import_jsx_runtime.jsxs)(import_jsx_runtime.Fragment, {
          children: [(0, import_jsx_runtime.jsx)("input", {
            type: "text",
            name: "username",
            autoComplete: "off",
            value: importedAddress || "",
            disabled: true,
            style: {
              display: "none"
            }
          }), (0, import_jsx_runtime.jsx)(FormFieldWithIconButton, {
            required: true,
            noSave: true,
            name: "password",
            autocomplete: "off",
            id: "password",
            onChange: (value) => {
              setPassword(value);
              setIsWrongPassword(false);
            },
            right: {
              onClick: () => setShowPassword(!showPassword),
              icon: showPassword ? (0, import_jsx_runtime.jsx)(EyeClosedIcon, {}) : (0, import_jsx_runtime.jsx)(EyeOpenIcon, {})
            },
            label: "Password",
            type: showPassword ? "text" : "password",
            value: password,
            error: isWrongPassword ? "Wrong Password" : ""
          }), (0, import_jsx_runtime.jsx)(Spacer, {
            y: "xl"
          })]
        }), (0, import_jsx_runtime.jsx)(Container, {
          flex: "row",
          style: {
            justifyContent: "flex-end"
          },
          children: (0, import_jsx_runtime.jsx)(Button, {
            variant: "accent",
            type: "submit",
            disabled: !jsonString,
            style: {
              minWidth: "110px",
              opacity: jsonString ? 1 : 0.5
            },
            children: "Import"
          })
        })]
      })]
    })]
  });
};
var CreateLocalWallet_Password = (props) => {
  const [password, setPassword] = (0, import_react3.useState)("");
  const [confirmPassword, setConfirmPassword] = (0, import_react3.useState)("");
  const [showPassword, setShowPassword] = (0, import_react3.useState)(false);
  const passwordMismatch = confirmPassword && password !== confirmPassword;
  const [isConnecting, setIsConnecting] = (0, import_react3.useState)(false);
  const {
    localWallet: localWallet2
  } = useLocalWalletInfo(props.localWalletConf, props.persist);
  const {
    setConnectedWallet,
    setConnectionStatus
  } = useWalletContext();
  const [showImportScreen, setShowImportScreen] = (0, import_react3.useState)(false);
  const [generatedAddress, setGeneratedAddress] = (0, import_react3.useState)(null);
  (0, import_react3.useEffect)(() => {
    if (!localWallet2 || showImportScreen || localWallet2.ethersWallet) {
      return;
    }
    localWallet2.generate().then((_address) => {
      setGeneratedAddress(_address);
    });
  }, [localWallet2, showImportScreen]);
  if (showImportScreen) {
    return (0, import_jsx_runtime.jsx)(ImportLocalWallet, {
      localWalletConf: props.localWalletConf,
      onConnect: props.onConnect,
      goBack: () => {
        setShowImportScreen(false);
      },
      persist: props.persist
    });
  }
  const handleConnect = async () => {
    if (passwordMismatch || !localWallet2) {
      throw new Error("Invalid state");
    }
    setIsConnecting(true);
    setConnectionStatus("connecting");
    await localWallet2.connect();
    await localWallet2.save({
      strategy: "encryptedJson",
      password
    });
    setConnectedWallet(localWallet2);
    setIsConnecting(false);
    props.onConnect();
  };
  return (0, import_jsx_runtime.jsxs)(Container, {
    fullHeight: true,
    children: [(0, import_jsx_runtime.jsx)(Container, {
      p: "lg",
      children: (0, import_jsx_runtime.jsx)(ModalHeader, {
        onBack: props.renderBackButton ? props.goBack : void 0,
        title: props.localWalletConf.meta.name,
        imgSrc: props.localWalletConf.meta.iconURL
      })
    }), (0, import_jsx_runtime.jsx)(Line, {}), (0, import_jsx_runtime.jsxs)(Container, {
      p: "lg",
      children: [(0, import_jsx_runtime.jsxs)(ModalDescription, {
        sm: true,
        children: ["Choose a password for your wallet. ", (0, import_jsx_runtime.jsx)("br", {}), " You", `'`, "ll be able to access and export this wallet with the same password."]
      }), (0, import_jsx_runtime.jsx)(Spacer, {
        y: "lg"
      }), (0, import_jsx_runtime.jsxs)("form", {
        onSubmit: (e) => {
          e.preventDefault();
          handleConnect();
        },
        children: [(0, import_jsx_runtime.jsx)("input", {
          type: "text",
          name: "username",
          autoComplete: "off",
          value: generatedAddress || "",
          disabled: true,
          style: {
            display: "none"
          }
        }), (0, import_jsx_runtime.jsx)(FormFieldWithIconButton, {
          name: "password",
          required: true,
          autocomplete: "new-password",
          id: "new-password",
          onChange: (value) => setPassword(value),
          right: {
            icon: showPassword ? (0, import_jsx_runtime.jsx)(EyeClosedIcon, {}) : (0, import_jsx_runtime.jsx)(EyeOpenIcon, {}),
            onClick: () => setShowPassword(!showPassword)
          },
          label: "Password",
          type: showPassword ? "text" : "password",
          value: password,
          dataTest: "new-password"
        }), (0, import_jsx_runtime.jsx)(Spacer, {
          y: "lg"
        }), (0, import_jsx_runtime.jsx)(FormFieldWithIconButton, {
          name: "confirm-password",
          required: true,
          autocomplete: "new-password",
          id: "confirm-password",
          onChange: (value) => setConfirmPassword(value),
          right: {
            icon: showPassword ? (0, import_jsx_runtime.jsx)(EyeClosedIcon, {}) : (0, import_jsx_runtime.jsx)(EyeOpenIcon, {}),
            onClick: () => setShowPassword(!showPassword)
          },
          label: "Confirm Password",
          type: showPassword ? "text" : "password",
          value: confirmPassword,
          error: passwordMismatch ? "Passwords don't match" : "",
          dataTest: "confirm-password"
        }), (0, import_jsx_runtime.jsx)(Spacer, {
          y: "lg"
        }), (0, import_jsx_runtime.jsxs)(Button, {
          variant: "accent",
          type: "submit",
          fullWidth: true,
          style: {
            gap: spacing.xs,
            display: "flex",
            justifyContent: "center",
            alignItems: "center"
          },
          "data-test": "create-new-wallet-button",
          children: [!isConnecting && (0, import_jsx_runtime.jsx)(PlusIcon, {
            width: iconSize.sm,
            height: iconSize.sm
          }), isConnecting ? "Connecting" : "Create new wallet", isConnecting && (0, import_jsx_runtime.jsx)(Spinner, {
            size: "sm",
            color: "accentButtonText"
          })]
        })]
      }), (0, import_jsx_runtime.jsx)(Spacer, {
        y: "lg"
      }), (0, import_jsx_runtime.jsx)(TextDivider, {
        children: (0, import_jsx_runtime.jsx)("span", {
          children: "OR"
        })
      }), (0, import_jsx_runtime.jsx)(Spacer, {
        y: "lg"
      }), (0, import_jsx_runtime.jsxs)(Button, {
        fullWidth: true,
        variant: "outline",
        onClick: () => {
          setShowImportScreen(true);
        },
        style: {
          display: "flex",
          gap: spacing.sm,
          alignItems: "center"
        },
        children: [(0, import_jsx_runtime.jsx)(PinBottomIcon, {
          width: iconSize.sm,
          height: iconSize.sm
        }), "Import wallet"]
      })]
    })]
  });
};
var CreateLocalWallet_Guest = (props) => {
  const {
    localWallet: localWallet2
  } = useLocalWalletInfo(props.localWallet, props.persist);
  const {
    setConnectedWallet,
    setConnectionStatus
  } = useWalletContext();
  const {
    onConnect
  } = props;
  const handleConnect = (0, import_react3.useCallback)(async () => {
    if (!localWallet2) {
      throw new Error("Invalid state");
    }
    await localWallet2.generate();
    setConnectionStatus("connecting");
    await wait(1e3);
    await localWallet2.connect();
    setConnectedWallet(localWallet2);
    onConnect();
  }, [localWallet2, setConnectedWallet, onConnect, setConnectionStatus]);
  const connecting = (0, import_react3.useRef)(false);
  (0, import_react3.useEffect)(() => {
    if (connecting.current || !localWallet2) {
      return;
    }
    connecting.current = true;
    handleConnect();
  }, [handleConnect, localWallet2]);
  return (0, import_jsx_runtime.jsx)(Container, {
    flex: "row",
    center: "both",
    fullHeight: true,
    style: {
      minHeight: "300px"
    },
    children: (0, import_jsx_runtime.jsx)(Spinner, {
      size: "xl",
      color: "accentText"
    })
  });
};
var OverrideConfirmation = (props) => {
  return (0, import_jsx_runtime.jsxs)(Container, {
    p: "lg",
    children: [(0, import_jsx_runtime.jsx)(ModalHeader, {
      onBack: props.onBack,
      title: "Warning"
    }), (0, import_jsx_runtime.jsx)(Spacer, {
      y: "xl"
    }), (0, import_jsx_runtime.jsxs)(Container, {
      children: [(0, import_jsx_runtime.jsx)(Text, {
        multiline: true,
        children: "Your current wallet will be deleted if you create a new wallet. Backup wallet to your device before creating a new wallet"
      }), (0, import_jsx_runtime.jsx)(Spacer, {
        y: "xl"
      }), (0, import_jsx_runtime.jsx)(Container, {
        flex: "row",
        style: {
          justifyContent: "flex-end"
        },
        children: (0, import_jsx_runtime.jsx)(Button, {
          variant: "accent",
          fullWidth: true,
          onClick: props.onBackup,
          children: "Backup wallet"
        })
      })]
    })]
  });
};
var ReconnectLocalWallet = (props) => {
  const [password, setPassword] = (0, import_react3.useState)("");
  const [showPassword, setShowPassword] = (0, import_react3.useState)(false);
  const [isWrongPassword, setIsWrongPassword] = (0, import_react3.useState)(false);
  const {
    setConnectedWallet,
    setConnectionStatus
  } = useWalletContext();
  const [isConnecting, setIsConnecting] = (0, import_react3.useState)(false);
  const [showCreate, setShowCreate] = (0, import_react3.useState)(false);
  const [showBackupConfirmation, setShowBackupConfirmation] = (0, import_react3.useState)(false);
  const [showExport, setShowExport] = (0, import_react3.useState)(false);
  const {
    localWallet: localWallet2,
    meta,
    walletData
  } = useLocalWalletInfo(props.localWallet, props.persist);
  const savedAddress = walletData ? walletData === "loading" ? "" : walletData.address : "";
  if (showExport) {
    if (!localWallet2) {
      throw new Error("Invalid state");
    }
    return (0, import_jsx_runtime.jsx)(ExportLocalWallet, {
      modalSize: props.modalSize,
      localWalletConfig: props.localWallet,
      onBack: () => {
        setShowExport(false);
      },
      onExport: () => {
        setShowExport(false);
        setShowBackupConfirmation(false);
        setShowCreate(true);
      }
    });
  }
  if (showBackupConfirmation) {
    return (0, import_jsx_runtime.jsx)(OverrideConfirmation, {
      meta,
      onBackup: () => {
        setShowExport(true);
      },
      onBack: () => {
        setShowBackupConfirmation(false);
      }
    });
  }
  if (showCreate) {
    return (0, import_jsx_runtime.jsx)(CreateLocalWallet_Password, {
      renderBackButton: props.supportedWallets.length > 1,
      localWalletConf: props.localWallet,
      goBack: () => {
        setShowCreate(false);
      },
      onConnect: props.onConnect,
      persist: props.persist
    });
  }
  const handleReconnect = async () => {
    if (!localWallet2) {
      throw new Error("Invalid state");
    }
    setIsConnecting(true);
    try {
      await localWallet2.load({
        strategy: "encryptedJson",
        password
      });
      setConnectionStatus("connecting");
      await localWallet2.connect();
      setConnectedWallet(localWallet2);
      props.onConnect();
    } catch (e) {
      setIsWrongPassword(true);
    }
    setIsConnecting(false);
  };
  return (0, import_jsx_runtime.jsxs)(Container, {
    animate: "fadein",
    children: [(0, import_jsx_runtime.jsx)(Container, {
      p: "lg",
      children: (0, import_jsx_runtime.jsx)(ModalHeader, {
        onBack: props.renderBackButton ? props.goBack : void 0,
        title: meta.name,
        imgSrc: meta.iconURL
      })
    }), (0, import_jsx_runtime.jsx)(Line, {}), (0, import_jsx_runtime.jsxs)(Container, {
      p: "lg",
      children: [(0, import_jsx_runtime.jsx)(Text, {
        multiline: true,
        size: "lg",
        color: "primaryText",
        children: "Connect to saved wallet"
      }), (0, import_jsx_runtime.jsx)(Spacer, {
        y: "xl"
      }), (0, import_jsx_runtime.jsx)(Label, {
        children: "Saved Wallet"
      }), (0, import_jsx_runtime.jsx)(Spacer, {
        y: "sm"
      }), (0, import_jsx_runtime.jsx)(Text, {
        children: savedAddress === "" ? "Loading..." : shortenAddress(savedAddress)
      }), (0, import_jsx_runtime.jsx)(Spacer, {
        y: "xl"
      }), (0, import_jsx_runtime.jsxs)("form", {
        onSubmit: (e) => {
          e.preventDefault();
          handleReconnect();
        },
        children: [(0, import_jsx_runtime.jsx)("input", {
          type: "text",
          name: "username",
          autoComplete: "off",
          value: savedAddress,
          disabled: true,
          style: {
            display: "none"
          }
        }), (0, import_jsx_runtime.jsx)(FormFieldWithIconButton, {
          required: true,
          name: "current-password",
          autocomplete: "current-password",
          id: "current-password",
          onChange: (value) => {
            setPassword(value);
            setIsWrongPassword(false);
          },
          right: {
            onClick: () => setShowPassword(!showPassword),
            icon: showPassword ? (0, import_jsx_runtime.jsx)(EyeClosedIcon, {}) : (0, import_jsx_runtime.jsx)(EyeOpenIcon, {})
          },
          label: "Password",
          type: showPassword ? "text" : "password",
          value: password,
          error: isWrongPassword ? "Wrong Password" : "",
          dataTest: "current-password",
          placeholder: "Enter your password"
        }), (0, import_jsx_runtime.jsx)(Spacer, {
          y: "md"
        }), (0, import_jsx_runtime.jsxs)(Button, {
          variant: "accent",
          type: "submit",
          fullWidth: true,
          style: {
            display: "flex",
            gap: spacing.sm
          },
          children: ["Continue", isConnecting && (0, import_jsx_runtime.jsx)(Spinner, {
            size: "sm",
            color: "accentButtonText"
          })]
        })]
      }), (0, import_jsx_runtime.jsx)(Spacer, {
        y: "xl"
      }), (0, import_jsx_runtime.jsx)(TextDivider, {
        children: (0, import_jsx_runtime.jsx)("span", {
          children: " OR "
        })
      }), (0, import_jsx_runtime.jsx)(Spacer, {
        y: "xl"
      }), (0, import_jsx_runtime.jsx)(Button, {
        variant: "outline",
        fullWidth: true,
        style: {
          textAlign: "center"
        },
        onClick: () => {
          setShowBackupConfirmation(true);
        },
        children: "Create a new wallet"
      })]
    })]
  });
};
var LocalWalletConnectUI = (props) => {
  const {
    walletData
  } = useLocalWalletInfo(props.walletConfig, props.persist);
  if (!props.persist) {
    return (0, import_jsx_runtime.jsx)(CreateLocalWallet_Guest, {
      persist: props.persist,
      localWallet: props.walletConfig,
      goBack: props.goBack,
      onConnect: props.close
    });
  }
  if (walletData === "loading") {
    return (0, import_jsx_runtime.jsx)(Container, {
      flex: "row",
      center: "both",
      style: {
        height: "300px"
      },
      children: (0, import_jsx_runtime.jsx)(Spinner, {
        size: "lg",
        color: "accentText"
      })
    });
  }
  if (walletData) {
    return (0, import_jsx_runtime.jsx)(ReconnectLocalWallet, {
      modalSize: props.modalSize,
      renderBackButton: props.supportedWallets.length > 1,
      supportedWallets: props.supportedWallets,
      onConnect: props.close,
      goBack: props.goBack,
      localWallet: props.walletConfig,
      persist: props.persist
    });
  }
  return (0, import_jsx_runtime.jsx)(CreateLocalWallet_Password, {
    goBack: props.goBack,
    localWalletConf: props.walletConfig,
    onConnect: props.close,
    renderBackButton: props.supportedWallets.length > 1,
    persist: props.persist
  });
};
var localWallet = (config) => {
  return {
    id: LocalWallet.id,
    meta: {
      ...LocalWallet.meta,
      name: "Guest Wallet",
      iconURL: "data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iODAiIGhlaWdodD0iODAiIHZpZXdCb3g9IjAgMCA4MCA4MCIgZmlsbD0ibm9uZSIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIj4KPHJlY3Qgd2lkdGg9IjgwIiBoZWlnaHQ9IjgwIiByeD0iMTIiIGZpbGw9InVybCgjcGFpbnQwX2xpbmVhcl8xXzY0KSIvPgo8ZyBjbGlwLXBhdGg9InVybCgjY2xpcDBfMV82NCkiPgo8cGF0aCBkPSJNNTguNzUgMTkuMTY2N0gyMS4yNUMxOC45NTgzIDE5LjE2NjcgMTcuMDgzMyAyMS4wNDE3IDE3LjA4MzMgMjMuMzMzNFY0OC4zMzM0QzE3LjA4MzMgNTAuNjI1IDE4Ljk1ODMgNTIuNSAyMS4yNSA1Mi41SDM1LjgzMzNMMzEuNjY2NyA1OC43NVY2MC44MzM0SDQ4LjMzMzNWNTguNzVMNDQuMTY2NyA1Mi41SDU4Ljc1QzYxLjA0MTcgNTIuNSA2Mi45MTY3IDUwLjYyNSA2Mi45MTY3IDQ4LjMzMzRWMjMuMzMzNEM2Mi45MTY3IDIxLjA0MTcgNjEuMDQxNyAxOS4xNjY3IDU4Ljc1IDE5LjE2NjdaTTU4Ljc1IDQ0LjE2NjdIMjEuMjVWMjMuMzMzNEg1OC43NVY0NC4xNjY3WiIgZmlsbD0id2hpdGUiLz4KPC9nPgo8ZGVmcz4KPGxpbmVhckdyYWRpZW50IGlkPSJwYWludDBfbGluZWFyXzFfNjQiIHgxPSI0MCIgeTE9IjAiIHgyPSI0MCIgeTI9IjgwIiBncmFkaWVudFVuaXRzPSJ1c2VyU3BhY2VPblVzZSI+CjxzdG9wIHN0b3AtY29sb3I9IiNDRTExQUIiLz4KPHN0b3Agb2Zmc2V0PSIxIiBzdG9wLWNvbG9yPSIjOTAwQkI1Ii8+CjwvbGluZWFyR3JhZGllbnQ+CjxjbGlwUGF0aCBpZD0iY2xpcDBfMV82NCI+CjxyZWN0IHdpZHRoPSI1MCIgaGVpZ2h0PSI1MCIgZmlsbD0id2hpdGUiIHRyYW5zZm9ybT0idHJhbnNsYXRlKDE1IDE1KSIvPgo8L2NsaXBQYXRoPgo8L2RlZnM+Cjwvc3ZnPgo="
    },
    create: (options) => new LocalWallet(options),
    connectUI(props) {
      return (0, import_jsx_runtime.jsx)(LocalWalletConnectUI, {
        ...props,
        persist: config && config.persist !== void 0 ? config.persist : true
      });
    }
  };
};
var SmartWalletConnecting = (props) => {
  const activeWallet = useWallet();
  const connect = useConnect();
  const connectedChain = useChain();
  const targetChain = useWalletContext().activeChain;
  const mismatch = useNetworkMismatch();
  const [connectError, setConnectError] = (0, import_react3.useState)(false);
  const [switchError, setSwitchError] = (0, import_react3.useState)(false);
  const [switchingNetwork, setSwitchingNetwork] = (0, import_react3.useState)(false);
  const connectionStatus = useConnectionStatus();
  const {
    onConnect
  } = props;
  const connectStarted = (0, import_react3.useRef)(false);
  const switchChain = useSwitchChain();
  const modalSize = (0, import_react3.useContext)(ModalConfigCtx).modalSize;
  const handleConnect = (0, import_react3.useCallback)(async () => {
    if (!activeWallet || !connectedChain || connectStarted.current) {
      return;
    }
    setConnectError(false);
    try {
      connectStarted.current = true;
      await connect(props.smartWallet, {
        personalWallet: activeWallet
      });
      onConnect();
    } catch (e) {
      console.error(e);
      setConnectError(true);
    }
  }, [activeWallet, connectedChain, connect, props.smartWallet, onConnect]);
  (0, import_react3.useEffect)(() => {
    if (!mismatch) {
      handleConnect();
    }
  }, [mismatch, handleConnect, activeWallet, connectedChain]);
  if (!connectError && (connectionStatus === "connecting" || !mismatch)) {
    return (0, import_jsx_runtime.jsx)(Container, {
      fullHeight: true,
      flex: "column",
      center: "both",
      style: {
        minHeight: "300px"
      },
      children: (0, import_jsx_runtime.jsx)(Spinner, {
        color: "accentText",
        size: "xl"
      })
    });
  }
  if (connectError) {
    return (0, import_jsx_runtime.jsx)(Container, {
      fullHeight: true,
      animate: "fadein",
      flex: "column",
      center: "both",
      p: "lg",
      style: {
        minHeight: "300px"
      },
      children: (0, import_jsx_runtime.jsx)(Text, {
        color: "danger",
        children: "Failed to connect to Smart Wallet"
      })
    });
  }
  return (0, import_jsx_runtime.jsxs)(Container, {
    fullHeight: true,
    animate: "fadein",
    flex: "column",
    children: [(0, import_jsx_runtime.jsx)(Container, {
      p: "lg",
      children: (0, import_jsx_runtime.jsx)(ModalHeader, {
        title: props.personalWallet.meta.name,
        imgSrc: props.personalWallet.meta.iconURL,
        onBack: props.onBack
      })
    }), modalSize === "compact" && (0, import_jsx_runtime.jsx)(Spacer, {
      y: "lg"
    }), (0, import_jsx_runtime.jsx)(Container, {
      expand: true,
      flex: "column",
      center: "both",
      p: "lg",
      children: (0, import_jsx_runtime.jsxs)(Container, {
        p: modalSize === "wide" ? "lg" : void 0,
        children: [(0, import_jsx_runtime.jsx)(Container, {
          flex: "row",
          center: "x",
          color: "danger",
          children: (0, import_jsx_runtime.jsx)(ExclamationTriangleIcon, {
            width: iconSize.lg,
            height: iconSize.lg
          })
        }), (0, import_jsx_runtime.jsx)(Spacer, {
          y: "md"
        }), (0, import_jsx_runtime.jsx)(Text, {
          size: "lg",
          color: "primaryText",
          center: true,
          weight: 500,
          children: "Wrong Network"
        }), (0, import_jsx_runtime.jsx)(Spacer, {
          y: "lg"
        }), (0, import_jsx_runtime.jsx)(Text, {
          multiline: true,
          center: true,
          children: "Your wallet is not connected to the required network"
        }), (0, import_jsx_runtime.jsx)(Spacer, {
          y: "xl"
        }), (0, import_jsx_runtime.jsxs)(Container, {
          flex: "column",
          gap: "md",
          children: [(0, import_jsx_runtime.jsxs)(Button, {
            type: "button",
            fullWidth: true,
            variant: "accent",
            style: {
              display: "flex",
              alignItems: "center",
              gap: spacing.sm
            },
            onClick: async () => {
              if (!activeWallet) {
                throw new Error("No active wallet");
              }
              setConnectError(false);
              setSwitchError(false);
              setSwitchingNetwork(true);
              try {
                await switchChain(targetChain.chainId);
              } catch (e) {
                setSwitchError(true);
              } finally {
                setSwitchingNetwork(false);
              }
            },
            children: [" ", switchingNetwork ? "Switching" : "Switch Network", switchingNetwork && (0, import_jsx_runtime.jsx)(Spinner, {
              size: "sm",
              color: "accentButtonText"
            })]
          }), (0, import_jsx_runtime.jsxs)(Container, {
            flex: "row",
            gap: "sm",
            center: "both",
            color: "danger",
            style: {
              textAlign: "center",
              fontSize: fontSize.sm,
              opacity: switchError ? 1 : 0,
              transition: "opacity 200ms ease"
            },
            children: [(0, import_jsx_runtime.jsx)(ExclamationTriangleIcon, {
              width: iconSize.sm,
              height: iconSize.sm
            }), (0, import_jsx_runtime.jsx)("span", {
              children: "Failed to switch network"
            })]
          })]
        })]
      })
    })]
  });
};
var smartWallet = (wallet, config) => {
  const WalletSelectUI = wallet.selectUI;
  return {
    ...wallet,
    create: (options) => new SmartWallet({
      ...options,
      ...config
    }),
    connectUI(props) {
      return (0, import_jsx_runtime.jsx)(SmartConnectUI, {
        ...props,
        personalWallet: wallet
      });
    },
    selectUI: WalletSelectUI ? (props) => {
      return (0, import_jsx_runtime.jsx)(WalletSelectUI, {
        ...props,
        walletConfig: wallet
      });
    } : void 0,
    personalWallets: [wallet]
  };
};
var SmartConnectUI = (props) => {
  const activeWallet = useWallet();
  const {
    walletConfig
  } = props;
  const PersonalWalletConfig = props.personalWallet;
  if (!activeWallet) {
    const _props = {
      ...props,
      walletConfig: PersonalWalletConfig,
      close: () => props.close(false)
    };
    if (PersonalWalletConfig.connectUI) {
      return (0, import_jsx_runtime.jsx)(PersonalWalletConfig.connectUI, {
        ..._props
      });
    }
    return (0, import_jsx_runtime.jsx)(HeadlessConnectUI, {
      ..._props
    });
  }
  return (0, import_jsx_runtime.jsx)(SmartWalletConnecting, {
    onBack: props.goBack,
    onConnect: props.close,
    smartWallet: walletConfig,
    personalWallet: props.personalWallet
  });
};
var smartWallet$1 = Object.freeze({
  __proto__: null,
  smartWallet,
  SmartConnectUI
});
export {
  ALL_ROLES,
  APPROVED_IMPLEMENTATIONS,
  AbiObjectSchema,
  AbiSchema,
  AbiTypeSchema,
  Account,
  AccountFactory,
  AddressOrEnsSchema,
  AddressSchema,
  AdminRoleMissingError,
  AssetNotFoundError,
  AuctionAlreadyStartedError,
  AuctionHasNotEndedError,
  BYOCContractMetadataSchema,
  BaseSignaturePayloadInput,
  BigNumberSchema,
  BigNumberTransformSchema,
  BigNumberishSchema,
  BloctoWallet,
  COMMON_FACTORY,
  CONTRACTS_MAP,
  CONTRACT_ADDRESSES,
  CREATE2_FACTORY_BYTECODE,
  CallOverrideSchema,
  ChainId,
  ChainIdToAddressSchema,
  ClaimConditionInputArray,
  ClaimConditionInputSchema,
  ClaimConditionMetadataSchema,
  ClaimConditionOutputSchema,
  ClaimEligibility,
  CoinbaseWallet,
  CommonContractOutputSchema,
  CommonContractSchema,
  CommonPlatformFeeSchema,
  CommonPrimarySaleSchema,
  CommonRoyaltySchema,
  CommonSymbolSchema,
  CommonTrustedForwarderSchema,
  CompilerMetadataFetchedSchema,
  ConnectModalInline,
  ConnectWallet,
  ContractAppURI,
  ContractDeployer,
  ContractEncoder,
  ContractEvents,
  ContractInfoSchema,
  ContractInterceptor,
  ContractMetadata,
  ContractOwner,
  ContractPlatformFee,
  ContractPrimarySale,
  ContractPublishedMetadata,
  ContractRoles,
  ContractRoyalty,
  CurrencySchema,
  CurrencyValueSchema,
  CustomContractDeploy,
  CustomContractInput,
  CustomContractOutput,
  CustomContractSchema,
  CustomFactoryInput,
  DEPLOYER_ABI,
  DEPLOYER_BYTECODE,
  DelayedReveal,
  DeployTransaction,
  DeployTypeInput,
  DeploymentNetworkInput,
  DropClaimConditions,
  DropErc1155ClaimConditions,
  DropErc1155History,
  DuplicateFileNameError,
  DuplicateLeafsError,
  EditionDropInitializer,
  EditionInitializer,
  EditionMetadataInputOrUriSchema,
  EditionMetadataInputSchema,
  EditionMetadataOutputSchema,
  EditionMetadataWithOwnerOutputSchema,
  EmbeddedWallet,
  EndDateSchema,
  Erc1155,
  Erc1155BatchMintable,
  Erc1155Burnable,
  Erc1155Enumerable,
  Erc1155LazyMintable,
  Erc1155Mintable,
  Erc1155SignatureMintable,
  Erc20,
  Erc20BatchMintable,
  Erc20Burnable,
  Erc20ClaimableWithConditions,
  Erc20Droppable,
  Erc20Mintable,
  Erc20SignatureMintable,
  Erc721,
  Erc721BatchMintable,
  Erc721Burnable,
  Erc721Claimable,
  Erc721ClaimableWithConditions,
  Erc721Enumerable,
  Erc721LazyMintable,
  Erc721Mintable,
  Erc721Supply,
  Erc721TieredDrop,
  Erc721WithQuantitySignatureMintable,
  EventType,
  ExtensionNotImplementedError,
  ExtraPublishMetadataSchemaInput,
  ExtraPublishMetadataSchemaOutput,
  FactoryDeploymentSchema,
  FetchError,
  FileNameMissingError,
  FrameWallet,
  FullPublishMetadataSchemaInput,
  FullPublishMetadataSchemaOutput,
  FunctionDeprecatedError,
  GAS_LIMIT_FOR_DEPLOYER,
  GasCostEstimator,
  GenericRequest,
  InjectedWallet,
  InterfaceId_IERC1155,
  InterfaceId_IERC721,
  InvalidAddressError,
  LINK_TOKEN_ADDRESS,
  LOCAL_NODE_PKEY,
  ListingNotFoundError,
  ListingType,
  LocalWallet,
  MagicLink,
  MarketplaceAuction,
  MarketplaceDirect,
  MarketplaceInitializer,
  MarketplaceV3DirectListings,
  MarketplaceV3EnglishAuctions,
  MarketplaceV3Initializer,
  MarketplaceV3Offers,
  MediaRenderer,
  MerkleSchema,
  MetaMaskWallet,
  MintRequest1155,
  MintRequest20,
  MintRequest721,
  MintRequest721withQuantity,
  MissingOwnerRoleError,
  MissingRoleError,
  MultiwrapInitializer,
  NATIVE_TOKENS,
  NATIVE_TOKEN_ADDRESS,
  NFTCollectionInitializer,
  NFTDropInitializer,
  NetworkSelector,
  NotEnoughTokensError,
  NotFoundError,
  OZ_DEFENDER_FORWARDER_ADDRESS,
  OptionalPropertiesInput,
  PAPER_API_URL,
  PREBUILT_CONTRACTS_APPURI_MAP,
  PREBUILT_CONTRACTS_MAP,
  PackInitializer,
  PaperCheckout,
  PaperWallet,
  PartialClaimConditionInputSchema,
  PermissionSnapshotSchema,
  PhantomWallet,
  PreDeployMetadata,
  PreDeployMetadataFetchedSchema,
  ProfileSchemaInput,
  ProfileSchemaOutput,
  ProposalState,
  PublishedContractSchema,
  QuantityAboveLimitError,
  RainbowWallet,
  RawDateSchema,
  RestrictedTransferError,
  RouterTypeInput,
  SIGNATURE,
  SUPPORTED_CHAIN_IDS,
  SUPPORTED_FEATURES,
  SafeWallet,
  Signature1155PayloadInput,
  Signature1155PayloadInputWithTokenId,
  Signature1155PayloadOutput,
  Signature20PayloadInput,
  Signature20PayloadOutput,
  Signature721PayloadInput,
  Signature721PayloadOutput,
  Signature721WithQuantityInput,
  Signature721WithQuantityOutput,
  SignatureDropInitializer,
  SignerPermissionRequest,
  SignerPermissionsSchema,
  SignerWallet,
  SmartWallet,
  SnapshotEntryInput,
  SnapshotEntryWithProofSchema,
  SnapshotInfoSchema,
  SnapshotInputSchema,
  SnapshotSchema,
  SplitInitializer,
  StandardErc1155,
  StandardErc20,
  StandardErc721,
  StartDateSchema,
  StaticJsonRpcBatchProvider,
  Status,
  THIRDWEB_DEPLOYER,
  ThirdwebAuthProvider,
  ThirdwebConfigProvider,
  ThirdwebConnectedWalletProvider,
  ThirdwebNftMedia,
  ThirdwebProvider,
  ThirdwebProviderCore,
  ThirdwebSDK,
  ThirdwebSDKProvider,
  ThirdwebThemeContext,
  TokenDropInitializer,
  TokenERC20History,
  TokenInitializer,
  TokenMintInputSchema,
  Transaction,
  TransactionError,
  TrustWallet,
  UploadError,
  UserWallet,
  VoteInitializer,
  VoteType,
  WalletConnect,
  Web3Button,
  WrongListingTypeError,
  ZerionWallet,
  __DEV__,
  approveErc20Allowance,
  assertEnabled,
  biconomySendFunction,
  bloctoWallet,
  checkClientIdOrSecretKey,
  checkVerificationStatus,
  cleanCurrencyAddress,
  coinbaseWallet,
  compilerMetadata,
  computeCloneFactoryAddress,
  computeDeploymentAddress,
  computeDeploymentInfo,
  computeEOAForwarderAddress,
  computeForwarderAddress,
  computeNativeTokenAddress,
  constructAbiFromBytecode,
  contractType,
  convertParamValues,
  convertToReadableQuantity,
  createCheckoutLinkIntent,
  createSnapshot,
  createTransactionBatches,
  darkTheme,
  defaultGaslessSendFunction,
  defaultTokens,
  defaultWallets,
  defenderSendFunction,
  deployContractDeterministic,
  deployContractDeterministicRaw,
  deployCreate2Factory,
  deployWithThrowawayDeployer,
  detectContractFeature,
  detectFeatures,
  detectFeaturesFromBytecode,
  directDeployDeterministic,
  directDeployDeterministicPublished,
  directDeployDeterministicWithUri,
  embeddedWallet,
  encodeConstructorParamsForImplementation,
  estimateGasForDeploy,
  extractCommentFromMetadata,
  extractConstructorParams,
  extractConstructorParamsFromAbi,
  extractEventsFromAbi,
  extractFunctionParamsFromAbi,
  extractFunctions,
  extractFunctionsFromAbi,
  extractIPFSHashFromBytecode,
  extractMinimalProxyImplementationAddress,
  fetchAbiFromAddress,
  fetchAndCacheDeployMetadata,
  fetchContractMetadata,
  fetchContractMetadataFromAddress,
  fetchCurrencyMetadata,
  fetchCurrencyValue,
  fetchExtendedReleaseMetadata,
  fetchPreDeployMetadata,
  fetchPublishedContractFromPolygon,
  fetchRawPredeployMetadata,
  fetchRegisteredCheckoutId,
  fetchSnapshotEntryForAddress,
  fetchSourceFilesFromMetadata,
  frameWallet,
  getAllDetectedExtensionNames,
  getAllDetectedExtensions,
  getAllDetectedExtensionsFromBytecode,
  getAllDetectedFeatureNames,
  getAllDetectedFeatures,
  getApprovedImplementation,
  getBlock,
  getBlockNumber,
  getBlockWithTransactions,
  getCachedAbiForContract,
  getChainId,
  getChainIdFromNetwork,
  getChainIdOrName,
  getChainProvider,
  getContract,
  getContractAddressByChainId,
  getContractFromAbi,
  getContractName,
  getContractPublisherAddress,
  getContractTypeForRemoteName,
  getCreate2FactoryAddress,
  getCreate2FactoryDeploymentInfo,
  getDefaultGasOverrides,
  getDefaultTrustedForwarders,
  getDeployArguments,
  getDeploymentInfo,
  getDynamicFeeData,
  getEncodedConstructorParamsForThirdwebContract,
  getErc1155,
  getErc20,
  getErc721,
  getErcs,
  getGasPrice,
  getInitBytecodeWithSalt,
  getKeylessTxn,
  getMultichainRegistryAddress,
  getNativeTokenByChainId,
  getPolygonGasPriorityFee,
  getProviderFromRpcUrl,
  getRoleHash,
  getRpcUrl,
  getSaltHash,
  getSignerAndProvider,
  getSupportedChains,
  getThirdwebContractAddress,
  getTrustedForwarders,
  hasERC20Allowance,
  hasFunction,
  hasMatchingAbi,
  includesErrorMessage,
  invalidateContractAndBalances,
  isChainConfig,
  isContractDeployed,
  isDowngradeVersion,
  isEIP155Enforced,
  isExtensionEnabled,
  isFeatureEnabled,
  isIncrementalVersion,
  isNativeToken,
  isProvider,
  isSigner,
  isVerifiedOnEtherscan,
  joinABIs,
  lightTheme,
  localWallet,
  magicLink,
  matchesAbiFromBytecode,
  matchesPrebuiltAbi,
  metamaskWallet,
  normalizeAmount,
  normalizePriceValue,
  paperWallet,
  parseChainIdToPaperChain,
  parseRevertReason,
  phantomWallet,
  predictAddressDeterministic,
  predictAddressDeterministicPublished,
  predictAddressDeterministicWithUri,
  predictThirdwebContractAddress,
  prepareGaslessRequest,
  rainbowWallet,
  resolveAddress,
  resolveContractUriAndBytecode,
  resolveContractUriFromAddress,
  resolveEns,
  resolveImplementation,
  resolveMimeType,
  safeWallet,
  setErc20Allowance,
  setSupportedChains,
  shouldNeverPersistQuery,
  smartWallet,
  toDisplayValue,
  toEther,
  toSemver,
  toUnits,
  toWei,
  trustWallet,
  useAcceptDirectListingOffer,
  useAccountAdmins,
  useAccountAdminsAndSigners,
  useAccountSigners,
  useAccounts,
  useAccountsForAddress,
  useActiveChain,
  useActiveClaimCondition,
  useActiveClaimConditionForWallet,
  useActiveListings,
  useAddAdmin,
  useAddress,
  useAirdropNFT,
  useAllRoleMembers,
  useAppURI,
  useAuctionWinner,
  useAuth,
  useBalance,
  useBatchesToReveal,
  useBidBuffer,
  useBloctoWallet,
  useBurnNFT,
  useBurnToken,
  useBuyDirectListing,
  useBuyNow,
  useCancelDirectListing,
  useCancelEnglishAuction,
  useCancelListing,
  useChain,
  useChainId,
  useClaimConditions,
  useClaimIneligibilityReasons,
  useClaimNFT,
  useClaimToken,
  useClaimedNFTSupply,
  useClaimedNFTs,
  useClaimerProofs,
  useCoinbaseWallet,
  useCompilerMetadata,
  useConnect,
  useConnectedWallet,
  useConnectionStatus,
  useContract,
  useContractEvents,
  useContractMetadata,
  useContractMetadataUpdate,
  useContractRead,
  useContractType,
  useContractWrite,
  useCreateAccount,
  useCreateAuctionListing,
  useCreateDirectListing,
  useCreateSessionKey,
  useCreateWalletInstance,
  useDelayedRevealLazyMint,
  useDirectListing,
  useDirectListings,
  useDirectListingsCount,
  useDisconnect,
  useENS,
  useEdition,
  useEditionDrop,
  useEnglishAuction,
  useEnglishAuctionWinningBid,
  useEnglishAuctions,
  useEnglishAuctionsCount,
  useExecuteAuctionSale,
  useFrameWallet,
  useGrantRole,
  useInstalledWallets,
  useIsAccountDeployed,
  useIsAddressRole,
  useIsWalletModalOpen,
  useLazyMint,
  useListing,
  useListings,
  useListingsCount,
  useLogin,
  useLogout,
  useMagic,
  useMakeBid,
  useMakeOffer,
  useMarketplace,
  useMetadata,
  useMetamask,
  useMinimumNextBid,
  useMintNFT,
  useMintNFTSupply,
  useMintToken,
  useMultiwrap,
  useNFT,
  useNFTBalance,
  useNFTCollection,
  useNFTDrop,
  useNFTs,
  useNetwork,
  useNetworkMismatch,
  useOffers,
  useOwnedNFTs,
  usePack,
  usePaperWallet,
  usePaperWalletUserEmail,
  usePlatformFees,
  usePrimarySaleRecipient,
  useRainbowWallet,
  useReadonlySDK,
  useRemoveAdmin,
  useResetClaimConditions,
  useResolvedMediaType,
  useRevealLazyMint,
  useRevokeRole,
  useRevokeSessionKey,
  useRoleMembers,
  useRoyaltySettings,
  useSDK,
  useSDKChainId,
  useSafe,
  useSetAllRoleMembers,
  useSetAppURI,
  useSetClaimConditions,
  useSetConnectedWallet,
  useSetConnectionStatus,
  useSetIsWalletModalOpen,
  useSetSharedMetadata,
  useSharedMetadata,
  useSignatureDrop,
  useSigner,
  useSmartWallet,
  useSplit,
  useStorage,
  useStorageUpload,
  useSupportedChains,
  useSupportedWallet,
  useSwitchAccount,
  useSwitchChain,
  useThirdwebAuthContext,
  useThirdwebConfigContext,
  useThirdwebConnectedWalletContext,
  useToken,
  useTokenBalance,
  useTokenDecimals,
  useTokenDrop,
  useTokenSupply,
  useTotalCirculatingSupply,
  useTotalCount,
  useTransferBatchToken,
  useTransferNFT,
  useTransferToken,
  useTrustWallet,
  useUnclaimedNFTSupply,
  useUnclaimedNFTs,
  useUpdateMetadata,
  useUpdatePlatformFees,
  useUpdatePrimarySaleRecipient,
  useUpdateRoyaltySettings,
  useUser,
  useValidDirectListings,
  useValidEnglishAuctions,
  useVote,
  useWallet,
  useWalletConfig,
  useWalletConnect,
  useWalletConnectV1,
  useWalletContext,
  useWallets,
  useWatchTransactions,
  useWinningBid,
  verify,
  verifyThirdwebPrebuiltImplementation,
  walletConnect,
  walletConnectV1,
  watchBlock,
  watchBlockNumber,
  watchBlockWithTransactions,
  watchTransactions,
  zerionWallet
};
//# sourceMappingURL=@thirdweb-dev_react.js.map
