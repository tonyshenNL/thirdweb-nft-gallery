import {
  basics_exports,
  concat_exports,
  equals_exports,
  from_string_exports,
  init_basics,
  init_concat,
  init_equals,
  init_from_string,
  init_to_string,
  require_browser_ponyfill,
  to_string_exports
} from "./chunk-KPMLBYIV.js";
import {
  require_utils
} from "./chunk-QJWU7UES.js";
import {
  c137,
  c80001,
  defaultChains,
  getValidChainRPCs
} from "./chunk-F44DUYBV.js";
import {
  eventemitter3_default
} from "./chunk-LMS4WD7T.js";
import {
  Contract,
  ContractFactory,
  init_lib7 as init_lib,
  utils_exports
} from "./chunk-FSHZLPV2.js";
import {
  BigNumber,
  lib_exports19 as lib_exports2,
  lib_exports8 as lib_exports
} from "./chunk-LXGF3WSV.js";
import {
  require_bn
} from "./chunk-JCGZRZHH.js";
import {
  global,
  import_buffer,
  import_process,
  init_shim,
  require_buffer
} from "./chunk-DLIX7YGU.js";
import {
  __commonJS,
  __privateAdd,
  __privateGet,
  __privateSet,
  __publicField,
  __require,
  __toCommonJS,
  __toESM
} from "./chunk-EUIKE2YQ.js";

// node_modules/@multiformats/base-x/src/index.js
var require_src = __commonJS({
  "node_modules/@multiformats/base-x/src/index.js"(exports, module) {
    "use strict";
    init_shim();
    function base(ALPHABET) {
      if (ALPHABET.length >= 255) {
        throw new TypeError("Alphabet too long");
      }
      var BASE_MAP = new Uint8Array(256);
      for (var j = 0; j < BASE_MAP.length; j++) {
        BASE_MAP[j] = 255;
      }
      for (var i = 0; i < ALPHABET.length; i++) {
        var x = ALPHABET.charAt(i);
        var xc = x.charCodeAt(0);
        if (BASE_MAP[xc] !== 255) {
          throw new TypeError(x + " is ambiguous");
        }
        BASE_MAP[xc] = i;
      }
      var BASE = ALPHABET.length;
      var LEADER = ALPHABET.charAt(0);
      var FACTOR = Math.log(BASE) / Math.log(256);
      var iFACTOR = Math.log(256) / Math.log(BASE);
      function encode(source) {
        if (source instanceof Uint8Array) {
        } else if (ArrayBuffer.isView(source)) {
          source = new Uint8Array(source.buffer, source.byteOffset, source.byteLength);
        } else if (Array.isArray(source)) {
          source = Uint8Array.from(source);
        }
        if (!(source instanceof Uint8Array)) {
          throw new TypeError("Expected Uint8Array");
        }
        if (source.length === 0) {
          return "";
        }
        var zeroes = 0;
        var length = 0;
        var pbegin = 0;
        var pend = source.length;
        while (pbegin !== pend && source[pbegin] === 0) {
          pbegin++;
          zeroes++;
        }
        var size = (pend - pbegin) * iFACTOR + 1 >>> 0;
        var b58 = new Uint8Array(size);
        while (pbegin !== pend) {
          var carry = source[pbegin];
          var i2 = 0;
          for (var it1 = size - 1; (carry !== 0 || i2 < length) && it1 !== -1; it1--, i2++) {
            carry += 256 * b58[it1] >>> 0;
            b58[it1] = carry % BASE >>> 0;
            carry = carry / BASE >>> 0;
          }
          if (carry !== 0) {
            throw new Error("Non-zero carry");
          }
          length = i2;
          pbegin++;
        }
        var it2 = size - length;
        while (it2 !== size && b58[it2] === 0) {
          it2++;
        }
        var str = LEADER.repeat(zeroes);
        for (; it2 < size; ++it2) {
          str += ALPHABET.charAt(b58[it2]);
        }
        return str;
      }
      function decodeUnsafe(source) {
        if (typeof source !== "string") {
          throw new TypeError("Expected String");
        }
        if (source.length === 0) {
          return new Uint8Array();
        }
        var psz = 0;
        if (source[psz] === " ") {
          return;
        }
        var zeroes = 0;
        var length = 0;
        while (source[psz] === LEADER) {
          zeroes++;
          psz++;
        }
        var size = (source.length - psz) * FACTOR + 1 >>> 0;
        var b256 = new Uint8Array(size);
        while (source[psz]) {
          var carry = BASE_MAP[source.charCodeAt(psz)];
          if (carry === 255) {
            return;
          }
          var i2 = 0;
          for (var it3 = size - 1; (carry !== 0 || i2 < length) && it3 !== -1; it3--, i2++) {
            carry += BASE * b256[it3] >>> 0;
            b256[it3] = carry % 256 >>> 0;
            carry = carry / 256 >>> 0;
          }
          if (carry !== 0) {
            throw new Error("Non-zero carry");
          }
          length = i2;
          psz++;
        }
        if (source[psz] === " ") {
          return;
        }
        var it4 = size - length;
        while (it4 !== size && b256[it4] === 0) {
          it4++;
        }
        var vch = new Uint8Array(zeroes + (size - it4));
        var j2 = zeroes;
        while (it4 !== size) {
          vch[j2++] = b256[it4++];
        }
        return vch;
      }
      function decode2(string) {
        var buffer = decodeUnsafe(string);
        if (buffer) {
          return buffer;
        }
        throw new Error("Non-base" + BASE + " character");
      }
      return {
        encode,
        decodeUnsafe,
        decode: decode2
      };
    }
    module.exports = base;
  }
});

// node_modules/multibase/src/util.js
var require_util = __commonJS({
  "node_modules/multibase/src/util.js"(exports, module) {
    "use strict";
    init_shim();
    var textDecoder = new TextDecoder();
    var decodeText = (bytes) => textDecoder.decode(bytes);
    var textEncoder = new TextEncoder();
    var encodeText = (text) => textEncoder.encode(text);
    function concat(arrs, length) {
      const output = new Uint8Array(length);
      let offset = 0;
      for (const arr of arrs) {
        output.set(arr, offset);
        offset += arr.length;
      }
      return output;
    }
    module.exports = { decodeText, encodeText, concat };
  }
});

// node_modules/multibase/src/base.js
var require_base = __commonJS({
  "node_modules/multibase/src/base.js"(exports, module) {
    "use strict";
    init_shim();
    var { encodeText } = require_util();
    var Base = class {
      /**
       * @param {BaseName} name
       * @param {BaseCode} code
       * @param {CodecFactory} factory
       * @param {string} alphabet
       */
      constructor(name, code, factory, alphabet) {
        this.name = name;
        this.code = code;
        this.codeBuf = encodeText(this.code);
        this.alphabet = alphabet;
        this.codec = factory(alphabet);
      }
      /**
       * @param {Uint8Array} buf
       * @returns {string}
       */
      encode(buf) {
        return this.codec.encode(buf);
      }
      /**
       * @param {string} string
       * @returns {Uint8Array}
       */
      decode(string) {
        for (const char of string) {
          if (this.alphabet && this.alphabet.indexOf(char) < 0) {
            throw new Error(`invalid character '${char}' in '${string}'`);
          }
        }
        return this.codec.decode(string);
      }
    };
    module.exports = Base;
  }
});

// node_modules/multibase/src/rfc4648.js
var require_rfc4648 = __commonJS({
  "node_modules/multibase/src/rfc4648.js"(exports, module) {
    "use strict";
    init_shim();
    var decode2 = (string, alphabet, bitsPerChar) => {
      const codes = {};
      for (let i = 0; i < alphabet.length; ++i) {
        codes[alphabet[i]] = i;
      }
      let end = string.length;
      while (string[end - 1] === "=") {
        --end;
      }
      const out = new Uint8Array(end * bitsPerChar / 8 | 0);
      let bits = 0;
      let buffer = 0;
      let written = 0;
      for (let i = 0; i < end; ++i) {
        const value = codes[string[i]];
        if (value === void 0) {
          throw new SyntaxError("Invalid character " + string[i]);
        }
        buffer = buffer << bitsPerChar | value;
        bits += bitsPerChar;
        if (bits >= 8) {
          bits -= 8;
          out[written++] = 255 & buffer >> bits;
        }
      }
      if (bits >= bitsPerChar || 255 & buffer << 8 - bits) {
        throw new SyntaxError("Unexpected end of data");
      }
      return out;
    };
    var encode = (data, alphabet, bitsPerChar) => {
      const pad = alphabet[alphabet.length - 1] === "=";
      const mask = (1 << bitsPerChar) - 1;
      let out = "";
      let bits = 0;
      let buffer = 0;
      for (let i = 0; i < data.length; ++i) {
        buffer = buffer << 8 | data[i];
        bits += 8;
        while (bits > bitsPerChar) {
          bits -= bitsPerChar;
          out += alphabet[mask & buffer >> bits];
        }
      }
      if (bits) {
        out += alphabet[mask & buffer << bitsPerChar - bits];
      }
      if (pad) {
        while (out.length * bitsPerChar & 7) {
          out += "=";
        }
      }
      return out;
    };
    var rfc4648 = (bitsPerChar) => (alphabet) => {
      return {
        /**
         * @param {Uint8Array} input
         * @returns {string}
         */
        encode(input) {
          return encode(input, alphabet, bitsPerChar);
        },
        /**
         * @param {string} input
         * @returns {Uint8Array}
         */
        decode(input) {
          return decode2(input, alphabet, bitsPerChar);
        }
      };
    };
    module.exports = { rfc4648 };
  }
});

// node_modules/multibase/src/constants.js
var require_constants = __commonJS({
  "node_modules/multibase/src/constants.js"(exports, module) {
    "use strict";
    init_shim();
    var baseX = require_src();
    var Base = require_base();
    var { rfc4648 } = require_rfc4648();
    var { decodeText, encodeText } = require_util();
    var identity = () => {
      return {
        encode: decodeText,
        decode: encodeText
      };
    };
    var constants = [
      ["identity", "\0", identity, ""],
      ["base2", "0", rfc4648(1), "01"],
      ["base8", "7", rfc4648(3), "01234567"],
      ["base10", "9", baseX, "0123456789"],
      ["base16", "f", rfc4648(4), "0123456789abcdef"],
      ["base16upper", "F", rfc4648(4), "0123456789ABCDEF"],
      ["base32hex", "v", rfc4648(5), "0123456789abcdefghijklmnopqrstuv"],
      ["base32hexupper", "V", rfc4648(5), "0123456789ABCDEFGHIJKLMNOPQRSTUV"],
      ["base32hexpad", "t", rfc4648(5), "0123456789abcdefghijklmnopqrstuv="],
      ["base32hexpadupper", "T", rfc4648(5), "0123456789ABCDEFGHIJKLMNOPQRSTUV="],
      ["base32", "b", rfc4648(5), "abcdefghijklmnopqrstuvwxyz234567"],
      ["base32upper", "B", rfc4648(5), "ABCDEFGHIJKLMNOPQRSTUVWXYZ234567"],
      ["base32pad", "c", rfc4648(5), "abcdefghijklmnopqrstuvwxyz234567="],
      ["base32padupper", "C", rfc4648(5), "ABCDEFGHIJKLMNOPQRSTUVWXYZ234567="],
      ["base32z", "h", rfc4648(5), "ybndrfg8ejkmcpqxot1uwisza345h769"],
      ["base36", "k", baseX, "0123456789abcdefghijklmnopqrstuvwxyz"],
      ["base36upper", "K", baseX, "0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ"],
      ["base58btc", "z", baseX, "123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz"],
      ["base58flickr", "Z", baseX, "123456789abcdefghijkmnopqrstuvwxyzABCDEFGHJKLMNPQRSTUVWXYZ"],
      ["base64", "m", rfc4648(6), "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/"],
      ["base64pad", "M", rfc4648(6), "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/="],
      ["base64url", "u", rfc4648(6), "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_"],
      ["base64urlpad", "U", rfc4648(6), "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_="]
    ];
    var names = constants.reduce(
      (prev, tupple) => {
        prev[tupple[0]] = new Base(tupple[0], tupple[1], tupple[2], tupple[3]);
        return prev;
      },
      /** @type {Record<BaseName,Base>} */
      {}
    );
    var codes = constants.reduce(
      (prev, tupple) => {
        prev[tupple[1]] = names[tupple[0]];
        return prev;
      },
      /** @type {Record<BaseCode,Base>} */
      {}
    );
    module.exports = {
      names,
      codes
    };
  }
});

// node_modules/multibase/src/index.js
var require_src2 = __commonJS({
  "node_modules/multibase/src/index.js"(exports, module) {
    "use strict";
    init_shim();
    var constants = require_constants();
    var { encodeText, decodeText, concat } = require_util();
    function multibase(nameOrCode, buf) {
      if (!buf) {
        throw new Error("requires an encoded Uint8Array");
      }
      const { name, codeBuf } = encoding(nameOrCode);
      validEncode(name, buf);
      return concat([codeBuf, buf], codeBuf.length + buf.length);
    }
    function encode(nameOrCode, buf) {
      const enc = encoding(nameOrCode);
      const data = encodeText(enc.encode(buf));
      return concat([enc.codeBuf, data], enc.codeBuf.length + data.length);
    }
    function decode2(data) {
      if (data instanceof Uint8Array) {
        data = decodeText(data);
      }
      const prefix2 = data[0];
      if (["f", "F", "v", "V", "t", "T", "b", "B", "c", "C", "h", "k", "K"].includes(prefix2)) {
        data = data.toLowerCase();
      }
      const enc = encoding(
        /** @type {BaseCode} */
        data[0]
      );
      return enc.decode(data.substring(1));
    }
    function isEncoded(data) {
      if (data instanceof Uint8Array) {
        data = decodeText(data);
      }
      if (Object.prototype.toString.call(data) !== "[object String]") {
        return false;
      }
      try {
        const enc = encoding(
          /** @type {BaseCode} */
          data[0]
        );
        return enc.name;
      } catch (err) {
        return false;
      }
    }
    function validEncode(name, buf) {
      const enc = encoding(name);
      enc.decode(decodeText(buf));
    }
    function encoding(nameOrCode) {
      if (Object.prototype.hasOwnProperty.call(
        constants.names,
        /** @type {BaseName} */
        nameOrCode
      )) {
        return constants.names[
          /** @type {BaseName} */
          nameOrCode
        ];
      } else if (Object.prototype.hasOwnProperty.call(
        constants.codes,
        /** @type {BaseCode} */
        nameOrCode
      )) {
        return constants.codes[
          /** @type {BaseCode} */
          nameOrCode
        ];
      } else {
        throw new Error(`Unsupported encoding: ${nameOrCode}`);
      }
    }
    function encodingFromData(data) {
      if (data instanceof Uint8Array) {
        data = decodeText(data);
      }
      return encoding(
        /** @type {BaseCode} */
        data[0]
      );
    }
    exports = module.exports = multibase;
    exports.encode = encode;
    exports.decode = decode2;
    exports.isEncoded = isEncoded;
    exports.encoding = encoding;
    exports.encodingFromData = encodingFromData;
    var names = Object.freeze(constants.names);
    var codes = Object.freeze(constants.codes);
    exports.names = names;
    exports.codes = codes;
  }
});

// node_modules/multihashes/node_modules/varint/encode.js
var require_encode = __commonJS({
  "node_modules/multihashes/node_modules/varint/encode.js"(exports, module) {
    init_shim();
    module.exports = encode;
    var MSB = 128;
    var REST = 127;
    var MSBALL = ~REST;
    var INT = Math.pow(2, 31);
    function encode(num, out, offset) {
      out = out || [];
      offset = offset || 0;
      var oldOffset = offset;
      while (num >= INT) {
        out[offset++] = num & 255 | MSB;
        num /= 128;
      }
      while (num & MSBALL) {
        out[offset++] = num & 255 | MSB;
        num >>>= 7;
      }
      out[offset] = num | 0;
      encode.bytes = offset - oldOffset + 1;
      return out;
    }
  }
});

// node_modules/multihashes/node_modules/varint/decode.js
var require_decode = __commonJS({
  "node_modules/multihashes/node_modules/varint/decode.js"(exports, module) {
    init_shim();
    module.exports = read2;
    var MSB = 128;
    var REST = 127;
    function read2(buf, offset) {
      var res = 0, offset = offset || 0, shift = 0, counter = offset, b, l = buf.length;
      do {
        if (counter >= l) {
          read2.bytes = 0;
          throw new RangeError("Could not decode varint");
        }
        b = buf[counter++];
        res += shift < 28 ? (b & REST) << shift : (b & REST) * Math.pow(2, shift);
        shift += 7;
      } while (b >= MSB);
      read2.bytes = counter - offset;
      return res;
    }
  }
});

// node_modules/multihashes/node_modules/varint/length.js
var require_length = __commonJS({
  "node_modules/multihashes/node_modules/varint/length.js"(exports, module) {
    init_shim();
    var N1 = Math.pow(2, 7);
    var N2 = Math.pow(2, 14);
    var N3 = Math.pow(2, 21);
    var N4 = Math.pow(2, 28);
    var N5 = Math.pow(2, 35);
    var N6 = Math.pow(2, 42);
    var N7 = Math.pow(2, 49);
    var N8 = Math.pow(2, 56);
    var N9 = Math.pow(2, 63);
    module.exports = function(value) {
      return value < N1 ? 1 : value < N2 ? 2 : value < N3 ? 3 : value < N4 ? 4 : value < N5 ? 5 : value < N6 ? 6 : value < N7 ? 7 : value < N8 ? 8 : value < N9 ? 9 : 10;
    };
  }
});

// node_modules/multihashes/node_modules/varint/index.js
var require_varint = __commonJS({
  "node_modules/multihashes/node_modules/varint/index.js"(exports, module) {
    init_shim();
    module.exports = {
      encode: require_encode(),
      decode: require_decode(),
      encodingLength: require_length()
    };
  }
});

// node_modules/multihashes/src/constants.js
var require_constants2 = __commonJS({
  "node_modules/multihashes/src/constants.js"(exports, module) {
    "use strict";
    init_shim();
    var names = Object.freeze({
      "identity": 0,
      "sha1": 17,
      "sha2-256": 18,
      "sha2-512": 19,
      "sha3-512": 20,
      "sha3-384": 21,
      "sha3-256": 22,
      "sha3-224": 23,
      "shake-128": 24,
      "shake-256": 25,
      "keccak-224": 26,
      "keccak-256": 27,
      "keccak-384": 28,
      "keccak-512": 29,
      "blake3": 30,
      "murmur3-128": 34,
      "murmur3-32": 35,
      "dbl-sha2-256": 86,
      "md4": 212,
      "md5": 213,
      "bmt": 214,
      "sha2-256-trunc254-padded": 4114,
      "ripemd-128": 4178,
      "ripemd-160": 4179,
      "ripemd-256": 4180,
      "ripemd-320": 4181,
      "x11": 4352,
      "kangarootwelve": 7425,
      "sm3-256": 21325,
      "blake2b-8": 45569,
      "blake2b-16": 45570,
      "blake2b-24": 45571,
      "blake2b-32": 45572,
      "blake2b-40": 45573,
      "blake2b-48": 45574,
      "blake2b-56": 45575,
      "blake2b-64": 45576,
      "blake2b-72": 45577,
      "blake2b-80": 45578,
      "blake2b-88": 45579,
      "blake2b-96": 45580,
      "blake2b-104": 45581,
      "blake2b-112": 45582,
      "blake2b-120": 45583,
      "blake2b-128": 45584,
      "blake2b-136": 45585,
      "blake2b-144": 45586,
      "blake2b-152": 45587,
      "blake2b-160": 45588,
      "blake2b-168": 45589,
      "blake2b-176": 45590,
      "blake2b-184": 45591,
      "blake2b-192": 45592,
      "blake2b-200": 45593,
      "blake2b-208": 45594,
      "blake2b-216": 45595,
      "blake2b-224": 45596,
      "blake2b-232": 45597,
      "blake2b-240": 45598,
      "blake2b-248": 45599,
      "blake2b-256": 45600,
      "blake2b-264": 45601,
      "blake2b-272": 45602,
      "blake2b-280": 45603,
      "blake2b-288": 45604,
      "blake2b-296": 45605,
      "blake2b-304": 45606,
      "blake2b-312": 45607,
      "blake2b-320": 45608,
      "blake2b-328": 45609,
      "blake2b-336": 45610,
      "blake2b-344": 45611,
      "blake2b-352": 45612,
      "blake2b-360": 45613,
      "blake2b-368": 45614,
      "blake2b-376": 45615,
      "blake2b-384": 45616,
      "blake2b-392": 45617,
      "blake2b-400": 45618,
      "blake2b-408": 45619,
      "blake2b-416": 45620,
      "blake2b-424": 45621,
      "blake2b-432": 45622,
      "blake2b-440": 45623,
      "blake2b-448": 45624,
      "blake2b-456": 45625,
      "blake2b-464": 45626,
      "blake2b-472": 45627,
      "blake2b-480": 45628,
      "blake2b-488": 45629,
      "blake2b-496": 45630,
      "blake2b-504": 45631,
      "blake2b-512": 45632,
      "blake2s-8": 45633,
      "blake2s-16": 45634,
      "blake2s-24": 45635,
      "blake2s-32": 45636,
      "blake2s-40": 45637,
      "blake2s-48": 45638,
      "blake2s-56": 45639,
      "blake2s-64": 45640,
      "blake2s-72": 45641,
      "blake2s-80": 45642,
      "blake2s-88": 45643,
      "blake2s-96": 45644,
      "blake2s-104": 45645,
      "blake2s-112": 45646,
      "blake2s-120": 45647,
      "blake2s-128": 45648,
      "blake2s-136": 45649,
      "blake2s-144": 45650,
      "blake2s-152": 45651,
      "blake2s-160": 45652,
      "blake2s-168": 45653,
      "blake2s-176": 45654,
      "blake2s-184": 45655,
      "blake2s-192": 45656,
      "blake2s-200": 45657,
      "blake2s-208": 45658,
      "blake2s-216": 45659,
      "blake2s-224": 45660,
      "blake2s-232": 45661,
      "blake2s-240": 45662,
      "blake2s-248": 45663,
      "blake2s-256": 45664,
      "skein256-8": 45825,
      "skein256-16": 45826,
      "skein256-24": 45827,
      "skein256-32": 45828,
      "skein256-40": 45829,
      "skein256-48": 45830,
      "skein256-56": 45831,
      "skein256-64": 45832,
      "skein256-72": 45833,
      "skein256-80": 45834,
      "skein256-88": 45835,
      "skein256-96": 45836,
      "skein256-104": 45837,
      "skein256-112": 45838,
      "skein256-120": 45839,
      "skein256-128": 45840,
      "skein256-136": 45841,
      "skein256-144": 45842,
      "skein256-152": 45843,
      "skein256-160": 45844,
      "skein256-168": 45845,
      "skein256-176": 45846,
      "skein256-184": 45847,
      "skein256-192": 45848,
      "skein256-200": 45849,
      "skein256-208": 45850,
      "skein256-216": 45851,
      "skein256-224": 45852,
      "skein256-232": 45853,
      "skein256-240": 45854,
      "skein256-248": 45855,
      "skein256-256": 45856,
      "skein512-8": 45857,
      "skein512-16": 45858,
      "skein512-24": 45859,
      "skein512-32": 45860,
      "skein512-40": 45861,
      "skein512-48": 45862,
      "skein512-56": 45863,
      "skein512-64": 45864,
      "skein512-72": 45865,
      "skein512-80": 45866,
      "skein512-88": 45867,
      "skein512-96": 45868,
      "skein512-104": 45869,
      "skein512-112": 45870,
      "skein512-120": 45871,
      "skein512-128": 45872,
      "skein512-136": 45873,
      "skein512-144": 45874,
      "skein512-152": 45875,
      "skein512-160": 45876,
      "skein512-168": 45877,
      "skein512-176": 45878,
      "skein512-184": 45879,
      "skein512-192": 45880,
      "skein512-200": 45881,
      "skein512-208": 45882,
      "skein512-216": 45883,
      "skein512-224": 45884,
      "skein512-232": 45885,
      "skein512-240": 45886,
      "skein512-248": 45887,
      "skein512-256": 45888,
      "skein512-264": 45889,
      "skein512-272": 45890,
      "skein512-280": 45891,
      "skein512-288": 45892,
      "skein512-296": 45893,
      "skein512-304": 45894,
      "skein512-312": 45895,
      "skein512-320": 45896,
      "skein512-328": 45897,
      "skein512-336": 45898,
      "skein512-344": 45899,
      "skein512-352": 45900,
      "skein512-360": 45901,
      "skein512-368": 45902,
      "skein512-376": 45903,
      "skein512-384": 45904,
      "skein512-392": 45905,
      "skein512-400": 45906,
      "skein512-408": 45907,
      "skein512-416": 45908,
      "skein512-424": 45909,
      "skein512-432": 45910,
      "skein512-440": 45911,
      "skein512-448": 45912,
      "skein512-456": 45913,
      "skein512-464": 45914,
      "skein512-472": 45915,
      "skein512-480": 45916,
      "skein512-488": 45917,
      "skein512-496": 45918,
      "skein512-504": 45919,
      "skein512-512": 45920,
      "skein1024-8": 45921,
      "skein1024-16": 45922,
      "skein1024-24": 45923,
      "skein1024-32": 45924,
      "skein1024-40": 45925,
      "skein1024-48": 45926,
      "skein1024-56": 45927,
      "skein1024-64": 45928,
      "skein1024-72": 45929,
      "skein1024-80": 45930,
      "skein1024-88": 45931,
      "skein1024-96": 45932,
      "skein1024-104": 45933,
      "skein1024-112": 45934,
      "skein1024-120": 45935,
      "skein1024-128": 45936,
      "skein1024-136": 45937,
      "skein1024-144": 45938,
      "skein1024-152": 45939,
      "skein1024-160": 45940,
      "skein1024-168": 45941,
      "skein1024-176": 45942,
      "skein1024-184": 45943,
      "skein1024-192": 45944,
      "skein1024-200": 45945,
      "skein1024-208": 45946,
      "skein1024-216": 45947,
      "skein1024-224": 45948,
      "skein1024-232": 45949,
      "skein1024-240": 45950,
      "skein1024-248": 45951,
      "skein1024-256": 45952,
      "skein1024-264": 45953,
      "skein1024-272": 45954,
      "skein1024-280": 45955,
      "skein1024-288": 45956,
      "skein1024-296": 45957,
      "skein1024-304": 45958,
      "skein1024-312": 45959,
      "skein1024-320": 45960,
      "skein1024-328": 45961,
      "skein1024-336": 45962,
      "skein1024-344": 45963,
      "skein1024-352": 45964,
      "skein1024-360": 45965,
      "skein1024-368": 45966,
      "skein1024-376": 45967,
      "skein1024-384": 45968,
      "skein1024-392": 45969,
      "skein1024-400": 45970,
      "skein1024-408": 45971,
      "skein1024-416": 45972,
      "skein1024-424": 45973,
      "skein1024-432": 45974,
      "skein1024-440": 45975,
      "skein1024-448": 45976,
      "skein1024-456": 45977,
      "skein1024-464": 45978,
      "skein1024-472": 45979,
      "skein1024-480": 45980,
      "skein1024-488": 45981,
      "skein1024-496": 45982,
      "skein1024-504": 45983,
      "skein1024-512": 45984,
      "skein1024-520": 45985,
      "skein1024-528": 45986,
      "skein1024-536": 45987,
      "skein1024-544": 45988,
      "skein1024-552": 45989,
      "skein1024-560": 45990,
      "skein1024-568": 45991,
      "skein1024-576": 45992,
      "skein1024-584": 45993,
      "skein1024-592": 45994,
      "skein1024-600": 45995,
      "skein1024-608": 45996,
      "skein1024-616": 45997,
      "skein1024-624": 45998,
      "skein1024-632": 45999,
      "skein1024-640": 46e3,
      "skein1024-648": 46001,
      "skein1024-656": 46002,
      "skein1024-664": 46003,
      "skein1024-672": 46004,
      "skein1024-680": 46005,
      "skein1024-688": 46006,
      "skein1024-696": 46007,
      "skein1024-704": 46008,
      "skein1024-712": 46009,
      "skein1024-720": 46010,
      "skein1024-728": 46011,
      "skein1024-736": 46012,
      "skein1024-744": 46013,
      "skein1024-752": 46014,
      "skein1024-760": 46015,
      "skein1024-768": 46016,
      "skein1024-776": 46017,
      "skein1024-784": 46018,
      "skein1024-792": 46019,
      "skein1024-800": 46020,
      "skein1024-808": 46021,
      "skein1024-816": 46022,
      "skein1024-824": 46023,
      "skein1024-832": 46024,
      "skein1024-840": 46025,
      "skein1024-848": 46026,
      "skein1024-856": 46027,
      "skein1024-864": 46028,
      "skein1024-872": 46029,
      "skein1024-880": 46030,
      "skein1024-888": 46031,
      "skein1024-896": 46032,
      "skein1024-904": 46033,
      "skein1024-912": 46034,
      "skein1024-920": 46035,
      "skein1024-928": 46036,
      "skein1024-936": 46037,
      "skein1024-944": 46038,
      "skein1024-952": 46039,
      "skein1024-960": 46040,
      "skein1024-968": 46041,
      "skein1024-976": 46042,
      "skein1024-984": 46043,
      "skein1024-992": 46044,
      "skein1024-1000": 46045,
      "skein1024-1008": 46046,
      "skein1024-1016": 46047,
      "skein1024-1024": 46048,
      "poseidon-bls12_381-a2-fc1": 46081,
      "poseidon-bls12_381-a2-fc1-sc": 46082
    });
    module.exports = { names };
  }
});

// node_modules/multihashes/src/index.js
var require_src3 = __commonJS({
  "node_modules/multihashes/src/index.js"(exports, module) {
    "use strict";
    init_shim();
    var multibase = require_src2();
    var varint = require_varint();
    var { names } = require_constants2();
    var { toString: uint8ArrayToString } = (init_to_string(), __toCommonJS(to_string_exports));
    var { fromString: uint8ArrayFromString } = (init_from_string(), __toCommonJS(from_string_exports));
    var { concat: uint8ArrayConcat } = (init_concat(), __toCommonJS(concat_exports));
    var codes = (
      /** @type {import('./types').CodeNameMap} */
      {}
    );
    for (const key in names) {
      const name = (
        /** @type {HashName} */
        key
      );
      codes[names[name]] = name;
    }
    Object.freeze(codes);
    function toHexString(hash) {
      if (!(hash instanceof Uint8Array)) {
        throw new Error("must be passed a Uint8Array");
      }
      return uint8ArrayToString(hash, "base16");
    }
    function fromHexString(hash) {
      return uint8ArrayFromString(hash, "base16");
    }
    function toB58String(hash) {
      if (!(hash instanceof Uint8Array)) {
        throw new Error("must be passed a Uint8Array");
      }
      return uint8ArrayToString(multibase.encode("base58btc", hash)).slice(1);
    }
    function fromB58String(hash) {
      const encoded = hash instanceof Uint8Array ? uint8ArrayToString(hash) : hash;
      return multibase.decode("z" + encoded);
    }
    function decode2(bytes) {
      if (!(bytes instanceof Uint8Array)) {
        throw new Error("multihash must be a Uint8Array");
      }
      if (bytes.length < 2) {
        throw new Error("multihash too short. must be > 2 bytes.");
      }
      const code = (
        /** @type {HashCode} */
        varint.decode(bytes)
      );
      if (!isValidCode(code)) {
        throw new Error(`multihash unknown function code: 0x${code.toString(16)}`);
      }
      bytes = bytes.slice(varint.decode.bytes);
      const len = varint.decode(bytes);
      if (len < 0) {
        throw new Error(`multihash invalid length: ${len}`);
      }
      bytes = bytes.slice(varint.decode.bytes);
      if (bytes.length !== len) {
        throw new Error(`multihash length inconsistent: 0x${uint8ArrayToString(bytes, "base16")}`);
      }
      return {
        code,
        name: codes[code],
        length: len,
        digest: bytes
      };
    }
    function encode(digest, code, length) {
      if (!digest || code === void 0) {
        throw new Error("multihash encode requires at least two args: digest, code");
      }
      const hashfn = coerceCode(code);
      if (!(digest instanceof Uint8Array)) {
        throw new Error("digest should be a Uint8Array");
      }
      if (length == null) {
        length = digest.length;
      }
      if (length && digest.length !== length) {
        throw new Error("digest length should be equal to specified length.");
      }
      const hash = varint.encode(hashfn);
      const len = varint.encode(length);
      return uint8ArrayConcat([hash, len, digest], hash.length + len.length + digest.length);
    }
    function coerceCode(name) {
      let code = name;
      if (typeof name === "string") {
        if (names[name] === void 0) {
          throw new Error(`Unrecognized hash function named: ${name}`);
        }
        code = names[name];
      }
      if (typeof code !== "number") {
        throw new Error(`Hash function code should be a number. Got: ${code}`);
      }
      if (codes[code] === void 0 && !isAppCode(code)) {
        throw new Error(`Unrecognized function code: ${code}`);
      }
      return code;
    }
    function isAppCode(code) {
      return code > 0 && code < 16;
    }
    function isValidCode(code) {
      if (isAppCode(code)) {
        return true;
      }
      if (codes[code]) {
        return true;
      }
      return false;
    }
    function validate2(multihash) {
      decode2(multihash);
    }
    function prefix2(multihash) {
      validate2(multihash);
      return multihash.subarray(0, 2);
    }
    module.exports = {
      names,
      codes,
      toHexString,
      fromHexString,
      toB58String,
      fromB58String,
      decode: decode2,
      encode,
      coerceCode,
      isAppCode,
      validate: validate2,
      prefix: prefix2,
      isValidCode
    };
  }
});

// node_modules/varint/encode.js
var require_encode2 = __commonJS({
  "node_modules/varint/encode.js"(exports, module) {
    init_shim();
    module.exports = encode;
    var MSB = 128;
    var REST = 127;
    var MSBALL = ~REST;
    var INT = Math.pow(2, 31);
    function encode(num, out, offset) {
      if (Number.MAX_SAFE_INTEGER && num > Number.MAX_SAFE_INTEGER) {
        encode.bytes = 0;
        throw new RangeError("Could not encode varint");
      }
      out = out || [];
      offset = offset || 0;
      var oldOffset = offset;
      while (num >= INT) {
        out[offset++] = num & 255 | MSB;
        num /= 128;
      }
      while (num & MSBALL) {
        out[offset++] = num & 255 | MSB;
        num >>>= 7;
      }
      out[offset] = num | 0;
      encode.bytes = offset - oldOffset + 1;
      return out;
    }
  }
});

// node_modules/varint/decode.js
var require_decode2 = __commonJS({
  "node_modules/varint/decode.js"(exports, module) {
    init_shim();
    module.exports = read2;
    var MSB = 128;
    var REST = 127;
    function read2(buf, offset) {
      var res = 0, offset = offset || 0, shift = 0, counter = offset, b, l = buf.length;
      do {
        if (counter >= l || shift > 49) {
          read2.bytes = 0;
          throw new RangeError("Could not decode varint");
        }
        b = buf[counter++];
        res += shift < 28 ? (b & REST) << shift : (b & REST) * Math.pow(2, shift);
        shift += 7;
      } while (b >= MSB);
      read2.bytes = counter - offset;
      return res;
    }
  }
});

// node_modules/varint/length.js
var require_length2 = __commonJS({
  "node_modules/varint/length.js"(exports, module) {
    init_shim();
    var N1 = Math.pow(2, 7);
    var N2 = Math.pow(2, 14);
    var N3 = Math.pow(2, 21);
    var N4 = Math.pow(2, 28);
    var N5 = Math.pow(2, 35);
    var N6 = Math.pow(2, 42);
    var N7 = Math.pow(2, 49);
    var N8 = Math.pow(2, 56);
    var N9 = Math.pow(2, 63);
    module.exports = function(value) {
      return value < N1 ? 1 : value < N2 ? 2 : value < N3 ? 3 : value < N4 ? 4 : value < N5 ? 5 : value < N6 ? 6 : value < N7 ? 7 : value < N8 ? 8 : value < N9 ? 9 : 10;
    };
  }
});

// node_modules/varint/index.js
var require_varint2 = __commonJS({
  "node_modules/varint/index.js"(exports, module) {
    init_shim();
    module.exports = {
      encode: require_encode2(),
      decode: require_decode2(),
      encodingLength: require_length2()
    };
  }
});

// node_modules/multicodec/src/util.js
var require_util2 = __commonJS({
  "node_modules/multicodec/src/util.js"(exports, module) {
    "use strict";
    init_shim();
    var varint = require_varint2();
    var { toString: uint8ArrayToString } = (init_to_string(), __toCommonJS(to_string_exports));
    var { fromString: uint8ArrayFromString } = (init_from_string(), __toCommonJS(from_string_exports));
    module.exports = {
      numberToUint8Array,
      uint8ArrayToNumber,
      varintUint8ArrayEncode,
      varintEncode
    };
    function uint8ArrayToNumber(buf) {
      return parseInt(uint8ArrayToString(buf, "base16"), 16);
    }
    function numberToUint8Array(num) {
      let hexString = num.toString(16);
      if (hexString.length % 2 === 1) {
        hexString = "0" + hexString;
      }
      return uint8ArrayFromString(hexString, "base16");
    }
    function varintUint8ArrayEncode(input) {
      return Uint8Array.from(varint.encode(uint8ArrayToNumber(input)));
    }
    function varintEncode(num) {
      return Uint8Array.from(varint.encode(num));
    }
  }
});

// node_modules/multicodec/src/generated-table.js
var require_generated_table = __commonJS({
  "node_modules/multicodec/src/generated-table.js"(exports, module) {
    "use strict";
    init_shim();
    var baseTable = Object.freeze({
      "identity": 0,
      "cidv1": 1,
      "cidv2": 2,
      "cidv3": 3,
      "ip4": 4,
      "tcp": 6,
      "sha1": 17,
      "sha2-256": 18,
      "sha2-512": 19,
      "sha3-512": 20,
      "sha3-384": 21,
      "sha3-256": 22,
      "sha3-224": 23,
      "shake-128": 24,
      "shake-256": 25,
      "keccak-224": 26,
      "keccak-256": 27,
      "keccak-384": 28,
      "keccak-512": 29,
      "blake3": 30,
      "dccp": 33,
      "murmur3-128": 34,
      "murmur3-32": 35,
      "ip6": 41,
      "ip6zone": 42,
      "path": 47,
      "multicodec": 48,
      "multihash": 49,
      "multiaddr": 50,
      "multibase": 51,
      "dns": 53,
      "dns4": 54,
      "dns6": 55,
      "dnsaddr": 56,
      "protobuf": 80,
      "cbor": 81,
      "raw": 85,
      "dbl-sha2-256": 86,
      "rlp": 96,
      "bencode": 99,
      "dag-pb": 112,
      "dag-cbor": 113,
      "libp2p-key": 114,
      "git-raw": 120,
      "torrent-info": 123,
      "torrent-file": 124,
      "leofcoin-block": 129,
      "leofcoin-tx": 130,
      "leofcoin-pr": 131,
      "sctp": 132,
      "dag-jose": 133,
      "dag-cose": 134,
      "eth-block": 144,
      "eth-block-list": 145,
      "eth-tx-trie": 146,
      "eth-tx": 147,
      "eth-tx-receipt-trie": 148,
      "eth-tx-receipt": 149,
      "eth-state-trie": 150,
      "eth-account-snapshot": 151,
      "eth-storage-trie": 152,
      "eth-receipt-log-trie": 153,
      "eth-reciept-log": 154,
      "bitcoin-block": 176,
      "bitcoin-tx": 177,
      "bitcoin-witness-commitment": 178,
      "zcash-block": 192,
      "zcash-tx": 193,
      "caip-50": 202,
      "streamid": 206,
      "stellar-block": 208,
      "stellar-tx": 209,
      "md4": 212,
      "md5": 213,
      "bmt": 214,
      "decred-block": 224,
      "decred-tx": 225,
      "ipld-ns": 226,
      "ipfs-ns": 227,
      "swarm-ns": 228,
      "ipns-ns": 229,
      "zeronet": 230,
      "secp256k1-pub": 231,
      "bls12_381-g1-pub": 234,
      "bls12_381-g2-pub": 235,
      "x25519-pub": 236,
      "ed25519-pub": 237,
      "bls12_381-g1g2-pub": 238,
      "dash-block": 240,
      "dash-tx": 241,
      "swarm-manifest": 250,
      "swarm-feed": 251,
      "udp": 273,
      "p2p-webrtc-star": 275,
      "p2p-webrtc-direct": 276,
      "p2p-stardust": 277,
      "p2p-circuit": 290,
      "dag-json": 297,
      "udt": 301,
      "utp": 302,
      "unix": 400,
      "thread": 406,
      "p2p": 421,
      "ipfs": 421,
      "https": 443,
      "onion": 444,
      "onion3": 445,
      "garlic64": 446,
      "garlic32": 447,
      "tls": 448,
      "noise": 454,
      "quic": 460,
      "ws": 477,
      "wss": 478,
      "p2p-websocket-star": 479,
      "http": 480,
      "swhid-1-snp": 496,
      "json": 512,
      "messagepack": 513,
      "libp2p-peer-record": 769,
      "libp2p-relay-rsvp": 770,
      "car-index-sorted": 1024,
      "sha2-256-trunc254-padded": 4114,
      "ripemd-128": 4178,
      "ripemd-160": 4179,
      "ripemd-256": 4180,
      "ripemd-320": 4181,
      "x11": 4352,
      "p256-pub": 4608,
      "p384-pub": 4609,
      "p521-pub": 4610,
      "ed448-pub": 4611,
      "x448-pub": 4612,
      "ed25519-priv": 4864,
      "secp256k1-priv": 4865,
      "x25519-priv": 4866,
      "kangarootwelve": 7425,
      "sm3-256": 21325,
      "blake2b-8": 45569,
      "blake2b-16": 45570,
      "blake2b-24": 45571,
      "blake2b-32": 45572,
      "blake2b-40": 45573,
      "blake2b-48": 45574,
      "blake2b-56": 45575,
      "blake2b-64": 45576,
      "blake2b-72": 45577,
      "blake2b-80": 45578,
      "blake2b-88": 45579,
      "blake2b-96": 45580,
      "blake2b-104": 45581,
      "blake2b-112": 45582,
      "blake2b-120": 45583,
      "blake2b-128": 45584,
      "blake2b-136": 45585,
      "blake2b-144": 45586,
      "blake2b-152": 45587,
      "blake2b-160": 45588,
      "blake2b-168": 45589,
      "blake2b-176": 45590,
      "blake2b-184": 45591,
      "blake2b-192": 45592,
      "blake2b-200": 45593,
      "blake2b-208": 45594,
      "blake2b-216": 45595,
      "blake2b-224": 45596,
      "blake2b-232": 45597,
      "blake2b-240": 45598,
      "blake2b-248": 45599,
      "blake2b-256": 45600,
      "blake2b-264": 45601,
      "blake2b-272": 45602,
      "blake2b-280": 45603,
      "blake2b-288": 45604,
      "blake2b-296": 45605,
      "blake2b-304": 45606,
      "blake2b-312": 45607,
      "blake2b-320": 45608,
      "blake2b-328": 45609,
      "blake2b-336": 45610,
      "blake2b-344": 45611,
      "blake2b-352": 45612,
      "blake2b-360": 45613,
      "blake2b-368": 45614,
      "blake2b-376": 45615,
      "blake2b-384": 45616,
      "blake2b-392": 45617,
      "blake2b-400": 45618,
      "blake2b-408": 45619,
      "blake2b-416": 45620,
      "blake2b-424": 45621,
      "blake2b-432": 45622,
      "blake2b-440": 45623,
      "blake2b-448": 45624,
      "blake2b-456": 45625,
      "blake2b-464": 45626,
      "blake2b-472": 45627,
      "blake2b-480": 45628,
      "blake2b-488": 45629,
      "blake2b-496": 45630,
      "blake2b-504": 45631,
      "blake2b-512": 45632,
      "blake2s-8": 45633,
      "blake2s-16": 45634,
      "blake2s-24": 45635,
      "blake2s-32": 45636,
      "blake2s-40": 45637,
      "blake2s-48": 45638,
      "blake2s-56": 45639,
      "blake2s-64": 45640,
      "blake2s-72": 45641,
      "blake2s-80": 45642,
      "blake2s-88": 45643,
      "blake2s-96": 45644,
      "blake2s-104": 45645,
      "blake2s-112": 45646,
      "blake2s-120": 45647,
      "blake2s-128": 45648,
      "blake2s-136": 45649,
      "blake2s-144": 45650,
      "blake2s-152": 45651,
      "blake2s-160": 45652,
      "blake2s-168": 45653,
      "blake2s-176": 45654,
      "blake2s-184": 45655,
      "blake2s-192": 45656,
      "blake2s-200": 45657,
      "blake2s-208": 45658,
      "blake2s-216": 45659,
      "blake2s-224": 45660,
      "blake2s-232": 45661,
      "blake2s-240": 45662,
      "blake2s-248": 45663,
      "blake2s-256": 45664,
      "skein256-8": 45825,
      "skein256-16": 45826,
      "skein256-24": 45827,
      "skein256-32": 45828,
      "skein256-40": 45829,
      "skein256-48": 45830,
      "skein256-56": 45831,
      "skein256-64": 45832,
      "skein256-72": 45833,
      "skein256-80": 45834,
      "skein256-88": 45835,
      "skein256-96": 45836,
      "skein256-104": 45837,
      "skein256-112": 45838,
      "skein256-120": 45839,
      "skein256-128": 45840,
      "skein256-136": 45841,
      "skein256-144": 45842,
      "skein256-152": 45843,
      "skein256-160": 45844,
      "skein256-168": 45845,
      "skein256-176": 45846,
      "skein256-184": 45847,
      "skein256-192": 45848,
      "skein256-200": 45849,
      "skein256-208": 45850,
      "skein256-216": 45851,
      "skein256-224": 45852,
      "skein256-232": 45853,
      "skein256-240": 45854,
      "skein256-248": 45855,
      "skein256-256": 45856,
      "skein512-8": 45857,
      "skein512-16": 45858,
      "skein512-24": 45859,
      "skein512-32": 45860,
      "skein512-40": 45861,
      "skein512-48": 45862,
      "skein512-56": 45863,
      "skein512-64": 45864,
      "skein512-72": 45865,
      "skein512-80": 45866,
      "skein512-88": 45867,
      "skein512-96": 45868,
      "skein512-104": 45869,
      "skein512-112": 45870,
      "skein512-120": 45871,
      "skein512-128": 45872,
      "skein512-136": 45873,
      "skein512-144": 45874,
      "skein512-152": 45875,
      "skein512-160": 45876,
      "skein512-168": 45877,
      "skein512-176": 45878,
      "skein512-184": 45879,
      "skein512-192": 45880,
      "skein512-200": 45881,
      "skein512-208": 45882,
      "skein512-216": 45883,
      "skein512-224": 45884,
      "skein512-232": 45885,
      "skein512-240": 45886,
      "skein512-248": 45887,
      "skein512-256": 45888,
      "skein512-264": 45889,
      "skein512-272": 45890,
      "skein512-280": 45891,
      "skein512-288": 45892,
      "skein512-296": 45893,
      "skein512-304": 45894,
      "skein512-312": 45895,
      "skein512-320": 45896,
      "skein512-328": 45897,
      "skein512-336": 45898,
      "skein512-344": 45899,
      "skein512-352": 45900,
      "skein512-360": 45901,
      "skein512-368": 45902,
      "skein512-376": 45903,
      "skein512-384": 45904,
      "skein512-392": 45905,
      "skein512-400": 45906,
      "skein512-408": 45907,
      "skein512-416": 45908,
      "skein512-424": 45909,
      "skein512-432": 45910,
      "skein512-440": 45911,
      "skein512-448": 45912,
      "skein512-456": 45913,
      "skein512-464": 45914,
      "skein512-472": 45915,
      "skein512-480": 45916,
      "skein512-488": 45917,
      "skein512-496": 45918,
      "skein512-504": 45919,
      "skein512-512": 45920,
      "skein1024-8": 45921,
      "skein1024-16": 45922,
      "skein1024-24": 45923,
      "skein1024-32": 45924,
      "skein1024-40": 45925,
      "skein1024-48": 45926,
      "skein1024-56": 45927,
      "skein1024-64": 45928,
      "skein1024-72": 45929,
      "skein1024-80": 45930,
      "skein1024-88": 45931,
      "skein1024-96": 45932,
      "skein1024-104": 45933,
      "skein1024-112": 45934,
      "skein1024-120": 45935,
      "skein1024-128": 45936,
      "skein1024-136": 45937,
      "skein1024-144": 45938,
      "skein1024-152": 45939,
      "skein1024-160": 45940,
      "skein1024-168": 45941,
      "skein1024-176": 45942,
      "skein1024-184": 45943,
      "skein1024-192": 45944,
      "skein1024-200": 45945,
      "skein1024-208": 45946,
      "skein1024-216": 45947,
      "skein1024-224": 45948,
      "skein1024-232": 45949,
      "skein1024-240": 45950,
      "skein1024-248": 45951,
      "skein1024-256": 45952,
      "skein1024-264": 45953,
      "skein1024-272": 45954,
      "skein1024-280": 45955,
      "skein1024-288": 45956,
      "skein1024-296": 45957,
      "skein1024-304": 45958,
      "skein1024-312": 45959,
      "skein1024-320": 45960,
      "skein1024-328": 45961,
      "skein1024-336": 45962,
      "skein1024-344": 45963,
      "skein1024-352": 45964,
      "skein1024-360": 45965,
      "skein1024-368": 45966,
      "skein1024-376": 45967,
      "skein1024-384": 45968,
      "skein1024-392": 45969,
      "skein1024-400": 45970,
      "skein1024-408": 45971,
      "skein1024-416": 45972,
      "skein1024-424": 45973,
      "skein1024-432": 45974,
      "skein1024-440": 45975,
      "skein1024-448": 45976,
      "skein1024-456": 45977,
      "skein1024-464": 45978,
      "skein1024-472": 45979,
      "skein1024-480": 45980,
      "skein1024-488": 45981,
      "skein1024-496": 45982,
      "skein1024-504": 45983,
      "skein1024-512": 45984,
      "skein1024-520": 45985,
      "skein1024-528": 45986,
      "skein1024-536": 45987,
      "skein1024-544": 45988,
      "skein1024-552": 45989,
      "skein1024-560": 45990,
      "skein1024-568": 45991,
      "skein1024-576": 45992,
      "skein1024-584": 45993,
      "skein1024-592": 45994,
      "skein1024-600": 45995,
      "skein1024-608": 45996,
      "skein1024-616": 45997,
      "skein1024-624": 45998,
      "skein1024-632": 45999,
      "skein1024-640": 46e3,
      "skein1024-648": 46001,
      "skein1024-656": 46002,
      "skein1024-664": 46003,
      "skein1024-672": 46004,
      "skein1024-680": 46005,
      "skein1024-688": 46006,
      "skein1024-696": 46007,
      "skein1024-704": 46008,
      "skein1024-712": 46009,
      "skein1024-720": 46010,
      "skein1024-728": 46011,
      "skein1024-736": 46012,
      "skein1024-744": 46013,
      "skein1024-752": 46014,
      "skein1024-760": 46015,
      "skein1024-768": 46016,
      "skein1024-776": 46017,
      "skein1024-784": 46018,
      "skein1024-792": 46019,
      "skein1024-800": 46020,
      "skein1024-808": 46021,
      "skein1024-816": 46022,
      "skein1024-824": 46023,
      "skein1024-832": 46024,
      "skein1024-840": 46025,
      "skein1024-848": 46026,
      "skein1024-856": 46027,
      "skein1024-864": 46028,
      "skein1024-872": 46029,
      "skein1024-880": 46030,
      "skein1024-888": 46031,
      "skein1024-896": 46032,
      "skein1024-904": 46033,
      "skein1024-912": 46034,
      "skein1024-920": 46035,
      "skein1024-928": 46036,
      "skein1024-936": 46037,
      "skein1024-944": 46038,
      "skein1024-952": 46039,
      "skein1024-960": 46040,
      "skein1024-968": 46041,
      "skein1024-976": 46042,
      "skein1024-984": 46043,
      "skein1024-992": 46044,
      "skein1024-1000": 46045,
      "skein1024-1008": 46046,
      "skein1024-1016": 46047,
      "skein1024-1024": 46048,
      "poseidon-bls12_381-a2-fc1": 46081,
      "poseidon-bls12_381-a2-fc1-sc": 46082,
      "zeroxcert-imprint-256": 52753,
      "fil-commitment-unsealed": 61697,
      "fil-commitment-sealed": 61698,
      "holochain-adr-v0": 8417572,
      "holochain-adr-v1": 8483108,
      "holochain-key-v0": 9728292,
      "holochain-key-v1": 9793828,
      "holochain-sig-v0": 10645796,
      "holochain-sig-v1": 10711332,
      "skynet-ns": 11639056,
      "arweave-ns": 11704592
    });
    module.exports = { baseTable };
  }
});

// node_modules/multicodec/src/maps.js
var require_maps = __commonJS({
  "node_modules/multicodec/src/maps.js"(exports, module) {
    "use strict";
    init_shim();
    var { baseTable } = require_generated_table();
    var varintEncode = require_util2().varintEncode;
    var nameToVarint = (
      /** @type {NameUint8ArrayMap} */
      {}
    );
    var constantToCode = (
      /** @type {ConstantCodeMap} */
      {}
    );
    var codeToName = (
      /** @type {CodeNameMap} */
      {}
    );
    for (const name in baseTable) {
      const codecName = (
        /** @type {CodecName} */
        name
      );
      const code = baseTable[codecName];
      nameToVarint[codecName] = varintEncode(code);
      const constant = (
        /** @type {CodecConstant} */
        codecName.toUpperCase().replace(/-/g, "_")
      );
      constantToCode[constant] = code;
      if (!codeToName[code]) {
        codeToName[code] = codecName;
      }
    }
    Object.freeze(nameToVarint);
    Object.freeze(constantToCode);
    Object.freeze(codeToName);
    var nameToCode = Object.freeze(baseTable);
    module.exports = {
      nameToVarint,
      constantToCode,
      nameToCode,
      codeToName
    };
  }
});

// node_modules/multicodec/src/index.js
var require_src4 = __commonJS({
  "node_modules/multicodec/src/index.js"(exports, module) {
    "use strict";
    init_shim();
    var varint = require_varint2();
    var { concat: uint8ArrayConcat } = (init_concat(), __toCommonJS(concat_exports));
    var util2 = require_util2();
    var { nameToVarint, constantToCode, nameToCode, codeToName } = require_maps();
    function addPrefix(multicodecStrOrCode, data) {
      let prefix2;
      if (multicodecStrOrCode instanceof Uint8Array) {
        prefix2 = util2.varintUint8ArrayEncode(multicodecStrOrCode);
      } else {
        if (nameToVarint[multicodecStrOrCode]) {
          prefix2 = nameToVarint[multicodecStrOrCode];
        } else {
          throw new Error("multicodec not recognized");
        }
      }
      return uint8ArrayConcat([prefix2, data], prefix2.length + data.length);
    }
    function rmPrefix(data) {
      varint.decode(
        /** @type {Buffer} */
        data
      );
      return data.slice(varint.decode.bytes);
    }
    function getNameFromData(prefixedData) {
      const code = (
        /** @type {CodecCode} */
        varint.decode(
          /** @type {Buffer} */
          prefixedData
        )
      );
      const name = codeToName[code];
      if (name === void 0) {
        throw new Error(`Code "${code}" not found`);
      }
      return name;
    }
    function getNameFromCode(codec) {
      return codeToName[codec];
    }
    function getCodeFromName(name) {
      const code = nameToCode[name];
      if (code === void 0) {
        throw new Error(`Codec "${name}" not found`);
      }
      return code;
    }
    function getCodeFromData(prefixedData) {
      return (
        /** @type {CodecCode} */
        varint.decode(
          /** @type {Buffer} */
          prefixedData
        )
      );
    }
    function getVarintFromName(name) {
      const code = nameToVarint[name];
      if (code === void 0) {
        throw new Error(`Codec "${name}" not found`);
      }
      return code;
    }
    function getVarintFromCode(code) {
      return util2.varintEncode(code);
    }
    function getCodec(prefixedData) {
      return getNameFromData(prefixedData);
    }
    function getName(codec) {
      return getNameFromCode(codec);
    }
    function getNumber(name) {
      return getCodeFromName(name);
    }
    function getCode(prefixedData) {
      return getCodeFromData(prefixedData);
    }
    function getCodeVarint(name) {
      return getVarintFromName(name);
    }
    function getVarint(code) {
      return Array.from(getVarintFromCode(code));
    }
    module.exports = {
      addPrefix,
      rmPrefix,
      getNameFromData,
      getNameFromCode,
      getCodeFromName,
      getCodeFromData,
      getVarintFromName,
      getVarintFromCode,
      // Deprecated
      getCodec,
      getName,
      getNumber,
      getCode,
      getCodeVarint,
      getVarint,
      // Make the constants top-level constants
      ...constantToCode,
      // Export the maps
      nameToVarint,
      nameToCode,
      codeToName
    };
  }
});

// node_modules/cids/src/cid-util.js
var require_cid_util = __commonJS({
  "node_modules/cids/src/cid-util.js"(exports, module) {
    "use strict";
    init_shim();
    var mh = require_src3();
    var CIDUtil = {
      /**
       * Test if the given input is a valid CID object.
       * Returns an error message if it is not.
       * Returns undefined if it is a valid CID.
       *
       * @param {any} other
       * @returns {string|undefined}
       */
      checkCIDComponents: function(other) {
        if (other == null) {
          return "null values are not valid CIDs";
        }
        if (!(other.version === 0 || other.version === 1)) {
          return "Invalid version, must be a number equal to 1 or 0";
        }
        if (typeof other.codec !== "string") {
          return "codec must be string";
        }
        if (other.version === 0) {
          if (other.codec !== "dag-pb") {
            return "codec must be 'dag-pb' for CIDv0";
          }
          if (other.multibaseName !== "base58btc") {
            return "multibaseName must be 'base58btc' for CIDv0";
          }
        }
        if (!(other.multihash instanceof Uint8Array)) {
          return "multihash must be a Uint8Array";
        }
        try {
          mh.validate(other.multihash);
        } catch (err) {
          let errorMsg = err.message;
          if (!errorMsg) {
            errorMsg = "Multihash validation failed";
          }
          return errorMsg;
        }
      }
    };
    module.exports = CIDUtil;
  }
});

// node_modules/cids/src/index.js
var require_src5 = __commonJS({
  "node_modules/cids/src/index.js"(exports, module) {
    "use strict";
    init_shim();
    var mh = require_src3();
    var multibase = require_src2();
    var multicodec = require_src4();
    var CIDUtil = require_cid_util();
    var { concat: uint8ArrayConcat } = (init_concat(), __toCommonJS(concat_exports));
    var { toString: uint8ArrayToString } = (init_to_string(), __toCommonJS(to_string_exports));
    var { equals: uint8ArrayEquals } = (init_equals(), __toCommonJS(equals_exports));
    var codecs = multicodec.nameToCode;
    var codecInts = (
      /** @type {CodecName[]} */
      Object.keys(codecs).reduce(
        (p, name) => {
          p[codecs[name]] = name;
          return p;
        },
        /** @type {Record<CodecCode, CodecName>} */
        {}
      )
    );
    var symbol = Symbol.for("@ipld/js-cid/CID");
    var CID = class _CID {
      /**
       * Create a new CID.
       *
       * The algorithm for argument input is roughly:
       * ```
       * if (cid)
       *   -> create a copy
       * else if (str)
       *   if (1st char is on multibase table) -> CID String
       *   else -> bs58 encoded multihash
       * else if (Uint8Array)
       *   if (1st byte is 0 or 1) -> CID
       *   else -> multihash
       * else if (Number)
       *   -> construct CID by parts
       * ```
       *
       * @param {CIDVersion | string | Uint8Array | CID} version
       * @param {string|number} [codec]
       * @param {Uint8Array} [multihash]
       * @param {string} [multibaseName]
       *
       * @example
       * new CID(<version>, <codec>, <multihash>, <multibaseName>)
       * new CID(<cidStr>)
       * new CID(<cid.bytes>)
       * new CID(<multihash>)
       * new CID(<bs58 encoded multihash>)
       * new CID(<cid>)
       */
      constructor(version, codec, multihash, multibaseName) {
        this.version;
        this.codec;
        this.multihash;
        Object.defineProperty(this, symbol, { value: true });
        if (_CID.isCID(version)) {
          const cid = (
            /** @type {CID} */
            version
          );
          this.version = cid.version;
          this.codec = cid.codec;
          this.multihash = cid.multihash;
          this.multibaseName = cid.multibaseName || (cid.version === 0 ? "base58btc" : "base32");
          return;
        }
        if (typeof version === "string") {
          const baseName = multibase.isEncoded(version);
          if (baseName) {
            const cid = multibase.decode(version);
            this.version = /** @type {CIDVersion} */
            parseInt(cid[0].toString(), 16);
            this.codec = multicodec.getCodec(cid.slice(1));
            this.multihash = multicodec.rmPrefix(cid.slice(1));
            this.multibaseName = baseName;
          } else {
            this.version = 0;
            this.codec = "dag-pb";
            this.multihash = mh.fromB58String(version);
            this.multibaseName = "base58btc";
          }
          _CID.validateCID(this);
          Object.defineProperty(this, "string", { value: version });
          return;
        }
        if (version instanceof Uint8Array) {
          const v = parseInt(version[0].toString(), 16);
          if (v === 1) {
            const cid = version;
            this.version = v;
            this.codec = multicodec.getCodec(cid.slice(1));
            this.multihash = multicodec.rmPrefix(cid.slice(1));
            this.multibaseName = "base32";
          } else {
            this.version = 0;
            this.codec = "dag-pb";
            this.multihash = version;
            this.multibaseName = "base58btc";
          }
          _CID.validateCID(this);
          return;
        }
        this.version = version;
        if (typeof codec === "number") {
          codec = codecInts[codec];
        }
        this.codec = /** @type {CodecName} */
        codec;
        this.multihash = /** @type {Uint8Array} */
        multihash;
        this.multibaseName = multibaseName || (version === 0 ? "base58btc" : "base32");
        _CID.validateCID(this);
      }
      /**
       * The CID as a `Uint8Array`
       *
       * @returns {Uint8Array}
       *
       */
      get bytes() {
        let bytes = this._bytes;
        if (!bytes) {
          if (this.version === 0) {
            bytes = this.multihash;
          } else if (this.version === 1) {
            const codec = multicodec.getCodeVarint(this.codec);
            bytes = uint8ArrayConcat([
              [1],
              codec,
              this.multihash
            ], 1 + codec.byteLength + this.multihash.byteLength);
          } else {
            throw new Error("unsupported version");
          }
          Object.defineProperty(this, "_bytes", { value: bytes });
        }
        return bytes;
      }
      /**
       * The prefix of the CID.
       *
       * @returns {Uint8Array}
       */
      get prefix() {
        const codec = multicodec.getCodeVarint(this.codec);
        const multihash = mh.prefix(this.multihash);
        const prefix2 = uint8ArrayConcat([
          [this.version],
          codec,
          multihash
        ], 1 + codec.byteLength + multihash.byteLength);
        return prefix2;
      }
      /**
       * The codec of the CID in its number form.
       *
       * @returns {CodecCode}
       */
      get code() {
        return codecs[this.codec];
      }
      /**
       * Convert to a CID of version `0`.
       *
       * @returns {CID}
       */
      toV0() {
        if (this.codec !== "dag-pb") {
          throw new Error("Cannot convert a non dag-pb CID to CIDv0");
        }
        const { name, length } = mh.decode(this.multihash);
        if (name !== "sha2-256") {
          throw new Error("Cannot convert non sha2-256 multihash CID to CIDv0");
        }
        if (length !== 32) {
          throw new Error("Cannot convert non 32 byte multihash CID to CIDv0");
        }
        return new _CID(0, this.codec, this.multihash);
      }
      /**
       * Convert to a CID of version `1`.
       *
       * @returns {CID}
       */
      toV1() {
        return new _CID(1, this.codec, this.multihash, this.multibaseName);
      }
      /**
       * Encode the CID into a string.
       *
       * @param {BaseNameOrCode} [base=this.multibaseName] - Base encoding to use.
       * @returns {string}
       */
      toBaseEncodedString(base = this.multibaseName) {
        if (this.string && this.string.length !== 0 && base === this.multibaseName) {
          return this.string;
        }
        let str;
        if (this.version === 0) {
          if (base !== "base58btc") {
            throw new Error("not supported with CIDv0, to support different bases, please migrate the instance do CIDv1, you can do that through cid.toV1()");
          }
          str = mh.toB58String(this.multihash);
        } else if (this.version === 1) {
          str = uint8ArrayToString(multibase.encode(base, this.bytes));
        } else {
          throw new Error("unsupported version");
        }
        if (base === this.multibaseName) {
          Object.defineProperty(this, "string", { value: str });
        }
        return str;
      }
      /**
       * CID(QmdfTbBqBPQ7VNxZEYEj14VmRuZBkqFbiwReogJgS1zR1n)
       *
       * @returns {string}
       */
      [Symbol.for("nodejs.util.inspect.custom")]() {
        return "CID(" + this.toString() + ")";
      }
      /**
       * Encode the CID into a string.
       *
       * @param {BaseNameOrCode} [base=this.multibaseName] - Base encoding to use.
       * @returns {string}
       */
      toString(base) {
        return this.toBaseEncodedString(base);
      }
      /**
       * Serialize to a plain object.
       *
       * @returns {SerializedCID}
       */
      toJSON() {
        return {
          codec: this.codec,
          version: this.version,
          hash: this.multihash
        };
      }
      /**
       * Compare equality with another CID.
       *
       * @param {CID} other
       * @returns {boolean}
       */
      equals(other) {
        return this.codec === other.codec && this.version === other.version && uint8ArrayEquals(this.multihash, other.multihash);
      }
      /**
       * Test if the given input is a valid CID object.
       * Throws if it is not.
       *
       * @param {any} other - The other CID.
       * @returns {void}
       */
      static validateCID(other) {
        const errorMsg = CIDUtil.checkCIDComponents(other);
        if (errorMsg) {
          throw new Error(errorMsg);
        }
      }
      /**
       * Check if object is a CID instance
       *
       * @param {any} value
       * @returns {value is CID}
       */
      static isCID(value) {
        return value instanceof _CID || Boolean(value && value[symbol]);
      }
    };
    CID.codecs = codecs;
    module.exports = CID;
  }
});

// node_modules/explain-error/index.js
var require_explain_error = __commonJS({
  "node_modules/explain-error/index.js"(exports, module) {
    init_shim();
    function getStack(err) {
      if (err.stack && err.name && err.message)
        return err.stack.substring(err.name.length + 3 + err.message.length).split("\n");
      else if (err.stack)
        return err.stack.split("\n");
    }
    function removePrefix(a, b) {
      return a.filter(function(e) {
        return !~b.indexOf(e);
      });
    }
    var explain = module.exports = function(err, message) {
      if (!(err.stack && err.name && err.message)) {
        console.error(new Error("stackless error"));
        return err;
      }
      var _err = new Error(message);
      var stack = removePrefix(getStack(_err).slice(1), getStack(err)).join("\n");
      _err.__proto__ = err;
      _err.stack = _err.name + ": " + _err.message + "\n" + stack + "\n  " + err.stack;
      return _err;
    };
  }
});

// node_modules/cid-tool/src/core/base32.js
var require_base32 = __commonJS({
  "node_modules/cid-tool/src/core/base32.js"(exports, module) {
    "use strict";
    init_shim();
    var CID = require_src5();
    var explain = require_explain_error();
    module.exports = function base32(cid) {
      try {
        cid = new CID(cid);
      } catch (err) {
        throw explain(err, `invalid cid: ${cid}`);
      }
      if (cid.version !== 1) {
        cid = cid.toV1();
      }
      return cid.toBaseEncodedString("base32");
    };
  }
});

// node_modules/cid-tool/src/core/bases.js
var require_bases = __commonJS({
  "node_modules/cid-tool/src/core/bases.js"(exports, module) {
    "use strict";
    init_shim();
    var multibase = require_src2();
    module.exports = function bases() {
      const output = [];
      for (const base of Object.values(multibase.names)) {
        output.push({ name: base.name, code: base.code });
      }
      return output;
    };
  }
});

// node_modules/cid-tool/src/core/codecs.js
var require_codecs = __commonJS({
  "node_modules/cid-tool/src/core/codecs.js"(exports, module) {
    "use strict";
    init_shim();
    var CID = require_src5();
    module.exports = function codecs() {
      const output = [];
      for (const [key, value] of Object.entries(CID.codecs)) {
        output.push({ name: key, code: value });
      }
      return output;
    };
  }
});

// node_modules/cid-tool/node_modules/uint8arrays/util/bases.js
var require_bases2 = __commonJS({
  "node_modules/cid-tool/node_modules/uint8arrays/util/bases.js"(exports, module) {
    "use strict";
    init_shim();
    var { bases } = (init_basics(), __toCommonJS(basics_exports));
    function createCodec(name, prefix2, encode, decode2) {
      return {
        name,
        prefix: prefix2,
        encoder: {
          name,
          prefix: prefix2,
          encode
        },
        decoder: {
          decode: decode2
        }
      };
    }
    var string = createCodec("utf8", "u", (buf) => {
      const decoder2 = new TextDecoder("utf8");
      return "u" + decoder2.decode(buf);
    }, (str) => {
      const encoder = new TextEncoder();
      return encoder.encode(str.substring(1));
    });
    var ascii = createCodec("ascii", "a", (buf) => {
      let string2 = "a";
      for (let i = 0; i < buf.length; i++) {
        string2 += String.fromCharCode(buf[i]);
      }
      return string2;
    }, (str) => {
      str = str.substring(1);
      const buf = new Uint8Array(str.length);
      for (let i = 0; i < str.length; i++) {
        buf[i] = str.charCodeAt(i);
      }
      return buf;
    });
    var BASES = {
      "utf8": string,
      "utf-8": string,
      "hex": bases.base16,
      "latin1": ascii,
      "ascii": ascii,
      "binary": ascii,
      ...bases
    };
    module.exports = BASES;
  }
});

// node_modules/cid-tool/node_modules/uint8arrays/to-string.js
var require_to_string = __commonJS({
  "node_modules/cid-tool/node_modules/uint8arrays/to-string.js"(exports, module) {
    "use strict";
    init_shim();
    var bases = require_bases2();
    function toString(array, encoding = "utf8") {
      const base = bases[encoding];
      if (!base) {
        throw new Error(`Unsupported encoding "${encoding}"`);
      }
      return base.encoder.encode(array).substring(1);
    }
    module.exports = toString;
  }
});

// node_modules/cid-tool/src/core/format.js
var require_format = __commonJS({
  "node_modules/cid-tool/src/core/format.js"(exports, module) {
    "use strict";
    init_shim();
    var CID = require_src5();
    var bases = require_bases();
    var codecs = require_codecs();
    var explain = require_explain_error();
    var multibase = require_src2();
    var multihash = require_src3();
    var uint8ArrayToString = require_to_string();
    module.exports = function format(cid, options) {
      options = options || {};
      let formatStr = options.format || "%s";
      if (formatStr === "prefix") {
        formatStr = "%P";
      }
      if (!isString(formatStr) || formatStr.indexOf("%") === -1) {
        throw new Error(`invalid format string: ${formatStr}`);
      }
      const originalCid = cid;
      try {
        cid = new CID(cid);
      } catch (err) {
        throw explain(err, `invalid cid: ${cid}`);
      }
      if (options.cidVersion != null && cid.version !== options.cidVersion) {
        if (options.cidVersion === 0) {
          cid = cid.toV0();
        } else if (options.cidVersion === 1) {
          cid = cid.toV1();
        } else {
          throw new Error(`invalid cid version: ${options.cidVersion}`);
        }
      }
      let base = "base58btc";
      if (options.base) {
        base = findBase(options.base).name;
      } else if (isString(originalCid)) {
        base = multibase.isEncoded(originalCid) || base;
      }
      return formatStr.replace(/%([a-zA-Z%])/g, replacer(cid, base));
    };
    function isString(obj) {
      return Object.prototype.toString.call(obj) === "[object String]";
    }
    function replacer(cid, base) {
      const replace = (match, specifier) => {
        switch (specifier) {
          case "%":
            return "%";
          case "b":
            return base;
          case "B":
            return findBase(base).code;
          case "v":
            return `cidv${cid.version}`;
          case "V":
            return cid.version.toString();
          case "c":
            return cid.codec;
          case "C":
            return findCodec(cid).toString();
          case "h":
            return multihash.decode(cid.multihash).name;
          case "H":
            return multihash.decode(cid.multihash).code.toString();
          case "L":
            return multihash.decode(cid.multihash).length.toString();
          case "m":
            return uint8ArrayToString(multibase.encode(base, cid.multihash));
          case "M":
            return uint8ArrayToString(cid.multihash, base);
          case "d":
            return uint8ArrayToString(multibase.encode(base, multihash.decode(cid.multihash).digest));
          case "D":
            return uint8ArrayToString(multihash.decode(cid.multihash).digest, base);
          case "s":
            return cid.toString(base);
          case "S":
            return cid.version === 1 ? cid.toString(base).slice(1) : uint8ArrayToString(cid.bytes, base);
          case "P":
            return prefix2(cid);
          default:
            throw new Error(`unrecognized specifier in format string: ${specifier}`);
        }
      };
      return replace;
    }
    function findBase(nameOrCode) {
      const baseNameCode = bases().find((b) => b.code === nameOrCode || b.name === nameOrCode);
      if (!baseNameCode) {
        throw new Error(`invalid multibase: ${nameOrCode}`);
      }
      return baseNameCode;
    }
    function findCodec(cid) {
      const codec = codecs().find((c) => c.name === cid.codec);
      if (!codec) {
        throw new Error(`invalid codec: ${cid.codec}`);
      }
      return codec.code;
    }
    function prefix2(cid) {
      const { name, length } = multihash.decode(cid.multihash);
      return `cidv${cid.version}-${cid.codec}-${name}-${length}`;
    }
  }
});

// node_modules/cid-tool/src/core/hashes.js
var require_hashes = __commonJS({
  "node_modules/cid-tool/src/core/hashes.js"(exports, module) {
    "use strict";
    init_shim();
    var multihash = require_src3();
    module.exports = function hashes() {
      const output = [];
      for (const [name, code] of Object.entries(multihash.names)) {
        output.push({ name, code });
      }
      return output;
    };
  }
});

// node_modules/cid-tool/src/core/index.js
var require_core = __commonJS({
  "node_modules/cid-tool/src/core/index.js"(exports) {
    "use strict";
    init_shim();
    exports.base32 = require_base32();
    exports.bases = require_bases();
    exports.codecs = require_codecs();
    exports.format = require_format();
    exports.hashes = require_hashes();
  }
});

// node_modules/cid-tool/src/index.js
var require_src6 = __commonJS({
  "node_modules/cid-tool/src/index.js"(exports, module) {
    "use strict";
    init_shim();
    module.exports = require_core();
  }
});

// node_modules/form-data/lib/browser.js
var require_browser = __commonJS({
  "node_modules/form-data/lib/browser.js"(exports, module) {
    init_shim();
    module.exports = typeof self == "object" ? self.FormData : window.FormData;
  }
});

// node_modules/fast-deep-equal/index.js
var require_fast_deep_equal = __commonJS({
  "node_modules/fast-deep-equal/index.js"(exports, module) {
    "use strict";
    init_shim();
    module.exports = function equal(a, b) {
      if (a === b)
        return true;
      if (a && b && typeof a == "object" && typeof b == "object") {
        if (a.constructor !== b.constructor)
          return false;
        var length, i, keys;
        if (Array.isArray(a)) {
          length = a.length;
          if (length != b.length)
            return false;
          for (i = length; i-- !== 0; )
            if (!equal(a[i], b[i]))
              return false;
          return true;
        }
        if (a.constructor === RegExp)
          return a.source === b.source && a.flags === b.flags;
        if (a.valueOf !== Object.prototype.valueOf)
          return a.valueOf() === b.valueOf();
        if (a.toString !== Object.prototype.toString)
          return a.toString() === b.toString();
        keys = Object.keys(a);
        length = keys.length;
        if (length !== Object.keys(b).length)
          return false;
        for (i = length; i-- !== 0; )
          if (!Object.prototype.hasOwnProperty.call(b, keys[i]))
            return false;
        for (i = length; i-- !== 0; ) {
          var key = keys[i];
          if (!equal(a[key], b[key]))
            return false;
        }
        return true;
      }
      return a !== a && b !== b;
    };
  }
});

// node_modules/buffer-reverse/index.js
var require_buffer_reverse = __commonJS({
  "node_modules/buffer-reverse/index.js"(exports, module) {
    init_shim();
    module.exports = function reverse(src2) {
      var buffer = new import_buffer.Buffer(src2.length);
      for (var i = 0, j = src2.length - 1; i <= j; ++i, --j) {
        buffer[i] = src2[j];
        buffer[j] = src2[i];
      }
      return buffer;
    };
  }
});

// node_modules/merkletreejs/node_modules/crypto-js/core.js
var require_core2 = __commonJS({
  "node_modules/merkletreejs/node_modules/crypto-js/core.js"(exports, module) {
    init_shim();
    (function(root, factory) {
      if (typeof exports === "object") {
        module.exports = exports = factory();
      } else if (typeof define === "function" && define.amd) {
        define([], factory);
      } else {
        root.CryptoJS = factory();
      }
    })(exports, function() {
      var CryptoJS = CryptoJS || function(Math2, undefined2) {
        var create = Object.create || function() {
          function F() {
          }
          ;
          return function(obj) {
            var subtype;
            F.prototype = obj;
            subtype = new F();
            F.prototype = null;
            return subtype;
          };
        }();
        var C = {};
        var C_lib = C.lib = {};
        var Base = C_lib.Base = function() {
          return {
            /**
             * Creates a new object that inherits from this object.
             *
             * @param {Object} overrides Properties to copy into the new object.
             *
             * @return {Object} The new object.
             *
             * @static
             *
             * @example
             *
             *     var MyType = CryptoJS.lib.Base.extend({
             *         field: 'value',
             *
             *         method: function () {
             *         }
             *     });
             */
            extend: function(overrides) {
              var subtype = create(this);
              if (overrides) {
                subtype.mixIn(overrides);
              }
              if (!subtype.hasOwnProperty("init") || this.init === subtype.init) {
                subtype.init = function() {
                  subtype.$super.init.apply(this, arguments);
                };
              }
              subtype.init.prototype = subtype;
              subtype.$super = this;
              return subtype;
            },
            /**
             * Extends this object and runs the init method.
             * Arguments to create() will be passed to init().
             *
             * @return {Object} The new object.
             *
             * @static
             *
             * @example
             *
             *     var instance = MyType.create();
             */
            create: function() {
              var instance = this.extend();
              instance.init.apply(instance, arguments);
              return instance;
            },
            /**
             * Initializes a newly created object.
             * Override this method to add some logic when your objects are created.
             *
             * @example
             *
             *     var MyType = CryptoJS.lib.Base.extend({
             *         init: function () {
             *             // ...
             *         }
             *     });
             */
            init: function() {
            },
            /**
             * Copies properties into this object.
             *
             * @param {Object} properties The properties to mix in.
             *
             * @example
             *
             *     MyType.mixIn({
             *         field: 'value'
             *     });
             */
            mixIn: function(properties) {
              for (var propertyName in properties) {
                if (properties.hasOwnProperty(propertyName)) {
                  this[propertyName] = properties[propertyName];
                }
              }
              if (properties.hasOwnProperty("toString")) {
                this.toString = properties.toString;
              }
            },
            /**
             * Creates a copy of this object.
             *
             * @return {Object} The clone.
             *
             * @example
             *
             *     var clone = instance.clone();
             */
            clone: function() {
              return this.init.prototype.extend(this);
            }
          };
        }();
        var WordArray = C_lib.WordArray = Base.extend({
          /**
           * Initializes a newly created word array.
           *
           * @param {Array} words (Optional) An array of 32-bit words.
           * @param {number} sigBytes (Optional) The number of significant bytes in the words.
           *
           * @example
           *
           *     var wordArray = CryptoJS.lib.WordArray.create();
           *     var wordArray = CryptoJS.lib.WordArray.create([0x00010203, 0x04050607]);
           *     var wordArray = CryptoJS.lib.WordArray.create([0x00010203, 0x04050607], 6);
           */
          init: function(words, sigBytes) {
            words = this.words = words || [];
            if (sigBytes != undefined2) {
              this.sigBytes = sigBytes;
            } else {
              this.sigBytes = words.length * 4;
            }
          },
          /**
           * Converts this word array to a string.
           *
           * @param {Encoder} encoder (Optional) The encoding strategy to use. Default: CryptoJS.enc.Hex
           *
           * @return {string} The stringified word array.
           *
           * @example
           *
           *     var string = wordArray + '';
           *     var string = wordArray.toString();
           *     var string = wordArray.toString(CryptoJS.enc.Utf8);
           */
          toString: function(encoder) {
            return (encoder || Hex).stringify(this);
          },
          /**
           * Concatenates a word array to this word array.
           *
           * @param {WordArray} wordArray The word array to append.
           *
           * @return {WordArray} This word array.
           *
           * @example
           *
           *     wordArray1.concat(wordArray2);
           */
          concat: function(wordArray) {
            var thisWords = this.words;
            var thatWords = wordArray.words;
            var thisSigBytes = this.sigBytes;
            var thatSigBytes = wordArray.sigBytes;
            this.clamp();
            if (thisSigBytes % 4) {
              for (var i = 0; i < thatSigBytes; i++) {
                var thatByte = thatWords[i >>> 2] >>> 24 - i % 4 * 8 & 255;
                thisWords[thisSigBytes + i >>> 2] |= thatByte << 24 - (thisSigBytes + i) % 4 * 8;
              }
            } else {
              for (var i = 0; i < thatSigBytes; i += 4) {
                thisWords[thisSigBytes + i >>> 2] = thatWords[i >>> 2];
              }
            }
            this.sigBytes += thatSigBytes;
            return this;
          },
          /**
           * Removes insignificant bits.
           *
           * @example
           *
           *     wordArray.clamp();
           */
          clamp: function() {
            var words = this.words;
            var sigBytes = this.sigBytes;
            words[sigBytes >>> 2] &= 4294967295 << 32 - sigBytes % 4 * 8;
            words.length = Math2.ceil(sigBytes / 4);
          },
          /**
           * Creates a copy of this word array.
           *
           * @return {WordArray} The clone.
           *
           * @example
           *
           *     var clone = wordArray.clone();
           */
          clone: function() {
            var clone = Base.clone.call(this);
            clone.words = this.words.slice(0);
            return clone;
          },
          /**
           * Creates a word array filled with random bytes.
           *
           * @param {number} nBytes The number of random bytes to generate.
           *
           * @return {WordArray} The random word array.
           *
           * @static
           *
           * @example
           *
           *     var wordArray = CryptoJS.lib.WordArray.random(16);
           */
          random: function(nBytes) {
            var words = [];
            var r = function(m_w) {
              var m_w = m_w;
              var m_z = 987654321;
              var mask = 4294967295;
              return function() {
                m_z = 36969 * (m_z & 65535) + (m_z >> 16) & mask;
                m_w = 18e3 * (m_w & 65535) + (m_w >> 16) & mask;
                var result = (m_z << 16) + m_w & mask;
                result /= 4294967296;
                result += 0.5;
                return result * (Math2.random() > 0.5 ? 1 : -1);
              };
            };
            for (var i = 0, rcache; i < nBytes; i += 4) {
              var _r = r((rcache || Math2.random()) * 4294967296);
              rcache = _r() * 987654071;
              words.push(_r() * 4294967296 | 0);
            }
            return new WordArray.init(words, nBytes);
          }
        });
        var C_enc = C.enc = {};
        var Hex = C_enc.Hex = {
          /**
           * Converts a word array to a hex string.
           *
           * @param {WordArray} wordArray The word array.
           *
           * @return {string} The hex string.
           *
           * @static
           *
           * @example
           *
           *     var hexString = CryptoJS.enc.Hex.stringify(wordArray);
           */
          stringify: function(wordArray) {
            var words = wordArray.words;
            var sigBytes = wordArray.sigBytes;
            var hexChars = [];
            for (var i = 0; i < sigBytes; i++) {
              var bite = words[i >>> 2] >>> 24 - i % 4 * 8 & 255;
              hexChars.push((bite >>> 4).toString(16));
              hexChars.push((bite & 15).toString(16));
            }
            return hexChars.join("");
          },
          /**
           * Converts a hex string to a word array.
           *
           * @param {string} hexStr The hex string.
           *
           * @return {WordArray} The word array.
           *
           * @static
           *
           * @example
           *
           *     var wordArray = CryptoJS.enc.Hex.parse(hexString);
           */
          parse: function(hexStr) {
            var hexStrLength = hexStr.length;
            var words = [];
            for (var i = 0; i < hexStrLength; i += 2) {
              words[i >>> 3] |= parseInt(hexStr.substr(i, 2), 16) << 24 - i % 8 * 4;
            }
            return new WordArray.init(words, hexStrLength / 2);
          }
        };
        var Latin1 = C_enc.Latin1 = {
          /**
           * Converts a word array to a Latin1 string.
           *
           * @param {WordArray} wordArray The word array.
           *
           * @return {string} The Latin1 string.
           *
           * @static
           *
           * @example
           *
           *     var latin1String = CryptoJS.enc.Latin1.stringify(wordArray);
           */
          stringify: function(wordArray) {
            var words = wordArray.words;
            var sigBytes = wordArray.sigBytes;
            var latin1Chars = [];
            for (var i = 0; i < sigBytes; i++) {
              var bite = words[i >>> 2] >>> 24 - i % 4 * 8 & 255;
              latin1Chars.push(String.fromCharCode(bite));
            }
            return latin1Chars.join("");
          },
          /**
           * Converts a Latin1 string to a word array.
           *
           * @param {string} latin1Str The Latin1 string.
           *
           * @return {WordArray} The word array.
           *
           * @static
           *
           * @example
           *
           *     var wordArray = CryptoJS.enc.Latin1.parse(latin1String);
           */
          parse: function(latin1Str) {
            var latin1StrLength = latin1Str.length;
            var words = [];
            for (var i = 0; i < latin1StrLength; i++) {
              words[i >>> 2] |= (latin1Str.charCodeAt(i) & 255) << 24 - i % 4 * 8;
            }
            return new WordArray.init(words, latin1StrLength);
          }
        };
        var Utf8 = C_enc.Utf8 = {
          /**
           * Converts a word array to a UTF-8 string.
           *
           * @param {WordArray} wordArray The word array.
           *
           * @return {string} The UTF-8 string.
           *
           * @static
           *
           * @example
           *
           *     var utf8String = CryptoJS.enc.Utf8.stringify(wordArray);
           */
          stringify: function(wordArray) {
            try {
              return decodeURIComponent(escape(Latin1.stringify(wordArray)));
            } catch (e) {
              throw new Error("Malformed UTF-8 data");
            }
          },
          /**
           * Converts a UTF-8 string to a word array.
           *
           * @param {string} utf8Str The UTF-8 string.
           *
           * @return {WordArray} The word array.
           *
           * @static
           *
           * @example
           *
           *     var wordArray = CryptoJS.enc.Utf8.parse(utf8String);
           */
          parse: function(utf8Str) {
            return Latin1.parse(unescape(encodeURIComponent(utf8Str)));
          }
        };
        var BufferedBlockAlgorithm = C_lib.BufferedBlockAlgorithm = Base.extend({
          /**
           * Resets this block algorithm's data buffer to its initial state.
           *
           * @example
           *
           *     bufferedBlockAlgorithm.reset();
           */
          reset: function() {
            this._data = new WordArray.init();
            this._nDataBytes = 0;
          },
          /**
           * Adds new data to this block algorithm's buffer.
           *
           * @param {WordArray|string} data The data to append. Strings are converted to a WordArray using UTF-8.
           *
           * @example
           *
           *     bufferedBlockAlgorithm._append('data');
           *     bufferedBlockAlgorithm._append(wordArray);
           */
          _append: function(data) {
            if (typeof data == "string") {
              data = Utf8.parse(data);
            }
            this._data.concat(data);
            this._nDataBytes += data.sigBytes;
          },
          /**
           * Processes available data blocks.
           *
           * This method invokes _doProcessBlock(offset), which must be implemented by a concrete subtype.
           *
           * @param {boolean} doFlush Whether all blocks and partial blocks should be processed.
           *
           * @return {WordArray} The processed data.
           *
           * @example
           *
           *     var processedData = bufferedBlockAlgorithm._process();
           *     var processedData = bufferedBlockAlgorithm._process(!!'flush');
           */
          _process: function(doFlush) {
            var data = this._data;
            var dataWords = data.words;
            var dataSigBytes = data.sigBytes;
            var blockSize = this.blockSize;
            var blockSizeBytes = blockSize * 4;
            var nBlocksReady = dataSigBytes / blockSizeBytes;
            if (doFlush) {
              nBlocksReady = Math2.ceil(nBlocksReady);
            } else {
              nBlocksReady = Math2.max((nBlocksReady | 0) - this._minBufferSize, 0);
            }
            var nWordsReady = nBlocksReady * blockSize;
            var nBytesReady = Math2.min(nWordsReady * 4, dataSigBytes);
            if (nWordsReady) {
              for (var offset = 0; offset < nWordsReady; offset += blockSize) {
                this._doProcessBlock(dataWords, offset);
              }
              var processedWords = dataWords.splice(0, nWordsReady);
              data.sigBytes -= nBytesReady;
            }
            return new WordArray.init(processedWords, nBytesReady);
          },
          /**
           * Creates a copy of this object.
           *
           * @return {Object} The clone.
           *
           * @example
           *
           *     var clone = bufferedBlockAlgorithm.clone();
           */
          clone: function() {
            var clone = Base.clone.call(this);
            clone._data = this._data.clone();
            return clone;
          },
          _minBufferSize: 0
        });
        var Hasher = C_lib.Hasher = BufferedBlockAlgorithm.extend({
          /**
           * Configuration options.
           */
          cfg: Base.extend(),
          /**
           * Initializes a newly created hasher.
           *
           * @param {Object} cfg (Optional) The configuration options to use for this hash computation.
           *
           * @example
           *
           *     var hasher = CryptoJS.algo.SHA256.create();
           */
          init: function(cfg) {
            this.cfg = this.cfg.extend(cfg);
            this.reset();
          },
          /**
           * Resets this hasher to its initial state.
           *
           * @example
           *
           *     hasher.reset();
           */
          reset: function() {
            BufferedBlockAlgorithm.reset.call(this);
            this._doReset();
          },
          /**
           * Updates this hasher with a message.
           *
           * @param {WordArray|string} messageUpdate The message to append.
           *
           * @return {Hasher} This hasher.
           *
           * @example
           *
           *     hasher.update('message');
           *     hasher.update(wordArray);
           */
          update: function(messageUpdate) {
            this._append(messageUpdate);
            this._process();
            return this;
          },
          /**
           * Finalizes the hash computation.
           * Note that the finalize operation is effectively a destructive, read-once operation.
           *
           * @param {WordArray|string} messageUpdate (Optional) A final message update.
           *
           * @return {WordArray} The hash.
           *
           * @example
           *
           *     var hash = hasher.finalize();
           *     var hash = hasher.finalize('message');
           *     var hash = hasher.finalize(wordArray);
           */
          finalize: function(messageUpdate) {
            if (messageUpdate) {
              this._append(messageUpdate);
            }
            var hash = this._doFinalize();
            return hash;
          },
          blockSize: 512 / 32,
          /**
           * Creates a shortcut function to a hasher's object interface.
           *
           * @param {Hasher} hasher The hasher to create a helper for.
           *
           * @return {Function} The shortcut function.
           *
           * @static
           *
           * @example
           *
           *     var SHA256 = CryptoJS.lib.Hasher._createHelper(CryptoJS.algo.SHA256);
           */
          _createHelper: function(hasher) {
            return function(message, cfg) {
              return new hasher.init(cfg).finalize(message);
            };
          },
          /**
           * Creates a shortcut function to the HMAC's object interface.
           *
           * @param {Hasher} hasher The hasher to use in this HMAC helper.
           *
           * @return {Function} The shortcut function.
           *
           * @static
           *
           * @example
           *
           *     var HmacSHA256 = CryptoJS.lib.Hasher._createHmacHelper(CryptoJS.algo.SHA256);
           */
          _createHmacHelper: function(hasher) {
            return function(message, key) {
              return new C_algo.HMAC.init(hasher, key).finalize(message);
            };
          }
        });
        var C_algo = C.algo = {};
        return C;
      }(Math);
      return CryptoJS;
    });
  }
});

// node_modules/merkletreejs/node_modules/crypto-js/sha256.js
var require_sha256 = __commonJS({
  "node_modules/merkletreejs/node_modules/crypto-js/sha256.js"(exports, module) {
    init_shim();
    (function(root, factory) {
      if (typeof exports === "object") {
        module.exports = exports = factory(require_core2());
      } else if (typeof define === "function" && define.amd) {
        define(["./core"], factory);
      } else {
        factory(root.CryptoJS);
      }
    })(exports, function(CryptoJS) {
      (function(Math2) {
        var C = CryptoJS;
        var C_lib = C.lib;
        var WordArray = C_lib.WordArray;
        var Hasher = C_lib.Hasher;
        var C_algo = C.algo;
        var H = [];
        var K = [];
        (function() {
          function isPrime(n2) {
            var sqrtN = Math2.sqrt(n2);
            for (var factor = 2; factor <= sqrtN; factor++) {
              if (!(n2 % factor)) {
                return false;
              }
            }
            return true;
          }
          function getFractionalBits(n2) {
            return (n2 - (n2 | 0)) * 4294967296 | 0;
          }
          var n = 2;
          var nPrime = 0;
          while (nPrime < 64) {
            if (isPrime(n)) {
              if (nPrime < 8) {
                H[nPrime] = getFractionalBits(Math2.pow(n, 1 / 2));
              }
              K[nPrime] = getFractionalBits(Math2.pow(n, 1 / 3));
              nPrime++;
            }
            n++;
          }
        })();
        var W = [];
        var SHA256 = C_algo.SHA256 = Hasher.extend({
          _doReset: function() {
            this._hash = new WordArray.init(H.slice(0));
          },
          _doProcessBlock: function(M, offset) {
            var H2 = this._hash.words;
            var a = H2[0];
            var b = H2[1];
            var c = H2[2];
            var d = H2[3];
            var e = H2[4];
            var f2 = H2[5];
            var g = H2[6];
            var h = H2[7];
            for (var i = 0; i < 64; i++) {
              if (i < 16) {
                W[i] = M[offset + i] | 0;
              } else {
                var gamma0x = W[i - 15];
                var gamma0 = (gamma0x << 25 | gamma0x >>> 7) ^ (gamma0x << 14 | gamma0x >>> 18) ^ gamma0x >>> 3;
                var gamma1x = W[i - 2];
                var gamma1 = (gamma1x << 15 | gamma1x >>> 17) ^ (gamma1x << 13 | gamma1x >>> 19) ^ gamma1x >>> 10;
                W[i] = gamma0 + W[i - 7] + gamma1 + W[i - 16];
              }
              var ch = e & f2 ^ ~e & g;
              var maj = a & b ^ a & c ^ b & c;
              var sigma0 = (a << 30 | a >>> 2) ^ (a << 19 | a >>> 13) ^ (a << 10 | a >>> 22);
              var sigma1 = (e << 26 | e >>> 6) ^ (e << 21 | e >>> 11) ^ (e << 7 | e >>> 25);
              var t1 = h + sigma1 + ch + K[i] + W[i];
              var t2 = sigma0 + maj;
              h = g;
              g = f2;
              f2 = e;
              e = d + t1 | 0;
              d = c;
              c = b;
              b = a;
              a = t1 + t2 | 0;
            }
            H2[0] = H2[0] + a | 0;
            H2[1] = H2[1] + b | 0;
            H2[2] = H2[2] + c | 0;
            H2[3] = H2[3] + d | 0;
            H2[4] = H2[4] + e | 0;
            H2[5] = H2[5] + f2 | 0;
            H2[6] = H2[6] + g | 0;
            H2[7] = H2[7] + h | 0;
          },
          _doFinalize: function() {
            var data = this._data;
            var dataWords = data.words;
            var nBitsTotal = this._nDataBytes * 8;
            var nBitsLeft = data.sigBytes * 8;
            dataWords[nBitsLeft >>> 5] |= 128 << 24 - nBitsLeft % 32;
            dataWords[(nBitsLeft + 64 >>> 9 << 4) + 14] = Math2.floor(nBitsTotal / 4294967296);
            dataWords[(nBitsLeft + 64 >>> 9 << 4) + 15] = nBitsTotal;
            data.sigBytes = dataWords.length * 4;
            this._process();
            return this._hash;
          },
          clone: function() {
            var clone = Hasher.clone.call(this);
            clone._hash = this._hash.clone();
            return clone;
          }
        });
        C.SHA256 = Hasher._createHelper(SHA256);
        C.HmacSHA256 = Hasher._createHmacHelper(SHA256);
      })(Math);
      return CryptoJS.SHA256;
    });
  }
});

// node_modules/treeify/treeify.js
var require_treeify = __commonJS({
  "node_modules/treeify/treeify.js"(exports, module) {
    init_shim();
    (function(root, factory) {
      if (typeof exports === "object") {
        module.exports = factory();
      } else if (typeof define === "function" && define.amd) {
        define(factory);
      } else {
        root.treeify = factory();
      }
    })(exports, function() {
      function makePrefix(key, last) {
        var str = last ? "└" : "├";
        if (key) {
          str += "─ ";
        } else {
          str += "──┐";
        }
        return str;
      }
      function filterKeys(obj, hideFunctions) {
        var keys = [];
        for (var branch in obj) {
          if (!obj.hasOwnProperty(branch)) {
            continue;
          }
          if (hideFunctions && typeof obj[branch] === "function") {
            continue;
          }
          keys.push(branch);
        }
        return keys;
      }
      function growBranch(key, root, last, lastStates, showValues, hideFunctions, callback) {
        var line = "", index = 0, lastKey, circular, lastStatesCopy = lastStates.slice(0);
        if (lastStatesCopy.push([root, last]) && lastStates.length > 0) {
          lastStates.forEach(function(lastState, idx) {
            if (idx > 0) {
              line += (lastState[1] ? " " : "│") + "  ";
            }
            if (!circular && lastState[0] === root) {
              circular = true;
            }
          });
          line += makePrefix(key, last) + key;
          showValues && (typeof root !== "object" || root instanceof Date) && (line += ": " + root);
          circular && (line += " (circular ref.)");
          callback(line);
        }
        if (!circular && typeof root === "object") {
          var keys = filterKeys(root, hideFunctions);
          keys.forEach(function(branch) {
            lastKey = ++index === keys.length;
            growBranch(branch, root[branch], lastKey, lastStatesCopy, showValues, hideFunctions, callback);
          });
        }
      }
      ;
      var Treeify = {};
      Treeify.asLines = function(obj, showValues, hideFunctions, lineCallback) {
        var hideFunctionsArg = typeof hideFunctions !== "function" ? hideFunctions : false;
        growBranch(".", obj, false, [], showValues, hideFunctionsArg, lineCallback || hideFunctions);
      };
      Treeify.asTree = function(obj, showValues, hideFunctions) {
        var tree = "";
        growBranch(".", obj, false, [], showValues, hideFunctions, function(line) {
          tree += line + "\n";
        });
        return tree;
      };
      return Treeify;
    });
  }
});

// node_modules/merkletreejs/node_modules/crypto-js/x64-core.js
var require_x64_core = __commonJS({
  "node_modules/merkletreejs/node_modules/crypto-js/x64-core.js"(exports, module) {
    init_shim();
    (function(root, factory) {
      if (typeof exports === "object") {
        module.exports = exports = factory(require_core2());
      } else if (typeof define === "function" && define.amd) {
        define(["./core"], factory);
      } else {
        factory(root.CryptoJS);
      }
    })(exports, function(CryptoJS) {
      (function(undefined2) {
        var C = CryptoJS;
        var C_lib = C.lib;
        var Base = C_lib.Base;
        var X32WordArray = C_lib.WordArray;
        var C_x64 = C.x64 = {};
        var X64Word = C_x64.Word = Base.extend({
          /**
           * Initializes a newly created 64-bit word.
           *
           * @param {number} high The high 32 bits.
           * @param {number} low The low 32 bits.
           *
           * @example
           *
           *     var x64Word = CryptoJS.x64.Word.create(0x00010203, 0x04050607);
           */
          init: function(high, low) {
            this.high = high;
            this.low = low;
          }
          /**
           * Bitwise NOTs this word.
           *
           * @return {X64Word} A new x64-Word object after negating.
           *
           * @example
           *
           *     var negated = x64Word.not();
           */
          // not: function () {
          // var high = ~this.high;
          // var low = ~this.low;
          // return X64Word.create(high, low);
          // },
          /**
           * Bitwise ANDs this word with the passed word.
           *
           * @param {X64Word} word The x64-Word to AND with this word.
           *
           * @return {X64Word} A new x64-Word object after ANDing.
           *
           * @example
           *
           *     var anded = x64Word.and(anotherX64Word);
           */
          // and: function (word) {
          // var high = this.high & word.high;
          // var low = this.low & word.low;
          // return X64Word.create(high, low);
          // },
          /**
           * Bitwise ORs this word with the passed word.
           *
           * @param {X64Word} word The x64-Word to OR with this word.
           *
           * @return {X64Word} A new x64-Word object after ORing.
           *
           * @example
           *
           *     var ored = x64Word.or(anotherX64Word);
           */
          // or: function (word) {
          // var high = this.high | word.high;
          // var low = this.low | word.low;
          // return X64Word.create(high, low);
          // },
          /**
           * Bitwise XORs this word with the passed word.
           *
           * @param {X64Word} word The x64-Word to XOR with this word.
           *
           * @return {X64Word} A new x64-Word object after XORing.
           *
           * @example
           *
           *     var xored = x64Word.xor(anotherX64Word);
           */
          // xor: function (word) {
          // var high = this.high ^ word.high;
          // var low = this.low ^ word.low;
          // return X64Word.create(high, low);
          // },
          /**
           * Shifts this word n bits to the left.
           *
           * @param {number} n The number of bits to shift.
           *
           * @return {X64Word} A new x64-Word object after shifting.
           *
           * @example
           *
           *     var shifted = x64Word.shiftL(25);
           */
          // shiftL: function (n) {
          // if (n < 32) {
          // var high = (this.high << n) | (this.low >>> (32 - n));
          // var low = this.low << n;
          // } else {
          // var high = this.low << (n - 32);
          // var low = 0;
          // }
          // return X64Word.create(high, low);
          // },
          /**
           * Shifts this word n bits to the right.
           *
           * @param {number} n The number of bits to shift.
           *
           * @return {X64Word} A new x64-Word object after shifting.
           *
           * @example
           *
           *     var shifted = x64Word.shiftR(7);
           */
          // shiftR: function (n) {
          // if (n < 32) {
          // var low = (this.low >>> n) | (this.high << (32 - n));
          // var high = this.high >>> n;
          // } else {
          // var low = this.high >>> (n - 32);
          // var high = 0;
          // }
          // return X64Word.create(high, low);
          // },
          /**
           * Rotates this word n bits to the left.
           *
           * @param {number} n The number of bits to rotate.
           *
           * @return {X64Word} A new x64-Word object after rotating.
           *
           * @example
           *
           *     var rotated = x64Word.rotL(25);
           */
          // rotL: function (n) {
          // return this.shiftL(n).or(this.shiftR(64 - n));
          // },
          /**
           * Rotates this word n bits to the right.
           *
           * @param {number} n The number of bits to rotate.
           *
           * @return {X64Word} A new x64-Word object after rotating.
           *
           * @example
           *
           *     var rotated = x64Word.rotR(7);
           */
          // rotR: function (n) {
          // return this.shiftR(n).or(this.shiftL(64 - n));
          // },
          /**
           * Adds this word with the passed word.
           *
           * @param {X64Word} word The x64-Word to add with this word.
           *
           * @return {X64Word} A new x64-Word object after adding.
           *
           * @example
           *
           *     var added = x64Word.add(anotherX64Word);
           */
          // add: function (word) {
          // var low = (this.low + word.low) | 0;
          // var carry = (low >>> 0) < (this.low >>> 0) ? 1 : 0;
          // var high = (this.high + word.high + carry) | 0;
          // return X64Word.create(high, low);
          // }
        });
        var X64WordArray = C_x64.WordArray = Base.extend({
          /**
           * Initializes a newly created word array.
           *
           * @param {Array} words (Optional) An array of CryptoJS.x64.Word objects.
           * @param {number} sigBytes (Optional) The number of significant bytes in the words.
           *
           * @example
           *
           *     var wordArray = CryptoJS.x64.WordArray.create();
           *
           *     var wordArray = CryptoJS.x64.WordArray.create([
           *         CryptoJS.x64.Word.create(0x00010203, 0x04050607),
           *         CryptoJS.x64.Word.create(0x18191a1b, 0x1c1d1e1f)
           *     ]);
           *
           *     var wordArray = CryptoJS.x64.WordArray.create([
           *         CryptoJS.x64.Word.create(0x00010203, 0x04050607),
           *         CryptoJS.x64.Word.create(0x18191a1b, 0x1c1d1e1f)
           *     ], 10);
           */
          init: function(words, sigBytes) {
            words = this.words = words || [];
            if (sigBytes != undefined2) {
              this.sigBytes = sigBytes;
            } else {
              this.sigBytes = words.length * 8;
            }
          },
          /**
           * Converts this 64-bit word array to a 32-bit word array.
           *
           * @return {CryptoJS.lib.WordArray} This word array's data as a 32-bit word array.
           *
           * @example
           *
           *     var x32WordArray = x64WordArray.toX32();
           */
          toX32: function() {
            var x64Words = this.words;
            var x64WordsLength = x64Words.length;
            var x32Words = [];
            for (var i = 0; i < x64WordsLength; i++) {
              var x64Word = x64Words[i];
              x32Words.push(x64Word.high);
              x32Words.push(x64Word.low);
            }
            return X32WordArray.create(x32Words, this.sigBytes);
          },
          /**
           * Creates a copy of this word array.
           *
           * @return {X64WordArray} The clone.
           *
           * @example
           *
           *     var clone = x64WordArray.clone();
           */
          clone: function() {
            var clone = Base.clone.call(this);
            var words = clone.words = this.words.slice(0);
            var wordsLength = words.length;
            for (var i = 0; i < wordsLength; i++) {
              words[i] = words[i].clone();
            }
            return clone;
          }
        });
      })();
      return CryptoJS;
    });
  }
});

// node_modules/merkletreejs/node_modules/crypto-js/lib-typedarrays.js
var require_lib_typedarrays = __commonJS({
  "node_modules/merkletreejs/node_modules/crypto-js/lib-typedarrays.js"(exports, module) {
    init_shim();
    (function(root, factory) {
      if (typeof exports === "object") {
        module.exports = exports = factory(require_core2());
      } else if (typeof define === "function" && define.amd) {
        define(["./core"], factory);
      } else {
        factory(root.CryptoJS);
      }
    })(exports, function(CryptoJS) {
      (function() {
        if (typeof ArrayBuffer != "function") {
          return;
        }
        var C = CryptoJS;
        var C_lib = C.lib;
        var WordArray = C_lib.WordArray;
        var superInit = WordArray.init;
        var subInit = WordArray.init = function(typedArray) {
          if (typedArray instanceof ArrayBuffer) {
            typedArray = new Uint8Array(typedArray);
          }
          if (typedArray instanceof Int8Array || typeof Uint8ClampedArray !== "undefined" && typedArray instanceof Uint8ClampedArray || typedArray instanceof Int16Array || typedArray instanceof Uint16Array || typedArray instanceof Int32Array || typedArray instanceof Uint32Array || typedArray instanceof Float32Array || typedArray instanceof Float64Array) {
            typedArray = new Uint8Array(typedArray.buffer, typedArray.byteOffset, typedArray.byteLength);
          }
          if (typedArray instanceof Uint8Array) {
            var typedArrayByteLength = typedArray.byteLength;
            var words = [];
            for (var i = 0; i < typedArrayByteLength; i++) {
              words[i >>> 2] |= typedArray[i] << 24 - i % 4 * 8;
            }
            superInit.call(this, words, typedArrayByteLength);
          } else {
            superInit.apply(this, arguments);
          }
        };
        subInit.prototype = WordArray;
      })();
      return CryptoJS.lib.WordArray;
    });
  }
});

// node_modules/merkletreejs/node_modules/crypto-js/enc-utf16.js
var require_enc_utf16 = __commonJS({
  "node_modules/merkletreejs/node_modules/crypto-js/enc-utf16.js"(exports, module) {
    init_shim();
    (function(root, factory) {
      if (typeof exports === "object") {
        module.exports = exports = factory(require_core2());
      } else if (typeof define === "function" && define.amd) {
        define(["./core"], factory);
      } else {
        factory(root.CryptoJS);
      }
    })(exports, function(CryptoJS) {
      (function() {
        var C = CryptoJS;
        var C_lib = C.lib;
        var WordArray = C_lib.WordArray;
        var C_enc = C.enc;
        var Utf16BE = C_enc.Utf16 = C_enc.Utf16BE = {
          /**
           * Converts a word array to a UTF-16 BE string.
           *
           * @param {WordArray} wordArray The word array.
           *
           * @return {string} The UTF-16 BE string.
           *
           * @static
           *
           * @example
           *
           *     var utf16String = CryptoJS.enc.Utf16.stringify(wordArray);
           */
          stringify: function(wordArray) {
            var words = wordArray.words;
            var sigBytes = wordArray.sigBytes;
            var utf16Chars = [];
            for (var i = 0; i < sigBytes; i += 2) {
              var codePoint = words[i >>> 2] >>> 16 - i % 4 * 8 & 65535;
              utf16Chars.push(String.fromCharCode(codePoint));
            }
            return utf16Chars.join("");
          },
          /**
           * Converts a UTF-16 BE string to a word array.
           *
           * @param {string} utf16Str The UTF-16 BE string.
           *
           * @return {WordArray} The word array.
           *
           * @static
           *
           * @example
           *
           *     var wordArray = CryptoJS.enc.Utf16.parse(utf16String);
           */
          parse: function(utf16Str) {
            var utf16StrLength = utf16Str.length;
            var words = [];
            for (var i = 0; i < utf16StrLength; i++) {
              words[i >>> 1] |= utf16Str.charCodeAt(i) << 16 - i % 2 * 16;
            }
            return WordArray.create(words, utf16StrLength * 2);
          }
        };
        C_enc.Utf16LE = {
          /**
           * Converts a word array to a UTF-16 LE string.
           *
           * @param {WordArray} wordArray The word array.
           *
           * @return {string} The UTF-16 LE string.
           *
           * @static
           *
           * @example
           *
           *     var utf16Str = CryptoJS.enc.Utf16LE.stringify(wordArray);
           */
          stringify: function(wordArray) {
            var words = wordArray.words;
            var sigBytes = wordArray.sigBytes;
            var utf16Chars = [];
            for (var i = 0; i < sigBytes; i += 2) {
              var codePoint = swapEndian(words[i >>> 2] >>> 16 - i % 4 * 8 & 65535);
              utf16Chars.push(String.fromCharCode(codePoint));
            }
            return utf16Chars.join("");
          },
          /**
           * Converts a UTF-16 LE string to a word array.
           *
           * @param {string} utf16Str The UTF-16 LE string.
           *
           * @return {WordArray} The word array.
           *
           * @static
           *
           * @example
           *
           *     var wordArray = CryptoJS.enc.Utf16LE.parse(utf16Str);
           */
          parse: function(utf16Str) {
            var utf16StrLength = utf16Str.length;
            var words = [];
            for (var i = 0; i < utf16StrLength; i++) {
              words[i >>> 1] |= swapEndian(utf16Str.charCodeAt(i) << 16 - i % 2 * 16);
            }
            return WordArray.create(words, utf16StrLength * 2);
          }
        };
        function swapEndian(word) {
          return word << 8 & 4278255360 | word >>> 8 & 16711935;
        }
      })();
      return CryptoJS.enc.Utf16;
    });
  }
});

// node_modules/merkletreejs/node_modules/crypto-js/enc-base64.js
var require_enc_base64 = __commonJS({
  "node_modules/merkletreejs/node_modules/crypto-js/enc-base64.js"(exports, module) {
    init_shim();
    (function(root, factory) {
      if (typeof exports === "object") {
        module.exports = exports = factory(require_core2());
      } else if (typeof define === "function" && define.amd) {
        define(["./core"], factory);
      } else {
        factory(root.CryptoJS);
      }
    })(exports, function(CryptoJS) {
      (function() {
        var C = CryptoJS;
        var C_lib = C.lib;
        var WordArray = C_lib.WordArray;
        var C_enc = C.enc;
        var Base64 = C_enc.Base64 = {
          /**
           * Converts a word array to a Base64 string.
           *
           * @param {WordArray} wordArray The word array.
           *
           * @return {string} The Base64 string.
           *
           * @static
           *
           * @example
           *
           *     var base64String = CryptoJS.enc.Base64.stringify(wordArray);
           */
          stringify: function(wordArray) {
            var words = wordArray.words;
            var sigBytes = wordArray.sigBytes;
            var map = this._map;
            wordArray.clamp();
            var base64Chars = [];
            for (var i = 0; i < sigBytes; i += 3) {
              var byte1 = words[i >>> 2] >>> 24 - i % 4 * 8 & 255;
              var byte2 = words[i + 1 >>> 2] >>> 24 - (i + 1) % 4 * 8 & 255;
              var byte3 = words[i + 2 >>> 2] >>> 24 - (i + 2) % 4 * 8 & 255;
              var triplet = byte1 << 16 | byte2 << 8 | byte3;
              for (var j = 0; j < 4 && i + j * 0.75 < sigBytes; j++) {
                base64Chars.push(map.charAt(triplet >>> 6 * (3 - j) & 63));
              }
            }
            var paddingChar = map.charAt(64);
            if (paddingChar) {
              while (base64Chars.length % 4) {
                base64Chars.push(paddingChar);
              }
            }
            return base64Chars.join("");
          },
          /**
           * Converts a Base64 string to a word array.
           *
           * @param {string} base64Str The Base64 string.
           *
           * @return {WordArray} The word array.
           *
           * @static
           *
           * @example
           *
           *     var wordArray = CryptoJS.enc.Base64.parse(base64String);
           */
          parse: function(base64Str) {
            var base64StrLength = base64Str.length;
            var map = this._map;
            var reverseMap = this._reverseMap;
            if (!reverseMap) {
              reverseMap = this._reverseMap = [];
              for (var j = 0; j < map.length; j++) {
                reverseMap[map.charCodeAt(j)] = j;
              }
            }
            var paddingChar = map.charAt(64);
            if (paddingChar) {
              var paddingIndex = base64Str.indexOf(paddingChar);
              if (paddingIndex !== -1) {
                base64StrLength = paddingIndex;
              }
            }
            return parseLoop(base64Str, base64StrLength, reverseMap);
          },
          _map: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/="
        };
        function parseLoop(base64Str, base64StrLength, reverseMap) {
          var words = [];
          var nBytes = 0;
          for (var i = 0; i < base64StrLength; i++) {
            if (i % 4) {
              var bits1 = reverseMap[base64Str.charCodeAt(i - 1)] << i % 4 * 2;
              var bits2 = reverseMap[base64Str.charCodeAt(i)] >>> 6 - i % 4 * 2;
              words[nBytes >>> 2] |= (bits1 | bits2) << 24 - nBytes % 4 * 8;
              nBytes++;
            }
          }
          return WordArray.create(words, nBytes);
        }
      })();
      return CryptoJS.enc.Base64;
    });
  }
});

// node_modules/merkletreejs/node_modules/crypto-js/md5.js
var require_md5 = __commonJS({
  "node_modules/merkletreejs/node_modules/crypto-js/md5.js"(exports, module) {
    init_shim();
    (function(root, factory) {
      if (typeof exports === "object") {
        module.exports = exports = factory(require_core2());
      } else if (typeof define === "function" && define.amd) {
        define(["./core"], factory);
      } else {
        factory(root.CryptoJS);
      }
    })(exports, function(CryptoJS) {
      (function(Math2) {
        var C = CryptoJS;
        var C_lib = C.lib;
        var WordArray = C_lib.WordArray;
        var Hasher = C_lib.Hasher;
        var C_algo = C.algo;
        var T = [];
        (function() {
          for (var i = 0; i < 64; i++) {
            T[i] = Math2.abs(Math2.sin(i + 1)) * 4294967296 | 0;
          }
        })();
        var MD5 = C_algo.MD5 = Hasher.extend({
          _doReset: function() {
            this._hash = new WordArray.init([
              1732584193,
              4023233417,
              2562383102,
              271733878
            ]);
          },
          _doProcessBlock: function(M, offset) {
            for (var i = 0; i < 16; i++) {
              var offset_i = offset + i;
              var M_offset_i = M[offset_i];
              M[offset_i] = (M_offset_i << 8 | M_offset_i >>> 24) & 16711935 | (M_offset_i << 24 | M_offset_i >>> 8) & 4278255360;
            }
            var H = this._hash.words;
            var M_offset_0 = M[offset + 0];
            var M_offset_1 = M[offset + 1];
            var M_offset_2 = M[offset + 2];
            var M_offset_3 = M[offset + 3];
            var M_offset_4 = M[offset + 4];
            var M_offset_5 = M[offset + 5];
            var M_offset_6 = M[offset + 6];
            var M_offset_7 = M[offset + 7];
            var M_offset_8 = M[offset + 8];
            var M_offset_9 = M[offset + 9];
            var M_offset_10 = M[offset + 10];
            var M_offset_11 = M[offset + 11];
            var M_offset_12 = M[offset + 12];
            var M_offset_13 = M[offset + 13];
            var M_offset_14 = M[offset + 14];
            var M_offset_15 = M[offset + 15];
            var a = H[0];
            var b = H[1];
            var c = H[2];
            var d = H[3];
            a = FF(a, b, c, d, M_offset_0, 7, T[0]);
            d = FF(d, a, b, c, M_offset_1, 12, T[1]);
            c = FF(c, d, a, b, M_offset_2, 17, T[2]);
            b = FF(b, c, d, a, M_offset_3, 22, T[3]);
            a = FF(a, b, c, d, M_offset_4, 7, T[4]);
            d = FF(d, a, b, c, M_offset_5, 12, T[5]);
            c = FF(c, d, a, b, M_offset_6, 17, T[6]);
            b = FF(b, c, d, a, M_offset_7, 22, T[7]);
            a = FF(a, b, c, d, M_offset_8, 7, T[8]);
            d = FF(d, a, b, c, M_offset_9, 12, T[9]);
            c = FF(c, d, a, b, M_offset_10, 17, T[10]);
            b = FF(b, c, d, a, M_offset_11, 22, T[11]);
            a = FF(a, b, c, d, M_offset_12, 7, T[12]);
            d = FF(d, a, b, c, M_offset_13, 12, T[13]);
            c = FF(c, d, a, b, M_offset_14, 17, T[14]);
            b = FF(b, c, d, a, M_offset_15, 22, T[15]);
            a = GG(a, b, c, d, M_offset_1, 5, T[16]);
            d = GG(d, a, b, c, M_offset_6, 9, T[17]);
            c = GG(c, d, a, b, M_offset_11, 14, T[18]);
            b = GG(b, c, d, a, M_offset_0, 20, T[19]);
            a = GG(a, b, c, d, M_offset_5, 5, T[20]);
            d = GG(d, a, b, c, M_offset_10, 9, T[21]);
            c = GG(c, d, a, b, M_offset_15, 14, T[22]);
            b = GG(b, c, d, a, M_offset_4, 20, T[23]);
            a = GG(a, b, c, d, M_offset_9, 5, T[24]);
            d = GG(d, a, b, c, M_offset_14, 9, T[25]);
            c = GG(c, d, a, b, M_offset_3, 14, T[26]);
            b = GG(b, c, d, a, M_offset_8, 20, T[27]);
            a = GG(a, b, c, d, M_offset_13, 5, T[28]);
            d = GG(d, a, b, c, M_offset_2, 9, T[29]);
            c = GG(c, d, a, b, M_offset_7, 14, T[30]);
            b = GG(b, c, d, a, M_offset_12, 20, T[31]);
            a = HH(a, b, c, d, M_offset_5, 4, T[32]);
            d = HH(d, a, b, c, M_offset_8, 11, T[33]);
            c = HH(c, d, a, b, M_offset_11, 16, T[34]);
            b = HH(b, c, d, a, M_offset_14, 23, T[35]);
            a = HH(a, b, c, d, M_offset_1, 4, T[36]);
            d = HH(d, a, b, c, M_offset_4, 11, T[37]);
            c = HH(c, d, a, b, M_offset_7, 16, T[38]);
            b = HH(b, c, d, a, M_offset_10, 23, T[39]);
            a = HH(a, b, c, d, M_offset_13, 4, T[40]);
            d = HH(d, a, b, c, M_offset_0, 11, T[41]);
            c = HH(c, d, a, b, M_offset_3, 16, T[42]);
            b = HH(b, c, d, a, M_offset_6, 23, T[43]);
            a = HH(a, b, c, d, M_offset_9, 4, T[44]);
            d = HH(d, a, b, c, M_offset_12, 11, T[45]);
            c = HH(c, d, a, b, M_offset_15, 16, T[46]);
            b = HH(b, c, d, a, M_offset_2, 23, T[47]);
            a = II(a, b, c, d, M_offset_0, 6, T[48]);
            d = II(d, a, b, c, M_offset_7, 10, T[49]);
            c = II(c, d, a, b, M_offset_14, 15, T[50]);
            b = II(b, c, d, a, M_offset_5, 21, T[51]);
            a = II(a, b, c, d, M_offset_12, 6, T[52]);
            d = II(d, a, b, c, M_offset_3, 10, T[53]);
            c = II(c, d, a, b, M_offset_10, 15, T[54]);
            b = II(b, c, d, a, M_offset_1, 21, T[55]);
            a = II(a, b, c, d, M_offset_8, 6, T[56]);
            d = II(d, a, b, c, M_offset_15, 10, T[57]);
            c = II(c, d, a, b, M_offset_6, 15, T[58]);
            b = II(b, c, d, a, M_offset_13, 21, T[59]);
            a = II(a, b, c, d, M_offset_4, 6, T[60]);
            d = II(d, a, b, c, M_offset_11, 10, T[61]);
            c = II(c, d, a, b, M_offset_2, 15, T[62]);
            b = II(b, c, d, a, M_offset_9, 21, T[63]);
            H[0] = H[0] + a | 0;
            H[1] = H[1] + b | 0;
            H[2] = H[2] + c | 0;
            H[3] = H[3] + d | 0;
          },
          _doFinalize: function() {
            var data = this._data;
            var dataWords = data.words;
            var nBitsTotal = this._nDataBytes * 8;
            var nBitsLeft = data.sigBytes * 8;
            dataWords[nBitsLeft >>> 5] |= 128 << 24 - nBitsLeft % 32;
            var nBitsTotalH = Math2.floor(nBitsTotal / 4294967296);
            var nBitsTotalL = nBitsTotal;
            dataWords[(nBitsLeft + 64 >>> 9 << 4) + 15] = (nBitsTotalH << 8 | nBitsTotalH >>> 24) & 16711935 | (nBitsTotalH << 24 | nBitsTotalH >>> 8) & 4278255360;
            dataWords[(nBitsLeft + 64 >>> 9 << 4) + 14] = (nBitsTotalL << 8 | nBitsTotalL >>> 24) & 16711935 | (nBitsTotalL << 24 | nBitsTotalL >>> 8) & 4278255360;
            data.sigBytes = (dataWords.length + 1) * 4;
            this._process();
            var hash = this._hash;
            var H = hash.words;
            for (var i = 0; i < 4; i++) {
              var H_i = H[i];
              H[i] = (H_i << 8 | H_i >>> 24) & 16711935 | (H_i << 24 | H_i >>> 8) & 4278255360;
            }
            return hash;
          },
          clone: function() {
            var clone = Hasher.clone.call(this);
            clone._hash = this._hash.clone();
            return clone;
          }
        });
        function FF(a, b, c, d, x, s, t) {
          var n = a + (b & c | ~b & d) + x + t;
          return (n << s | n >>> 32 - s) + b;
        }
        function GG(a, b, c, d, x, s, t) {
          var n = a + (b & d | c & ~d) + x + t;
          return (n << s | n >>> 32 - s) + b;
        }
        function HH(a, b, c, d, x, s, t) {
          var n = a + (b ^ c ^ d) + x + t;
          return (n << s | n >>> 32 - s) + b;
        }
        function II(a, b, c, d, x, s, t) {
          var n = a + (c ^ (b | ~d)) + x + t;
          return (n << s | n >>> 32 - s) + b;
        }
        C.MD5 = Hasher._createHelper(MD5);
        C.HmacMD5 = Hasher._createHmacHelper(MD5);
      })(Math);
      return CryptoJS.MD5;
    });
  }
});

// node_modules/merkletreejs/node_modules/crypto-js/sha1.js
var require_sha1 = __commonJS({
  "node_modules/merkletreejs/node_modules/crypto-js/sha1.js"(exports, module) {
    init_shim();
    (function(root, factory) {
      if (typeof exports === "object") {
        module.exports = exports = factory(require_core2());
      } else if (typeof define === "function" && define.amd) {
        define(["./core"], factory);
      } else {
        factory(root.CryptoJS);
      }
    })(exports, function(CryptoJS) {
      (function() {
        var C = CryptoJS;
        var C_lib = C.lib;
        var WordArray = C_lib.WordArray;
        var Hasher = C_lib.Hasher;
        var C_algo = C.algo;
        var W = [];
        var SHA1 = C_algo.SHA1 = Hasher.extend({
          _doReset: function() {
            this._hash = new WordArray.init([
              1732584193,
              4023233417,
              2562383102,
              271733878,
              3285377520
            ]);
          },
          _doProcessBlock: function(M, offset) {
            var H = this._hash.words;
            var a = H[0];
            var b = H[1];
            var c = H[2];
            var d = H[3];
            var e = H[4];
            for (var i = 0; i < 80; i++) {
              if (i < 16) {
                W[i] = M[offset + i] | 0;
              } else {
                var n = W[i - 3] ^ W[i - 8] ^ W[i - 14] ^ W[i - 16];
                W[i] = n << 1 | n >>> 31;
              }
              var t = (a << 5 | a >>> 27) + e + W[i];
              if (i < 20) {
                t += (b & c | ~b & d) + 1518500249;
              } else if (i < 40) {
                t += (b ^ c ^ d) + 1859775393;
              } else if (i < 60) {
                t += (b & c | b & d | c & d) - 1894007588;
              } else {
                t += (b ^ c ^ d) - 899497514;
              }
              e = d;
              d = c;
              c = b << 30 | b >>> 2;
              b = a;
              a = t;
            }
            H[0] = H[0] + a | 0;
            H[1] = H[1] + b | 0;
            H[2] = H[2] + c | 0;
            H[3] = H[3] + d | 0;
            H[4] = H[4] + e | 0;
          },
          _doFinalize: function() {
            var data = this._data;
            var dataWords = data.words;
            var nBitsTotal = this._nDataBytes * 8;
            var nBitsLeft = data.sigBytes * 8;
            dataWords[nBitsLeft >>> 5] |= 128 << 24 - nBitsLeft % 32;
            dataWords[(nBitsLeft + 64 >>> 9 << 4) + 14] = Math.floor(nBitsTotal / 4294967296);
            dataWords[(nBitsLeft + 64 >>> 9 << 4) + 15] = nBitsTotal;
            data.sigBytes = dataWords.length * 4;
            this._process();
            return this._hash;
          },
          clone: function() {
            var clone = Hasher.clone.call(this);
            clone._hash = this._hash.clone();
            return clone;
          }
        });
        C.SHA1 = Hasher._createHelper(SHA1);
        C.HmacSHA1 = Hasher._createHmacHelper(SHA1);
      })();
      return CryptoJS.SHA1;
    });
  }
});

// node_modules/merkletreejs/node_modules/crypto-js/sha224.js
var require_sha224 = __commonJS({
  "node_modules/merkletreejs/node_modules/crypto-js/sha224.js"(exports, module) {
    init_shim();
    (function(root, factory, undef) {
      if (typeof exports === "object") {
        module.exports = exports = factory(require_core2(), require_sha256());
      } else if (typeof define === "function" && define.amd) {
        define(["./core", "./sha256"], factory);
      } else {
        factory(root.CryptoJS);
      }
    })(exports, function(CryptoJS) {
      (function() {
        var C = CryptoJS;
        var C_lib = C.lib;
        var WordArray = C_lib.WordArray;
        var C_algo = C.algo;
        var SHA256 = C_algo.SHA256;
        var SHA224 = C_algo.SHA224 = SHA256.extend({
          _doReset: function() {
            this._hash = new WordArray.init([
              3238371032,
              914150663,
              812702999,
              4144912697,
              4290775857,
              1750603025,
              1694076839,
              3204075428
            ]);
          },
          _doFinalize: function() {
            var hash = SHA256._doFinalize.call(this);
            hash.sigBytes -= 4;
            return hash;
          }
        });
        C.SHA224 = SHA256._createHelper(SHA224);
        C.HmacSHA224 = SHA256._createHmacHelper(SHA224);
      })();
      return CryptoJS.SHA224;
    });
  }
});

// node_modules/merkletreejs/node_modules/crypto-js/sha512.js
var require_sha512 = __commonJS({
  "node_modules/merkletreejs/node_modules/crypto-js/sha512.js"(exports, module) {
    init_shim();
    (function(root, factory, undef) {
      if (typeof exports === "object") {
        module.exports = exports = factory(require_core2(), require_x64_core());
      } else if (typeof define === "function" && define.amd) {
        define(["./core", "./x64-core"], factory);
      } else {
        factory(root.CryptoJS);
      }
    })(exports, function(CryptoJS) {
      (function() {
        var C = CryptoJS;
        var C_lib = C.lib;
        var Hasher = C_lib.Hasher;
        var C_x64 = C.x64;
        var X64Word = C_x64.Word;
        var X64WordArray = C_x64.WordArray;
        var C_algo = C.algo;
        function X64Word_create() {
          return X64Word.create.apply(X64Word, arguments);
        }
        var K = [
          X64Word_create(1116352408, 3609767458),
          X64Word_create(1899447441, 602891725),
          X64Word_create(3049323471, 3964484399),
          X64Word_create(3921009573, 2173295548),
          X64Word_create(961987163, 4081628472),
          X64Word_create(1508970993, 3053834265),
          X64Word_create(2453635748, 2937671579),
          X64Word_create(2870763221, 3664609560),
          X64Word_create(3624381080, 2734883394),
          X64Word_create(310598401, 1164996542),
          X64Word_create(607225278, 1323610764),
          X64Word_create(1426881987, 3590304994),
          X64Word_create(1925078388, 4068182383),
          X64Word_create(2162078206, 991336113),
          X64Word_create(2614888103, 633803317),
          X64Word_create(3248222580, 3479774868),
          X64Word_create(3835390401, 2666613458),
          X64Word_create(4022224774, 944711139),
          X64Word_create(264347078, 2341262773),
          X64Word_create(604807628, 2007800933),
          X64Word_create(770255983, 1495990901),
          X64Word_create(1249150122, 1856431235),
          X64Word_create(1555081692, 3175218132),
          X64Word_create(1996064986, 2198950837),
          X64Word_create(2554220882, 3999719339),
          X64Word_create(2821834349, 766784016),
          X64Word_create(2952996808, 2566594879),
          X64Word_create(3210313671, 3203337956),
          X64Word_create(3336571891, 1034457026),
          X64Word_create(3584528711, 2466948901),
          X64Word_create(113926993, 3758326383),
          X64Word_create(338241895, 168717936),
          X64Word_create(666307205, 1188179964),
          X64Word_create(773529912, 1546045734),
          X64Word_create(1294757372, 1522805485),
          X64Word_create(1396182291, 2643833823),
          X64Word_create(1695183700, 2343527390),
          X64Word_create(1986661051, 1014477480),
          X64Word_create(2177026350, 1206759142),
          X64Word_create(2456956037, 344077627),
          X64Word_create(2730485921, 1290863460),
          X64Word_create(2820302411, 3158454273),
          X64Word_create(3259730800, 3505952657),
          X64Word_create(3345764771, 106217008),
          X64Word_create(3516065817, 3606008344),
          X64Word_create(3600352804, 1432725776),
          X64Word_create(4094571909, 1467031594),
          X64Word_create(275423344, 851169720),
          X64Word_create(430227734, 3100823752),
          X64Word_create(506948616, 1363258195),
          X64Word_create(659060556, 3750685593),
          X64Word_create(883997877, 3785050280),
          X64Word_create(958139571, 3318307427),
          X64Word_create(1322822218, 3812723403),
          X64Word_create(1537002063, 2003034995),
          X64Word_create(1747873779, 3602036899),
          X64Word_create(1955562222, 1575990012),
          X64Word_create(2024104815, 1125592928),
          X64Word_create(2227730452, 2716904306),
          X64Word_create(2361852424, 442776044),
          X64Word_create(2428436474, 593698344),
          X64Word_create(2756734187, 3733110249),
          X64Word_create(3204031479, 2999351573),
          X64Word_create(3329325298, 3815920427),
          X64Word_create(3391569614, 3928383900),
          X64Word_create(3515267271, 566280711),
          X64Word_create(3940187606, 3454069534),
          X64Word_create(4118630271, 4000239992),
          X64Word_create(116418474, 1914138554),
          X64Word_create(174292421, 2731055270),
          X64Word_create(289380356, 3203993006),
          X64Word_create(460393269, 320620315),
          X64Word_create(685471733, 587496836),
          X64Word_create(852142971, 1086792851),
          X64Word_create(1017036298, 365543100),
          X64Word_create(1126000580, 2618297676),
          X64Word_create(1288033470, 3409855158),
          X64Word_create(1501505948, 4234509866),
          X64Word_create(1607167915, 987167468),
          X64Word_create(1816402316, 1246189591)
        ];
        var W = [];
        (function() {
          for (var i = 0; i < 80; i++) {
            W[i] = X64Word_create();
          }
        })();
        var SHA512 = C_algo.SHA512 = Hasher.extend({
          _doReset: function() {
            this._hash = new X64WordArray.init([
              new X64Word.init(1779033703, 4089235720),
              new X64Word.init(3144134277, 2227873595),
              new X64Word.init(1013904242, 4271175723),
              new X64Word.init(2773480762, 1595750129),
              new X64Word.init(1359893119, 2917565137),
              new X64Word.init(2600822924, 725511199),
              new X64Word.init(528734635, 4215389547),
              new X64Word.init(1541459225, 327033209)
            ]);
          },
          _doProcessBlock: function(M, offset) {
            var H = this._hash.words;
            var H0 = H[0];
            var H1 = H[1];
            var H2 = H[2];
            var H3 = H[3];
            var H4 = H[4];
            var H5 = H[5];
            var H6 = H[6];
            var H7 = H[7];
            var H0h = H0.high;
            var H0l = H0.low;
            var H1h = H1.high;
            var H1l = H1.low;
            var H2h = H2.high;
            var H2l = H2.low;
            var H3h = H3.high;
            var H3l = H3.low;
            var H4h = H4.high;
            var H4l = H4.low;
            var H5h = H5.high;
            var H5l = H5.low;
            var H6h = H6.high;
            var H6l = H6.low;
            var H7h = H7.high;
            var H7l = H7.low;
            var ah = H0h;
            var al = H0l;
            var bh = H1h;
            var bl = H1l;
            var ch = H2h;
            var cl = H2l;
            var dh = H3h;
            var dl = H3l;
            var eh = H4h;
            var el = H4l;
            var fh = H5h;
            var fl = H5l;
            var gh = H6h;
            var gl = H6l;
            var hh = H7h;
            var hl = H7l;
            for (var i = 0; i < 80; i++) {
              var Wi = W[i];
              if (i < 16) {
                var Wih = Wi.high = M[offset + i * 2] | 0;
                var Wil = Wi.low = M[offset + i * 2 + 1] | 0;
              } else {
                var gamma0x = W[i - 15];
                var gamma0xh = gamma0x.high;
                var gamma0xl = gamma0x.low;
                var gamma0h = (gamma0xh >>> 1 | gamma0xl << 31) ^ (gamma0xh >>> 8 | gamma0xl << 24) ^ gamma0xh >>> 7;
                var gamma0l = (gamma0xl >>> 1 | gamma0xh << 31) ^ (gamma0xl >>> 8 | gamma0xh << 24) ^ (gamma0xl >>> 7 | gamma0xh << 25);
                var gamma1x = W[i - 2];
                var gamma1xh = gamma1x.high;
                var gamma1xl = gamma1x.low;
                var gamma1h = (gamma1xh >>> 19 | gamma1xl << 13) ^ (gamma1xh << 3 | gamma1xl >>> 29) ^ gamma1xh >>> 6;
                var gamma1l = (gamma1xl >>> 19 | gamma1xh << 13) ^ (gamma1xl << 3 | gamma1xh >>> 29) ^ (gamma1xl >>> 6 | gamma1xh << 26);
                var Wi7 = W[i - 7];
                var Wi7h = Wi7.high;
                var Wi7l = Wi7.low;
                var Wi16 = W[i - 16];
                var Wi16h = Wi16.high;
                var Wi16l = Wi16.low;
                var Wil = gamma0l + Wi7l;
                var Wih = gamma0h + Wi7h + (Wil >>> 0 < gamma0l >>> 0 ? 1 : 0);
                var Wil = Wil + gamma1l;
                var Wih = Wih + gamma1h + (Wil >>> 0 < gamma1l >>> 0 ? 1 : 0);
                var Wil = Wil + Wi16l;
                var Wih = Wih + Wi16h + (Wil >>> 0 < Wi16l >>> 0 ? 1 : 0);
                Wi.high = Wih;
                Wi.low = Wil;
              }
              var chh = eh & fh ^ ~eh & gh;
              var chl = el & fl ^ ~el & gl;
              var majh = ah & bh ^ ah & ch ^ bh & ch;
              var majl = al & bl ^ al & cl ^ bl & cl;
              var sigma0h = (ah >>> 28 | al << 4) ^ (ah << 30 | al >>> 2) ^ (ah << 25 | al >>> 7);
              var sigma0l = (al >>> 28 | ah << 4) ^ (al << 30 | ah >>> 2) ^ (al << 25 | ah >>> 7);
              var sigma1h = (eh >>> 14 | el << 18) ^ (eh >>> 18 | el << 14) ^ (eh << 23 | el >>> 9);
              var sigma1l = (el >>> 14 | eh << 18) ^ (el >>> 18 | eh << 14) ^ (el << 23 | eh >>> 9);
              var Ki = K[i];
              var Kih = Ki.high;
              var Kil = Ki.low;
              var t1l = hl + sigma1l;
              var t1h = hh + sigma1h + (t1l >>> 0 < hl >>> 0 ? 1 : 0);
              var t1l = t1l + chl;
              var t1h = t1h + chh + (t1l >>> 0 < chl >>> 0 ? 1 : 0);
              var t1l = t1l + Kil;
              var t1h = t1h + Kih + (t1l >>> 0 < Kil >>> 0 ? 1 : 0);
              var t1l = t1l + Wil;
              var t1h = t1h + Wih + (t1l >>> 0 < Wil >>> 0 ? 1 : 0);
              var t2l = sigma0l + majl;
              var t2h = sigma0h + majh + (t2l >>> 0 < sigma0l >>> 0 ? 1 : 0);
              hh = gh;
              hl = gl;
              gh = fh;
              gl = fl;
              fh = eh;
              fl = el;
              el = dl + t1l | 0;
              eh = dh + t1h + (el >>> 0 < dl >>> 0 ? 1 : 0) | 0;
              dh = ch;
              dl = cl;
              ch = bh;
              cl = bl;
              bh = ah;
              bl = al;
              al = t1l + t2l | 0;
              ah = t1h + t2h + (al >>> 0 < t1l >>> 0 ? 1 : 0) | 0;
            }
            H0l = H0.low = H0l + al;
            H0.high = H0h + ah + (H0l >>> 0 < al >>> 0 ? 1 : 0);
            H1l = H1.low = H1l + bl;
            H1.high = H1h + bh + (H1l >>> 0 < bl >>> 0 ? 1 : 0);
            H2l = H2.low = H2l + cl;
            H2.high = H2h + ch + (H2l >>> 0 < cl >>> 0 ? 1 : 0);
            H3l = H3.low = H3l + dl;
            H3.high = H3h + dh + (H3l >>> 0 < dl >>> 0 ? 1 : 0);
            H4l = H4.low = H4l + el;
            H4.high = H4h + eh + (H4l >>> 0 < el >>> 0 ? 1 : 0);
            H5l = H5.low = H5l + fl;
            H5.high = H5h + fh + (H5l >>> 0 < fl >>> 0 ? 1 : 0);
            H6l = H6.low = H6l + gl;
            H6.high = H6h + gh + (H6l >>> 0 < gl >>> 0 ? 1 : 0);
            H7l = H7.low = H7l + hl;
            H7.high = H7h + hh + (H7l >>> 0 < hl >>> 0 ? 1 : 0);
          },
          _doFinalize: function() {
            var data = this._data;
            var dataWords = data.words;
            var nBitsTotal = this._nDataBytes * 8;
            var nBitsLeft = data.sigBytes * 8;
            dataWords[nBitsLeft >>> 5] |= 128 << 24 - nBitsLeft % 32;
            dataWords[(nBitsLeft + 128 >>> 10 << 5) + 30] = Math.floor(nBitsTotal / 4294967296);
            dataWords[(nBitsLeft + 128 >>> 10 << 5) + 31] = nBitsTotal;
            data.sigBytes = dataWords.length * 4;
            this._process();
            var hash = this._hash.toX32();
            return hash;
          },
          clone: function() {
            var clone = Hasher.clone.call(this);
            clone._hash = this._hash.clone();
            return clone;
          },
          blockSize: 1024 / 32
        });
        C.SHA512 = Hasher._createHelper(SHA512);
        C.HmacSHA512 = Hasher._createHmacHelper(SHA512);
      })();
      return CryptoJS.SHA512;
    });
  }
});

// node_modules/merkletreejs/node_modules/crypto-js/sha384.js
var require_sha384 = __commonJS({
  "node_modules/merkletreejs/node_modules/crypto-js/sha384.js"(exports, module) {
    init_shim();
    (function(root, factory, undef) {
      if (typeof exports === "object") {
        module.exports = exports = factory(require_core2(), require_x64_core(), require_sha512());
      } else if (typeof define === "function" && define.amd) {
        define(["./core", "./x64-core", "./sha512"], factory);
      } else {
        factory(root.CryptoJS);
      }
    })(exports, function(CryptoJS) {
      (function() {
        var C = CryptoJS;
        var C_x64 = C.x64;
        var X64Word = C_x64.Word;
        var X64WordArray = C_x64.WordArray;
        var C_algo = C.algo;
        var SHA512 = C_algo.SHA512;
        var SHA384 = C_algo.SHA384 = SHA512.extend({
          _doReset: function() {
            this._hash = new X64WordArray.init([
              new X64Word.init(3418070365, 3238371032),
              new X64Word.init(1654270250, 914150663),
              new X64Word.init(2438529370, 812702999),
              new X64Word.init(355462360, 4144912697),
              new X64Word.init(1731405415, 4290775857),
              new X64Word.init(2394180231, 1750603025),
              new X64Word.init(3675008525, 1694076839),
              new X64Word.init(1203062813, 3204075428)
            ]);
          },
          _doFinalize: function() {
            var hash = SHA512._doFinalize.call(this);
            hash.sigBytes -= 16;
            return hash;
          }
        });
        C.SHA384 = SHA512._createHelper(SHA384);
        C.HmacSHA384 = SHA512._createHmacHelper(SHA384);
      })();
      return CryptoJS.SHA384;
    });
  }
});

// node_modules/merkletreejs/node_modules/crypto-js/sha3.js
var require_sha3 = __commonJS({
  "node_modules/merkletreejs/node_modules/crypto-js/sha3.js"(exports, module) {
    init_shim();
    (function(root, factory, undef) {
      if (typeof exports === "object") {
        module.exports = exports = factory(require_core2(), require_x64_core());
      } else if (typeof define === "function" && define.amd) {
        define(["./core", "./x64-core"], factory);
      } else {
        factory(root.CryptoJS);
      }
    })(exports, function(CryptoJS) {
      (function(Math2) {
        var C = CryptoJS;
        var C_lib = C.lib;
        var WordArray = C_lib.WordArray;
        var Hasher = C_lib.Hasher;
        var C_x64 = C.x64;
        var X64Word = C_x64.Word;
        var C_algo = C.algo;
        var RHO_OFFSETS = [];
        var PI_INDEXES = [];
        var ROUND_CONSTANTS = [];
        (function() {
          var x = 1, y = 0;
          for (var t = 0; t < 24; t++) {
            RHO_OFFSETS[x + 5 * y] = (t + 1) * (t + 2) / 2 % 64;
            var newX = y % 5;
            var newY = (2 * x + 3 * y) % 5;
            x = newX;
            y = newY;
          }
          for (var x = 0; x < 5; x++) {
            for (var y = 0; y < 5; y++) {
              PI_INDEXES[x + 5 * y] = y + (2 * x + 3 * y) % 5 * 5;
            }
          }
          var LFSR = 1;
          for (var i = 0; i < 24; i++) {
            var roundConstantMsw = 0;
            var roundConstantLsw = 0;
            for (var j = 0; j < 7; j++) {
              if (LFSR & 1) {
                var bitPosition = (1 << j) - 1;
                if (bitPosition < 32) {
                  roundConstantLsw ^= 1 << bitPosition;
                } else {
                  roundConstantMsw ^= 1 << bitPosition - 32;
                }
              }
              if (LFSR & 128) {
                LFSR = LFSR << 1 ^ 113;
              } else {
                LFSR <<= 1;
              }
            }
            ROUND_CONSTANTS[i] = X64Word.create(roundConstantMsw, roundConstantLsw);
          }
        })();
        var T = [];
        (function() {
          for (var i = 0; i < 25; i++) {
            T[i] = X64Word.create();
          }
        })();
        var SHA3 = C_algo.SHA3 = Hasher.extend({
          /**
           * Configuration options.
           *
           * @property {number} outputLength
           *   The desired number of bits in the output hash.
           *   Only values permitted are: 224, 256, 384, 512.
           *   Default: 512
           */
          cfg: Hasher.cfg.extend({
            outputLength: 512
          }),
          _doReset: function() {
            var state = this._state = [];
            for (var i = 0; i < 25; i++) {
              state[i] = new X64Word.init();
            }
            this.blockSize = (1600 - 2 * this.cfg.outputLength) / 32;
          },
          _doProcessBlock: function(M, offset) {
            var state = this._state;
            var nBlockSizeLanes = this.blockSize / 2;
            for (var i = 0; i < nBlockSizeLanes; i++) {
              var M2i = M[offset + 2 * i];
              var M2i1 = M[offset + 2 * i + 1];
              M2i = (M2i << 8 | M2i >>> 24) & 16711935 | (M2i << 24 | M2i >>> 8) & 4278255360;
              M2i1 = (M2i1 << 8 | M2i1 >>> 24) & 16711935 | (M2i1 << 24 | M2i1 >>> 8) & 4278255360;
              var lane = state[i];
              lane.high ^= M2i1;
              lane.low ^= M2i;
            }
            for (var round = 0; round < 24; round++) {
              for (var x = 0; x < 5; x++) {
                var tMsw = 0, tLsw = 0;
                for (var y = 0; y < 5; y++) {
                  var lane = state[x + 5 * y];
                  tMsw ^= lane.high;
                  tLsw ^= lane.low;
                }
                var Tx = T[x];
                Tx.high = tMsw;
                Tx.low = tLsw;
              }
              for (var x = 0; x < 5; x++) {
                var Tx4 = T[(x + 4) % 5];
                var Tx1 = T[(x + 1) % 5];
                var Tx1Msw = Tx1.high;
                var Tx1Lsw = Tx1.low;
                var tMsw = Tx4.high ^ (Tx1Msw << 1 | Tx1Lsw >>> 31);
                var tLsw = Tx4.low ^ (Tx1Lsw << 1 | Tx1Msw >>> 31);
                for (var y = 0; y < 5; y++) {
                  var lane = state[x + 5 * y];
                  lane.high ^= tMsw;
                  lane.low ^= tLsw;
                }
              }
              for (var laneIndex = 1; laneIndex < 25; laneIndex++) {
                var lane = state[laneIndex];
                var laneMsw = lane.high;
                var laneLsw = lane.low;
                var rhoOffset = RHO_OFFSETS[laneIndex];
                if (rhoOffset < 32) {
                  var tMsw = laneMsw << rhoOffset | laneLsw >>> 32 - rhoOffset;
                  var tLsw = laneLsw << rhoOffset | laneMsw >>> 32 - rhoOffset;
                } else {
                  var tMsw = laneLsw << rhoOffset - 32 | laneMsw >>> 64 - rhoOffset;
                  var tLsw = laneMsw << rhoOffset - 32 | laneLsw >>> 64 - rhoOffset;
                }
                var TPiLane = T[PI_INDEXES[laneIndex]];
                TPiLane.high = tMsw;
                TPiLane.low = tLsw;
              }
              var T0 = T[0];
              var state0 = state[0];
              T0.high = state0.high;
              T0.low = state0.low;
              for (var x = 0; x < 5; x++) {
                for (var y = 0; y < 5; y++) {
                  var laneIndex = x + 5 * y;
                  var lane = state[laneIndex];
                  var TLane = T[laneIndex];
                  var Tx1Lane = T[(x + 1) % 5 + 5 * y];
                  var Tx2Lane = T[(x + 2) % 5 + 5 * y];
                  lane.high = TLane.high ^ ~Tx1Lane.high & Tx2Lane.high;
                  lane.low = TLane.low ^ ~Tx1Lane.low & Tx2Lane.low;
                }
              }
              var lane = state[0];
              var roundConstant = ROUND_CONSTANTS[round];
              lane.high ^= roundConstant.high;
              lane.low ^= roundConstant.low;
              ;
            }
          },
          _doFinalize: function() {
            var data = this._data;
            var dataWords = data.words;
            var nBitsTotal = this._nDataBytes * 8;
            var nBitsLeft = data.sigBytes * 8;
            var blockSizeBits = this.blockSize * 32;
            dataWords[nBitsLeft >>> 5] |= 1 << 24 - nBitsLeft % 32;
            dataWords[(Math2.ceil((nBitsLeft + 1) / blockSizeBits) * blockSizeBits >>> 5) - 1] |= 128;
            data.sigBytes = dataWords.length * 4;
            this._process();
            var state = this._state;
            var outputLengthBytes = this.cfg.outputLength / 8;
            var outputLengthLanes = outputLengthBytes / 8;
            var hashWords = [];
            for (var i = 0; i < outputLengthLanes; i++) {
              var lane = state[i];
              var laneMsw = lane.high;
              var laneLsw = lane.low;
              laneMsw = (laneMsw << 8 | laneMsw >>> 24) & 16711935 | (laneMsw << 24 | laneMsw >>> 8) & 4278255360;
              laneLsw = (laneLsw << 8 | laneLsw >>> 24) & 16711935 | (laneLsw << 24 | laneLsw >>> 8) & 4278255360;
              hashWords.push(laneLsw);
              hashWords.push(laneMsw);
            }
            return new WordArray.init(hashWords, outputLengthBytes);
          },
          clone: function() {
            var clone = Hasher.clone.call(this);
            var state = clone._state = this._state.slice(0);
            for (var i = 0; i < 25; i++) {
              state[i] = state[i].clone();
            }
            return clone;
          }
        });
        C.SHA3 = Hasher._createHelper(SHA3);
        C.HmacSHA3 = Hasher._createHmacHelper(SHA3);
      })(Math);
      return CryptoJS.SHA3;
    });
  }
});

// node_modules/merkletreejs/node_modules/crypto-js/ripemd160.js
var require_ripemd160 = __commonJS({
  "node_modules/merkletreejs/node_modules/crypto-js/ripemd160.js"(exports, module) {
    init_shim();
    (function(root, factory) {
      if (typeof exports === "object") {
        module.exports = exports = factory(require_core2());
      } else if (typeof define === "function" && define.amd) {
        define(["./core"], factory);
      } else {
        factory(root.CryptoJS);
      }
    })(exports, function(CryptoJS) {
      (function(Math2) {
        var C = CryptoJS;
        var C_lib = C.lib;
        var WordArray = C_lib.WordArray;
        var Hasher = C_lib.Hasher;
        var C_algo = C.algo;
        var _zl = WordArray.create([
          0,
          1,
          2,
          3,
          4,
          5,
          6,
          7,
          8,
          9,
          10,
          11,
          12,
          13,
          14,
          15,
          7,
          4,
          13,
          1,
          10,
          6,
          15,
          3,
          12,
          0,
          9,
          5,
          2,
          14,
          11,
          8,
          3,
          10,
          14,
          4,
          9,
          15,
          8,
          1,
          2,
          7,
          0,
          6,
          13,
          11,
          5,
          12,
          1,
          9,
          11,
          10,
          0,
          8,
          12,
          4,
          13,
          3,
          7,
          15,
          14,
          5,
          6,
          2,
          4,
          0,
          5,
          9,
          7,
          12,
          2,
          10,
          14,
          1,
          3,
          8,
          11,
          6,
          15,
          13
        ]);
        var _zr = WordArray.create([
          5,
          14,
          7,
          0,
          9,
          2,
          11,
          4,
          13,
          6,
          15,
          8,
          1,
          10,
          3,
          12,
          6,
          11,
          3,
          7,
          0,
          13,
          5,
          10,
          14,
          15,
          8,
          12,
          4,
          9,
          1,
          2,
          15,
          5,
          1,
          3,
          7,
          14,
          6,
          9,
          11,
          8,
          12,
          2,
          10,
          0,
          4,
          13,
          8,
          6,
          4,
          1,
          3,
          11,
          15,
          0,
          5,
          12,
          2,
          13,
          9,
          7,
          10,
          14,
          12,
          15,
          10,
          4,
          1,
          5,
          8,
          7,
          6,
          2,
          13,
          14,
          0,
          3,
          9,
          11
        ]);
        var _sl = WordArray.create([
          11,
          14,
          15,
          12,
          5,
          8,
          7,
          9,
          11,
          13,
          14,
          15,
          6,
          7,
          9,
          8,
          7,
          6,
          8,
          13,
          11,
          9,
          7,
          15,
          7,
          12,
          15,
          9,
          11,
          7,
          13,
          12,
          11,
          13,
          6,
          7,
          14,
          9,
          13,
          15,
          14,
          8,
          13,
          6,
          5,
          12,
          7,
          5,
          11,
          12,
          14,
          15,
          14,
          15,
          9,
          8,
          9,
          14,
          5,
          6,
          8,
          6,
          5,
          12,
          9,
          15,
          5,
          11,
          6,
          8,
          13,
          12,
          5,
          12,
          13,
          14,
          11,
          8,
          5,
          6
        ]);
        var _sr = WordArray.create([
          8,
          9,
          9,
          11,
          13,
          15,
          15,
          5,
          7,
          7,
          8,
          11,
          14,
          14,
          12,
          6,
          9,
          13,
          15,
          7,
          12,
          8,
          9,
          11,
          7,
          7,
          12,
          7,
          6,
          15,
          13,
          11,
          9,
          7,
          15,
          11,
          8,
          6,
          6,
          14,
          12,
          13,
          5,
          14,
          13,
          13,
          7,
          5,
          15,
          5,
          8,
          11,
          14,
          14,
          6,
          14,
          6,
          9,
          12,
          9,
          12,
          5,
          15,
          8,
          8,
          5,
          12,
          9,
          12,
          5,
          14,
          6,
          8,
          13,
          6,
          5,
          15,
          13,
          11,
          11
        ]);
        var _hl = WordArray.create([0, 1518500249, 1859775393, 2400959708, 2840853838]);
        var _hr = WordArray.create([1352829926, 1548603684, 1836072691, 2053994217, 0]);
        var RIPEMD160 = C_algo.RIPEMD160 = Hasher.extend({
          _doReset: function() {
            this._hash = WordArray.create([1732584193, 4023233417, 2562383102, 271733878, 3285377520]);
          },
          _doProcessBlock: function(M, offset) {
            for (var i = 0; i < 16; i++) {
              var offset_i = offset + i;
              var M_offset_i = M[offset_i];
              M[offset_i] = (M_offset_i << 8 | M_offset_i >>> 24) & 16711935 | (M_offset_i << 24 | M_offset_i >>> 8) & 4278255360;
            }
            var H = this._hash.words;
            var hl = _hl.words;
            var hr = _hr.words;
            var zl = _zl.words;
            var zr = _zr.words;
            var sl = _sl.words;
            var sr = _sr.words;
            var al, bl, cl, dl, el;
            var ar, br, cr, dr, er;
            ar = al = H[0];
            br = bl = H[1];
            cr = cl = H[2];
            dr = dl = H[3];
            er = el = H[4];
            var t;
            for (var i = 0; i < 80; i += 1) {
              t = al + M[offset + zl[i]] | 0;
              if (i < 16) {
                t += f1(bl, cl, dl) + hl[0];
              } else if (i < 32) {
                t += f2(bl, cl, dl) + hl[1];
              } else if (i < 48) {
                t += f3(bl, cl, dl) + hl[2];
              } else if (i < 64) {
                t += f4(bl, cl, dl) + hl[3];
              } else {
                t += f5(bl, cl, dl) + hl[4];
              }
              t = t | 0;
              t = rotl(t, sl[i]);
              t = t + el | 0;
              al = el;
              el = dl;
              dl = rotl(cl, 10);
              cl = bl;
              bl = t;
              t = ar + M[offset + zr[i]] | 0;
              if (i < 16) {
                t += f5(br, cr, dr) + hr[0];
              } else if (i < 32) {
                t += f4(br, cr, dr) + hr[1];
              } else if (i < 48) {
                t += f3(br, cr, dr) + hr[2];
              } else if (i < 64) {
                t += f2(br, cr, dr) + hr[3];
              } else {
                t += f1(br, cr, dr) + hr[4];
              }
              t = t | 0;
              t = rotl(t, sr[i]);
              t = t + er | 0;
              ar = er;
              er = dr;
              dr = rotl(cr, 10);
              cr = br;
              br = t;
            }
            t = H[1] + cl + dr | 0;
            H[1] = H[2] + dl + er | 0;
            H[2] = H[3] + el + ar | 0;
            H[3] = H[4] + al + br | 0;
            H[4] = H[0] + bl + cr | 0;
            H[0] = t;
          },
          _doFinalize: function() {
            var data = this._data;
            var dataWords = data.words;
            var nBitsTotal = this._nDataBytes * 8;
            var nBitsLeft = data.sigBytes * 8;
            dataWords[nBitsLeft >>> 5] |= 128 << 24 - nBitsLeft % 32;
            dataWords[(nBitsLeft + 64 >>> 9 << 4) + 14] = (nBitsTotal << 8 | nBitsTotal >>> 24) & 16711935 | (nBitsTotal << 24 | nBitsTotal >>> 8) & 4278255360;
            data.sigBytes = (dataWords.length + 1) * 4;
            this._process();
            var hash = this._hash;
            var H = hash.words;
            for (var i = 0; i < 5; i++) {
              var H_i = H[i];
              H[i] = (H_i << 8 | H_i >>> 24) & 16711935 | (H_i << 24 | H_i >>> 8) & 4278255360;
            }
            return hash;
          },
          clone: function() {
            var clone = Hasher.clone.call(this);
            clone._hash = this._hash.clone();
            return clone;
          }
        });
        function f1(x, y, z2) {
          return x ^ y ^ z2;
        }
        function f2(x, y, z2) {
          return x & y | ~x & z2;
        }
        function f3(x, y, z2) {
          return (x | ~y) ^ z2;
        }
        function f4(x, y, z2) {
          return x & z2 | y & ~z2;
        }
        function f5(x, y, z2) {
          return x ^ (y | ~z2);
        }
        function rotl(x, n) {
          return x << n | x >>> 32 - n;
        }
        C.RIPEMD160 = Hasher._createHelper(RIPEMD160);
        C.HmacRIPEMD160 = Hasher._createHmacHelper(RIPEMD160);
      })(Math);
      return CryptoJS.RIPEMD160;
    });
  }
});

// node_modules/merkletreejs/node_modules/crypto-js/hmac.js
var require_hmac = __commonJS({
  "node_modules/merkletreejs/node_modules/crypto-js/hmac.js"(exports, module) {
    init_shim();
    (function(root, factory) {
      if (typeof exports === "object") {
        module.exports = exports = factory(require_core2());
      } else if (typeof define === "function" && define.amd) {
        define(["./core"], factory);
      } else {
        factory(root.CryptoJS);
      }
    })(exports, function(CryptoJS) {
      (function() {
        var C = CryptoJS;
        var C_lib = C.lib;
        var Base = C_lib.Base;
        var C_enc = C.enc;
        var Utf8 = C_enc.Utf8;
        var C_algo = C.algo;
        var HMAC = C_algo.HMAC = Base.extend({
          /**
           * Initializes a newly created HMAC.
           *
           * @param {Hasher} hasher The hash algorithm to use.
           * @param {WordArray|string} key The secret key.
           *
           * @example
           *
           *     var hmacHasher = CryptoJS.algo.HMAC.create(CryptoJS.algo.SHA256, key);
           */
          init: function(hasher, key) {
            hasher = this._hasher = new hasher.init();
            if (typeof key == "string") {
              key = Utf8.parse(key);
            }
            var hasherBlockSize = hasher.blockSize;
            var hasherBlockSizeBytes = hasherBlockSize * 4;
            if (key.sigBytes > hasherBlockSizeBytes) {
              key = hasher.finalize(key);
            }
            key.clamp();
            var oKey = this._oKey = key.clone();
            var iKey = this._iKey = key.clone();
            var oKeyWords = oKey.words;
            var iKeyWords = iKey.words;
            for (var i = 0; i < hasherBlockSize; i++) {
              oKeyWords[i] ^= 1549556828;
              iKeyWords[i] ^= 909522486;
            }
            oKey.sigBytes = iKey.sigBytes = hasherBlockSizeBytes;
            this.reset();
          },
          /**
           * Resets this HMAC to its initial state.
           *
           * @example
           *
           *     hmacHasher.reset();
           */
          reset: function() {
            var hasher = this._hasher;
            hasher.reset();
            hasher.update(this._iKey);
          },
          /**
           * Updates this HMAC with a message.
           *
           * @param {WordArray|string} messageUpdate The message to append.
           *
           * @return {HMAC} This HMAC instance.
           *
           * @example
           *
           *     hmacHasher.update('message');
           *     hmacHasher.update(wordArray);
           */
          update: function(messageUpdate) {
            this._hasher.update(messageUpdate);
            return this;
          },
          /**
           * Finalizes the HMAC computation.
           * Note that the finalize operation is effectively a destructive, read-once operation.
           *
           * @param {WordArray|string} messageUpdate (Optional) A final message update.
           *
           * @return {WordArray} The HMAC.
           *
           * @example
           *
           *     var hmac = hmacHasher.finalize();
           *     var hmac = hmacHasher.finalize('message');
           *     var hmac = hmacHasher.finalize(wordArray);
           */
          finalize: function(messageUpdate) {
            var hasher = this._hasher;
            var innerHash = hasher.finalize(messageUpdate);
            hasher.reset();
            var hmac = hasher.finalize(this._oKey.clone().concat(innerHash));
            return hmac;
          }
        });
      })();
    });
  }
});

// node_modules/merkletreejs/node_modules/crypto-js/pbkdf2.js
var require_pbkdf2 = __commonJS({
  "node_modules/merkletreejs/node_modules/crypto-js/pbkdf2.js"(exports, module) {
    init_shim();
    (function(root, factory, undef) {
      if (typeof exports === "object") {
        module.exports = exports = factory(require_core2(), require_sha1(), require_hmac());
      } else if (typeof define === "function" && define.amd) {
        define(["./core", "./sha1", "./hmac"], factory);
      } else {
        factory(root.CryptoJS);
      }
    })(exports, function(CryptoJS) {
      (function() {
        var C = CryptoJS;
        var C_lib = C.lib;
        var Base = C_lib.Base;
        var WordArray = C_lib.WordArray;
        var C_algo = C.algo;
        var SHA1 = C_algo.SHA1;
        var HMAC = C_algo.HMAC;
        var PBKDF2 = C_algo.PBKDF2 = Base.extend({
          /**
           * Configuration options.
           *
           * @property {number} keySize The key size in words to generate. Default: 4 (128 bits)
           * @property {Hasher} hasher The hasher to use. Default: SHA1
           * @property {number} iterations The number of iterations to perform. Default: 1
           */
          cfg: Base.extend({
            keySize: 128 / 32,
            hasher: SHA1,
            iterations: 1
          }),
          /**
           * Initializes a newly created key derivation function.
           *
           * @param {Object} cfg (Optional) The configuration options to use for the derivation.
           *
           * @example
           *
           *     var kdf = CryptoJS.algo.PBKDF2.create();
           *     var kdf = CryptoJS.algo.PBKDF2.create({ keySize: 8 });
           *     var kdf = CryptoJS.algo.PBKDF2.create({ keySize: 8, iterations: 1000 });
           */
          init: function(cfg) {
            this.cfg = this.cfg.extend(cfg);
          },
          /**
           * Computes the Password-Based Key Derivation Function 2.
           *
           * @param {WordArray|string} password The password.
           * @param {WordArray|string} salt A salt.
           *
           * @return {WordArray} The derived key.
           *
           * @example
           *
           *     var key = kdf.compute(password, salt);
           */
          compute: function(password, salt) {
            var cfg = this.cfg;
            var hmac = HMAC.create(cfg.hasher, password);
            var derivedKey = WordArray.create();
            var blockIndex = WordArray.create([1]);
            var derivedKeyWords = derivedKey.words;
            var blockIndexWords = blockIndex.words;
            var keySize = cfg.keySize;
            var iterations = cfg.iterations;
            while (derivedKeyWords.length < keySize) {
              var block = hmac.update(salt).finalize(blockIndex);
              hmac.reset();
              var blockWords = block.words;
              var blockWordsLength = blockWords.length;
              var intermediate = block;
              for (var i = 1; i < iterations; i++) {
                intermediate = hmac.finalize(intermediate);
                hmac.reset();
                var intermediateWords = intermediate.words;
                for (var j = 0; j < blockWordsLength; j++) {
                  blockWords[j] ^= intermediateWords[j];
                }
              }
              derivedKey.concat(block);
              blockIndexWords[0]++;
            }
            derivedKey.sigBytes = keySize * 4;
            return derivedKey;
          }
        });
        C.PBKDF2 = function(password, salt, cfg) {
          return PBKDF2.create(cfg).compute(password, salt);
        };
      })();
      return CryptoJS.PBKDF2;
    });
  }
});

// node_modules/merkletreejs/node_modules/crypto-js/evpkdf.js
var require_evpkdf = __commonJS({
  "node_modules/merkletreejs/node_modules/crypto-js/evpkdf.js"(exports, module) {
    init_shim();
    (function(root, factory, undef) {
      if (typeof exports === "object") {
        module.exports = exports = factory(require_core2(), require_sha1(), require_hmac());
      } else if (typeof define === "function" && define.amd) {
        define(["./core", "./sha1", "./hmac"], factory);
      } else {
        factory(root.CryptoJS);
      }
    })(exports, function(CryptoJS) {
      (function() {
        var C = CryptoJS;
        var C_lib = C.lib;
        var Base = C_lib.Base;
        var WordArray = C_lib.WordArray;
        var C_algo = C.algo;
        var MD5 = C_algo.MD5;
        var EvpKDF = C_algo.EvpKDF = Base.extend({
          /**
           * Configuration options.
           *
           * @property {number} keySize The key size in words to generate. Default: 4 (128 bits)
           * @property {Hasher} hasher The hash algorithm to use. Default: MD5
           * @property {number} iterations The number of iterations to perform. Default: 1
           */
          cfg: Base.extend({
            keySize: 128 / 32,
            hasher: MD5,
            iterations: 1
          }),
          /**
           * Initializes a newly created key derivation function.
           *
           * @param {Object} cfg (Optional) The configuration options to use for the derivation.
           *
           * @example
           *
           *     var kdf = CryptoJS.algo.EvpKDF.create();
           *     var kdf = CryptoJS.algo.EvpKDF.create({ keySize: 8 });
           *     var kdf = CryptoJS.algo.EvpKDF.create({ keySize: 8, iterations: 1000 });
           */
          init: function(cfg) {
            this.cfg = this.cfg.extend(cfg);
          },
          /**
           * Derives a key from a password.
           *
           * @param {WordArray|string} password The password.
           * @param {WordArray|string} salt A salt.
           *
           * @return {WordArray} The derived key.
           *
           * @example
           *
           *     var key = kdf.compute(password, salt);
           */
          compute: function(password, salt) {
            var cfg = this.cfg;
            var hasher = cfg.hasher.create();
            var derivedKey = WordArray.create();
            var derivedKeyWords = derivedKey.words;
            var keySize = cfg.keySize;
            var iterations = cfg.iterations;
            while (derivedKeyWords.length < keySize) {
              if (block) {
                hasher.update(block);
              }
              var block = hasher.update(password).finalize(salt);
              hasher.reset();
              for (var i = 1; i < iterations; i++) {
                block = hasher.finalize(block);
                hasher.reset();
              }
              derivedKey.concat(block);
            }
            derivedKey.sigBytes = keySize * 4;
            return derivedKey;
          }
        });
        C.EvpKDF = function(password, salt, cfg) {
          return EvpKDF.create(cfg).compute(password, salt);
        };
      })();
      return CryptoJS.EvpKDF;
    });
  }
});

// node_modules/merkletreejs/node_modules/crypto-js/cipher-core.js
var require_cipher_core = __commonJS({
  "node_modules/merkletreejs/node_modules/crypto-js/cipher-core.js"(exports, module) {
    init_shim();
    (function(root, factory, undef) {
      if (typeof exports === "object") {
        module.exports = exports = factory(require_core2(), require_evpkdf());
      } else if (typeof define === "function" && define.amd) {
        define(["./core", "./evpkdf"], factory);
      } else {
        factory(root.CryptoJS);
      }
    })(exports, function(CryptoJS) {
      CryptoJS.lib.Cipher || function(undefined2) {
        var C = CryptoJS;
        var C_lib = C.lib;
        var Base = C_lib.Base;
        var WordArray = C_lib.WordArray;
        var BufferedBlockAlgorithm = C_lib.BufferedBlockAlgorithm;
        var C_enc = C.enc;
        var Utf8 = C_enc.Utf8;
        var Base64 = C_enc.Base64;
        var C_algo = C.algo;
        var EvpKDF = C_algo.EvpKDF;
        var Cipher = C_lib.Cipher = BufferedBlockAlgorithm.extend({
          /**
           * Configuration options.
           *
           * @property {WordArray} iv The IV to use for this operation.
           */
          cfg: Base.extend(),
          /**
           * Creates this cipher in encryption mode.
           *
           * @param {WordArray} key The key.
           * @param {Object} cfg (Optional) The configuration options to use for this operation.
           *
           * @return {Cipher} A cipher instance.
           *
           * @static
           *
           * @example
           *
           *     var cipher = CryptoJS.algo.AES.createEncryptor(keyWordArray, { iv: ivWordArray });
           */
          createEncryptor: function(key, cfg) {
            return this.create(this._ENC_XFORM_MODE, key, cfg);
          },
          /**
           * Creates this cipher in decryption mode.
           *
           * @param {WordArray} key The key.
           * @param {Object} cfg (Optional) The configuration options to use for this operation.
           *
           * @return {Cipher} A cipher instance.
           *
           * @static
           *
           * @example
           *
           *     var cipher = CryptoJS.algo.AES.createDecryptor(keyWordArray, { iv: ivWordArray });
           */
          createDecryptor: function(key, cfg) {
            return this.create(this._DEC_XFORM_MODE, key, cfg);
          },
          /**
           * Initializes a newly created cipher.
           *
           * @param {number} xformMode Either the encryption or decryption transormation mode constant.
           * @param {WordArray} key The key.
           * @param {Object} cfg (Optional) The configuration options to use for this operation.
           *
           * @example
           *
           *     var cipher = CryptoJS.algo.AES.create(CryptoJS.algo.AES._ENC_XFORM_MODE, keyWordArray, { iv: ivWordArray });
           */
          init: function(xformMode, key, cfg) {
            this.cfg = this.cfg.extend(cfg);
            this._xformMode = xformMode;
            this._key = key;
            this.reset();
          },
          /**
           * Resets this cipher to its initial state.
           *
           * @example
           *
           *     cipher.reset();
           */
          reset: function() {
            BufferedBlockAlgorithm.reset.call(this);
            this._doReset();
          },
          /**
           * Adds data to be encrypted or decrypted.
           *
           * @param {WordArray|string} dataUpdate The data to encrypt or decrypt.
           *
           * @return {WordArray} The data after processing.
           *
           * @example
           *
           *     var encrypted = cipher.process('data');
           *     var encrypted = cipher.process(wordArray);
           */
          process: function(dataUpdate) {
            this._append(dataUpdate);
            return this._process();
          },
          /**
           * Finalizes the encryption or decryption process.
           * Note that the finalize operation is effectively a destructive, read-once operation.
           *
           * @param {WordArray|string} dataUpdate The final data to encrypt or decrypt.
           *
           * @return {WordArray} The data after final processing.
           *
           * @example
           *
           *     var encrypted = cipher.finalize();
           *     var encrypted = cipher.finalize('data');
           *     var encrypted = cipher.finalize(wordArray);
           */
          finalize: function(dataUpdate) {
            if (dataUpdate) {
              this._append(dataUpdate);
            }
            var finalProcessedData = this._doFinalize();
            return finalProcessedData;
          },
          keySize: 128 / 32,
          ivSize: 128 / 32,
          _ENC_XFORM_MODE: 1,
          _DEC_XFORM_MODE: 2,
          /**
           * Creates shortcut functions to a cipher's object interface.
           *
           * @param {Cipher} cipher The cipher to create a helper for.
           *
           * @return {Object} An object with encrypt and decrypt shortcut functions.
           *
           * @static
           *
           * @example
           *
           *     var AES = CryptoJS.lib.Cipher._createHelper(CryptoJS.algo.AES);
           */
          _createHelper: function() {
            function selectCipherStrategy(key) {
              if (typeof key == "string") {
                return PasswordBasedCipher;
              } else {
                return SerializableCipher;
              }
            }
            return function(cipher) {
              return {
                encrypt: function(message, key, cfg) {
                  return selectCipherStrategy(key).encrypt(cipher, message, key, cfg);
                },
                decrypt: function(ciphertext, key, cfg) {
                  return selectCipherStrategy(key).decrypt(cipher, ciphertext, key, cfg);
                }
              };
            };
          }()
        });
        var StreamCipher = C_lib.StreamCipher = Cipher.extend({
          _doFinalize: function() {
            var finalProcessedBlocks = this._process(true);
            return finalProcessedBlocks;
          },
          blockSize: 1
        });
        var C_mode = C.mode = {};
        var BlockCipherMode = C_lib.BlockCipherMode = Base.extend({
          /**
           * Creates this mode for encryption.
           *
           * @param {Cipher} cipher A block cipher instance.
           * @param {Array} iv The IV words.
           *
           * @static
           *
           * @example
           *
           *     var mode = CryptoJS.mode.CBC.createEncryptor(cipher, iv.words);
           */
          createEncryptor: function(cipher, iv) {
            return this.Encryptor.create(cipher, iv);
          },
          /**
           * Creates this mode for decryption.
           *
           * @param {Cipher} cipher A block cipher instance.
           * @param {Array} iv The IV words.
           *
           * @static
           *
           * @example
           *
           *     var mode = CryptoJS.mode.CBC.createDecryptor(cipher, iv.words);
           */
          createDecryptor: function(cipher, iv) {
            return this.Decryptor.create(cipher, iv);
          },
          /**
           * Initializes a newly created mode.
           *
           * @param {Cipher} cipher A block cipher instance.
           * @param {Array} iv The IV words.
           *
           * @example
           *
           *     var mode = CryptoJS.mode.CBC.Encryptor.create(cipher, iv.words);
           */
          init: function(cipher, iv) {
            this._cipher = cipher;
            this._iv = iv;
          }
        });
        var CBC = C_mode.CBC = function() {
          var CBC2 = BlockCipherMode.extend();
          CBC2.Encryptor = CBC2.extend({
            /**
             * Processes the data block at offset.
             *
             * @param {Array} words The data words to operate on.
             * @param {number} offset The offset where the block starts.
             *
             * @example
             *
             *     mode.processBlock(data.words, offset);
             */
            processBlock: function(words, offset) {
              var cipher = this._cipher;
              var blockSize = cipher.blockSize;
              xorBlock.call(this, words, offset, blockSize);
              cipher.encryptBlock(words, offset);
              this._prevBlock = words.slice(offset, offset + blockSize);
            }
          });
          CBC2.Decryptor = CBC2.extend({
            /**
             * Processes the data block at offset.
             *
             * @param {Array} words The data words to operate on.
             * @param {number} offset The offset where the block starts.
             *
             * @example
             *
             *     mode.processBlock(data.words, offset);
             */
            processBlock: function(words, offset) {
              var cipher = this._cipher;
              var blockSize = cipher.blockSize;
              var thisBlock = words.slice(offset, offset + blockSize);
              cipher.decryptBlock(words, offset);
              xorBlock.call(this, words, offset, blockSize);
              this._prevBlock = thisBlock;
            }
          });
          function xorBlock(words, offset, blockSize) {
            var iv = this._iv;
            if (iv) {
              var block = iv;
              this._iv = undefined2;
            } else {
              var block = this._prevBlock;
            }
            for (var i = 0; i < blockSize; i++) {
              words[offset + i] ^= block[i];
            }
          }
          return CBC2;
        }();
        var C_pad = C.pad = {};
        var Pkcs7 = C_pad.Pkcs7 = {
          /**
           * Pads data using the algorithm defined in PKCS #5/7.
           *
           * @param {WordArray} data The data to pad.
           * @param {number} blockSize The multiple that the data should be padded to.
           *
           * @static
           *
           * @example
           *
           *     CryptoJS.pad.Pkcs7.pad(wordArray, 4);
           */
          pad: function(data, blockSize) {
            var blockSizeBytes = blockSize * 4;
            var nPaddingBytes = blockSizeBytes - data.sigBytes % blockSizeBytes;
            var paddingWord = nPaddingBytes << 24 | nPaddingBytes << 16 | nPaddingBytes << 8 | nPaddingBytes;
            var paddingWords = [];
            for (var i = 0; i < nPaddingBytes; i += 4) {
              paddingWords.push(paddingWord);
            }
            var padding = WordArray.create(paddingWords, nPaddingBytes);
            data.concat(padding);
          },
          /**
           * Unpads data that had been padded using the algorithm defined in PKCS #5/7.
           *
           * @param {WordArray} data The data to unpad.
           *
           * @static
           *
           * @example
           *
           *     CryptoJS.pad.Pkcs7.unpad(wordArray);
           */
          unpad: function(data) {
            var nPaddingBytes = data.words[data.sigBytes - 1 >>> 2] & 255;
            data.sigBytes -= nPaddingBytes;
          }
        };
        var BlockCipher = C_lib.BlockCipher = Cipher.extend({
          /**
           * Configuration options.
           *
           * @property {Mode} mode The block mode to use. Default: CBC
           * @property {Padding} padding The padding strategy to use. Default: Pkcs7
           */
          cfg: Cipher.cfg.extend({
            mode: CBC,
            padding: Pkcs7
          }),
          reset: function() {
            Cipher.reset.call(this);
            var cfg = this.cfg;
            var iv = cfg.iv;
            var mode = cfg.mode;
            if (this._xformMode == this._ENC_XFORM_MODE) {
              var modeCreator = mode.createEncryptor;
            } else {
              var modeCreator = mode.createDecryptor;
              this._minBufferSize = 1;
            }
            if (this._mode && this._mode.__creator == modeCreator) {
              this._mode.init(this, iv && iv.words);
            } else {
              this._mode = modeCreator.call(mode, this, iv && iv.words);
              this._mode.__creator = modeCreator;
            }
          },
          _doProcessBlock: function(words, offset) {
            this._mode.processBlock(words, offset);
          },
          _doFinalize: function() {
            var padding = this.cfg.padding;
            if (this._xformMode == this._ENC_XFORM_MODE) {
              padding.pad(this._data, this.blockSize);
              var finalProcessedBlocks = this._process(true);
            } else {
              var finalProcessedBlocks = this._process(true);
              padding.unpad(finalProcessedBlocks);
            }
            return finalProcessedBlocks;
          },
          blockSize: 128 / 32
        });
        var CipherParams = C_lib.CipherParams = Base.extend({
          /**
           * Initializes a newly created cipher params object.
           *
           * @param {Object} cipherParams An object with any of the possible cipher parameters.
           *
           * @example
           *
           *     var cipherParams = CryptoJS.lib.CipherParams.create({
           *         ciphertext: ciphertextWordArray,
           *         key: keyWordArray,
           *         iv: ivWordArray,
           *         salt: saltWordArray,
           *         algorithm: CryptoJS.algo.AES,
           *         mode: CryptoJS.mode.CBC,
           *         padding: CryptoJS.pad.PKCS7,
           *         blockSize: 4,
           *         formatter: CryptoJS.format.OpenSSL
           *     });
           */
          init: function(cipherParams) {
            this.mixIn(cipherParams);
          },
          /**
           * Converts this cipher params object to a string.
           *
           * @param {Format} formatter (Optional) The formatting strategy to use.
           *
           * @return {string} The stringified cipher params.
           *
           * @throws Error If neither the formatter nor the default formatter is set.
           *
           * @example
           *
           *     var string = cipherParams + '';
           *     var string = cipherParams.toString();
           *     var string = cipherParams.toString(CryptoJS.format.OpenSSL);
           */
          toString: function(formatter) {
            return (formatter || this.formatter).stringify(this);
          }
        });
        var C_format = C.format = {};
        var OpenSSLFormatter = C_format.OpenSSL = {
          /**
           * Converts a cipher params object to an OpenSSL-compatible string.
           *
           * @param {CipherParams} cipherParams The cipher params object.
           *
           * @return {string} The OpenSSL-compatible string.
           *
           * @static
           *
           * @example
           *
           *     var openSSLString = CryptoJS.format.OpenSSL.stringify(cipherParams);
           */
          stringify: function(cipherParams) {
            var ciphertext = cipherParams.ciphertext;
            var salt = cipherParams.salt;
            if (salt) {
              var wordArray = WordArray.create([1398893684, 1701076831]).concat(salt).concat(ciphertext);
            } else {
              var wordArray = ciphertext;
            }
            return wordArray.toString(Base64);
          },
          /**
           * Converts an OpenSSL-compatible string to a cipher params object.
           *
           * @param {string} openSSLStr The OpenSSL-compatible string.
           *
           * @return {CipherParams} The cipher params object.
           *
           * @static
           *
           * @example
           *
           *     var cipherParams = CryptoJS.format.OpenSSL.parse(openSSLString);
           */
          parse: function(openSSLStr) {
            var ciphertext = Base64.parse(openSSLStr);
            var ciphertextWords = ciphertext.words;
            if (ciphertextWords[0] == 1398893684 && ciphertextWords[1] == 1701076831) {
              var salt = WordArray.create(ciphertextWords.slice(2, 4));
              ciphertextWords.splice(0, 4);
              ciphertext.sigBytes -= 16;
            }
            return CipherParams.create({ ciphertext, salt });
          }
        };
        var SerializableCipher = C_lib.SerializableCipher = Base.extend({
          /**
           * Configuration options.
           *
           * @property {Formatter} format The formatting strategy to convert cipher param objects to and from a string. Default: OpenSSL
           */
          cfg: Base.extend({
            format: OpenSSLFormatter
          }),
          /**
           * Encrypts a message.
           *
           * @param {Cipher} cipher The cipher algorithm to use.
           * @param {WordArray|string} message The message to encrypt.
           * @param {WordArray} key The key.
           * @param {Object} cfg (Optional) The configuration options to use for this operation.
           *
           * @return {CipherParams} A cipher params object.
           *
           * @static
           *
           * @example
           *
           *     var ciphertextParams = CryptoJS.lib.SerializableCipher.encrypt(CryptoJS.algo.AES, message, key);
           *     var ciphertextParams = CryptoJS.lib.SerializableCipher.encrypt(CryptoJS.algo.AES, message, key, { iv: iv });
           *     var ciphertextParams = CryptoJS.lib.SerializableCipher.encrypt(CryptoJS.algo.AES, message, key, { iv: iv, format: CryptoJS.format.OpenSSL });
           */
          encrypt: function(cipher, message, key, cfg) {
            cfg = this.cfg.extend(cfg);
            var encryptor = cipher.createEncryptor(key, cfg);
            var ciphertext = encryptor.finalize(message);
            var cipherCfg = encryptor.cfg;
            return CipherParams.create({
              ciphertext,
              key,
              iv: cipherCfg.iv,
              algorithm: cipher,
              mode: cipherCfg.mode,
              padding: cipherCfg.padding,
              blockSize: cipher.blockSize,
              formatter: cfg.format
            });
          },
          /**
           * Decrypts serialized ciphertext.
           *
           * @param {Cipher} cipher The cipher algorithm to use.
           * @param {CipherParams|string} ciphertext The ciphertext to decrypt.
           * @param {WordArray} key The key.
           * @param {Object} cfg (Optional) The configuration options to use for this operation.
           *
           * @return {WordArray} The plaintext.
           *
           * @static
           *
           * @example
           *
           *     var plaintext = CryptoJS.lib.SerializableCipher.decrypt(CryptoJS.algo.AES, formattedCiphertext, key, { iv: iv, format: CryptoJS.format.OpenSSL });
           *     var plaintext = CryptoJS.lib.SerializableCipher.decrypt(CryptoJS.algo.AES, ciphertextParams, key, { iv: iv, format: CryptoJS.format.OpenSSL });
           */
          decrypt: function(cipher, ciphertext, key, cfg) {
            cfg = this.cfg.extend(cfg);
            ciphertext = this._parse(ciphertext, cfg.format);
            var plaintext = cipher.createDecryptor(key, cfg).finalize(ciphertext.ciphertext);
            return plaintext;
          },
          /**
           * Converts serialized ciphertext to CipherParams,
           * else assumed CipherParams already and returns ciphertext unchanged.
           *
           * @param {CipherParams|string} ciphertext The ciphertext.
           * @param {Formatter} format The formatting strategy to use to parse serialized ciphertext.
           *
           * @return {CipherParams} The unserialized ciphertext.
           *
           * @static
           *
           * @example
           *
           *     var ciphertextParams = CryptoJS.lib.SerializableCipher._parse(ciphertextStringOrParams, format);
           */
          _parse: function(ciphertext, format) {
            if (typeof ciphertext == "string") {
              return format.parse(ciphertext, this);
            } else {
              return ciphertext;
            }
          }
        });
        var C_kdf = C.kdf = {};
        var OpenSSLKdf = C_kdf.OpenSSL = {
          /**
           * Derives a key and IV from a password.
           *
           * @param {string} password The password to derive from.
           * @param {number} keySize The size in words of the key to generate.
           * @param {number} ivSize The size in words of the IV to generate.
           * @param {WordArray|string} salt (Optional) A 64-bit salt to use. If omitted, a salt will be generated randomly.
           *
           * @return {CipherParams} A cipher params object with the key, IV, and salt.
           *
           * @static
           *
           * @example
           *
           *     var derivedParams = CryptoJS.kdf.OpenSSL.execute('Password', 256/32, 128/32);
           *     var derivedParams = CryptoJS.kdf.OpenSSL.execute('Password', 256/32, 128/32, 'saltsalt');
           */
          execute: function(password, keySize, ivSize, salt) {
            if (!salt) {
              salt = WordArray.random(64 / 8);
            }
            var key = EvpKDF.create({ keySize: keySize + ivSize }).compute(password, salt);
            var iv = WordArray.create(key.words.slice(keySize), ivSize * 4);
            key.sigBytes = keySize * 4;
            return CipherParams.create({ key, iv, salt });
          }
        };
        var PasswordBasedCipher = C_lib.PasswordBasedCipher = SerializableCipher.extend({
          /**
           * Configuration options.
           *
           * @property {KDF} kdf The key derivation function to use to generate a key and IV from a password. Default: OpenSSL
           */
          cfg: SerializableCipher.cfg.extend({
            kdf: OpenSSLKdf
          }),
          /**
           * Encrypts a message using a password.
           *
           * @param {Cipher} cipher The cipher algorithm to use.
           * @param {WordArray|string} message The message to encrypt.
           * @param {string} password The password.
           * @param {Object} cfg (Optional) The configuration options to use for this operation.
           *
           * @return {CipherParams} A cipher params object.
           *
           * @static
           *
           * @example
           *
           *     var ciphertextParams = CryptoJS.lib.PasswordBasedCipher.encrypt(CryptoJS.algo.AES, message, 'password');
           *     var ciphertextParams = CryptoJS.lib.PasswordBasedCipher.encrypt(CryptoJS.algo.AES, message, 'password', { format: CryptoJS.format.OpenSSL });
           */
          encrypt: function(cipher, message, password, cfg) {
            cfg = this.cfg.extend(cfg);
            var derivedParams = cfg.kdf.execute(password, cipher.keySize, cipher.ivSize);
            cfg.iv = derivedParams.iv;
            var ciphertext = SerializableCipher.encrypt.call(this, cipher, message, derivedParams.key, cfg);
            ciphertext.mixIn(derivedParams);
            return ciphertext;
          },
          /**
           * Decrypts serialized ciphertext using a password.
           *
           * @param {Cipher} cipher The cipher algorithm to use.
           * @param {CipherParams|string} ciphertext The ciphertext to decrypt.
           * @param {string} password The password.
           * @param {Object} cfg (Optional) The configuration options to use for this operation.
           *
           * @return {WordArray} The plaintext.
           *
           * @static
           *
           * @example
           *
           *     var plaintext = CryptoJS.lib.PasswordBasedCipher.decrypt(CryptoJS.algo.AES, formattedCiphertext, 'password', { format: CryptoJS.format.OpenSSL });
           *     var plaintext = CryptoJS.lib.PasswordBasedCipher.decrypt(CryptoJS.algo.AES, ciphertextParams, 'password', { format: CryptoJS.format.OpenSSL });
           */
          decrypt: function(cipher, ciphertext, password, cfg) {
            cfg = this.cfg.extend(cfg);
            ciphertext = this._parse(ciphertext, cfg.format);
            var derivedParams = cfg.kdf.execute(password, cipher.keySize, cipher.ivSize, ciphertext.salt);
            cfg.iv = derivedParams.iv;
            var plaintext = SerializableCipher.decrypt.call(this, cipher, ciphertext, derivedParams.key, cfg);
            return plaintext;
          }
        });
      }();
    });
  }
});

// node_modules/merkletreejs/node_modules/crypto-js/mode-cfb.js
var require_mode_cfb = __commonJS({
  "node_modules/merkletreejs/node_modules/crypto-js/mode-cfb.js"(exports, module) {
    init_shim();
    (function(root, factory, undef) {
      if (typeof exports === "object") {
        module.exports = exports = factory(require_core2(), require_cipher_core());
      } else if (typeof define === "function" && define.amd) {
        define(["./core", "./cipher-core"], factory);
      } else {
        factory(root.CryptoJS);
      }
    })(exports, function(CryptoJS) {
      CryptoJS.mode.CFB = function() {
        var CFB = CryptoJS.lib.BlockCipherMode.extend();
        CFB.Encryptor = CFB.extend({
          processBlock: function(words, offset) {
            var cipher = this._cipher;
            var blockSize = cipher.blockSize;
            generateKeystreamAndEncrypt.call(this, words, offset, blockSize, cipher);
            this._prevBlock = words.slice(offset, offset + blockSize);
          }
        });
        CFB.Decryptor = CFB.extend({
          processBlock: function(words, offset) {
            var cipher = this._cipher;
            var blockSize = cipher.blockSize;
            var thisBlock = words.slice(offset, offset + blockSize);
            generateKeystreamAndEncrypt.call(this, words, offset, blockSize, cipher);
            this._prevBlock = thisBlock;
          }
        });
        function generateKeystreamAndEncrypt(words, offset, blockSize, cipher) {
          var iv = this._iv;
          if (iv) {
            var keystream = iv.slice(0);
            this._iv = void 0;
          } else {
            var keystream = this._prevBlock;
          }
          cipher.encryptBlock(keystream, 0);
          for (var i = 0; i < blockSize; i++) {
            words[offset + i] ^= keystream[i];
          }
        }
        return CFB;
      }();
      return CryptoJS.mode.CFB;
    });
  }
});

// node_modules/merkletreejs/node_modules/crypto-js/mode-ctr.js
var require_mode_ctr = __commonJS({
  "node_modules/merkletreejs/node_modules/crypto-js/mode-ctr.js"(exports, module) {
    init_shim();
    (function(root, factory, undef) {
      if (typeof exports === "object") {
        module.exports = exports = factory(require_core2(), require_cipher_core());
      } else if (typeof define === "function" && define.amd) {
        define(["./core", "./cipher-core"], factory);
      } else {
        factory(root.CryptoJS);
      }
    })(exports, function(CryptoJS) {
      CryptoJS.mode.CTR = function() {
        var CTR = CryptoJS.lib.BlockCipherMode.extend();
        var Encryptor = CTR.Encryptor = CTR.extend({
          processBlock: function(words, offset) {
            var cipher = this._cipher;
            var blockSize = cipher.blockSize;
            var iv = this._iv;
            var counter = this._counter;
            if (iv) {
              counter = this._counter = iv.slice(0);
              this._iv = void 0;
            }
            var keystream = counter.slice(0);
            cipher.encryptBlock(keystream, 0);
            counter[blockSize - 1] = counter[blockSize - 1] + 1 | 0;
            for (var i = 0; i < blockSize; i++) {
              words[offset + i] ^= keystream[i];
            }
          }
        });
        CTR.Decryptor = Encryptor;
        return CTR;
      }();
      return CryptoJS.mode.CTR;
    });
  }
});

// node_modules/merkletreejs/node_modules/crypto-js/mode-ctr-gladman.js
var require_mode_ctr_gladman = __commonJS({
  "node_modules/merkletreejs/node_modules/crypto-js/mode-ctr-gladman.js"(exports, module) {
    init_shim();
    (function(root, factory, undef) {
      if (typeof exports === "object") {
        module.exports = exports = factory(require_core2(), require_cipher_core());
      } else if (typeof define === "function" && define.amd) {
        define(["./core", "./cipher-core"], factory);
      } else {
        factory(root.CryptoJS);
      }
    })(exports, function(CryptoJS) {
      CryptoJS.mode.CTRGladman = function() {
        var CTRGladman = CryptoJS.lib.BlockCipherMode.extend();
        function incWord(word) {
          if ((word >> 24 & 255) === 255) {
            var b1 = word >> 16 & 255;
            var b2 = word >> 8 & 255;
            var b3 = word & 255;
            if (b1 === 255) {
              b1 = 0;
              if (b2 === 255) {
                b2 = 0;
                if (b3 === 255) {
                  b3 = 0;
                } else {
                  ++b3;
                }
              } else {
                ++b2;
              }
            } else {
              ++b1;
            }
            word = 0;
            word += b1 << 16;
            word += b2 << 8;
            word += b3;
          } else {
            word += 1 << 24;
          }
          return word;
        }
        function incCounter(counter) {
          if ((counter[0] = incWord(counter[0])) === 0) {
            counter[1] = incWord(counter[1]);
          }
          return counter;
        }
        var Encryptor = CTRGladman.Encryptor = CTRGladman.extend({
          processBlock: function(words, offset) {
            var cipher = this._cipher;
            var blockSize = cipher.blockSize;
            var iv = this._iv;
            var counter = this._counter;
            if (iv) {
              counter = this._counter = iv.slice(0);
              this._iv = void 0;
            }
            incCounter(counter);
            var keystream = counter.slice(0);
            cipher.encryptBlock(keystream, 0);
            for (var i = 0; i < blockSize; i++) {
              words[offset + i] ^= keystream[i];
            }
          }
        });
        CTRGladman.Decryptor = Encryptor;
        return CTRGladman;
      }();
      return CryptoJS.mode.CTRGladman;
    });
  }
});

// node_modules/merkletreejs/node_modules/crypto-js/mode-ofb.js
var require_mode_ofb = __commonJS({
  "node_modules/merkletreejs/node_modules/crypto-js/mode-ofb.js"(exports, module) {
    init_shim();
    (function(root, factory, undef) {
      if (typeof exports === "object") {
        module.exports = exports = factory(require_core2(), require_cipher_core());
      } else if (typeof define === "function" && define.amd) {
        define(["./core", "./cipher-core"], factory);
      } else {
        factory(root.CryptoJS);
      }
    })(exports, function(CryptoJS) {
      CryptoJS.mode.OFB = function() {
        var OFB = CryptoJS.lib.BlockCipherMode.extend();
        var Encryptor = OFB.Encryptor = OFB.extend({
          processBlock: function(words, offset) {
            var cipher = this._cipher;
            var blockSize = cipher.blockSize;
            var iv = this._iv;
            var keystream = this._keystream;
            if (iv) {
              keystream = this._keystream = iv.slice(0);
              this._iv = void 0;
            }
            cipher.encryptBlock(keystream, 0);
            for (var i = 0; i < blockSize; i++) {
              words[offset + i] ^= keystream[i];
            }
          }
        });
        OFB.Decryptor = Encryptor;
        return OFB;
      }();
      return CryptoJS.mode.OFB;
    });
  }
});

// node_modules/merkletreejs/node_modules/crypto-js/mode-ecb.js
var require_mode_ecb = __commonJS({
  "node_modules/merkletreejs/node_modules/crypto-js/mode-ecb.js"(exports, module) {
    init_shim();
    (function(root, factory, undef) {
      if (typeof exports === "object") {
        module.exports = exports = factory(require_core2(), require_cipher_core());
      } else if (typeof define === "function" && define.amd) {
        define(["./core", "./cipher-core"], factory);
      } else {
        factory(root.CryptoJS);
      }
    })(exports, function(CryptoJS) {
      CryptoJS.mode.ECB = function() {
        var ECB = CryptoJS.lib.BlockCipherMode.extend();
        ECB.Encryptor = ECB.extend({
          processBlock: function(words, offset) {
            this._cipher.encryptBlock(words, offset);
          }
        });
        ECB.Decryptor = ECB.extend({
          processBlock: function(words, offset) {
            this._cipher.decryptBlock(words, offset);
          }
        });
        return ECB;
      }();
      return CryptoJS.mode.ECB;
    });
  }
});

// node_modules/merkletreejs/node_modules/crypto-js/pad-ansix923.js
var require_pad_ansix923 = __commonJS({
  "node_modules/merkletreejs/node_modules/crypto-js/pad-ansix923.js"(exports, module) {
    init_shim();
    (function(root, factory, undef) {
      if (typeof exports === "object") {
        module.exports = exports = factory(require_core2(), require_cipher_core());
      } else if (typeof define === "function" && define.amd) {
        define(["./core", "./cipher-core"], factory);
      } else {
        factory(root.CryptoJS);
      }
    })(exports, function(CryptoJS) {
      CryptoJS.pad.AnsiX923 = {
        pad: function(data, blockSize) {
          var dataSigBytes = data.sigBytes;
          var blockSizeBytes = blockSize * 4;
          var nPaddingBytes = blockSizeBytes - dataSigBytes % blockSizeBytes;
          var lastBytePos = dataSigBytes + nPaddingBytes - 1;
          data.clamp();
          data.words[lastBytePos >>> 2] |= nPaddingBytes << 24 - lastBytePos % 4 * 8;
          data.sigBytes += nPaddingBytes;
        },
        unpad: function(data) {
          var nPaddingBytes = data.words[data.sigBytes - 1 >>> 2] & 255;
          data.sigBytes -= nPaddingBytes;
        }
      };
      return CryptoJS.pad.Ansix923;
    });
  }
});

// node_modules/merkletreejs/node_modules/crypto-js/pad-iso10126.js
var require_pad_iso10126 = __commonJS({
  "node_modules/merkletreejs/node_modules/crypto-js/pad-iso10126.js"(exports, module) {
    init_shim();
    (function(root, factory, undef) {
      if (typeof exports === "object") {
        module.exports = exports = factory(require_core2(), require_cipher_core());
      } else if (typeof define === "function" && define.amd) {
        define(["./core", "./cipher-core"], factory);
      } else {
        factory(root.CryptoJS);
      }
    })(exports, function(CryptoJS) {
      CryptoJS.pad.Iso10126 = {
        pad: function(data, blockSize) {
          var blockSizeBytes = blockSize * 4;
          var nPaddingBytes = blockSizeBytes - data.sigBytes % blockSizeBytes;
          data.concat(CryptoJS.lib.WordArray.random(nPaddingBytes - 1)).concat(CryptoJS.lib.WordArray.create([nPaddingBytes << 24], 1));
        },
        unpad: function(data) {
          var nPaddingBytes = data.words[data.sigBytes - 1 >>> 2] & 255;
          data.sigBytes -= nPaddingBytes;
        }
      };
      return CryptoJS.pad.Iso10126;
    });
  }
});

// node_modules/merkletreejs/node_modules/crypto-js/pad-iso97971.js
var require_pad_iso97971 = __commonJS({
  "node_modules/merkletreejs/node_modules/crypto-js/pad-iso97971.js"(exports, module) {
    init_shim();
    (function(root, factory, undef) {
      if (typeof exports === "object") {
        module.exports = exports = factory(require_core2(), require_cipher_core());
      } else if (typeof define === "function" && define.amd) {
        define(["./core", "./cipher-core"], factory);
      } else {
        factory(root.CryptoJS);
      }
    })(exports, function(CryptoJS) {
      CryptoJS.pad.Iso97971 = {
        pad: function(data, blockSize) {
          data.concat(CryptoJS.lib.WordArray.create([2147483648], 1));
          CryptoJS.pad.ZeroPadding.pad(data, blockSize);
        },
        unpad: function(data) {
          CryptoJS.pad.ZeroPadding.unpad(data);
          data.sigBytes--;
        }
      };
      return CryptoJS.pad.Iso97971;
    });
  }
});

// node_modules/merkletreejs/node_modules/crypto-js/pad-zeropadding.js
var require_pad_zeropadding = __commonJS({
  "node_modules/merkletreejs/node_modules/crypto-js/pad-zeropadding.js"(exports, module) {
    init_shim();
    (function(root, factory, undef) {
      if (typeof exports === "object") {
        module.exports = exports = factory(require_core2(), require_cipher_core());
      } else if (typeof define === "function" && define.amd) {
        define(["./core", "./cipher-core"], factory);
      } else {
        factory(root.CryptoJS);
      }
    })(exports, function(CryptoJS) {
      CryptoJS.pad.ZeroPadding = {
        pad: function(data, blockSize) {
          var blockSizeBytes = blockSize * 4;
          data.clamp();
          data.sigBytes += blockSizeBytes - (data.sigBytes % blockSizeBytes || blockSizeBytes);
        },
        unpad: function(data) {
          var dataWords = data.words;
          var i = data.sigBytes - 1;
          while (!(dataWords[i >>> 2] >>> 24 - i % 4 * 8 & 255)) {
            i--;
          }
          data.sigBytes = i + 1;
        }
      };
      return CryptoJS.pad.ZeroPadding;
    });
  }
});

// node_modules/merkletreejs/node_modules/crypto-js/pad-nopadding.js
var require_pad_nopadding = __commonJS({
  "node_modules/merkletreejs/node_modules/crypto-js/pad-nopadding.js"(exports, module) {
    init_shim();
    (function(root, factory, undef) {
      if (typeof exports === "object") {
        module.exports = exports = factory(require_core2(), require_cipher_core());
      } else if (typeof define === "function" && define.amd) {
        define(["./core", "./cipher-core"], factory);
      } else {
        factory(root.CryptoJS);
      }
    })(exports, function(CryptoJS) {
      CryptoJS.pad.NoPadding = {
        pad: function() {
        },
        unpad: function() {
        }
      };
      return CryptoJS.pad.NoPadding;
    });
  }
});

// node_modules/merkletreejs/node_modules/crypto-js/format-hex.js
var require_format_hex = __commonJS({
  "node_modules/merkletreejs/node_modules/crypto-js/format-hex.js"(exports, module) {
    init_shim();
    (function(root, factory, undef) {
      if (typeof exports === "object") {
        module.exports = exports = factory(require_core2(), require_cipher_core());
      } else if (typeof define === "function" && define.amd) {
        define(["./core", "./cipher-core"], factory);
      } else {
        factory(root.CryptoJS);
      }
    })(exports, function(CryptoJS) {
      (function(undefined2) {
        var C = CryptoJS;
        var C_lib = C.lib;
        var CipherParams = C_lib.CipherParams;
        var C_enc = C.enc;
        var Hex = C_enc.Hex;
        var C_format = C.format;
        var HexFormatter = C_format.Hex = {
          /**
           * Converts the ciphertext of a cipher params object to a hexadecimally encoded string.
           *
           * @param {CipherParams} cipherParams The cipher params object.
           *
           * @return {string} The hexadecimally encoded string.
           *
           * @static
           *
           * @example
           *
           *     var hexString = CryptoJS.format.Hex.stringify(cipherParams);
           */
          stringify: function(cipherParams) {
            return cipherParams.ciphertext.toString(Hex);
          },
          /**
           * Converts a hexadecimally encoded ciphertext string to a cipher params object.
           *
           * @param {string} input The hexadecimally encoded string.
           *
           * @return {CipherParams} The cipher params object.
           *
           * @static
           *
           * @example
           *
           *     var cipherParams = CryptoJS.format.Hex.parse(hexString);
           */
          parse: function(input) {
            var ciphertext = Hex.parse(input);
            return CipherParams.create({ ciphertext });
          }
        };
      })();
      return CryptoJS.format.Hex;
    });
  }
});

// node_modules/merkletreejs/node_modules/crypto-js/aes.js
var require_aes = __commonJS({
  "node_modules/merkletreejs/node_modules/crypto-js/aes.js"(exports, module) {
    init_shim();
    (function(root, factory, undef) {
      if (typeof exports === "object") {
        module.exports = exports = factory(require_core2(), require_enc_base64(), require_md5(), require_evpkdf(), require_cipher_core());
      } else if (typeof define === "function" && define.amd) {
        define(["./core", "./enc-base64", "./md5", "./evpkdf", "./cipher-core"], factory);
      } else {
        factory(root.CryptoJS);
      }
    })(exports, function(CryptoJS) {
      (function() {
        var C = CryptoJS;
        var C_lib = C.lib;
        var BlockCipher = C_lib.BlockCipher;
        var C_algo = C.algo;
        var SBOX = [];
        var INV_SBOX = [];
        var SUB_MIX_0 = [];
        var SUB_MIX_1 = [];
        var SUB_MIX_2 = [];
        var SUB_MIX_3 = [];
        var INV_SUB_MIX_0 = [];
        var INV_SUB_MIX_1 = [];
        var INV_SUB_MIX_2 = [];
        var INV_SUB_MIX_3 = [];
        (function() {
          var d = [];
          for (var i = 0; i < 256; i++) {
            if (i < 128) {
              d[i] = i << 1;
            } else {
              d[i] = i << 1 ^ 283;
            }
          }
          var x = 0;
          var xi = 0;
          for (var i = 0; i < 256; i++) {
            var sx = xi ^ xi << 1 ^ xi << 2 ^ xi << 3 ^ xi << 4;
            sx = sx >>> 8 ^ sx & 255 ^ 99;
            SBOX[x] = sx;
            INV_SBOX[sx] = x;
            var x2 = d[x];
            var x4 = d[x2];
            var x8 = d[x4];
            var t = d[sx] * 257 ^ sx * 16843008;
            SUB_MIX_0[x] = t << 24 | t >>> 8;
            SUB_MIX_1[x] = t << 16 | t >>> 16;
            SUB_MIX_2[x] = t << 8 | t >>> 24;
            SUB_MIX_3[x] = t;
            var t = x8 * 16843009 ^ x4 * 65537 ^ x2 * 257 ^ x * 16843008;
            INV_SUB_MIX_0[sx] = t << 24 | t >>> 8;
            INV_SUB_MIX_1[sx] = t << 16 | t >>> 16;
            INV_SUB_MIX_2[sx] = t << 8 | t >>> 24;
            INV_SUB_MIX_3[sx] = t;
            if (!x) {
              x = xi = 1;
            } else {
              x = x2 ^ d[d[d[x8 ^ x2]]];
              xi ^= d[d[xi]];
            }
          }
        })();
        var RCON = [0, 1, 2, 4, 8, 16, 32, 64, 128, 27, 54];
        var AES = C_algo.AES = BlockCipher.extend({
          _doReset: function() {
            if (this._nRounds && this._keyPriorReset === this._key) {
              return;
            }
            var key = this._keyPriorReset = this._key;
            var keyWords = key.words;
            var keySize = key.sigBytes / 4;
            var nRounds = this._nRounds = keySize + 6;
            var ksRows = (nRounds + 1) * 4;
            var keySchedule = this._keySchedule = [];
            for (var ksRow = 0; ksRow < ksRows; ksRow++) {
              if (ksRow < keySize) {
                keySchedule[ksRow] = keyWords[ksRow];
              } else {
                var t = keySchedule[ksRow - 1];
                if (!(ksRow % keySize)) {
                  t = t << 8 | t >>> 24;
                  t = SBOX[t >>> 24] << 24 | SBOX[t >>> 16 & 255] << 16 | SBOX[t >>> 8 & 255] << 8 | SBOX[t & 255];
                  t ^= RCON[ksRow / keySize | 0] << 24;
                } else if (keySize > 6 && ksRow % keySize == 4) {
                  t = SBOX[t >>> 24] << 24 | SBOX[t >>> 16 & 255] << 16 | SBOX[t >>> 8 & 255] << 8 | SBOX[t & 255];
                }
                keySchedule[ksRow] = keySchedule[ksRow - keySize] ^ t;
              }
            }
            var invKeySchedule = this._invKeySchedule = [];
            for (var invKsRow = 0; invKsRow < ksRows; invKsRow++) {
              var ksRow = ksRows - invKsRow;
              if (invKsRow % 4) {
                var t = keySchedule[ksRow];
              } else {
                var t = keySchedule[ksRow - 4];
              }
              if (invKsRow < 4 || ksRow <= 4) {
                invKeySchedule[invKsRow] = t;
              } else {
                invKeySchedule[invKsRow] = INV_SUB_MIX_0[SBOX[t >>> 24]] ^ INV_SUB_MIX_1[SBOX[t >>> 16 & 255]] ^ INV_SUB_MIX_2[SBOX[t >>> 8 & 255]] ^ INV_SUB_MIX_3[SBOX[t & 255]];
              }
            }
          },
          encryptBlock: function(M, offset) {
            this._doCryptBlock(M, offset, this._keySchedule, SUB_MIX_0, SUB_MIX_1, SUB_MIX_2, SUB_MIX_3, SBOX);
          },
          decryptBlock: function(M, offset) {
            var t = M[offset + 1];
            M[offset + 1] = M[offset + 3];
            M[offset + 3] = t;
            this._doCryptBlock(M, offset, this._invKeySchedule, INV_SUB_MIX_0, INV_SUB_MIX_1, INV_SUB_MIX_2, INV_SUB_MIX_3, INV_SBOX);
            var t = M[offset + 1];
            M[offset + 1] = M[offset + 3];
            M[offset + 3] = t;
          },
          _doCryptBlock: function(M, offset, keySchedule, SUB_MIX_02, SUB_MIX_12, SUB_MIX_22, SUB_MIX_32, SBOX2) {
            var nRounds = this._nRounds;
            var s0 = M[offset] ^ keySchedule[0];
            var s1 = M[offset + 1] ^ keySchedule[1];
            var s2 = M[offset + 2] ^ keySchedule[2];
            var s3 = M[offset + 3] ^ keySchedule[3];
            var ksRow = 4;
            for (var round = 1; round < nRounds; round++) {
              var t0 = SUB_MIX_02[s0 >>> 24] ^ SUB_MIX_12[s1 >>> 16 & 255] ^ SUB_MIX_22[s2 >>> 8 & 255] ^ SUB_MIX_32[s3 & 255] ^ keySchedule[ksRow++];
              var t1 = SUB_MIX_02[s1 >>> 24] ^ SUB_MIX_12[s2 >>> 16 & 255] ^ SUB_MIX_22[s3 >>> 8 & 255] ^ SUB_MIX_32[s0 & 255] ^ keySchedule[ksRow++];
              var t2 = SUB_MIX_02[s2 >>> 24] ^ SUB_MIX_12[s3 >>> 16 & 255] ^ SUB_MIX_22[s0 >>> 8 & 255] ^ SUB_MIX_32[s1 & 255] ^ keySchedule[ksRow++];
              var t3 = SUB_MIX_02[s3 >>> 24] ^ SUB_MIX_12[s0 >>> 16 & 255] ^ SUB_MIX_22[s1 >>> 8 & 255] ^ SUB_MIX_32[s2 & 255] ^ keySchedule[ksRow++];
              s0 = t0;
              s1 = t1;
              s2 = t2;
              s3 = t3;
            }
            var t0 = (SBOX2[s0 >>> 24] << 24 | SBOX2[s1 >>> 16 & 255] << 16 | SBOX2[s2 >>> 8 & 255] << 8 | SBOX2[s3 & 255]) ^ keySchedule[ksRow++];
            var t1 = (SBOX2[s1 >>> 24] << 24 | SBOX2[s2 >>> 16 & 255] << 16 | SBOX2[s3 >>> 8 & 255] << 8 | SBOX2[s0 & 255]) ^ keySchedule[ksRow++];
            var t2 = (SBOX2[s2 >>> 24] << 24 | SBOX2[s3 >>> 16 & 255] << 16 | SBOX2[s0 >>> 8 & 255] << 8 | SBOX2[s1 & 255]) ^ keySchedule[ksRow++];
            var t3 = (SBOX2[s3 >>> 24] << 24 | SBOX2[s0 >>> 16 & 255] << 16 | SBOX2[s1 >>> 8 & 255] << 8 | SBOX2[s2 & 255]) ^ keySchedule[ksRow++];
            M[offset] = t0;
            M[offset + 1] = t1;
            M[offset + 2] = t2;
            M[offset + 3] = t3;
          },
          keySize: 256 / 32
        });
        C.AES = BlockCipher._createHelper(AES);
      })();
      return CryptoJS.AES;
    });
  }
});

// node_modules/merkletreejs/node_modules/crypto-js/tripledes.js
var require_tripledes = __commonJS({
  "node_modules/merkletreejs/node_modules/crypto-js/tripledes.js"(exports, module) {
    init_shim();
    (function(root, factory, undef) {
      if (typeof exports === "object") {
        module.exports = exports = factory(require_core2(), require_enc_base64(), require_md5(), require_evpkdf(), require_cipher_core());
      } else if (typeof define === "function" && define.amd) {
        define(["./core", "./enc-base64", "./md5", "./evpkdf", "./cipher-core"], factory);
      } else {
        factory(root.CryptoJS);
      }
    })(exports, function(CryptoJS) {
      (function() {
        var C = CryptoJS;
        var C_lib = C.lib;
        var WordArray = C_lib.WordArray;
        var BlockCipher = C_lib.BlockCipher;
        var C_algo = C.algo;
        var PC1 = [
          57,
          49,
          41,
          33,
          25,
          17,
          9,
          1,
          58,
          50,
          42,
          34,
          26,
          18,
          10,
          2,
          59,
          51,
          43,
          35,
          27,
          19,
          11,
          3,
          60,
          52,
          44,
          36,
          63,
          55,
          47,
          39,
          31,
          23,
          15,
          7,
          62,
          54,
          46,
          38,
          30,
          22,
          14,
          6,
          61,
          53,
          45,
          37,
          29,
          21,
          13,
          5,
          28,
          20,
          12,
          4
        ];
        var PC2 = [
          14,
          17,
          11,
          24,
          1,
          5,
          3,
          28,
          15,
          6,
          21,
          10,
          23,
          19,
          12,
          4,
          26,
          8,
          16,
          7,
          27,
          20,
          13,
          2,
          41,
          52,
          31,
          37,
          47,
          55,
          30,
          40,
          51,
          45,
          33,
          48,
          44,
          49,
          39,
          56,
          34,
          53,
          46,
          42,
          50,
          36,
          29,
          32
        ];
        var BIT_SHIFTS = [1, 2, 4, 6, 8, 10, 12, 14, 15, 17, 19, 21, 23, 25, 27, 28];
        var SBOX_P = [
          {
            0: 8421888,
            268435456: 32768,
            536870912: 8421378,
            805306368: 2,
            1073741824: 512,
            1342177280: 8421890,
            1610612736: 8389122,
            1879048192: 8388608,
            2147483648: 514,
            2415919104: 8389120,
            2684354560: 33280,
            2952790016: 8421376,
            3221225472: 32770,
            3489660928: 8388610,
            3758096384: 0,
            4026531840: 33282,
            134217728: 0,
            402653184: 8421890,
            671088640: 33282,
            939524096: 32768,
            1207959552: 8421888,
            1476395008: 512,
            1744830464: 8421378,
            2013265920: 2,
            2281701376: 8389120,
            2550136832: 33280,
            2818572288: 8421376,
            3087007744: 8389122,
            3355443200: 8388610,
            3623878656: 32770,
            3892314112: 514,
            4160749568: 8388608,
            1: 32768,
            268435457: 2,
            536870913: 8421888,
            805306369: 8388608,
            1073741825: 8421378,
            1342177281: 33280,
            1610612737: 512,
            1879048193: 8389122,
            2147483649: 8421890,
            2415919105: 8421376,
            2684354561: 8388610,
            2952790017: 33282,
            3221225473: 514,
            3489660929: 8389120,
            3758096385: 32770,
            4026531841: 0,
            134217729: 8421890,
            402653185: 8421376,
            671088641: 8388608,
            939524097: 512,
            1207959553: 32768,
            1476395009: 8388610,
            1744830465: 2,
            2013265921: 33282,
            2281701377: 32770,
            2550136833: 8389122,
            2818572289: 514,
            3087007745: 8421888,
            3355443201: 8389120,
            3623878657: 0,
            3892314113: 33280,
            4160749569: 8421378
          },
          {
            0: 1074282512,
            16777216: 16384,
            33554432: 524288,
            50331648: 1074266128,
            67108864: 1073741840,
            83886080: 1074282496,
            100663296: 1073758208,
            117440512: 16,
            134217728: 540672,
            150994944: 1073758224,
            167772160: 1073741824,
            184549376: 540688,
            201326592: 524304,
            218103808: 0,
            234881024: 16400,
            251658240: 1074266112,
            8388608: 1073758208,
            25165824: 540688,
            41943040: 16,
            58720256: 1073758224,
            75497472: 1074282512,
            92274688: 1073741824,
            109051904: 524288,
            125829120: 1074266128,
            142606336: 524304,
            159383552: 0,
            176160768: 16384,
            192937984: 1074266112,
            209715200: 1073741840,
            226492416: 540672,
            243269632: 1074282496,
            260046848: 16400,
            268435456: 0,
            285212672: 1074266128,
            301989888: 1073758224,
            318767104: 1074282496,
            335544320: 1074266112,
            352321536: 16,
            369098752: 540688,
            385875968: 16384,
            402653184: 16400,
            419430400: 524288,
            436207616: 524304,
            452984832: 1073741840,
            469762048: 540672,
            486539264: 1073758208,
            503316480: 1073741824,
            520093696: 1074282512,
            276824064: 540688,
            293601280: 524288,
            310378496: 1074266112,
            327155712: 16384,
            343932928: 1073758208,
            360710144: 1074282512,
            377487360: 16,
            394264576: 1073741824,
            411041792: 1074282496,
            427819008: 1073741840,
            444596224: 1073758224,
            461373440: 524304,
            478150656: 0,
            494927872: 16400,
            511705088: 1074266128,
            528482304: 540672
          },
          {
            0: 260,
            1048576: 0,
            2097152: 67109120,
            3145728: 65796,
            4194304: 65540,
            5242880: 67108868,
            6291456: 67174660,
            7340032: 67174400,
            8388608: 67108864,
            9437184: 67174656,
            10485760: 65792,
            11534336: 67174404,
            12582912: 67109124,
            13631488: 65536,
            14680064: 4,
            15728640: 256,
            524288: 67174656,
            1572864: 67174404,
            2621440: 0,
            3670016: 67109120,
            4718592: 67108868,
            5767168: 65536,
            6815744: 65540,
            7864320: 260,
            8912896: 4,
            9961472: 256,
            11010048: 67174400,
            12058624: 65796,
            13107200: 65792,
            14155776: 67109124,
            15204352: 67174660,
            16252928: 67108864,
            16777216: 67174656,
            17825792: 65540,
            18874368: 65536,
            19922944: 67109120,
            20971520: 256,
            22020096: 67174660,
            23068672: 67108868,
            24117248: 0,
            25165824: 67109124,
            26214400: 67108864,
            27262976: 4,
            28311552: 65792,
            29360128: 67174400,
            30408704: 260,
            31457280: 65796,
            32505856: 67174404,
            17301504: 67108864,
            18350080: 260,
            19398656: 67174656,
            20447232: 0,
            21495808: 65540,
            22544384: 67109120,
            23592960: 256,
            24641536: 67174404,
            25690112: 65536,
            26738688: 67174660,
            27787264: 65796,
            28835840: 67108868,
            29884416: 67109124,
            30932992: 67174400,
            31981568: 4,
            33030144: 65792
          },
          {
            0: 2151682048,
            65536: 2147487808,
            131072: 4198464,
            196608: 2151677952,
            262144: 0,
            327680: 4198400,
            393216: 2147483712,
            458752: 4194368,
            524288: 2147483648,
            589824: 4194304,
            655360: 64,
            720896: 2147487744,
            786432: 2151678016,
            851968: 4160,
            917504: 4096,
            983040: 2151682112,
            32768: 2147487808,
            98304: 64,
            163840: 2151678016,
            229376: 2147487744,
            294912: 4198400,
            360448: 2151682112,
            425984: 0,
            491520: 2151677952,
            557056: 4096,
            622592: 2151682048,
            688128: 4194304,
            753664: 4160,
            819200: 2147483648,
            884736: 4194368,
            950272: 4198464,
            1015808: 2147483712,
            1048576: 4194368,
            1114112: 4198400,
            1179648: 2147483712,
            1245184: 0,
            1310720: 4160,
            1376256: 2151678016,
            1441792: 2151682048,
            1507328: 2147487808,
            1572864: 2151682112,
            1638400: 2147483648,
            1703936: 2151677952,
            1769472: 4198464,
            1835008: 2147487744,
            1900544: 4194304,
            1966080: 64,
            2031616: 4096,
            1081344: 2151677952,
            1146880: 2151682112,
            1212416: 0,
            1277952: 4198400,
            1343488: 4194368,
            1409024: 2147483648,
            1474560: 2147487808,
            1540096: 64,
            1605632: 2147483712,
            1671168: 4096,
            1736704: 2147487744,
            1802240: 2151678016,
            1867776: 4160,
            1933312: 2151682048,
            1998848: 4194304,
            2064384: 4198464
          },
          {
            0: 128,
            4096: 17039360,
            8192: 262144,
            12288: 536870912,
            16384: 537133184,
            20480: 16777344,
            24576: 553648256,
            28672: 262272,
            32768: 16777216,
            36864: 537133056,
            40960: 536871040,
            45056: 553910400,
            49152: 553910272,
            53248: 0,
            57344: 17039488,
            61440: 553648128,
            2048: 17039488,
            6144: 553648256,
            10240: 128,
            14336: 17039360,
            18432: 262144,
            22528: 537133184,
            26624: 553910272,
            30720: 536870912,
            34816: 537133056,
            38912: 0,
            43008: 553910400,
            47104: 16777344,
            51200: 536871040,
            55296: 553648128,
            59392: 16777216,
            63488: 262272,
            65536: 262144,
            69632: 128,
            73728: 536870912,
            77824: 553648256,
            81920: 16777344,
            86016: 553910272,
            90112: 537133184,
            94208: 16777216,
            98304: 553910400,
            102400: 553648128,
            106496: 17039360,
            110592: 537133056,
            114688: 262272,
            118784: 536871040,
            122880: 0,
            126976: 17039488,
            67584: 553648256,
            71680: 16777216,
            75776: 17039360,
            79872: 537133184,
            83968: 536870912,
            88064: 17039488,
            92160: 128,
            96256: 553910272,
            100352: 262272,
            104448: 553910400,
            108544: 0,
            112640: 553648128,
            116736: 16777344,
            120832: 262144,
            124928: 537133056,
            129024: 536871040
          },
          {
            0: 268435464,
            256: 8192,
            512: 270532608,
            768: 270540808,
            1024: 268443648,
            1280: 2097152,
            1536: 2097160,
            1792: 268435456,
            2048: 0,
            2304: 268443656,
            2560: 2105344,
            2816: 8,
            3072: 270532616,
            3328: 2105352,
            3584: 8200,
            3840: 270540800,
            128: 270532608,
            384: 270540808,
            640: 8,
            896: 2097152,
            1152: 2105352,
            1408: 268435464,
            1664: 268443648,
            1920: 8200,
            2176: 2097160,
            2432: 8192,
            2688: 268443656,
            2944: 270532616,
            3200: 0,
            3456: 270540800,
            3712: 2105344,
            3968: 268435456,
            4096: 268443648,
            4352: 270532616,
            4608: 270540808,
            4864: 8200,
            5120: 2097152,
            5376: 268435456,
            5632: 268435464,
            5888: 2105344,
            6144: 2105352,
            6400: 0,
            6656: 8,
            6912: 270532608,
            7168: 8192,
            7424: 268443656,
            7680: 270540800,
            7936: 2097160,
            4224: 8,
            4480: 2105344,
            4736: 2097152,
            4992: 268435464,
            5248: 268443648,
            5504: 8200,
            5760: 270540808,
            6016: 270532608,
            6272: 270540800,
            6528: 270532616,
            6784: 8192,
            7040: 2105352,
            7296: 2097160,
            7552: 0,
            7808: 268435456,
            8064: 268443656
          },
          {
            0: 1048576,
            16: 33555457,
            32: 1024,
            48: 1049601,
            64: 34604033,
            80: 0,
            96: 1,
            112: 34603009,
            128: 33555456,
            144: 1048577,
            160: 33554433,
            176: 34604032,
            192: 34603008,
            208: 1025,
            224: 1049600,
            240: 33554432,
            8: 34603009,
            24: 0,
            40: 33555457,
            56: 34604032,
            72: 1048576,
            88: 33554433,
            104: 33554432,
            120: 1025,
            136: 1049601,
            152: 33555456,
            168: 34603008,
            184: 1048577,
            200: 1024,
            216: 34604033,
            232: 1,
            248: 1049600,
            256: 33554432,
            272: 1048576,
            288: 33555457,
            304: 34603009,
            320: 1048577,
            336: 33555456,
            352: 34604032,
            368: 1049601,
            384: 1025,
            400: 34604033,
            416: 1049600,
            432: 1,
            448: 0,
            464: 34603008,
            480: 33554433,
            496: 1024,
            264: 1049600,
            280: 33555457,
            296: 34603009,
            312: 1,
            328: 33554432,
            344: 1048576,
            360: 1025,
            376: 34604032,
            392: 33554433,
            408: 34603008,
            424: 0,
            440: 34604033,
            456: 1049601,
            472: 1024,
            488: 33555456,
            504: 1048577
          },
          {
            0: 134219808,
            1: 131072,
            2: 134217728,
            3: 32,
            4: 131104,
            5: 134350880,
            6: 134350848,
            7: 2048,
            8: 134348800,
            9: 134219776,
            10: 133120,
            11: 134348832,
            12: 2080,
            13: 0,
            14: 134217760,
            15: 133152,
            2147483648: 2048,
            2147483649: 134350880,
            2147483650: 134219808,
            2147483651: 134217728,
            2147483652: 134348800,
            2147483653: 133120,
            2147483654: 133152,
            2147483655: 32,
            2147483656: 134217760,
            2147483657: 2080,
            2147483658: 131104,
            2147483659: 134350848,
            2147483660: 0,
            2147483661: 134348832,
            2147483662: 134219776,
            2147483663: 131072,
            16: 133152,
            17: 134350848,
            18: 32,
            19: 2048,
            20: 134219776,
            21: 134217760,
            22: 134348832,
            23: 131072,
            24: 0,
            25: 131104,
            26: 134348800,
            27: 134219808,
            28: 134350880,
            29: 133120,
            30: 2080,
            31: 134217728,
            2147483664: 131072,
            2147483665: 2048,
            2147483666: 134348832,
            2147483667: 133152,
            2147483668: 32,
            2147483669: 134348800,
            2147483670: 134217728,
            2147483671: 134219808,
            2147483672: 134350880,
            2147483673: 134217760,
            2147483674: 134219776,
            2147483675: 0,
            2147483676: 133120,
            2147483677: 2080,
            2147483678: 131104,
            2147483679: 134350848
          }
        ];
        var SBOX_MASK = [
          4160749569,
          528482304,
          33030144,
          2064384,
          129024,
          8064,
          504,
          2147483679
        ];
        var DES = C_algo.DES = BlockCipher.extend({
          _doReset: function() {
            var key = this._key;
            var keyWords = key.words;
            var keyBits = [];
            for (var i = 0; i < 56; i++) {
              var keyBitPos = PC1[i] - 1;
              keyBits[i] = keyWords[keyBitPos >>> 5] >>> 31 - keyBitPos % 32 & 1;
            }
            var subKeys = this._subKeys = [];
            for (var nSubKey = 0; nSubKey < 16; nSubKey++) {
              var subKey = subKeys[nSubKey] = [];
              var bitShift = BIT_SHIFTS[nSubKey];
              for (var i = 0; i < 24; i++) {
                subKey[i / 6 | 0] |= keyBits[(PC2[i] - 1 + bitShift) % 28] << 31 - i % 6;
                subKey[4 + (i / 6 | 0)] |= keyBits[28 + (PC2[i + 24] - 1 + bitShift) % 28] << 31 - i % 6;
              }
              subKey[0] = subKey[0] << 1 | subKey[0] >>> 31;
              for (var i = 1; i < 7; i++) {
                subKey[i] = subKey[i] >>> (i - 1) * 4 + 3;
              }
              subKey[7] = subKey[7] << 5 | subKey[7] >>> 27;
            }
            var invSubKeys = this._invSubKeys = [];
            for (var i = 0; i < 16; i++) {
              invSubKeys[i] = subKeys[15 - i];
            }
          },
          encryptBlock: function(M, offset) {
            this._doCryptBlock(M, offset, this._subKeys);
          },
          decryptBlock: function(M, offset) {
            this._doCryptBlock(M, offset, this._invSubKeys);
          },
          _doCryptBlock: function(M, offset, subKeys) {
            this._lBlock = M[offset];
            this._rBlock = M[offset + 1];
            exchangeLR.call(this, 4, 252645135);
            exchangeLR.call(this, 16, 65535);
            exchangeRL.call(this, 2, 858993459);
            exchangeRL.call(this, 8, 16711935);
            exchangeLR.call(this, 1, 1431655765);
            for (var round = 0; round < 16; round++) {
              var subKey = subKeys[round];
              var lBlock = this._lBlock;
              var rBlock = this._rBlock;
              var f2 = 0;
              for (var i = 0; i < 8; i++) {
                f2 |= SBOX_P[i][((rBlock ^ subKey[i]) & SBOX_MASK[i]) >>> 0];
              }
              this._lBlock = rBlock;
              this._rBlock = lBlock ^ f2;
            }
            var t = this._lBlock;
            this._lBlock = this._rBlock;
            this._rBlock = t;
            exchangeLR.call(this, 1, 1431655765);
            exchangeRL.call(this, 8, 16711935);
            exchangeRL.call(this, 2, 858993459);
            exchangeLR.call(this, 16, 65535);
            exchangeLR.call(this, 4, 252645135);
            M[offset] = this._lBlock;
            M[offset + 1] = this._rBlock;
          },
          keySize: 64 / 32,
          ivSize: 64 / 32,
          blockSize: 64 / 32
        });
        function exchangeLR(offset, mask) {
          var t = (this._lBlock >>> offset ^ this._rBlock) & mask;
          this._rBlock ^= t;
          this._lBlock ^= t << offset;
        }
        function exchangeRL(offset, mask) {
          var t = (this._rBlock >>> offset ^ this._lBlock) & mask;
          this._lBlock ^= t;
          this._rBlock ^= t << offset;
        }
        C.DES = BlockCipher._createHelper(DES);
        var TripleDES = C_algo.TripleDES = BlockCipher.extend({
          _doReset: function() {
            var key = this._key;
            var keyWords = key.words;
            this._des1 = DES.createEncryptor(WordArray.create(keyWords.slice(0, 2)));
            this._des2 = DES.createEncryptor(WordArray.create(keyWords.slice(2, 4)));
            this._des3 = DES.createEncryptor(WordArray.create(keyWords.slice(4, 6)));
          },
          encryptBlock: function(M, offset) {
            this._des1.encryptBlock(M, offset);
            this._des2.decryptBlock(M, offset);
            this._des3.encryptBlock(M, offset);
          },
          decryptBlock: function(M, offset) {
            this._des3.decryptBlock(M, offset);
            this._des2.encryptBlock(M, offset);
            this._des1.decryptBlock(M, offset);
          },
          keySize: 192 / 32,
          ivSize: 64 / 32,
          blockSize: 64 / 32
        });
        C.TripleDES = BlockCipher._createHelper(TripleDES);
      })();
      return CryptoJS.TripleDES;
    });
  }
});

// node_modules/merkletreejs/node_modules/crypto-js/rc4.js
var require_rc4 = __commonJS({
  "node_modules/merkletreejs/node_modules/crypto-js/rc4.js"(exports, module) {
    init_shim();
    (function(root, factory, undef) {
      if (typeof exports === "object") {
        module.exports = exports = factory(require_core2(), require_enc_base64(), require_md5(), require_evpkdf(), require_cipher_core());
      } else if (typeof define === "function" && define.amd) {
        define(["./core", "./enc-base64", "./md5", "./evpkdf", "./cipher-core"], factory);
      } else {
        factory(root.CryptoJS);
      }
    })(exports, function(CryptoJS) {
      (function() {
        var C = CryptoJS;
        var C_lib = C.lib;
        var StreamCipher = C_lib.StreamCipher;
        var C_algo = C.algo;
        var RC4 = C_algo.RC4 = StreamCipher.extend({
          _doReset: function() {
            var key = this._key;
            var keyWords = key.words;
            var keySigBytes = key.sigBytes;
            var S = this._S = [];
            for (var i = 0; i < 256; i++) {
              S[i] = i;
            }
            for (var i = 0, j = 0; i < 256; i++) {
              var keyByteIndex = i % keySigBytes;
              var keyByte = keyWords[keyByteIndex >>> 2] >>> 24 - keyByteIndex % 4 * 8 & 255;
              j = (j + S[i] + keyByte) % 256;
              var t = S[i];
              S[i] = S[j];
              S[j] = t;
            }
            this._i = this._j = 0;
          },
          _doProcessBlock: function(M, offset) {
            M[offset] ^= generateKeystreamWord.call(this);
          },
          keySize: 256 / 32,
          ivSize: 0
        });
        function generateKeystreamWord() {
          var S = this._S;
          var i = this._i;
          var j = this._j;
          var keystreamWord = 0;
          for (var n = 0; n < 4; n++) {
            i = (i + 1) % 256;
            j = (j + S[i]) % 256;
            var t = S[i];
            S[i] = S[j];
            S[j] = t;
            keystreamWord |= S[(S[i] + S[j]) % 256] << 24 - n * 8;
          }
          this._i = i;
          this._j = j;
          return keystreamWord;
        }
        C.RC4 = StreamCipher._createHelper(RC4);
        var RC4Drop = C_algo.RC4Drop = RC4.extend({
          /**
           * Configuration options.
           *
           * @property {number} drop The number of keystream words to drop. Default 192
           */
          cfg: RC4.cfg.extend({
            drop: 192
          }),
          _doReset: function() {
            RC4._doReset.call(this);
            for (var i = this.cfg.drop; i > 0; i--) {
              generateKeystreamWord.call(this);
            }
          }
        });
        C.RC4Drop = StreamCipher._createHelper(RC4Drop);
      })();
      return CryptoJS.RC4;
    });
  }
});

// node_modules/merkletreejs/node_modules/crypto-js/rabbit.js
var require_rabbit = __commonJS({
  "node_modules/merkletreejs/node_modules/crypto-js/rabbit.js"(exports, module) {
    init_shim();
    (function(root, factory, undef) {
      if (typeof exports === "object") {
        module.exports = exports = factory(require_core2(), require_enc_base64(), require_md5(), require_evpkdf(), require_cipher_core());
      } else if (typeof define === "function" && define.amd) {
        define(["./core", "./enc-base64", "./md5", "./evpkdf", "./cipher-core"], factory);
      } else {
        factory(root.CryptoJS);
      }
    })(exports, function(CryptoJS) {
      (function() {
        var C = CryptoJS;
        var C_lib = C.lib;
        var StreamCipher = C_lib.StreamCipher;
        var C_algo = C.algo;
        var S = [];
        var C_ = [];
        var G = [];
        var Rabbit = C_algo.Rabbit = StreamCipher.extend({
          _doReset: function() {
            var K = this._key.words;
            var iv = this.cfg.iv;
            for (var i = 0; i < 4; i++) {
              K[i] = (K[i] << 8 | K[i] >>> 24) & 16711935 | (K[i] << 24 | K[i] >>> 8) & 4278255360;
            }
            var X = this._X = [
              K[0],
              K[3] << 16 | K[2] >>> 16,
              K[1],
              K[0] << 16 | K[3] >>> 16,
              K[2],
              K[1] << 16 | K[0] >>> 16,
              K[3],
              K[2] << 16 | K[1] >>> 16
            ];
            var C2 = this._C = [
              K[2] << 16 | K[2] >>> 16,
              K[0] & 4294901760 | K[1] & 65535,
              K[3] << 16 | K[3] >>> 16,
              K[1] & 4294901760 | K[2] & 65535,
              K[0] << 16 | K[0] >>> 16,
              K[2] & 4294901760 | K[3] & 65535,
              K[1] << 16 | K[1] >>> 16,
              K[3] & 4294901760 | K[0] & 65535
            ];
            this._b = 0;
            for (var i = 0; i < 4; i++) {
              nextState.call(this);
            }
            for (var i = 0; i < 8; i++) {
              C2[i] ^= X[i + 4 & 7];
            }
            if (iv) {
              var IV = iv.words;
              var IV_0 = IV[0];
              var IV_1 = IV[1];
              var i0 = (IV_0 << 8 | IV_0 >>> 24) & 16711935 | (IV_0 << 24 | IV_0 >>> 8) & 4278255360;
              var i2 = (IV_1 << 8 | IV_1 >>> 24) & 16711935 | (IV_1 << 24 | IV_1 >>> 8) & 4278255360;
              var i1 = i0 >>> 16 | i2 & 4294901760;
              var i3 = i2 << 16 | i0 & 65535;
              C2[0] ^= i0;
              C2[1] ^= i1;
              C2[2] ^= i2;
              C2[3] ^= i3;
              C2[4] ^= i0;
              C2[5] ^= i1;
              C2[6] ^= i2;
              C2[7] ^= i3;
              for (var i = 0; i < 4; i++) {
                nextState.call(this);
              }
            }
          },
          _doProcessBlock: function(M, offset) {
            var X = this._X;
            nextState.call(this);
            S[0] = X[0] ^ X[5] >>> 16 ^ X[3] << 16;
            S[1] = X[2] ^ X[7] >>> 16 ^ X[5] << 16;
            S[2] = X[4] ^ X[1] >>> 16 ^ X[7] << 16;
            S[3] = X[6] ^ X[3] >>> 16 ^ X[1] << 16;
            for (var i = 0; i < 4; i++) {
              S[i] = (S[i] << 8 | S[i] >>> 24) & 16711935 | (S[i] << 24 | S[i] >>> 8) & 4278255360;
              M[offset + i] ^= S[i];
            }
          },
          blockSize: 128 / 32,
          ivSize: 64 / 32
        });
        function nextState() {
          var X = this._X;
          var C2 = this._C;
          for (var i = 0; i < 8; i++) {
            C_[i] = C2[i];
          }
          C2[0] = C2[0] + 1295307597 + this._b | 0;
          C2[1] = C2[1] + 3545052371 + (C2[0] >>> 0 < C_[0] >>> 0 ? 1 : 0) | 0;
          C2[2] = C2[2] + 886263092 + (C2[1] >>> 0 < C_[1] >>> 0 ? 1 : 0) | 0;
          C2[3] = C2[3] + 1295307597 + (C2[2] >>> 0 < C_[2] >>> 0 ? 1 : 0) | 0;
          C2[4] = C2[4] + 3545052371 + (C2[3] >>> 0 < C_[3] >>> 0 ? 1 : 0) | 0;
          C2[5] = C2[5] + 886263092 + (C2[4] >>> 0 < C_[4] >>> 0 ? 1 : 0) | 0;
          C2[6] = C2[6] + 1295307597 + (C2[5] >>> 0 < C_[5] >>> 0 ? 1 : 0) | 0;
          C2[7] = C2[7] + 3545052371 + (C2[6] >>> 0 < C_[6] >>> 0 ? 1 : 0) | 0;
          this._b = C2[7] >>> 0 < C_[7] >>> 0 ? 1 : 0;
          for (var i = 0; i < 8; i++) {
            var gx = X[i] + C2[i];
            var ga = gx & 65535;
            var gb = gx >>> 16;
            var gh = ((ga * ga >>> 17) + ga * gb >>> 15) + gb * gb;
            var gl = ((gx & 4294901760) * gx | 0) + ((gx & 65535) * gx | 0);
            G[i] = gh ^ gl;
          }
          X[0] = G[0] + (G[7] << 16 | G[7] >>> 16) + (G[6] << 16 | G[6] >>> 16) | 0;
          X[1] = G[1] + (G[0] << 8 | G[0] >>> 24) + G[7] | 0;
          X[2] = G[2] + (G[1] << 16 | G[1] >>> 16) + (G[0] << 16 | G[0] >>> 16) | 0;
          X[3] = G[3] + (G[2] << 8 | G[2] >>> 24) + G[1] | 0;
          X[4] = G[4] + (G[3] << 16 | G[3] >>> 16) + (G[2] << 16 | G[2] >>> 16) | 0;
          X[5] = G[5] + (G[4] << 8 | G[4] >>> 24) + G[3] | 0;
          X[6] = G[6] + (G[5] << 16 | G[5] >>> 16) + (G[4] << 16 | G[4] >>> 16) | 0;
          X[7] = G[7] + (G[6] << 8 | G[6] >>> 24) + G[5] | 0;
        }
        C.Rabbit = StreamCipher._createHelper(Rabbit);
      })();
      return CryptoJS.Rabbit;
    });
  }
});

// node_modules/merkletreejs/node_modules/crypto-js/rabbit-legacy.js
var require_rabbit_legacy = __commonJS({
  "node_modules/merkletreejs/node_modules/crypto-js/rabbit-legacy.js"(exports, module) {
    init_shim();
    (function(root, factory, undef) {
      if (typeof exports === "object") {
        module.exports = exports = factory(require_core2(), require_enc_base64(), require_md5(), require_evpkdf(), require_cipher_core());
      } else if (typeof define === "function" && define.amd) {
        define(["./core", "./enc-base64", "./md5", "./evpkdf", "./cipher-core"], factory);
      } else {
        factory(root.CryptoJS);
      }
    })(exports, function(CryptoJS) {
      (function() {
        var C = CryptoJS;
        var C_lib = C.lib;
        var StreamCipher = C_lib.StreamCipher;
        var C_algo = C.algo;
        var S = [];
        var C_ = [];
        var G = [];
        var RabbitLegacy = C_algo.RabbitLegacy = StreamCipher.extend({
          _doReset: function() {
            var K = this._key.words;
            var iv = this.cfg.iv;
            var X = this._X = [
              K[0],
              K[3] << 16 | K[2] >>> 16,
              K[1],
              K[0] << 16 | K[3] >>> 16,
              K[2],
              K[1] << 16 | K[0] >>> 16,
              K[3],
              K[2] << 16 | K[1] >>> 16
            ];
            var C2 = this._C = [
              K[2] << 16 | K[2] >>> 16,
              K[0] & 4294901760 | K[1] & 65535,
              K[3] << 16 | K[3] >>> 16,
              K[1] & 4294901760 | K[2] & 65535,
              K[0] << 16 | K[0] >>> 16,
              K[2] & 4294901760 | K[3] & 65535,
              K[1] << 16 | K[1] >>> 16,
              K[3] & 4294901760 | K[0] & 65535
            ];
            this._b = 0;
            for (var i = 0; i < 4; i++) {
              nextState.call(this);
            }
            for (var i = 0; i < 8; i++) {
              C2[i] ^= X[i + 4 & 7];
            }
            if (iv) {
              var IV = iv.words;
              var IV_0 = IV[0];
              var IV_1 = IV[1];
              var i0 = (IV_0 << 8 | IV_0 >>> 24) & 16711935 | (IV_0 << 24 | IV_0 >>> 8) & 4278255360;
              var i2 = (IV_1 << 8 | IV_1 >>> 24) & 16711935 | (IV_1 << 24 | IV_1 >>> 8) & 4278255360;
              var i1 = i0 >>> 16 | i2 & 4294901760;
              var i3 = i2 << 16 | i0 & 65535;
              C2[0] ^= i0;
              C2[1] ^= i1;
              C2[2] ^= i2;
              C2[3] ^= i3;
              C2[4] ^= i0;
              C2[5] ^= i1;
              C2[6] ^= i2;
              C2[7] ^= i3;
              for (var i = 0; i < 4; i++) {
                nextState.call(this);
              }
            }
          },
          _doProcessBlock: function(M, offset) {
            var X = this._X;
            nextState.call(this);
            S[0] = X[0] ^ X[5] >>> 16 ^ X[3] << 16;
            S[1] = X[2] ^ X[7] >>> 16 ^ X[5] << 16;
            S[2] = X[4] ^ X[1] >>> 16 ^ X[7] << 16;
            S[3] = X[6] ^ X[3] >>> 16 ^ X[1] << 16;
            for (var i = 0; i < 4; i++) {
              S[i] = (S[i] << 8 | S[i] >>> 24) & 16711935 | (S[i] << 24 | S[i] >>> 8) & 4278255360;
              M[offset + i] ^= S[i];
            }
          },
          blockSize: 128 / 32,
          ivSize: 64 / 32
        });
        function nextState() {
          var X = this._X;
          var C2 = this._C;
          for (var i = 0; i < 8; i++) {
            C_[i] = C2[i];
          }
          C2[0] = C2[0] + 1295307597 + this._b | 0;
          C2[1] = C2[1] + 3545052371 + (C2[0] >>> 0 < C_[0] >>> 0 ? 1 : 0) | 0;
          C2[2] = C2[2] + 886263092 + (C2[1] >>> 0 < C_[1] >>> 0 ? 1 : 0) | 0;
          C2[3] = C2[3] + 1295307597 + (C2[2] >>> 0 < C_[2] >>> 0 ? 1 : 0) | 0;
          C2[4] = C2[4] + 3545052371 + (C2[3] >>> 0 < C_[3] >>> 0 ? 1 : 0) | 0;
          C2[5] = C2[5] + 886263092 + (C2[4] >>> 0 < C_[4] >>> 0 ? 1 : 0) | 0;
          C2[6] = C2[6] + 1295307597 + (C2[5] >>> 0 < C_[5] >>> 0 ? 1 : 0) | 0;
          C2[7] = C2[7] + 3545052371 + (C2[6] >>> 0 < C_[6] >>> 0 ? 1 : 0) | 0;
          this._b = C2[7] >>> 0 < C_[7] >>> 0 ? 1 : 0;
          for (var i = 0; i < 8; i++) {
            var gx = X[i] + C2[i];
            var ga = gx & 65535;
            var gb = gx >>> 16;
            var gh = ((ga * ga >>> 17) + ga * gb >>> 15) + gb * gb;
            var gl = ((gx & 4294901760) * gx | 0) + ((gx & 65535) * gx | 0);
            G[i] = gh ^ gl;
          }
          X[0] = G[0] + (G[7] << 16 | G[7] >>> 16) + (G[6] << 16 | G[6] >>> 16) | 0;
          X[1] = G[1] + (G[0] << 8 | G[0] >>> 24) + G[7] | 0;
          X[2] = G[2] + (G[1] << 16 | G[1] >>> 16) + (G[0] << 16 | G[0] >>> 16) | 0;
          X[3] = G[3] + (G[2] << 8 | G[2] >>> 24) + G[1] | 0;
          X[4] = G[4] + (G[3] << 16 | G[3] >>> 16) + (G[2] << 16 | G[2] >>> 16) | 0;
          X[5] = G[5] + (G[4] << 8 | G[4] >>> 24) + G[3] | 0;
          X[6] = G[6] + (G[5] << 16 | G[5] >>> 16) + (G[4] << 16 | G[4] >>> 16) | 0;
          X[7] = G[7] + (G[6] << 8 | G[6] >>> 24) + G[5] | 0;
        }
        C.RabbitLegacy = StreamCipher._createHelper(RabbitLegacy);
      })();
      return CryptoJS.RabbitLegacy;
    });
  }
});

// node_modules/merkletreejs/node_modules/crypto-js/index.js
var require_crypto_js = __commonJS({
  "node_modules/merkletreejs/node_modules/crypto-js/index.js"(exports, module) {
    init_shim();
    (function(root, factory, undef) {
      if (typeof exports === "object") {
        module.exports = exports = factory(require_core2(), require_x64_core(), require_lib_typedarrays(), require_enc_utf16(), require_enc_base64(), require_md5(), require_sha1(), require_sha256(), require_sha224(), require_sha512(), require_sha384(), require_sha3(), require_ripemd160(), require_hmac(), require_pbkdf2(), require_evpkdf(), require_cipher_core(), require_mode_cfb(), require_mode_ctr(), require_mode_ctr_gladman(), require_mode_ofb(), require_mode_ecb(), require_pad_ansix923(), require_pad_iso10126(), require_pad_iso97971(), require_pad_zeropadding(), require_pad_nopadding(), require_format_hex(), require_aes(), require_tripledes(), require_rc4(), require_rabbit(), require_rabbit_legacy());
      } else if (typeof define === "function" && define.amd) {
        define(["./core", "./x64-core", "./lib-typedarrays", "./enc-utf16", "./enc-base64", "./md5", "./sha1", "./sha256", "./sha224", "./sha512", "./sha384", "./sha3", "./ripemd160", "./hmac", "./pbkdf2", "./evpkdf", "./cipher-core", "./mode-cfb", "./mode-ctr", "./mode-ctr-gladman", "./mode-ofb", "./mode-ecb", "./pad-ansix923", "./pad-iso10126", "./pad-iso97971", "./pad-zeropadding", "./pad-nopadding", "./format-hex", "./aes", "./tripledes", "./rc4", "./rabbit", "./rabbit-legacy"], factory);
      } else {
        root.CryptoJS = factory(root.CryptoJS);
      }
    })(exports, function(CryptoJS) {
      return CryptoJS;
    });
  }
});

// node_modules/merkletreejs/dist/Base.js
var require_Base = __commonJS({
  "node_modules/merkletreejs/dist/Base.js"(exports) {
    "use strict";
    init_shim();
    var __importDefault = exports && exports.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.Base = void 0;
    var buffer_1 = require_buffer();
    var crypto_js_1 = __importDefault(require_crypto_js());
    var Base = class _Base {
      /**
       * print
       * @desc Prints out a visual representation of the merkle tree.
       * @example
       *```js
       *tree.print()
       *```
       */
      print() {
        _Base.print(this);
      }
      /**
       * bufferIndexOf
       * @desc Returns the first index of which given buffer is found in array.
       * @param {Buffer[]} haystack - Array of buffers.
       * @param {Buffer} needle - Buffer to find.
       * @return {Number} - Index number
       *
       * @example
       * ```js
       *const index = tree.bufferIndexOf(haystack, needle)
       *```
       */
      _bufferIndexOf(array, element) {
        for (let i = 0; i < array.length; i++) {
          if (element.equals(array[i])) {
            return i;
          }
        }
        return -1;
      }
      /**
       * bufferify
       * @desc Returns a buffer type for the given value.
       * @param {String|Number|Object|Buffer|ArrayBuffer} value
       * @return {Buffer}
       *
       * @example
       * ```js
       *const buf = MerkleTree.bufferify('0x1234')
       *```
       */
      static bufferify(value) {
        if (!buffer_1.Buffer.isBuffer(value)) {
          if (typeof value === "object" && value.words) {
            return buffer_1.Buffer.from(value.toString(crypto_js_1.default.enc.Hex), "hex");
          } else if (_Base.isHexString(value)) {
            return buffer_1.Buffer.from(value.replace(/^0x/, ""), "hex");
          } else if (typeof value === "string") {
            return buffer_1.Buffer.from(value);
          } else if (typeof value === "number") {
            let s = value.toString();
            if (s.length % 2) {
              s = `0${s}`;
            }
            return buffer_1.Buffer.from(s, "hex");
          } else if (ArrayBuffer.isView(value)) {
            return buffer_1.Buffer.from(value.buffer, value.byteOffset, value.byteLength);
          }
        }
        return value;
      }
      /**
       * isHexString
       * @desc Returns true if value is a hex string.
       * @param {String} value
       * @return {Boolean}
       *
       * @example
       * ```js
       *console.log(MerkleTree.isHexString('0x1234'))
       *```
       */
      static isHexString(v) {
        return typeof v === "string" && /^(0x)?[0-9A-Fa-f]*$/.test(v);
      }
      /**
       * print
       * @desc Prints out a visual representation of the given merkle tree.
       * @param {Object} tree - Merkle tree instance.
       * @return {String}
       * @example
       *```js
       *MerkleTree.print(tree)
       *```
       */
      static print(tree) {
        console.log(tree.toString());
      }
      /**
       * bufferToHex
       * @desc Returns a hex string with 0x prefix for given buffer.
       * @param {Buffer} value
       * @return {String}
       * @example
       *```js
       *const hexStr = tree.bufferToHex(Buffer.from('A'))
       *```
       */
      bufferToHex(value, withPrefix = true) {
        return _Base.bufferToHex(value, withPrefix);
      }
      /**
       * bufferToHex
       * @desc Returns a hex string with 0x prefix for given buffer.
       * @param {Buffer} value
       * @return {String}
       * @example
       *```js
       *const hexStr = MerkleTree.bufferToHex(Buffer.from('A'))
       *```
       */
      static bufferToHex(value, withPrefix = true) {
        return `${withPrefix ? "0x" : ""}${(value || buffer_1.Buffer.alloc(0)).toString("hex")}`;
      }
      /**
       * bufferify
       * @desc Returns a buffer type for the given value.
       * @param {String|Number|Object|Buffer} value
       * @return {Buffer}
       *
       * @example
       * ```js
       *const buf = tree.bufferify('0x1234')
       *```
       */
      bufferify(value) {
        return _Base.bufferify(value);
      }
      /**
       * bufferifyFn
       * @desc Returns a function that will bufferify the return value.
       * @param {Function}
       * @return {Function}
       *
       * @example
       * ```js
       *const fn = tree.bufferifyFn((value) => sha256(value))
       *```
       */
      bufferifyFn(f2) {
        return (value) => {
          const v = f2(value);
          if (buffer_1.Buffer.isBuffer(v)) {
            return v;
          }
          if (this._isHexString(v)) {
            return buffer_1.Buffer.from(v.replace("0x", ""), "hex");
          }
          if (typeof v === "string") {
            return buffer_1.Buffer.from(v);
          }
          if (ArrayBuffer.isView(v)) {
            return buffer_1.Buffer.from(v.buffer, v.byteOffset, v.byteLength);
          }
          return buffer_1.Buffer.from(f2(crypto_js_1.default.enc.Hex.parse(value.toString("hex"))).toString(crypto_js_1.default.enc.Hex), "hex");
        };
      }
      /**
       * isHexString
       * @desc Returns true if value is a hex string.
       * @param {String} value
       * @return {Boolean}
       *
       * @example
       * ```js
       *console.log(MerkleTree.isHexString('0x1234'))
       *```
       */
      _isHexString(value) {
        return _Base.isHexString(value);
      }
      /**
       * log2
       * @desc Returns the log2 of number.
       * @param {Number} value
       * @return {Number}
       */
      _log2(n) {
        return n === 1 ? 0 : 1 + this._log2(n / 2 | 0);
      }
      /**
       * zip
       * @desc Returns true if value is a hex string.
       * @param {String[]|Number[]|Buffer[]} a - first array
       * @param {String[]|Number[]|Buffer[]} b -  second array
       * @return {String[][]|Number[][]|Buffer[][]}
       *
       * @example
       * ```js
       *const zipped = tree.zip(['a', 'b'],['A', 'B'])
       *console.log(zipped) // [ [ 'a', 'A' ], [ 'b', 'B' ] ]
       *```
       */
      _zip(a, b) {
        return a.map((e, i) => [e, b[i]]);
      }
    };
    exports.Base = Base;
    exports.default = Base;
  }
});

// node_modules/merkletreejs/dist/MerkleTree.js
var require_MerkleTree = __commonJS({
  "node_modules/merkletreejs/dist/MerkleTree.js"(exports) {
    "use strict";
    init_shim();
    var __importDefault = exports && exports.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.MerkleTree = void 0;
    var buffer_1 = require_buffer();
    var buffer_reverse_1 = __importDefault(require_buffer_reverse());
    var sha256_1 = __importDefault(require_sha256());
    var treeify_1 = __importDefault(require_treeify());
    var Base_1 = __importDefault(require_Base());
    var MerkleTree2 = class _MerkleTree extends Base_1.default {
      /**
       * @desc Constructs a Merkle Tree.
       * All nodes and leaves are stored as Buffers.
       * Lonely leaf nodes are promoted to the next level up without being hashed again.
       * @param {Buffer[]} leaves - Array of hashed leaves. Each leaf must be a Buffer.
       * @param {Function} hashFunction - Hash function to use for hashing leaves and nodes
       * @param {Object} options - Additional options
       * @example
       *```js
       *const MerkleTree = require('merkletreejs')
       *const crypto = require('crypto')
       *
       *function sha256(data) {
       *  // returns Buffer
       *  return crypto.createHash('sha256').update(data).digest()
       *}
       *
       *const leaves = ['a', 'b', 'c'].map(value => keccak(value))
       *
       *const tree = new MerkleTree(leaves, sha256)
       *```
       */
      constructor(leaves, hashFn = sha256_1.default, options = {}) {
        super();
        this.duplicateOdd = false;
        this.hashLeaves = false;
        this.isBitcoinTree = false;
        this.leaves = [];
        this.layers = [];
        this.sortLeaves = false;
        this.sortPairs = false;
        this.sort = false;
        this.fillDefaultHash = null;
        this.isBitcoinTree = !!options.isBitcoinTree;
        this.hashLeaves = !!options.hashLeaves;
        this.sortLeaves = !!options.sortLeaves;
        this.sortPairs = !!options.sortPairs;
        if (options.fillDefaultHash) {
          if (typeof options.fillDefaultHash === "function") {
            this.fillDefaultHash = options.fillDefaultHash;
          } else if (buffer_1.Buffer.isBuffer(options.fillDefaultHash) || typeof options.fillDefaultHash === "string") {
            this.fillDefaultHash = (idx, hashFn2) => options.fillDefaultHash;
          } else {
            throw new Error('method "fillDefaultHash" must be a function, Buffer, or string');
          }
        }
        this.sort = !!options.sort;
        if (this.sort) {
          this.sortLeaves = true;
          this.sortPairs = true;
        }
        this.duplicateOdd = !!options.duplicateOdd;
        this.hashFn = this.bufferifyFn(hashFn);
        this.processLeaves(leaves);
      }
      processLeaves(leaves) {
        if (this.hashLeaves) {
          leaves = leaves.map(this.hashFn);
        }
        this.leaves = leaves.map(this.bufferify);
        if (this.sortLeaves) {
          this.leaves = this.leaves.sort(buffer_1.Buffer.compare);
        }
        if (this.fillDefaultHash) {
          for (let i = 0; i < Math.pow(2, Math.ceil(Math.log2(this.leaves.length))); i++) {
            if (i >= this.leaves.length) {
              this.leaves.push(this.bufferify(this.fillDefaultHash(i, this.hashFn)));
            }
          }
        }
        this.layers = [this.leaves];
        this._createHashes(this.leaves);
      }
      _createHashes(nodes) {
        while (nodes.length > 1) {
          const layerIndex = this.layers.length;
          this.layers.push([]);
          for (let i = 0; i < nodes.length; i += 2) {
            if (i + 1 === nodes.length) {
              if (nodes.length % 2 === 1) {
                let data2 = nodes[nodes.length - 1];
                let hash2 = data2;
                if (this.isBitcoinTree) {
                  data2 = buffer_1.Buffer.concat([buffer_reverse_1.default(data2), buffer_reverse_1.default(data2)]);
                  hash2 = this.hashFn(data2);
                  hash2 = buffer_reverse_1.default(this.hashFn(hash2));
                  this.layers[layerIndex].push(hash2);
                  continue;
                } else {
                  if (this.duplicateOdd) {
                  } else {
                    this.layers[layerIndex].push(nodes[i]);
                    continue;
                  }
                }
              }
            }
            const left = nodes[i];
            const right = i + 1 === nodes.length ? left : nodes[i + 1];
            let data = null;
            let combined = null;
            if (this.isBitcoinTree) {
              combined = [buffer_reverse_1.default(left), buffer_reverse_1.default(right)];
            } else {
              combined = [left, right];
            }
            if (this.sortPairs) {
              combined.sort(buffer_1.Buffer.compare);
            }
            data = buffer_1.Buffer.concat(combined);
            let hash = this.hashFn(data);
            if (this.isBitcoinTree) {
              hash = buffer_reverse_1.default(this.hashFn(hash));
            }
            this.layers[layerIndex].push(hash);
          }
          nodes = this.layers[layerIndex];
        }
      }
      /**
       * addLeaf
       * @desc Adds a leaf to the tree and re-calculates layers.
       * @param {String|Buffer} - Leaf
       * @param {Boolean} - Set to true if the leaf should be hashed before being added to tree.
       * @example
       *```js
       *tree.addLeaf(newLeaf)
       *```
       */
      addLeaf(leaf, shouldHash = false) {
        if (shouldHash) {
          leaf = this.hashFn(leaf);
        }
        this.processLeaves(this.leaves.concat(leaf));
      }
      /**
       * addLeaves
       * @desc Adds multiple leaves to the tree and re-calculates layers.
       * @param {String[]|Buffer[]} - Array of leaves
       * @param {Boolean} - Set to true if the leaves should be hashed before being added to tree.
       * @example
       *```js
       *tree.addLeaves(newLeaves)
       *```
       */
      addLeaves(leaves, shouldHash = false) {
        if (shouldHash) {
          leaves = leaves.map(this.hashFn);
        }
        this.processLeaves(this.leaves.concat(leaves));
      }
      /**
       * getLeaves
       * @desc Returns array of leaves of Merkle Tree.
       * @return {Buffer[]}
       * @example
       *```js
       *const leaves = tree.getLeaves()
       *```
       */
      getLeaves(values) {
        if (Array.isArray(values)) {
          if (this.hashLeaves) {
            values = values.map(this.hashFn);
            if (this.sortLeaves) {
              values = values.sort(buffer_1.Buffer.compare);
            }
          }
          return this.leaves.filter((leaf) => this._bufferIndexOf(values, leaf) !== -1);
        }
        return this.leaves;
      }
      /**
       * getLeaf
       * @desc Returns the leaf at the given index.
       * @param {Number} - Index number
       * @return {Buffer}
       * @example
       *```js
       *const leaf = tree.getLeaf(1)
       *```
       */
      getLeaf(index) {
        if (index < 0 || index > this.leaves.length - 1) {
          return buffer_1.Buffer.from([]);
        }
        return this.leaves[index];
      }
      /**
       * getLeafIndex
       * @desc Returns the index of the given leaf, or -1 if the leaf is not found.
       * @param {String|Buffer} - Target leaf
       * @return {number}
       * @example
       *```js
       *const leaf = Buffer.from('abc')
       *const index = tree.getLeafIndex(leaf)
       *```
       */
      getLeafIndex(target) {
        target = this.bufferify(target);
        const leaves = this.getLeaves();
        for (let i = 0; i < leaves.length; i++) {
          const leaf = leaves[i];
          if (leaf.equals(target)) {
            return i;
          }
        }
        return -1;
      }
      /**
       * getLeafCount
       * @desc Returns the total number of leaves.
       * @return {number}
       * @example
       *```js
       *const count = tree.getLeafCount()
       *```
       */
      getLeafCount() {
        return this.leaves.length;
      }
      /**
       * getHexLeaves
       * @desc Returns array of leaves of Merkle Tree as hex strings.
       * @return {String[]}
       * @example
       *```js
       *const leaves = tree.getHexLeaves()
       *```
       */
      getHexLeaves() {
        return this.leaves.map((leaf) => this.bufferToHex(leaf));
      }
      /**
       * marshalLeaves
       * @desc Returns array of leaves of Merkle Tree as a JSON string.
       * @param {String[]|Buffer[]} - Merkle tree leaves
       * @return {String} - List of leaves as JSON string
       * @example
       *```js
       *const jsonStr = MerkleTree.marshalLeaves(leaves)
       *```
       */
      static marshalLeaves(leaves) {
        return JSON.stringify(leaves.map((leaf) => _MerkleTree.bufferToHex(leaf)), null, 2);
      }
      /**
       * unmarshalLeaves
       * @desc Returns array of leaves of Merkle Tree as a Buffers.
       * @param {String|Object} - JSON stringified leaves
       * @return {Buffer[]} - Unmarshalled list of leaves
       * @example
       *```js
       *const leaves = MerkleTree.unmarshalLeaves(jsonStr)
       *```
       */
      static unmarshalLeaves(jsonStr) {
        let parsed = null;
        if (typeof jsonStr === "string") {
          parsed = JSON.parse(jsonStr);
        } else if (jsonStr instanceof Object) {
          parsed = jsonStr;
        } else {
          throw new Error("Expected type of string or object");
        }
        if (!parsed) {
          return [];
        }
        if (!Array.isArray(parsed)) {
          throw new Error("Expected JSON string to be array");
        }
        return parsed.map(_MerkleTree.bufferify);
      }
      /**
       * getLayers
       * @desc Returns multi-dimensional array of all layers of Merkle Tree, including leaves and root.
       * @return {Buffer[]}
       * @example
       *```js
       *const layers = tree.getLayers()
       *```
       */
      getLayers() {
        return this.layers;
      }
      /**
       * getHexLayers
       * @desc Returns multi-dimensional array of all layers of Merkle Tree, including leaves and root as hex strings.
       * @return {String[]}
       * @example
       *```js
       *const layers = tree.getHexLayers()
       *```
       */
      getHexLayers() {
        return this.layers.reduce((acc, item) => {
          if (Array.isArray(item)) {
            acc.push(item.map((layer) => this.bufferToHex(layer)));
          } else {
            acc.push(item);
          }
          return acc;
        }, []);
      }
      /**
       * getLayersFlat
       * @desc Returns single flat array of all layers of Merkle Tree, including leaves and root.
       * @return {Buffer[]}
       * @example
       *```js
       *const layers = tree.getLayersFlat()
       *```
       */
      getLayersFlat() {
        const layers = this.layers.reduce((acc, item) => {
          if (Array.isArray(item)) {
            acc.unshift(...item);
          } else {
            acc.unshift(item);
          }
          return acc;
        }, []);
        layers.unshift(buffer_1.Buffer.from([0]));
        return layers;
      }
      /**
       * getHexLayersFlat
       * @desc Returns single flat array of all layers of Merkle Tree, including leaves and root as hex string.
       * @return {String[]}
       * @example
       *```js
       *const layers = tree.getHexLayersFlat()
       *```
       */
      getHexLayersFlat() {
        return this.getLayersFlat().map((layer) => this.bufferToHex(layer));
      }
      /**
       * getLayerCount
       * @desc Returns the total number of layers.
       * @return {number}
       * @example
       *```js
       *const count = tree.getLayerCount()
       *```
       */
      getLayerCount() {
        return this.getLayers().length;
      }
      /**
       * getRoot
       * @desc Returns the Merkle root hash as a Buffer.
       * @return {Buffer}
       * @example
       *```js
       *const root = tree.getRoot()
       *```
       */
      getRoot() {
        if (this.layers.length === 0) {
          return buffer_1.Buffer.from([]);
        }
        return this.layers[this.layers.length - 1][0] || buffer_1.Buffer.from([]);
      }
      /**
       * getHexRoot
       * @desc Returns the Merkle root hash as a hex string.
       * @return {String}
       * @example
       *```js
       *const root = tree.getHexRoot()
       *```
       */
      getHexRoot() {
        return this.bufferToHex(this.getRoot());
      }
      /**
       * getProof
       * @desc Returns the proof for a target leaf.
       * @param {Buffer} leaf - Target leaf
       * @param {Number} [index] - Target leaf index in leaves array.
       * Use if there are leaves containing duplicate data in order to distinguish it.
       * @return {Object[]} - Array of objects containing a position property of type string
       * with values of 'left' or 'right' and a data property of type Buffer.
       * @example
       * ```js
       *const proof = tree.getProof(leaves[2])
       *```
       *
       * @example
       *```js
       *const leaves = ['a', 'b', 'a'].map(value => keccak(value))
       *const tree = new MerkleTree(leaves, keccak)
       *const proof = tree.getProof(leaves[2], 2)
       *```
       */
      getProof(leaf, index) {
        if (typeof leaf === "undefined") {
          throw new Error("leaf is required");
        }
        leaf = this.bufferify(leaf);
        const proof = [];
        if (!Number.isInteger(index)) {
          index = -1;
          for (let i = 0; i < this.leaves.length; i++) {
            if (buffer_1.Buffer.compare(leaf, this.leaves[i]) === 0) {
              index = i;
            }
          }
        }
        if (index <= -1) {
          return [];
        }
        for (let i = 0; i < this.layers.length; i++) {
          const layer = this.layers[i];
          const isRightNode = index % 2;
          const pairIndex = isRightNode ? index - 1 : this.isBitcoinTree && index === layer.length - 1 && i < this.layers.length - 1 ? index : index + 1;
          if (pairIndex < layer.length) {
            proof.push({
              position: isRightNode ? "left" : "right",
              data: layer[pairIndex]
            });
          }
          index = index / 2 | 0;
        }
        return proof;
      }
      /**
       * getHexProof
       * @desc Returns the proof for a target leaf as hex strings.
       * @param {Buffer} leaf - Target leaf
       * @param {Number} [index] - Target leaf index in leaves array.
       * Use if there are leaves containing duplicate data in order to distinguish it.
       * @return {String[]} - Proof array as hex strings.
       * @example
       * ```js
       *const proof = tree.getHexProof(leaves[2])
       *```
       */
      getHexProof(leaf, index) {
        return this.getProof(leaf, index).map((item) => this.bufferToHex(item.data));
      }
      /**
      * getPositionalHexProof
      * @desc Returns the proof for a target leaf as hex strings and the position in binary (left == 0).
      * @param {Buffer} leaf - Target leaf
      * @param {Number} [index] - Target leaf index in leaves array.
      * Use if there are leaves containing duplicate data in order to distinguish it.
      * @return {(string | number)[][]} - Proof array as hex strings. position at index 0
      * @example
      * ```js
      *const proof = tree.getPositionalHexProof(leaves[2])
      *```
      */
      getPositionalHexProof(leaf, index) {
        return this.getProof(leaf, index).map((item) => {
          return [
            item.position === "left" ? 0 : 1,
            this.bufferToHex(item.data)
          ];
        });
      }
      /**
       * marshalProof
       * @desc Returns proof array as JSON string.
       * @param {String[]|Object[]} proof - Merkle tree proof array
       * @return {String} - Proof array as JSON string.
       * @example
       * ```js
       *const jsonStr = MerkleTree.marshalProof(proof)
       *```
       */
      static marshalProof(proof) {
        const json = proof.map((item) => {
          if (typeof item === "string") {
            return item;
          }
          if (buffer_1.Buffer.isBuffer(item)) {
            return _MerkleTree.bufferToHex(item);
          }
          return {
            position: item.position,
            data: _MerkleTree.bufferToHex(item.data)
          };
        });
        return JSON.stringify(json, null, 2);
      }
      /**
       * unmarshalProof
       * @desc Returns the proof for a target leaf as a list of Buffers.
       * @param {String|Object} - Merkle tree leaves
       * @return {String|Object} - Marshalled proof
       * @example
       * ```js
       *const proof = MerkleTree.unmarshalProof(jsonStr)
       *```
       */
      static unmarshalProof(jsonStr) {
        let parsed = null;
        if (typeof jsonStr === "string") {
          parsed = JSON.parse(jsonStr);
        } else if (jsonStr instanceof Object) {
          parsed = jsonStr;
        } else {
          throw new Error("Expected type of string or object");
        }
        if (!parsed) {
          return [];
        }
        if (!Array.isArray(parsed)) {
          throw new Error("Expected JSON string to be array");
        }
        return parsed.map((item) => {
          if (typeof item === "string") {
            return _MerkleTree.bufferify(item);
          } else if (item instanceof Object) {
            return {
              position: item.position,
              data: _MerkleTree.bufferify(item.data)
            };
          } else {
            throw new Error("Expected item to be of type string or object");
          }
        });
      }
      /**
       * getProofIndices
       * @desc Returns the proof indices for given tree indices.
       * @param {Number[]} treeIndices - Tree indices
       * @param {Number} depth - Tree depth; number of layers.
       * @return {Number[]} - Proof indices
       * @example
       * ```js
       *const proofIndices = tree.getProofIndices([2,5,6], 4)
       *console.log(proofIndices) // [ 23, 20, 19, 8, 3 ]
       *```
       */
      getProofIndices(treeIndices, depth) {
        const leafCount = Math.pow(2, depth);
        let maximalIndices = /* @__PURE__ */ new Set();
        for (const index of treeIndices) {
          let x = leafCount + index;
          while (x > 1) {
            maximalIndices.add(x ^ 1);
            x = x / 2 | 0;
          }
        }
        const a = treeIndices.map((index) => leafCount + index);
        const b = Array.from(maximalIndices).sort((a2, b2) => a2 - b2).reverse();
        maximalIndices = a.concat(b);
        const redundantIndices = /* @__PURE__ */ new Set();
        const proof = [];
        for (let index of maximalIndices) {
          if (!redundantIndices.has(index)) {
            proof.push(index);
            while (index > 1) {
              redundantIndices.add(index);
              if (!redundantIndices.has(index ^ 1))
                break;
              index = index / 2 | 0;
            }
          }
        }
        return proof.filter((index) => {
          return !treeIndices.includes(index - leafCount);
        });
      }
      getProofIndicesForUnevenTree(sortedLeafIndices, leavesCount) {
        const depth = Math.ceil(Math.log2(leavesCount));
        const unevenLayers = [];
        for (let index = 0; index < depth; index++) {
          const unevenLayer = leavesCount % 2 !== 0;
          if (unevenLayer) {
            unevenLayers.push({ index, leavesCount });
          }
          leavesCount = Math.ceil(leavesCount / 2);
        }
        const proofIndices = [];
        let layerNodes = sortedLeafIndices;
        for (let layerIndex = 0; layerIndex < depth; layerIndex++) {
          const siblingIndices = layerNodes.map((index) => {
            if (index % 2 === 0) {
              return index + 1;
            }
            return index - 1;
          });
          let proofNodeIndices = siblingIndices.filter((index) => !layerNodes.includes(index));
          const unevenLayer = unevenLayers.find(({ index }) => index === layerIndex);
          if (unevenLayer && layerNodes.includes(unevenLayer.leavesCount - 1)) {
            proofNodeIndices = proofNodeIndices.slice(0, -1);
          }
          proofIndices.push(proofNodeIndices);
          layerNodes = [...new Set(layerNodes.map((index) => {
            if (index % 2 === 0) {
              return index / 2;
            }
            if (index % 2 === 0) {
              return (index + 1) / 2;
            }
            return (index - 1) / 2;
          }))];
        }
        return proofIndices;
      }
      /**
       * getMultiProof
       * @desc Returns the multiproof for given tree indices.
       * @param {Number[]} indices - Tree indices.
       * @return {Buffer[]} - Multiproofs
       * @example
       * ```js
       *const indices = [2, 5, 6]
       *const proof = tree.getMultiProof(indices)
       *```
       */
      getMultiProof(tree, indices) {
        if (!indices) {
          indices = tree;
          tree = this.getLayersFlat();
        }
        const isUneven = this.isUnevenTree();
        if (isUneven) {
          if (indices.every(Number.isInteger)) {
            return this.getMultiProofForUnevenTree(indices);
          }
        }
        if (!indices.every(Number.isInteger)) {
          let els = indices;
          if (this.sortPairs) {
            els = els.sort(buffer_1.Buffer.compare);
          }
          let ids = els.map((el) => this._bufferIndexOf(this.leaves, el)).sort((a, b) => a === b ? 0 : a > b ? 1 : -1);
          if (!ids.every((idx) => idx !== -1)) {
            throw new Error("Element does not exist in Merkle tree");
          }
          const hashes = [];
          const proof = [];
          let nextIds = [];
          for (let i = 0; i < this.layers.length; i++) {
            const layer = this.layers[i];
            for (let j = 0; j < ids.length; j++) {
              const idx = ids[j];
              const pairElement = this._getPairNode(layer, idx);
              hashes.push(layer[idx]);
              if (pairElement) {
                proof.push(pairElement);
              }
              nextIds.push(idx / 2 | 0);
            }
            ids = nextIds.filter((value, i2, self2) => self2.indexOf(value) === i2);
            nextIds = [];
          }
          return proof.filter((value) => !hashes.includes(value));
        }
        return this.getProofIndices(indices, this._log2(tree.length / 2 | 0)).map((index) => tree[index]);
      }
      getMultiProofForUnevenTree(tree, indices) {
        if (!indices) {
          indices = tree;
          tree = this.getLayers();
        }
        let proofHashes = [];
        let currentLayerIndices = indices;
        for (const treeLayer of tree) {
          const siblings = [];
          for (const index of currentLayerIndices) {
            if (index % 2 === 0) {
              const idx2 = index + 1;
              if (!currentLayerIndices.includes(idx2)) {
                if (treeLayer[idx2]) {
                  siblings.push(treeLayer[idx2]);
                  continue;
                }
              }
            }
            const idx = index - 1;
            if (!currentLayerIndices.includes(idx)) {
              if (treeLayer[idx]) {
                siblings.push(treeLayer[idx]);
                continue;
              }
            }
          }
          proofHashes = proofHashes.concat(siblings);
          const uniqueIndices = /* @__PURE__ */ new Set();
          for (const index of currentLayerIndices) {
            if (index % 2 === 0) {
              uniqueIndices.add(index / 2);
              continue;
            }
            if (index % 2 === 0) {
              uniqueIndices.add((index + 1) / 2);
              continue;
            }
            uniqueIndices.add((index - 1) / 2);
          }
          currentLayerIndices = Array.from(uniqueIndices);
        }
        return proofHashes;
      }
      /**
       * getHexMultiProof
       * @desc Returns the multiproof for given tree indices as hex strings.
       * @param {Number[]} indices - Tree indices.
       * @return {String[]} - Multiproofs as hex strings.
       * @example
       * ```js
       *const indices = [2, 5, 6]
       *const proof = tree.getHexMultiProof(indices)
       *```
       */
      getHexMultiProof(tree, indices) {
        return this.getMultiProof(tree, indices).map((x) => this.bufferToHex(x));
      }
      /**
       * getProofFlags
       * @desc Returns list of booleans where proofs should be used instead of hashing.
       * Proof flags are used in the Solidity multiproof verifiers.
       * @param {Number[]|Buffer[]} leaves
       * @param {Buffer[]} proofs
       * @return {Boolean[]} - Boolean flags
       * @example
       * ```js
       *const indices = [2, 5, 6]
       *const proof = tree.getMultiProof(indices)
       *const proofFlags = tree.getProofFlags(leaves, proof)
       *```
       */
      getProofFlags(leaves, proofs) {
        if (!Array.isArray(leaves) || leaves.length <= 0) {
          throw new Error("Invalid Inputs!");
        }
        let ids;
        if (leaves.every(Number.isInteger)) {
          ids = leaves.sort((a, b) => a === b ? 0 : a > b ? 1 : -1);
        } else {
          ids = leaves.map((el) => this._bufferIndexOf(this.leaves, el)).sort((a, b) => a === b ? 0 : a > b ? 1 : -1);
        }
        if (!ids.every((idx) => idx !== -1)) {
          throw new Error("Element does not exist in Merkle tree");
        }
        const _proofs = proofs.map((item) => this.bufferify(item));
        const tested = [];
        const flags = [];
        for (let index = 0; index < this.layers.length; index++) {
          const layer = this.layers[index];
          ids = ids.reduce((ids2, idx) => {
            const skipped = tested.includes(layer[idx]);
            if (!skipped) {
              const pairElement = this._getPairNode(layer, idx);
              const proofUsed = _proofs.includes(layer[idx]) || _proofs.includes(pairElement);
              pairElement && flags.push(!proofUsed);
              tested.push(layer[idx]);
              tested.push(pairElement);
            }
            ids2.push(idx / 2 | 0);
            return ids2;
          }, []);
        }
        return flags;
      }
      /**
       * verify
       * @desc Returns true if the proof path (array of hashes) can connect the target node
       * to the Merkle root.
       * @param {Object[]} proof - Array of proof objects that should connect
       * target node to Merkle root.
       * @param {Buffer} targetNode - Target node Buffer
       * @param {Buffer} root - Merkle root Buffer
       * @return {Boolean}
       * @example
       *```js
       *const root = tree.getRoot()
       *const proof = tree.getProof(leaves[2])
       *const verified = tree.verify(proof, leaves[2], root)
       *```
       */
      verify(proof, targetNode, root) {
        let hash = this.bufferify(targetNode);
        root = this.bufferify(root);
        if (!Array.isArray(proof) || !targetNode || !root) {
          return false;
        }
        for (let i = 0; i < proof.length; i++) {
          const node = proof[i];
          let data = null;
          let isLeftNode = null;
          if (typeof node === "string") {
            data = this.bufferify(node);
            isLeftNode = true;
          } else if (Array.isArray(node)) {
            isLeftNode = node[0] === 0;
            data = this.bufferify(node[1]);
          } else if (buffer_1.Buffer.isBuffer(node)) {
            data = node;
            isLeftNode = true;
          } else if (node instanceof Object) {
            data = this.bufferify(node.data);
            isLeftNode = node.position === "left";
          } else {
            throw new Error("Expected node to be of type string or object");
          }
          const buffers = [];
          if (this.isBitcoinTree) {
            buffers.push(buffer_reverse_1.default(hash));
            buffers[isLeftNode ? "unshift" : "push"](buffer_reverse_1.default(data));
            hash = this.hashFn(buffer_1.Buffer.concat(buffers));
            hash = buffer_reverse_1.default(this.hashFn(hash));
          } else {
            if (this.sortPairs) {
              if (buffer_1.Buffer.compare(hash, data) === -1) {
                buffers.push(hash, data);
                hash = this.hashFn(buffer_1.Buffer.concat(buffers));
              } else {
                buffers.push(data, hash);
                hash = this.hashFn(buffer_1.Buffer.concat(buffers));
              }
            } else {
              buffers.push(hash);
              buffers[isLeftNode ? "unshift" : "push"](data);
              hash = this.hashFn(buffer_1.Buffer.concat(buffers));
            }
          }
        }
        return buffer_1.Buffer.compare(hash, root) === 0;
      }
      /**
       * verifyMultiProof
       * @desc Returns true if the multiproofs can connect the leaves to the Merkle root.
       * @param {Buffer} root - Merkle tree root
       * @param {Number[]} proofIndices - Leave indices for proof
       * @param {Buffer[]} proofLeaves - Leaf values at indices for proof
       * @param {Number} leavesCount - Count of original leaves
       * @param {Buffer[]} proof - Multiproofs given indices
       * @return {Boolean}
       * @example
       *```js
       *const leaves = tree.getLeaves()
       *const root = tree.getRoot()
       *const treeFlat = tree.getLayersFlat()
       *const leavesCount = leaves.length
       *const proofIndices = [2, 5, 6]
       *const proofLeaves = proofIndices.map(i => leaves[i])
       *const proof = tree.getMultiProof(treeFlat, indices)
       *const verified = tree.verifyMultiProof(root, proofIndices, proofLeaves, leavesCount, proof)
       *```
       */
      verifyMultiProof(root, proofIndices, proofLeaves, leavesCount, proof) {
        const isUneven = this.isUnevenTree();
        if (isUneven) {
          return this.verifyMultiProofForUnevenTree(root, proofIndices, proofLeaves, leavesCount, proof);
        }
        const depth = Math.ceil(Math.log2(leavesCount));
        root = this.bufferify(root);
        proofLeaves = proofLeaves.map((leaf) => this.bufferify(leaf));
        proof = proof.map((leaf) => this.bufferify(leaf));
        const tree = {};
        for (const [index, leaf] of this._zip(proofIndices, proofLeaves)) {
          tree[Math.pow(2, depth) + index] = leaf;
        }
        for (const [index, proofitem] of this._zip(this.getProofIndices(proofIndices, depth), proof)) {
          tree[index] = proofitem;
        }
        let indexqueue = Object.keys(tree).map((value) => +value).sort((a, b) => a - b);
        indexqueue = indexqueue.slice(0, indexqueue.length - 1);
        let i = 0;
        while (i < indexqueue.length) {
          const index = indexqueue[i];
          if (index >= 2 && {}.hasOwnProperty.call(tree, index ^ 1)) {
            let pair = [tree[index - index % 2], tree[index - index % 2 + 1]];
            if (this.sortPairs) {
              pair = pair.sort(buffer_1.Buffer.compare);
            }
            const hash = pair[1] ? this.hashFn(buffer_1.Buffer.concat(pair)) : pair[0];
            tree[index / 2 | 0] = hash;
            indexqueue.push(index / 2 | 0);
          }
          i += 1;
        }
        return !proofIndices.length || {}.hasOwnProperty.call(tree, 1) && tree[1].equals(root);
      }
      verifyMultiProofWithFlags(root, leaves, proofs, proofFlag) {
        root = this.bufferify(root);
        leaves = leaves.map(this.bufferify);
        proofs = proofs.map(this.bufferify);
        const leavesLen = leaves.length;
        const totalHashes = proofFlag.length;
        const hashes = [];
        let leafPos = 0;
        let hashPos = 0;
        let proofPos = 0;
        for (let i = 0; i < totalHashes; i++) {
          const bufA = proofFlag[i] ? leafPos < leavesLen ? leaves[leafPos++] : hashes[hashPos++] : proofs[proofPos++];
          const bufB = leafPos < leavesLen ? leaves[leafPos++] : hashes[hashPos++];
          const buffers = [bufA, bufB].sort(buffer_1.Buffer.compare);
          hashes[i] = this.hashFn(buffer_1.Buffer.concat(buffers));
        }
        return buffer_1.Buffer.compare(hashes[totalHashes - 1], root) === 0;
      }
      verifyMultiProofForUnevenTree(root, indices, leaves, leavesCount, proof) {
        root = this.bufferify(root);
        leaves = leaves.map((leaf) => this.bufferify(leaf));
        proof = proof.map((leaf) => this.bufferify(leaf));
        const computedRoot = this.calculateRootForUnevenTree(indices, leaves, leavesCount, proof);
        return root.equals(computedRoot);
      }
      /**
       * getDepth
       * @desc Returns the tree depth (number of layers)
       * @return {Number}
       * @example
       *```js
       *const depth = tree.getDepth()
       *```
       */
      getDepth() {
        return this.getLayers().length - 1;
      }
      /**
       * getLayersAsObject
       * @desc Returns the layers as nested objects instead of an array.
       * @example
       *```js
       *const layersObj = tree.getLayersAsObject()
       *```
       */
      getLayersAsObject() {
        const layers = this.getLayers().map((layer) => layer.map((value) => this.bufferToHex(value, false)));
        const objs = [];
        for (let i = 0; i < layers.length; i++) {
          const arr = [];
          for (let j = 0; j < layers[i].length; j++) {
            const obj = { [layers[i][j]]: null };
            if (objs.length) {
              obj[layers[i][j]] = {};
              const a = objs.shift();
              const akey = Object.keys(a)[0];
              obj[layers[i][j]][akey] = a[akey];
              if (objs.length) {
                const b = objs.shift();
                const bkey = Object.keys(b)[0];
                obj[layers[i][j]][bkey] = b[bkey];
              }
            }
            arr.push(obj);
          }
          objs.push(...arr);
        }
        return objs[0];
      }
      /**
       * verify
       * @desc Returns true if the proof path (array of hashes) can connect the target node
       * to the Merkle root.
       * @param {Object[]} proof - Array of proof objects that should connect
       * target node to Merkle root.
       * @param {Buffer} targetNode - Target node Buffer
       * @param {Buffer} root - Merkle root Buffer
       * @param {Function} hashFunction - Hash function for hashing leaves and nodes
       * @param {Object} options - Additional options
       * @return {Boolean}
       * @example
       *```js
       *const verified = MerkleTree.verify(proof, leaf, root, sha256, options)
       *```
       */
      static verify(proof, targetNode, root, hashFn = sha256_1.default, options = {}) {
        const tree = new _MerkleTree([], hashFn, options);
        return tree.verify(proof, targetNode, root);
      }
      /**
       * getMultiProof
       * @desc Returns the multiproof for given tree indices.
       * @param {Buffer[]} tree - Tree as a flat array.
       * @param {Number[]} indices - Tree indices.
       * @return {Buffer[]} - Multiproofs
       *
       *@example
       * ```js
       *const flatTree = tree.getLayersFlat()
       *const indices = [2, 5, 6]
       *const proof = MerkleTree.getMultiProof(flatTree, indices)
       *```
       */
      static getMultiProof(tree, indices) {
        const t = new _MerkleTree([]);
        return t.getMultiProof(tree, indices);
      }
      /**
       * resetTree
       * @desc Resets the tree by clearing the leaves and layers.
       * @example
       *```js
       *tree.resetTree()
       *```
       */
      resetTree() {
        this.leaves = [];
        this.layers = [];
      }
      /**
       * getPairNode
       * @desc Returns the node at the index for given layer.
       * @param {Buffer[]} layer - Tree layer
       * @param {Number} index - Index at layer.
       * @return {Buffer} - Node
       *
       *@example
       * ```js
       *const node = tree.getPairNode(layer, index)
       *```
       */
      _getPairNode(layer, idx) {
        const pairIdx = idx % 2 === 0 ? idx + 1 : idx - 1;
        if (pairIdx < layer.length) {
          return layer[pairIdx];
        } else {
          return null;
        }
      }
      /**
       * toTreeString
       * @desc Returns a visual representation of the merkle tree as a string.
       * @return {String}
       * @example
       *```js
       *console.log(tree.toTreeString())
       *```
       */
      _toTreeString() {
        const obj = this.getLayersAsObject();
        return treeify_1.default.asTree(obj, true);
      }
      /**
       * toString
       * @desc Returns a visual representation of the merkle tree as a string.
       * @example
       *```js
       *console.log(tree.toString())
       *```
       */
      toString() {
        return this._toTreeString();
      }
      isUnevenTree(treeLayers) {
        const depth = (treeLayers === null || treeLayers === void 0 ? void 0 : treeLayers.length) || this.getDepth();
        return !this.isPowOf2(depth);
      }
      isPowOf2(v) {
        return v && !(v & v - 1);
      }
      calculateRootForUnevenTree(leafIndices, leafHashes, totalLeavesCount, proofHashes) {
        const leafTuples = this._zip(leafIndices, leafHashes).sort(([indexA], [indexB]) => indexA - indexB);
        const leafTupleIndices = leafTuples.map(([index]) => index);
        const proofIndices = this.getProofIndicesForUnevenTree(leafTupleIndices, totalLeavesCount);
        let nextSliceStart = 0;
        const proofTuplesByLayers = [];
        for (let i = 0; i < proofIndices.length; i++) {
          const indices = proofIndices[i];
          const sliceStart = nextSliceStart;
          nextSliceStart += indices.length;
          proofTuplesByLayers[i] = this._zip(indices, proofHashes.slice(sliceStart, nextSliceStart));
        }
        const tree = [leafTuples];
        for (let layerIndex = 0; layerIndex < proofTuplesByLayers.length; layerIndex++) {
          const currentLayer = proofTuplesByLayers[layerIndex].concat(tree[layerIndex]).sort(([indexA], [indexB]) => indexA - indexB).map(([, hash]) => hash);
          const s = tree[layerIndex].map(([layerIndex2]) => layerIndex2);
          const parentIndices = [...new Set(s.map((index) => {
            if (index % 2 === 0) {
              return index / 2;
            }
            if (index % 2 === 0) {
              return (index + 1) / 2;
            }
            return (index - 1) / 2;
          }))];
          const parentLayer = [];
          for (let i = 0; i < parentIndices.length; i++) {
            const parentNodeTreeIndex = parentIndices[i];
            const bufA = currentLayer[i * 2];
            const bufB = currentLayer[i * 2 + 1];
            const hash = bufB ? this.hashFn(buffer_1.Buffer.concat([bufA, bufB])) : bufA;
            parentLayer.push([parentNodeTreeIndex, hash]);
          }
          tree.push(parentLayer);
        }
        return tree[tree.length - 1][0][1];
      }
    };
    exports.MerkleTree = MerkleTree2;
    if (typeof window !== "undefined") {
      ;
      window.MerkleTree = MerkleTree2;
    }
    exports.default = MerkleTree2;
  }
});

// node_modules/merkletreejs/dist/MerkleMountainRange.js
var require_MerkleMountainRange = __commonJS({
  "node_modules/merkletreejs/dist/MerkleMountainRange.js"(exports) {
    "use strict";
    init_shim();
    var __importDefault = exports && exports.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.MerkleMountainRange = void 0;
    var buffer_1 = require_buffer();
    var sha256_1 = __importDefault(require_sha256());
    var Base_1 = __importDefault(require_Base());
    var MerkleMountainRange = class extends Base_1.default {
      constructor(hashFn = sha256_1.default, leaves = [], hashLeafFn, peakBaggingFn, hashBranchFn) {
        super();
        this.root = buffer_1.Buffer.alloc(0);
        this.size = 0;
        this.width = 0;
        this.hashes = {};
        this.data = {};
        leaves = leaves.map(this.bufferify);
        this.hashFn = this.bufferifyFn(hashFn);
        this.hashLeafFn = hashLeafFn;
        this.peakBaggingFn = peakBaggingFn;
        this.hashBranchFn = hashBranchFn;
        for (const leaf of leaves) {
          this.append(leaf);
        }
      }
      /**
       * @desc This only stores the hashed value of the leaf.
       * If you need to retrieve the detail data later, use a map to store them.
       */
      append(data) {
        data = this.bufferify(data);
        const dataHash = this.hashFn(data);
        const dataHashHex = this.bufferToHex(dataHash);
        if (!this.data[dataHashHex] || this.bufferToHex(this.hashFn(this.data[dataHashHex])) !== dataHashHex) {
          this.data[dataHashHex] = data;
        }
        const leaf = this.hashLeaf(this.size + 1, dataHash);
        this.hashes[this.size + 1] = leaf;
        this.width += 1;
        const peakIndexes = this.getPeakIndexes(this.width);
        this.size = this.getSize(this.width);
        const peaks = [];
        for (let i = 0; i < peakIndexes.length; i++) {
          peaks[i] = this._getOrCreateNode(peakIndexes[i]);
        }
        this.root = this.peakBagging(this.width, peaks);
      }
      /**
       * @desc It returns the hash of a leaf node with hash(M | DATA )
       *       M is the index of the node.
       */
      hashLeaf(index, dataHash) {
        dataHash = this.bufferify(dataHash);
        if (this.hashLeafFn) {
          return this.bufferify(this.hashLeafFn(index, dataHash));
        }
        return this.hashFn(buffer_1.Buffer.concat([this.bufferify(index), dataHash]));
      }
      /**
       * @desc It returns the hash a parent node with hash(M | Left child | Right child)
       *       M is the index of the node.
       */
      hashBranch(index, left, right) {
        if (this.hashBranchFn) {
          return this.bufferify(this.hashBranchFn(index, left, right));
        }
        return this.hashFn(buffer_1.Buffer.concat([this.bufferify(index), this.bufferify(left), this.bufferify(right)]));
      }
      getPeaks() {
        const peakIndexes = this.getPeakIndexes(this.width);
        const peaks = [];
        for (let i = 0; i < peakIndexes.length; i++) {
          peaks[i] = this.hashes[peakIndexes[i]];
        }
        return peaks;
      }
      getLeafIndex(width) {
        if (width % 2 === 1) {
          return this.getSize(width);
        }
        return this.getSize(width - 1) + 1;
      }
      /**
       * @desc It returns all peaks of the smallest merkle mountain range tree which includes
       *       the given index(size).
       */
      getPeakIndexes(width) {
        const numPeaks = this.numOfPeaks(width);
        const peakIndexes = [];
        let count = 0;
        let size = 0;
        for (let i = 255; i > 0; i--) {
          if ((width & 1 << i - 1) !== 0) {
            size = size + (1 << i) - 1;
            peakIndexes[count++] = size;
            if (peakIndexes.length >= numPeaks) {
              break;
            }
          }
        }
        if (count !== peakIndexes.length) {
          throw new Error("invalid bit calculation");
        }
        return peakIndexes;
      }
      numOfPeaks(width) {
        let bits = width;
        let num = 0;
        while (bits > 0) {
          if (bits % 2 === 1) {
            num++;
          }
          bits = bits >> 1;
        }
        return num;
      }
      peakBagging(width, peaks) {
        const size = this.getSize(width);
        if (this.numOfPeaks(width) !== peaks.length) {
          throw new Error("received invalid number of peaks");
        }
        if (width === 0 && !peaks.length) {
          return buffer_1.Buffer.alloc(0);
        }
        if (this.peakBaggingFn) {
          return this.bufferify(this.peakBaggingFn(size, peaks));
        }
        return this.hashFn(buffer_1.Buffer.concat([this.bufferify(size), ...peaks.map(this.bufferify)]));
      }
      /**
       * @desc It returns the size of the tree.
       */
      getSize(width) {
        return (width << 1) - this.numOfPeaks(width);
      }
      /**
       * @desc It returns the root value of the tree.
       */
      getRoot() {
        return this.root;
      }
      getHexRoot() {
        return this.bufferToHex(this.getRoot());
      }
      /**
       * @dev It returns the hash value of a node for the given position. Note that the index starts from 1.
       */
      getNode(index) {
        return this.hashes[index];
      }
      /**
       * @desc It returns the height of the highest peak.
       */
      mountainHeight(size) {
        let height = 1;
        while (1 << height <= size + height) {
          height++;
        }
        return height - 1;
      }
      /**
       * @desc It returns the height of the index.
       */
      heightAt(index) {
        let reducedIndex = index;
        let peakIndex = 0;
        let height = 0;
        while (reducedIndex > peakIndex) {
          reducedIndex -= (1 << height) - 1;
          height = this.mountainHeight(reducedIndex);
          peakIndex = (1 << height) - 1;
        }
        return height - (peakIndex - reducedIndex);
      }
      /**
       * @desc It returns whether the index is the leaf node or not
       */
      isLeaf(index) {
        return this.heightAt(index) === 1;
      }
      /**
       * @desc It returns the children when it is a parent node.
       */
      getChildren(index) {
        const left = index - (1 << this.heightAt(index) - 1);
        const right = index - 1;
        if (left === right) {
          throw new Error("not a parent");
        }
        return [left, right];
      }
      /**
       * @desc It returns a merkle proof for a leaf. Note that the index starts from 1.
       */
      getMerkleProof(index) {
        if (index > this.size) {
          throw new Error("out of range");
        }
        if (!this.isLeaf(index)) {
          throw new Error("not a leaf");
        }
        const root = this.root;
        const width = this.width;
        const peaks = this.getPeakIndexes(this.width);
        const peakBagging = [];
        let cursor = 0;
        for (let i = 0; i < peaks.length; i++) {
          peakBagging[i] = this.hashes[peaks[i]];
          if (peaks[i] >= index && cursor === 0) {
            cursor = peaks[i];
          }
        }
        let left = 0;
        let right = 0;
        let height = this.heightAt(cursor);
        const siblings = [];
        while (cursor !== index) {
          height--;
          [left, right] = this.getChildren(cursor);
          cursor = index <= left ? left : right;
          siblings[height - 1] = this.hashes[index <= left ? right : left];
        }
        return {
          root,
          width,
          peakBagging,
          siblings
        };
      }
      /**
       * @desc It returns true when the given params verifies that the given value exists in the tree or reverts the transaction.
       */
      verify(root, width, index, value, peaks, siblings) {
        value = this.bufferify(value);
        const size = this.getSize(width);
        if (size < index) {
          throw new Error("index is out of range");
        }
        if (!root.equals(this.peakBagging(width, peaks))) {
          throw new Error("invalid root hash from the peaks");
        }
        let cursor = 0;
        let targetPeak;
        const peakIndexes = this.getPeakIndexes(width);
        for (let i = 0; i < peakIndexes.length; i++) {
          if (peakIndexes[i] >= index) {
            targetPeak = peaks[i];
            cursor = peakIndexes[i];
            break;
          }
        }
        if (!targetPeak) {
          throw new Error("target not found");
        }
        let height = siblings.length + 1;
        const path = new Array(height);
        let left = 0;
        let right = 0;
        while (height > 0) {
          path[--height] = cursor;
          if (cursor === index) {
            break;
          } else {
            [left, right] = this.getChildren(cursor);
            cursor = index > left ? right : left;
            continue;
          }
        }
        let node;
        while (height < path.length) {
          cursor = path[height];
          if (height === 0) {
            node = this.hashLeaf(cursor, this.hashFn(value));
          } else if (cursor - 1 === path[height - 1]) {
            node = this.hashBranch(cursor, siblings[height - 1], node);
          } else {
            node = this.hashBranch(cursor, node, siblings[height - 1]);
          }
          height++;
        }
        if (!node.equals(targetPeak)) {
          throw new Error("hashed peak is invalid");
        }
        return true;
      }
      peaksToPeakMap(width, peaks) {
        const peakMap = {};
        let bitIndex = 0;
        let peakRef = 0;
        let count = peaks.length;
        for (let height = 1; height <= 32; height++) {
          bitIndex = 32 - height;
          peakRef = 1 << height - 1;
          if ((width & peakRef) !== 0) {
            peakMap[bitIndex] = peaks[--count];
          } else {
            peakMap[bitIndex] = 0;
          }
        }
        if (count !== 0) {
          throw new Error("invalid number of peaks");
        }
        return peakMap;
      }
      peakMapToPeaks(width, peakMap) {
        const arrLength = this.numOfPeaks(width);
        const peaks = new Array(arrLength);
        let count = 0;
        for (let i = 0; i < 32; i++) {
          if (peakMap[i] !== 0) {
            peaks[count++] = peakMap[i];
          }
        }
        if (count !== arrLength) {
          throw new Error("invalid number of peaks");
        }
        return peaks;
      }
      peakUpdate(width, prevPeakMap, itemHash) {
        const nextPeakMap = {};
        const newWidth = width + 1;
        let cursorIndex = this.getLeafIndex(newWidth);
        let cursorNode = this.hashLeaf(cursorIndex, itemHash);
        let bitIndex = 0;
        let peakRef = 0;
        let prevPeakExist = false;
        let nextPeakExist = false;
        let obtained = false;
        for (let height = 1; height <= 32; height++) {
          bitIndex = 32 - height;
          if (obtained) {
            nextPeakMap[bitIndex] = prevPeakMap[bitIndex];
          } else {
            peakRef = 1 << height - 1;
            prevPeakExist = (width & peakRef) !== 0;
            nextPeakExist = (newWidth & peakRef) !== 0;
            cursorIndex++;
            if (prevPeakExist) {
              cursorNode = this.hashBranch(cursorIndex, prevPeakMap[bitIndex], cursorNode);
            }
            if (nextPeakExist) {
              if (prevPeakExist) {
                nextPeakMap[bitIndex] = prevPeakMap[bitIndex];
              } else {
                nextPeakMap[bitIndex] = cursorNode;
              }
              obtained = true;
            } else {
              nextPeakMap[bitIndex] = 0;
            }
          }
        }
        return nextPeakMap;
      }
      rollUp(root, width, peaks, itemHashes) {
        if (!root.equals(this.peakBagging(width, peaks))) {
          throw new Error("invalid root hash from the peaks");
        }
        let tmpWidth = width;
        let tmpPeakMap = this.peaksToPeakMap(width, peaks);
        for (let i = 0; i < itemHashes.length; i++) {
          tmpPeakMap = this.peakUpdate(tmpWidth, tmpPeakMap, itemHashes[i]);
          tmpWidth++;
        }
        return this.peakBagging(tmpWidth, this.peakMapToPeaks(tmpWidth, tmpPeakMap));
      }
      /**
       * @desc It returns the hash value of the node for the index.
       *      If the hash already exists it simply returns the stored value. On the other hand,
       *      it computes hashes recursively downward.
       *      Only appending an item calls this function.
       */
      _getOrCreateNode(index) {
        if (index > this.size) {
          throw new Error("out of range");
        }
        if (!this.hashes[index]) {
          const [leftIndex, rightIndex] = this.getChildren(index);
          const leftHash = this._getOrCreateNode(leftIndex);
          const rightHash = this._getOrCreateNode(rightIndex);
          this.hashes[index] = this.hashBranch(index, leftHash, rightHash);
        }
        return this.hashes[index];
      }
    };
    exports.MerkleMountainRange = MerkleMountainRange;
    exports.default = MerkleMountainRange;
  }
});

// node_modules/merkletreejs/dist/index.js
var require_dist = __commonJS({
  "node_modules/merkletreejs/dist/index.js"(exports) {
    "use strict";
    init_shim();
    var __importDefault = exports && exports.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.MerkleTree = void 0;
    var MerkleTree_1 = __importDefault(require_MerkleTree());
    exports.MerkleTree = MerkleTree_1.default;
    var MerkleMountainRange_1 = require_MerkleMountainRange();
    Object.defineProperty(exports, "MerkleMountainRange", { enumerable: true, get: function() {
      return MerkleMountainRange_1.MerkleMountainRange;
    } });
    exports.default = MerkleTree_1.default;
  }
});

// node_modules/base-x/src/index.js
var require_src7 = __commonJS({
  "node_modules/base-x/src/index.js"(exports, module) {
    "use strict";
    init_shim();
    function base(ALPHABET) {
      if (ALPHABET.length >= 255) {
        throw new TypeError("Alphabet too long");
      }
      var BASE_MAP = new Uint8Array(256);
      for (var j = 0; j < BASE_MAP.length; j++) {
        BASE_MAP[j] = 255;
      }
      for (var i = 0; i < ALPHABET.length; i++) {
        var x = ALPHABET.charAt(i);
        var xc = x.charCodeAt(0);
        if (BASE_MAP[xc] !== 255) {
          throw new TypeError(x + " is ambiguous");
        }
        BASE_MAP[xc] = i;
      }
      var BASE = ALPHABET.length;
      var LEADER = ALPHABET.charAt(0);
      var FACTOR = Math.log(BASE) / Math.log(256);
      var iFACTOR = Math.log(256) / Math.log(BASE);
      function encode(source) {
        if (source instanceof Uint8Array) {
        } else if (ArrayBuffer.isView(source)) {
          source = new Uint8Array(source.buffer, source.byteOffset, source.byteLength);
        } else if (Array.isArray(source)) {
          source = Uint8Array.from(source);
        }
        if (!(source instanceof Uint8Array)) {
          throw new TypeError("Expected Uint8Array");
        }
        if (source.length === 0) {
          return "";
        }
        var zeroes = 0;
        var length = 0;
        var pbegin = 0;
        var pend = source.length;
        while (pbegin !== pend && source[pbegin] === 0) {
          pbegin++;
          zeroes++;
        }
        var size = (pend - pbegin) * iFACTOR + 1 >>> 0;
        var b58 = new Uint8Array(size);
        while (pbegin !== pend) {
          var carry = source[pbegin];
          var i2 = 0;
          for (var it1 = size - 1; (carry !== 0 || i2 < length) && it1 !== -1; it1--, i2++) {
            carry += 256 * b58[it1] >>> 0;
            b58[it1] = carry % BASE >>> 0;
            carry = carry / BASE >>> 0;
          }
          if (carry !== 0) {
            throw new Error("Non-zero carry");
          }
          length = i2;
          pbegin++;
        }
        var it2 = size - length;
        while (it2 !== size && b58[it2] === 0) {
          it2++;
        }
        var str = LEADER.repeat(zeroes);
        for (; it2 < size; ++it2) {
          str += ALPHABET.charAt(b58[it2]);
        }
        return str;
      }
      function decodeUnsafe(source) {
        if (typeof source !== "string") {
          throw new TypeError("Expected String");
        }
        if (source.length === 0) {
          return new Uint8Array();
        }
        var psz = 0;
        var zeroes = 0;
        var length = 0;
        while (source[psz] === LEADER) {
          zeroes++;
          psz++;
        }
        var size = (source.length - psz) * FACTOR + 1 >>> 0;
        var b256 = new Uint8Array(size);
        while (source[psz]) {
          var carry = BASE_MAP[source.charCodeAt(psz)];
          if (carry === 255) {
            return;
          }
          var i2 = 0;
          for (var it3 = size - 1; (carry !== 0 || i2 < length) && it3 !== -1; it3--, i2++) {
            carry += BASE * b256[it3] >>> 0;
            b256[it3] = carry % 256 >>> 0;
            carry = carry / 256 >>> 0;
          }
          if (carry !== 0) {
            throw new Error("Non-zero carry");
          }
          length = i2;
          psz++;
        }
        var it4 = size - length;
        while (it4 !== size && b256[it4] === 0) {
          it4++;
        }
        var vch = new Uint8Array(zeroes + (size - it4));
        var j2 = zeroes;
        while (it4 !== size) {
          vch[j2++] = b256[it4++];
        }
        return vch;
      }
      function decode2(string) {
        var buffer = decodeUnsafe(string);
        if (buffer) {
          return buffer;
        }
        throw new Error("Non-base" + BASE + " character");
      }
      return {
        encode,
        decodeUnsafe,
        decode: decode2
      };
    }
    module.exports = base;
  }
});

// node_modules/bs58/index.js
var require_bs58 = __commonJS({
  "node_modules/bs58/index.js"(exports, module) {
    init_shim();
    var basex = require_src7();
    var ALPHABET = "123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz";
    module.exports = basex(ALPHABET);
  }
});

// node_modules/zod/lib/index.mjs
init_shim();
var util;
(function(util2) {
  util2.assertEqual = (val) => val;
  function assertIs(_arg) {
  }
  util2.assertIs = assertIs;
  function assertNever(_x) {
    throw new Error();
  }
  util2.assertNever = assertNever;
  util2.arrayToEnum = (items) => {
    const obj = {};
    for (const item of items) {
      obj[item] = item;
    }
    return obj;
  };
  util2.getValidEnumValues = (obj) => {
    const validKeys = util2.objectKeys(obj).filter((k) => typeof obj[obj[k]] !== "number");
    const filtered = {};
    for (const k of validKeys) {
      filtered[k] = obj[k];
    }
    return util2.objectValues(filtered);
  };
  util2.objectValues = (obj) => {
    return util2.objectKeys(obj).map(function(e) {
      return obj[e];
    });
  };
  util2.objectKeys = typeof Object.keys === "function" ? (obj) => Object.keys(obj) : (object) => {
    const keys = [];
    for (const key in object) {
      if (Object.prototype.hasOwnProperty.call(object, key)) {
        keys.push(key);
      }
    }
    return keys;
  };
  util2.find = (arr, checker) => {
    for (const item of arr) {
      if (checker(item))
        return item;
    }
    return void 0;
  };
  util2.isInteger = typeof Number.isInteger === "function" ? (val) => Number.isInteger(val) : (val) => typeof val === "number" && isFinite(val) && Math.floor(val) === val;
  function joinValues(array, separator = " | ") {
    return array.map((val) => typeof val === "string" ? `'${val}'` : val).join(separator);
  }
  util2.joinValues = joinValues;
  util2.jsonStringifyReplacer = (_, value) => {
    if (typeof value === "bigint") {
      return value.toString();
    }
    return value;
  };
})(util || (util = {}));
var objectUtil;
(function(objectUtil2) {
  objectUtil2.mergeShapes = (first, second) => {
    return {
      ...first,
      ...second
      // second overwrites first
    };
  };
})(objectUtil || (objectUtil = {}));
var ZodParsedType = util.arrayToEnum([
  "string",
  "nan",
  "number",
  "integer",
  "float",
  "boolean",
  "date",
  "bigint",
  "symbol",
  "function",
  "undefined",
  "null",
  "array",
  "object",
  "unknown",
  "promise",
  "void",
  "never",
  "map",
  "set"
]);
var getParsedType = (data) => {
  const t = typeof data;
  switch (t) {
    case "undefined":
      return ZodParsedType.undefined;
    case "string":
      return ZodParsedType.string;
    case "number":
      return isNaN(data) ? ZodParsedType.nan : ZodParsedType.number;
    case "boolean":
      return ZodParsedType.boolean;
    case "function":
      return ZodParsedType.function;
    case "bigint":
      return ZodParsedType.bigint;
    case "symbol":
      return ZodParsedType.symbol;
    case "object":
      if (Array.isArray(data)) {
        return ZodParsedType.array;
      }
      if (data === null) {
        return ZodParsedType.null;
      }
      if (data.then && typeof data.then === "function" && data.catch && typeof data.catch === "function") {
        return ZodParsedType.promise;
      }
      if (typeof Map !== "undefined" && data instanceof Map) {
        return ZodParsedType.map;
      }
      if (typeof Set !== "undefined" && data instanceof Set) {
        return ZodParsedType.set;
      }
      if (typeof Date !== "undefined" && data instanceof Date) {
        return ZodParsedType.date;
      }
      return ZodParsedType.object;
    default:
      return ZodParsedType.unknown;
  }
};
var ZodIssueCode = util.arrayToEnum([
  "invalid_type",
  "invalid_literal",
  "custom",
  "invalid_union",
  "invalid_union_discriminator",
  "invalid_enum_value",
  "unrecognized_keys",
  "invalid_arguments",
  "invalid_return_type",
  "invalid_date",
  "invalid_string",
  "too_small",
  "too_big",
  "invalid_intersection_types",
  "not_multiple_of",
  "not_finite"
]);
var quotelessJson = (obj) => {
  const json = JSON.stringify(obj, null, 2);
  return json.replace(/"([^"]+)":/g, "$1:");
};
var ZodError = class extends Error {
  constructor(issues) {
    super();
    this.issues = [];
    this.addIssue = (sub) => {
      this.issues = [...this.issues, sub];
    };
    this.addIssues = (subs = []) => {
      this.issues = [...this.issues, ...subs];
    };
    const actualProto = new.target.prototype;
    if (Object.setPrototypeOf) {
      Object.setPrototypeOf(this, actualProto);
    } else {
      this.__proto__ = actualProto;
    }
    this.name = "ZodError";
    this.issues = issues;
  }
  get errors() {
    return this.issues;
  }
  format(_mapper) {
    const mapper = _mapper || function(issue) {
      return issue.message;
    };
    const fieldErrors = { _errors: [] };
    const processError = (error) => {
      for (const issue of error.issues) {
        if (issue.code === "invalid_union") {
          issue.unionErrors.map(processError);
        } else if (issue.code === "invalid_return_type") {
          processError(issue.returnTypeError);
        } else if (issue.code === "invalid_arguments") {
          processError(issue.argumentsError);
        } else if (issue.path.length === 0) {
          fieldErrors._errors.push(mapper(issue));
        } else {
          let curr = fieldErrors;
          let i = 0;
          while (i < issue.path.length) {
            const el = issue.path[i];
            const terminal = i === issue.path.length - 1;
            if (!terminal) {
              curr[el] = curr[el] || { _errors: [] };
            } else {
              curr[el] = curr[el] || { _errors: [] };
              curr[el]._errors.push(mapper(issue));
            }
            curr = curr[el];
            i++;
          }
        }
      }
    };
    processError(this);
    return fieldErrors;
  }
  toString() {
    return this.message;
  }
  get message() {
    return JSON.stringify(this.issues, util.jsonStringifyReplacer, 2);
  }
  get isEmpty() {
    return this.issues.length === 0;
  }
  flatten(mapper = (issue) => issue.message) {
    const fieldErrors = {};
    const formErrors = [];
    for (const sub of this.issues) {
      if (sub.path.length > 0) {
        fieldErrors[sub.path[0]] = fieldErrors[sub.path[0]] || [];
        fieldErrors[sub.path[0]].push(mapper(sub));
      } else {
        formErrors.push(mapper(sub));
      }
    }
    return { formErrors, fieldErrors };
  }
  get formErrors() {
    return this.flatten();
  }
};
ZodError.create = (issues) => {
  const error = new ZodError(issues);
  return error;
};
var errorMap = (issue, _ctx) => {
  let message;
  switch (issue.code) {
    case ZodIssueCode.invalid_type:
      if (issue.received === ZodParsedType.undefined) {
        message = "Required";
      } else {
        message = `Expected ${issue.expected}, received ${issue.received}`;
      }
      break;
    case ZodIssueCode.invalid_literal:
      message = `Invalid literal value, expected ${JSON.stringify(issue.expected, util.jsonStringifyReplacer)}`;
      break;
    case ZodIssueCode.unrecognized_keys:
      message = `Unrecognized key(s) in object: ${util.joinValues(issue.keys, ", ")}`;
      break;
    case ZodIssueCode.invalid_union:
      message = `Invalid input`;
      break;
    case ZodIssueCode.invalid_union_discriminator:
      message = `Invalid discriminator value. Expected ${util.joinValues(issue.options)}`;
      break;
    case ZodIssueCode.invalid_enum_value:
      message = `Invalid enum value. Expected ${util.joinValues(issue.options)}, received '${issue.received}'`;
      break;
    case ZodIssueCode.invalid_arguments:
      message = `Invalid function arguments`;
      break;
    case ZodIssueCode.invalid_return_type:
      message = `Invalid function return type`;
      break;
    case ZodIssueCode.invalid_date:
      message = `Invalid date`;
      break;
    case ZodIssueCode.invalid_string:
      if (typeof issue.validation === "object") {
        if ("includes" in issue.validation) {
          message = `Invalid input: must include "${issue.validation.includes}"`;
          if (typeof issue.validation.position === "number") {
            message = `${message} at one or more positions greater than or equal to ${issue.validation.position}`;
          }
        } else if ("startsWith" in issue.validation) {
          message = `Invalid input: must start with "${issue.validation.startsWith}"`;
        } else if ("endsWith" in issue.validation) {
          message = `Invalid input: must end with "${issue.validation.endsWith}"`;
        } else {
          util.assertNever(issue.validation);
        }
      } else if (issue.validation !== "regex") {
        message = `Invalid ${issue.validation}`;
      } else {
        message = "Invalid";
      }
      break;
    case ZodIssueCode.too_small:
      if (issue.type === "array")
        message = `Array must contain ${issue.exact ? "exactly" : issue.inclusive ? `at least` : `more than`} ${issue.minimum} element(s)`;
      else if (issue.type === "string")
        message = `String must contain ${issue.exact ? "exactly" : issue.inclusive ? `at least` : `over`} ${issue.minimum} character(s)`;
      else if (issue.type === "number")
        message = `Number must be ${issue.exact ? `exactly equal to ` : issue.inclusive ? `greater than or equal to ` : `greater than `}${issue.minimum}`;
      else if (issue.type === "date")
        message = `Date must be ${issue.exact ? `exactly equal to ` : issue.inclusive ? `greater than or equal to ` : `greater than `}${new Date(Number(issue.minimum))}`;
      else
        message = "Invalid input";
      break;
    case ZodIssueCode.too_big:
      if (issue.type === "array")
        message = `Array must contain ${issue.exact ? `exactly` : issue.inclusive ? `at most` : `less than`} ${issue.maximum} element(s)`;
      else if (issue.type === "string")
        message = `String must contain ${issue.exact ? `exactly` : issue.inclusive ? `at most` : `under`} ${issue.maximum} character(s)`;
      else if (issue.type === "number")
        message = `Number must be ${issue.exact ? `exactly` : issue.inclusive ? `less than or equal to` : `less than`} ${issue.maximum}`;
      else if (issue.type === "bigint")
        message = `BigInt must be ${issue.exact ? `exactly` : issue.inclusive ? `less than or equal to` : `less than`} ${issue.maximum}`;
      else if (issue.type === "date")
        message = `Date must be ${issue.exact ? `exactly` : issue.inclusive ? `smaller than or equal to` : `smaller than`} ${new Date(Number(issue.maximum))}`;
      else
        message = "Invalid input";
      break;
    case ZodIssueCode.custom:
      message = `Invalid input`;
      break;
    case ZodIssueCode.invalid_intersection_types:
      message = `Intersection results could not be merged`;
      break;
    case ZodIssueCode.not_multiple_of:
      message = `Number must be a multiple of ${issue.multipleOf}`;
      break;
    case ZodIssueCode.not_finite:
      message = "Number must be finite";
      break;
    default:
      message = _ctx.defaultError;
      util.assertNever(issue);
  }
  return { message };
};
var overrideErrorMap = errorMap;
function setErrorMap(map) {
  overrideErrorMap = map;
}
function getErrorMap() {
  return overrideErrorMap;
}
var makeIssue = (params) => {
  const { data, path, errorMaps, issueData } = params;
  const fullPath = [...path, ...issueData.path || []];
  const fullIssue = {
    ...issueData,
    path: fullPath
  };
  let errorMessage = "";
  const maps = errorMaps.filter((m) => !!m).slice().reverse();
  for (const map of maps) {
    errorMessage = map(fullIssue, { data, defaultError: errorMessage }).message;
  }
  return {
    ...issueData,
    path: fullPath,
    message: issueData.message || errorMessage
  };
};
var EMPTY_PATH = [];
function addIssueToContext(ctx, issueData) {
  const issue = makeIssue({
    issueData,
    data: ctx.data,
    path: ctx.path,
    errorMaps: [
      ctx.common.contextualErrorMap,
      ctx.schemaErrorMap,
      getErrorMap(),
      errorMap
      // then global default map
    ].filter((x) => !!x)
  });
  ctx.common.issues.push(issue);
}
var ParseStatus = class _ParseStatus {
  constructor() {
    this.value = "valid";
  }
  dirty() {
    if (this.value === "valid")
      this.value = "dirty";
  }
  abort() {
    if (this.value !== "aborted")
      this.value = "aborted";
  }
  static mergeArray(status, results) {
    const arrayValue = [];
    for (const s of results) {
      if (s.status === "aborted")
        return INVALID;
      if (s.status === "dirty")
        status.dirty();
      arrayValue.push(s.value);
    }
    return { status: status.value, value: arrayValue };
  }
  static async mergeObjectAsync(status, pairs) {
    const syncPairs = [];
    for (const pair of pairs) {
      syncPairs.push({
        key: await pair.key,
        value: await pair.value
      });
    }
    return _ParseStatus.mergeObjectSync(status, syncPairs);
  }
  static mergeObjectSync(status, pairs) {
    const finalObject = {};
    for (const pair of pairs) {
      const { key, value } = pair;
      if (key.status === "aborted")
        return INVALID;
      if (value.status === "aborted")
        return INVALID;
      if (key.status === "dirty")
        status.dirty();
      if (value.status === "dirty")
        status.dirty();
      if (key.value !== "__proto__" && (typeof value.value !== "undefined" || pair.alwaysSet)) {
        finalObject[key.value] = value.value;
      }
    }
    return { status: status.value, value: finalObject };
  }
};
var INVALID = Object.freeze({
  status: "aborted"
});
var DIRTY = (value) => ({ status: "dirty", value });
var OK = (value) => ({ status: "valid", value });
var isAborted = (x) => x.status === "aborted";
var isDirty = (x) => x.status === "dirty";
var isValid = (x) => x.status === "valid";
var isAsync = (x) => typeof Promise !== "undefined" && x instanceof Promise;
var errorUtil;
(function(errorUtil2) {
  errorUtil2.errToObj = (message) => typeof message === "string" ? { message } : message || {};
  errorUtil2.toString = (message) => typeof message === "string" ? message : message === null || message === void 0 ? void 0 : message.message;
})(errorUtil || (errorUtil = {}));
var ParseInputLazyPath = class {
  constructor(parent, value, path, key) {
    this._cachedPath = [];
    this.parent = parent;
    this.data = value;
    this._path = path;
    this._key = key;
  }
  get path() {
    if (!this._cachedPath.length) {
      if (this._key instanceof Array) {
        this._cachedPath.push(...this._path, ...this._key);
      } else {
        this._cachedPath.push(...this._path, this._key);
      }
    }
    return this._cachedPath;
  }
};
var handleResult = (ctx, result) => {
  if (isValid(result)) {
    return { success: true, data: result.value };
  } else {
    if (!ctx.common.issues.length) {
      throw new Error("Validation failed but no issues detected.");
    }
    return {
      success: false,
      get error() {
        if (this._error)
          return this._error;
        const error = new ZodError(ctx.common.issues);
        this._error = error;
        return this._error;
      }
    };
  }
};
function processCreateParams(params) {
  if (!params)
    return {};
  const { errorMap: errorMap2, invalid_type_error, required_error, description } = params;
  if (errorMap2 && (invalid_type_error || required_error)) {
    throw new Error(`Can't use "invalid_type_error" or "required_error" in conjunction with custom error map.`);
  }
  if (errorMap2)
    return { errorMap: errorMap2, description };
  const customMap = (iss, ctx) => {
    if (iss.code !== "invalid_type")
      return { message: ctx.defaultError };
    if (typeof ctx.data === "undefined") {
      return { message: required_error !== null && required_error !== void 0 ? required_error : ctx.defaultError };
    }
    return { message: invalid_type_error !== null && invalid_type_error !== void 0 ? invalid_type_error : ctx.defaultError };
  };
  return { errorMap: customMap, description };
}
var ZodType = class {
  constructor(def) {
    this.spa = this.safeParseAsync;
    this._def = def;
    this.parse = this.parse.bind(this);
    this.safeParse = this.safeParse.bind(this);
    this.parseAsync = this.parseAsync.bind(this);
    this.safeParseAsync = this.safeParseAsync.bind(this);
    this.spa = this.spa.bind(this);
    this.refine = this.refine.bind(this);
    this.refinement = this.refinement.bind(this);
    this.superRefine = this.superRefine.bind(this);
    this.optional = this.optional.bind(this);
    this.nullable = this.nullable.bind(this);
    this.nullish = this.nullish.bind(this);
    this.array = this.array.bind(this);
    this.promise = this.promise.bind(this);
    this.or = this.or.bind(this);
    this.and = this.and.bind(this);
    this.transform = this.transform.bind(this);
    this.brand = this.brand.bind(this);
    this.default = this.default.bind(this);
    this.catch = this.catch.bind(this);
    this.describe = this.describe.bind(this);
    this.pipe = this.pipe.bind(this);
    this.readonly = this.readonly.bind(this);
    this.isNullable = this.isNullable.bind(this);
    this.isOptional = this.isOptional.bind(this);
  }
  get description() {
    return this._def.description;
  }
  _getType(input) {
    return getParsedType(input.data);
  }
  _getOrReturnCtx(input, ctx) {
    return ctx || {
      common: input.parent.common,
      data: input.data,
      parsedType: getParsedType(input.data),
      schemaErrorMap: this._def.errorMap,
      path: input.path,
      parent: input.parent
    };
  }
  _processInputParams(input) {
    return {
      status: new ParseStatus(),
      ctx: {
        common: input.parent.common,
        data: input.data,
        parsedType: getParsedType(input.data),
        schemaErrorMap: this._def.errorMap,
        path: input.path,
        parent: input.parent
      }
    };
  }
  _parseSync(input) {
    const result = this._parse(input);
    if (isAsync(result)) {
      throw new Error("Synchronous parse encountered promise.");
    }
    return result;
  }
  _parseAsync(input) {
    const result = this._parse(input);
    return Promise.resolve(result);
  }
  parse(data, params) {
    const result = this.safeParse(data, params);
    if (result.success)
      return result.data;
    throw result.error;
  }
  safeParse(data, params) {
    var _a;
    const ctx = {
      common: {
        issues: [],
        async: (_a = params === null || params === void 0 ? void 0 : params.async) !== null && _a !== void 0 ? _a : false,
        contextualErrorMap: params === null || params === void 0 ? void 0 : params.errorMap
      },
      path: (params === null || params === void 0 ? void 0 : params.path) || [],
      schemaErrorMap: this._def.errorMap,
      parent: null,
      data,
      parsedType: getParsedType(data)
    };
    const result = this._parseSync({ data, path: ctx.path, parent: ctx });
    return handleResult(ctx, result);
  }
  async parseAsync(data, params) {
    const result = await this.safeParseAsync(data, params);
    if (result.success)
      return result.data;
    throw result.error;
  }
  async safeParseAsync(data, params) {
    const ctx = {
      common: {
        issues: [],
        contextualErrorMap: params === null || params === void 0 ? void 0 : params.errorMap,
        async: true
      },
      path: (params === null || params === void 0 ? void 0 : params.path) || [],
      schemaErrorMap: this._def.errorMap,
      parent: null,
      data,
      parsedType: getParsedType(data)
    };
    const maybeAsyncResult = this._parse({ data, path: ctx.path, parent: ctx });
    const result = await (isAsync(maybeAsyncResult) ? maybeAsyncResult : Promise.resolve(maybeAsyncResult));
    return handleResult(ctx, result);
  }
  refine(check, message) {
    const getIssueProperties = (val) => {
      if (typeof message === "string" || typeof message === "undefined") {
        return { message };
      } else if (typeof message === "function") {
        return message(val);
      } else {
        return message;
      }
    };
    return this._refinement((val, ctx) => {
      const result = check(val);
      const setError = () => ctx.addIssue({
        code: ZodIssueCode.custom,
        ...getIssueProperties(val)
      });
      if (typeof Promise !== "undefined" && result instanceof Promise) {
        return result.then((data) => {
          if (!data) {
            setError();
            return false;
          } else {
            return true;
          }
        });
      }
      if (!result) {
        setError();
        return false;
      } else {
        return true;
      }
    });
  }
  refinement(check, refinementData) {
    return this._refinement((val, ctx) => {
      if (!check(val)) {
        ctx.addIssue(typeof refinementData === "function" ? refinementData(val, ctx) : refinementData);
        return false;
      } else {
        return true;
      }
    });
  }
  _refinement(refinement) {
    return new ZodEffects({
      schema: this,
      typeName: ZodFirstPartyTypeKind.ZodEffects,
      effect: { type: "refinement", refinement }
    });
  }
  superRefine(refinement) {
    return this._refinement(refinement);
  }
  optional() {
    return ZodOptional.create(this, this._def);
  }
  nullable() {
    return ZodNullable.create(this, this._def);
  }
  nullish() {
    return this.nullable().optional();
  }
  array() {
    return ZodArray.create(this, this._def);
  }
  promise() {
    return ZodPromise.create(this, this._def);
  }
  or(option) {
    return ZodUnion.create([this, option], this._def);
  }
  and(incoming) {
    return ZodIntersection.create(this, incoming, this._def);
  }
  transform(transform) {
    return new ZodEffects({
      ...processCreateParams(this._def),
      schema: this,
      typeName: ZodFirstPartyTypeKind.ZodEffects,
      effect: { type: "transform", transform }
    });
  }
  default(def) {
    const defaultValueFunc = typeof def === "function" ? def : () => def;
    return new ZodDefault({
      ...processCreateParams(this._def),
      innerType: this,
      defaultValue: defaultValueFunc,
      typeName: ZodFirstPartyTypeKind.ZodDefault
    });
  }
  brand() {
    return new ZodBranded({
      typeName: ZodFirstPartyTypeKind.ZodBranded,
      type: this,
      ...processCreateParams(this._def)
    });
  }
  catch(def) {
    const catchValueFunc = typeof def === "function" ? def : () => def;
    return new ZodCatch({
      ...processCreateParams(this._def),
      innerType: this,
      catchValue: catchValueFunc,
      typeName: ZodFirstPartyTypeKind.ZodCatch
    });
  }
  describe(description) {
    const This = this.constructor;
    return new This({
      ...this._def,
      description
    });
  }
  pipe(target) {
    return ZodPipeline.create(this, target);
  }
  readonly() {
    return ZodReadonly.create(this);
  }
  isOptional() {
    return this.safeParse(void 0).success;
  }
  isNullable() {
    return this.safeParse(null).success;
  }
};
var cuidRegex = /^c[^\s-]{8,}$/i;
var cuid2Regex = /^[a-z][a-z0-9]*$/;
var ulidRegex = /^[0-9A-HJKMNP-TV-Z]{26}$/;
var uuidRegex = /^[0-9a-fA-F]{8}\b-[0-9a-fA-F]{4}\b-[0-9a-fA-F]{4}\b-[0-9a-fA-F]{4}\b-[0-9a-fA-F]{12}$/i;
var emailRegex = /^(?!\.)(?!.*\.\.)([A-Z0-9_+-\.]*)[A-Z0-9_+-]@([A-Z0-9][A-Z0-9\-]*\.)+[A-Z]{2,}$/i;
var _emojiRegex = `^(\\p{Extended_Pictographic}|\\p{Emoji_Component})+$`;
var emojiRegex;
var ipv4Regex = /^(((25[0-5])|(2[0-4][0-9])|(1[0-9]{2})|([0-9]{1,2}))\.){3}((25[0-5])|(2[0-4][0-9])|(1[0-9]{2})|([0-9]{1,2}))$/;
var ipv6Regex = /^(([a-f0-9]{1,4}:){7}|::([a-f0-9]{1,4}:){0,6}|([a-f0-9]{1,4}:){1}:([a-f0-9]{1,4}:){0,5}|([a-f0-9]{1,4}:){2}:([a-f0-9]{1,4}:){0,4}|([a-f0-9]{1,4}:){3}:([a-f0-9]{1,4}:){0,3}|([a-f0-9]{1,4}:){4}:([a-f0-9]{1,4}:){0,2}|([a-f0-9]{1,4}:){5}:([a-f0-9]{1,4}:){0,1})([a-f0-9]{1,4}|(((25[0-5])|(2[0-4][0-9])|(1[0-9]{2})|([0-9]{1,2}))\.){3}((25[0-5])|(2[0-4][0-9])|(1[0-9]{2})|([0-9]{1,2})))$/;
var datetimeRegex = (args) => {
  if (args.precision) {
    if (args.offset) {
      return new RegExp(`^\\d{4}-\\d{2}-\\d{2}T\\d{2}:\\d{2}:\\d{2}\\.\\d{${args.precision}}(([+-]\\d{2}(:?\\d{2})?)|Z)$`);
    } else {
      return new RegExp(`^\\d{4}-\\d{2}-\\d{2}T\\d{2}:\\d{2}:\\d{2}\\.\\d{${args.precision}}Z$`);
    }
  } else if (args.precision === 0) {
    if (args.offset) {
      return new RegExp(`^\\d{4}-\\d{2}-\\d{2}T\\d{2}:\\d{2}:\\d{2}(([+-]\\d{2}(:?\\d{2})?)|Z)$`);
    } else {
      return new RegExp(`^\\d{4}-\\d{2}-\\d{2}T\\d{2}:\\d{2}:\\d{2}Z$`);
    }
  } else {
    if (args.offset) {
      return new RegExp(`^\\d{4}-\\d{2}-\\d{2}T\\d{2}:\\d{2}:\\d{2}(\\.\\d+)?(([+-]\\d{2}(:?\\d{2})?)|Z)$`);
    } else {
      return new RegExp(`^\\d{4}-\\d{2}-\\d{2}T\\d{2}:\\d{2}:\\d{2}(\\.\\d+)?Z$`);
    }
  }
};
function isValidIP(ip, version) {
  if ((version === "v4" || !version) && ipv4Regex.test(ip)) {
    return true;
  }
  if ((version === "v6" || !version) && ipv6Regex.test(ip)) {
    return true;
  }
  return false;
}
var ZodString = class _ZodString extends ZodType {
  _parse(input) {
    if (this._def.coerce) {
      input.data = String(input.data);
    }
    const parsedType = this._getType(input);
    if (parsedType !== ZodParsedType.string) {
      const ctx2 = this._getOrReturnCtx(input);
      addIssueToContext(
        ctx2,
        {
          code: ZodIssueCode.invalid_type,
          expected: ZodParsedType.string,
          received: ctx2.parsedType
        }
        //
      );
      return INVALID;
    }
    const status = new ParseStatus();
    let ctx = void 0;
    for (const check of this._def.checks) {
      if (check.kind === "min") {
        if (input.data.length < check.value) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.too_small,
            minimum: check.value,
            type: "string",
            inclusive: true,
            exact: false,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "max") {
        if (input.data.length > check.value) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.too_big,
            maximum: check.value,
            type: "string",
            inclusive: true,
            exact: false,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "length") {
        const tooBig = input.data.length > check.value;
        const tooSmall = input.data.length < check.value;
        if (tooBig || tooSmall) {
          ctx = this._getOrReturnCtx(input, ctx);
          if (tooBig) {
            addIssueToContext(ctx, {
              code: ZodIssueCode.too_big,
              maximum: check.value,
              type: "string",
              inclusive: true,
              exact: true,
              message: check.message
            });
          } else if (tooSmall) {
            addIssueToContext(ctx, {
              code: ZodIssueCode.too_small,
              minimum: check.value,
              type: "string",
              inclusive: true,
              exact: true,
              message: check.message
            });
          }
          status.dirty();
        }
      } else if (check.kind === "email") {
        if (!emailRegex.test(input.data)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            validation: "email",
            code: ZodIssueCode.invalid_string,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "emoji") {
        if (!emojiRegex) {
          emojiRegex = new RegExp(_emojiRegex, "u");
        }
        if (!emojiRegex.test(input.data)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            validation: "emoji",
            code: ZodIssueCode.invalid_string,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "uuid") {
        if (!uuidRegex.test(input.data)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            validation: "uuid",
            code: ZodIssueCode.invalid_string,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "cuid") {
        if (!cuidRegex.test(input.data)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            validation: "cuid",
            code: ZodIssueCode.invalid_string,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "cuid2") {
        if (!cuid2Regex.test(input.data)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            validation: "cuid2",
            code: ZodIssueCode.invalid_string,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "ulid") {
        if (!ulidRegex.test(input.data)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            validation: "ulid",
            code: ZodIssueCode.invalid_string,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "url") {
        try {
          new URL(input.data);
        } catch (_a) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            validation: "url",
            code: ZodIssueCode.invalid_string,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "regex") {
        check.regex.lastIndex = 0;
        const testResult = check.regex.test(input.data);
        if (!testResult) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            validation: "regex",
            code: ZodIssueCode.invalid_string,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "trim") {
        input.data = input.data.trim();
      } else if (check.kind === "includes") {
        if (!input.data.includes(check.value, check.position)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.invalid_string,
            validation: { includes: check.value, position: check.position },
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "toLowerCase") {
        input.data = input.data.toLowerCase();
      } else if (check.kind === "toUpperCase") {
        input.data = input.data.toUpperCase();
      } else if (check.kind === "startsWith") {
        if (!input.data.startsWith(check.value)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.invalid_string,
            validation: { startsWith: check.value },
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "endsWith") {
        if (!input.data.endsWith(check.value)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.invalid_string,
            validation: { endsWith: check.value },
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "datetime") {
        const regex = datetimeRegex(check);
        if (!regex.test(input.data)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.invalid_string,
            validation: "datetime",
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "ip") {
        if (!isValidIP(input.data, check.version)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            validation: "ip",
            code: ZodIssueCode.invalid_string,
            message: check.message
          });
          status.dirty();
        }
      } else {
        util.assertNever(check);
      }
    }
    return { status: status.value, value: input.data };
  }
  _regex(regex, validation, message) {
    return this.refinement((data) => regex.test(data), {
      validation,
      code: ZodIssueCode.invalid_string,
      ...errorUtil.errToObj(message)
    });
  }
  _addCheck(check) {
    return new _ZodString({
      ...this._def,
      checks: [...this._def.checks, check]
    });
  }
  email(message) {
    return this._addCheck({ kind: "email", ...errorUtil.errToObj(message) });
  }
  url(message) {
    return this._addCheck({ kind: "url", ...errorUtil.errToObj(message) });
  }
  emoji(message) {
    return this._addCheck({ kind: "emoji", ...errorUtil.errToObj(message) });
  }
  uuid(message) {
    return this._addCheck({ kind: "uuid", ...errorUtil.errToObj(message) });
  }
  cuid(message) {
    return this._addCheck({ kind: "cuid", ...errorUtil.errToObj(message) });
  }
  cuid2(message) {
    return this._addCheck({ kind: "cuid2", ...errorUtil.errToObj(message) });
  }
  ulid(message) {
    return this._addCheck({ kind: "ulid", ...errorUtil.errToObj(message) });
  }
  ip(options) {
    return this._addCheck({ kind: "ip", ...errorUtil.errToObj(options) });
  }
  datetime(options) {
    var _a;
    if (typeof options === "string") {
      return this._addCheck({
        kind: "datetime",
        precision: null,
        offset: false,
        message: options
      });
    }
    return this._addCheck({
      kind: "datetime",
      precision: typeof (options === null || options === void 0 ? void 0 : options.precision) === "undefined" ? null : options === null || options === void 0 ? void 0 : options.precision,
      offset: (_a = options === null || options === void 0 ? void 0 : options.offset) !== null && _a !== void 0 ? _a : false,
      ...errorUtil.errToObj(options === null || options === void 0 ? void 0 : options.message)
    });
  }
  regex(regex, message) {
    return this._addCheck({
      kind: "regex",
      regex,
      ...errorUtil.errToObj(message)
    });
  }
  includes(value, options) {
    return this._addCheck({
      kind: "includes",
      value,
      position: options === null || options === void 0 ? void 0 : options.position,
      ...errorUtil.errToObj(options === null || options === void 0 ? void 0 : options.message)
    });
  }
  startsWith(value, message) {
    return this._addCheck({
      kind: "startsWith",
      value,
      ...errorUtil.errToObj(message)
    });
  }
  endsWith(value, message) {
    return this._addCheck({
      kind: "endsWith",
      value,
      ...errorUtil.errToObj(message)
    });
  }
  min(minLength, message) {
    return this._addCheck({
      kind: "min",
      value: minLength,
      ...errorUtil.errToObj(message)
    });
  }
  max(maxLength, message) {
    return this._addCheck({
      kind: "max",
      value: maxLength,
      ...errorUtil.errToObj(message)
    });
  }
  length(len, message) {
    return this._addCheck({
      kind: "length",
      value: len,
      ...errorUtil.errToObj(message)
    });
  }
  /**
   * @deprecated Use z.string().min(1) instead.
   * @see {@link ZodString.min}
   */
  nonempty(message) {
    return this.min(1, errorUtil.errToObj(message));
  }
  trim() {
    return new _ZodString({
      ...this._def,
      checks: [...this._def.checks, { kind: "trim" }]
    });
  }
  toLowerCase() {
    return new _ZodString({
      ...this._def,
      checks: [...this._def.checks, { kind: "toLowerCase" }]
    });
  }
  toUpperCase() {
    return new _ZodString({
      ...this._def,
      checks: [...this._def.checks, { kind: "toUpperCase" }]
    });
  }
  get isDatetime() {
    return !!this._def.checks.find((ch) => ch.kind === "datetime");
  }
  get isEmail() {
    return !!this._def.checks.find((ch) => ch.kind === "email");
  }
  get isURL() {
    return !!this._def.checks.find((ch) => ch.kind === "url");
  }
  get isEmoji() {
    return !!this._def.checks.find((ch) => ch.kind === "emoji");
  }
  get isUUID() {
    return !!this._def.checks.find((ch) => ch.kind === "uuid");
  }
  get isCUID() {
    return !!this._def.checks.find((ch) => ch.kind === "cuid");
  }
  get isCUID2() {
    return !!this._def.checks.find((ch) => ch.kind === "cuid2");
  }
  get isULID() {
    return !!this._def.checks.find((ch) => ch.kind === "ulid");
  }
  get isIP() {
    return !!this._def.checks.find((ch) => ch.kind === "ip");
  }
  get minLength() {
    let min = null;
    for (const ch of this._def.checks) {
      if (ch.kind === "min") {
        if (min === null || ch.value > min)
          min = ch.value;
      }
    }
    return min;
  }
  get maxLength() {
    let max = null;
    for (const ch of this._def.checks) {
      if (ch.kind === "max") {
        if (max === null || ch.value < max)
          max = ch.value;
      }
    }
    return max;
  }
};
ZodString.create = (params) => {
  var _a;
  return new ZodString({
    checks: [],
    typeName: ZodFirstPartyTypeKind.ZodString,
    coerce: (_a = params === null || params === void 0 ? void 0 : params.coerce) !== null && _a !== void 0 ? _a : false,
    ...processCreateParams(params)
  });
};
function floatSafeRemainder(val, step) {
  const valDecCount = (val.toString().split(".")[1] || "").length;
  const stepDecCount = (step.toString().split(".")[1] || "").length;
  const decCount = valDecCount > stepDecCount ? valDecCount : stepDecCount;
  const valInt = parseInt(val.toFixed(decCount).replace(".", ""));
  const stepInt = parseInt(step.toFixed(decCount).replace(".", ""));
  return valInt % stepInt / Math.pow(10, decCount);
}
var ZodNumber = class _ZodNumber extends ZodType {
  constructor() {
    super(...arguments);
    this.min = this.gte;
    this.max = this.lte;
    this.step = this.multipleOf;
  }
  _parse(input) {
    if (this._def.coerce) {
      input.data = Number(input.data);
    }
    const parsedType = this._getType(input);
    if (parsedType !== ZodParsedType.number) {
      const ctx2 = this._getOrReturnCtx(input);
      addIssueToContext(ctx2, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.number,
        received: ctx2.parsedType
      });
      return INVALID;
    }
    let ctx = void 0;
    const status = new ParseStatus();
    for (const check of this._def.checks) {
      if (check.kind === "int") {
        if (!util.isInteger(input.data)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.invalid_type,
            expected: "integer",
            received: "float",
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "min") {
        const tooSmall = check.inclusive ? input.data < check.value : input.data <= check.value;
        if (tooSmall) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.too_small,
            minimum: check.value,
            type: "number",
            inclusive: check.inclusive,
            exact: false,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "max") {
        const tooBig = check.inclusive ? input.data > check.value : input.data >= check.value;
        if (tooBig) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.too_big,
            maximum: check.value,
            type: "number",
            inclusive: check.inclusive,
            exact: false,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "multipleOf") {
        if (floatSafeRemainder(input.data, check.value) !== 0) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.not_multiple_of,
            multipleOf: check.value,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "finite") {
        if (!Number.isFinite(input.data)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.not_finite,
            message: check.message
          });
          status.dirty();
        }
      } else {
        util.assertNever(check);
      }
    }
    return { status: status.value, value: input.data };
  }
  gte(value, message) {
    return this.setLimit("min", value, true, errorUtil.toString(message));
  }
  gt(value, message) {
    return this.setLimit("min", value, false, errorUtil.toString(message));
  }
  lte(value, message) {
    return this.setLimit("max", value, true, errorUtil.toString(message));
  }
  lt(value, message) {
    return this.setLimit("max", value, false, errorUtil.toString(message));
  }
  setLimit(kind, value, inclusive, message) {
    return new _ZodNumber({
      ...this._def,
      checks: [
        ...this._def.checks,
        {
          kind,
          value,
          inclusive,
          message: errorUtil.toString(message)
        }
      ]
    });
  }
  _addCheck(check) {
    return new _ZodNumber({
      ...this._def,
      checks: [...this._def.checks, check]
    });
  }
  int(message) {
    return this._addCheck({
      kind: "int",
      message: errorUtil.toString(message)
    });
  }
  positive(message) {
    return this._addCheck({
      kind: "min",
      value: 0,
      inclusive: false,
      message: errorUtil.toString(message)
    });
  }
  negative(message) {
    return this._addCheck({
      kind: "max",
      value: 0,
      inclusive: false,
      message: errorUtil.toString(message)
    });
  }
  nonpositive(message) {
    return this._addCheck({
      kind: "max",
      value: 0,
      inclusive: true,
      message: errorUtil.toString(message)
    });
  }
  nonnegative(message) {
    return this._addCheck({
      kind: "min",
      value: 0,
      inclusive: true,
      message: errorUtil.toString(message)
    });
  }
  multipleOf(value, message) {
    return this._addCheck({
      kind: "multipleOf",
      value,
      message: errorUtil.toString(message)
    });
  }
  finite(message) {
    return this._addCheck({
      kind: "finite",
      message: errorUtil.toString(message)
    });
  }
  safe(message) {
    return this._addCheck({
      kind: "min",
      inclusive: true,
      value: Number.MIN_SAFE_INTEGER,
      message: errorUtil.toString(message)
    })._addCheck({
      kind: "max",
      inclusive: true,
      value: Number.MAX_SAFE_INTEGER,
      message: errorUtil.toString(message)
    });
  }
  get minValue() {
    let min = null;
    for (const ch of this._def.checks) {
      if (ch.kind === "min") {
        if (min === null || ch.value > min)
          min = ch.value;
      }
    }
    return min;
  }
  get maxValue() {
    let max = null;
    for (const ch of this._def.checks) {
      if (ch.kind === "max") {
        if (max === null || ch.value < max)
          max = ch.value;
      }
    }
    return max;
  }
  get isInt() {
    return !!this._def.checks.find((ch) => ch.kind === "int" || ch.kind === "multipleOf" && util.isInteger(ch.value));
  }
  get isFinite() {
    let max = null, min = null;
    for (const ch of this._def.checks) {
      if (ch.kind === "finite" || ch.kind === "int" || ch.kind === "multipleOf") {
        return true;
      } else if (ch.kind === "min") {
        if (min === null || ch.value > min)
          min = ch.value;
      } else if (ch.kind === "max") {
        if (max === null || ch.value < max)
          max = ch.value;
      }
    }
    return Number.isFinite(min) && Number.isFinite(max);
  }
};
ZodNumber.create = (params) => {
  return new ZodNumber({
    checks: [],
    typeName: ZodFirstPartyTypeKind.ZodNumber,
    coerce: (params === null || params === void 0 ? void 0 : params.coerce) || false,
    ...processCreateParams(params)
  });
};
var ZodBigInt = class _ZodBigInt extends ZodType {
  constructor() {
    super(...arguments);
    this.min = this.gte;
    this.max = this.lte;
  }
  _parse(input) {
    if (this._def.coerce) {
      input.data = BigInt(input.data);
    }
    const parsedType = this._getType(input);
    if (parsedType !== ZodParsedType.bigint) {
      const ctx2 = this._getOrReturnCtx(input);
      addIssueToContext(ctx2, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.bigint,
        received: ctx2.parsedType
      });
      return INVALID;
    }
    let ctx = void 0;
    const status = new ParseStatus();
    for (const check of this._def.checks) {
      if (check.kind === "min") {
        const tooSmall = check.inclusive ? input.data < check.value : input.data <= check.value;
        if (tooSmall) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.too_small,
            type: "bigint",
            minimum: check.value,
            inclusive: check.inclusive,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "max") {
        const tooBig = check.inclusive ? input.data > check.value : input.data >= check.value;
        if (tooBig) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.too_big,
            type: "bigint",
            maximum: check.value,
            inclusive: check.inclusive,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "multipleOf") {
        if (input.data % check.value !== BigInt(0)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.not_multiple_of,
            multipleOf: check.value,
            message: check.message
          });
          status.dirty();
        }
      } else {
        util.assertNever(check);
      }
    }
    return { status: status.value, value: input.data };
  }
  gte(value, message) {
    return this.setLimit("min", value, true, errorUtil.toString(message));
  }
  gt(value, message) {
    return this.setLimit("min", value, false, errorUtil.toString(message));
  }
  lte(value, message) {
    return this.setLimit("max", value, true, errorUtil.toString(message));
  }
  lt(value, message) {
    return this.setLimit("max", value, false, errorUtil.toString(message));
  }
  setLimit(kind, value, inclusive, message) {
    return new _ZodBigInt({
      ...this._def,
      checks: [
        ...this._def.checks,
        {
          kind,
          value,
          inclusive,
          message: errorUtil.toString(message)
        }
      ]
    });
  }
  _addCheck(check) {
    return new _ZodBigInt({
      ...this._def,
      checks: [...this._def.checks, check]
    });
  }
  positive(message) {
    return this._addCheck({
      kind: "min",
      value: BigInt(0),
      inclusive: false,
      message: errorUtil.toString(message)
    });
  }
  negative(message) {
    return this._addCheck({
      kind: "max",
      value: BigInt(0),
      inclusive: false,
      message: errorUtil.toString(message)
    });
  }
  nonpositive(message) {
    return this._addCheck({
      kind: "max",
      value: BigInt(0),
      inclusive: true,
      message: errorUtil.toString(message)
    });
  }
  nonnegative(message) {
    return this._addCheck({
      kind: "min",
      value: BigInt(0),
      inclusive: true,
      message: errorUtil.toString(message)
    });
  }
  multipleOf(value, message) {
    return this._addCheck({
      kind: "multipleOf",
      value,
      message: errorUtil.toString(message)
    });
  }
  get minValue() {
    let min = null;
    for (const ch of this._def.checks) {
      if (ch.kind === "min") {
        if (min === null || ch.value > min)
          min = ch.value;
      }
    }
    return min;
  }
  get maxValue() {
    let max = null;
    for (const ch of this._def.checks) {
      if (ch.kind === "max") {
        if (max === null || ch.value < max)
          max = ch.value;
      }
    }
    return max;
  }
};
ZodBigInt.create = (params) => {
  var _a;
  return new ZodBigInt({
    checks: [],
    typeName: ZodFirstPartyTypeKind.ZodBigInt,
    coerce: (_a = params === null || params === void 0 ? void 0 : params.coerce) !== null && _a !== void 0 ? _a : false,
    ...processCreateParams(params)
  });
};
var ZodBoolean = class extends ZodType {
  _parse(input) {
    if (this._def.coerce) {
      input.data = Boolean(input.data);
    }
    const parsedType = this._getType(input);
    if (parsedType !== ZodParsedType.boolean) {
      const ctx = this._getOrReturnCtx(input);
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.boolean,
        received: ctx.parsedType
      });
      return INVALID;
    }
    return OK(input.data);
  }
};
ZodBoolean.create = (params) => {
  return new ZodBoolean({
    typeName: ZodFirstPartyTypeKind.ZodBoolean,
    coerce: (params === null || params === void 0 ? void 0 : params.coerce) || false,
    ...processCreateParams(params)
  });
};
var ZodDate = class _ZodDate extends ZodType {
  _parse(input) {
    if (this._def.coerce) {
      input.data = new Date(input.data);
    }
    const parsedType = this._getType(input);
    if (parsedType !== ZodParsedType.date) {
      const ctx2 = this._getOrReturnCtx(input);
      addIssueToContext(ctx2, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.date,
        received: ctx2.parsedType
      });
      return INVALID;
    }
    if (isNaN(input.data.getTime())) {
      const ctx2 = this._getOrReturnCtx(input);
      addIssueToContext(ctx2, {
        code: ZodIssueCode.invalid_date
      });
      return INVALID;
    }
    const status = new ParseStatus();
    let ctx = void 0;
    for (const check of this._def.checks) {
      if (check.kind === "min") {
        if (input.data.getTime() < check.value) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.too_small,
            message: check.message,
            inclusive: true,
            exact: false,
            minimum: check.value,
            type: "date"
          });
          status.dirty();
        }
      } else if (check.kind === "max") {
        if (input.data.getTime() > check.value) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.too_big,
            message: check.message,
            inclusive: true,
            exact: false,
            maximum: check.value,
            type: "date"
          });
          status.dirty();
        }
      } else {
        util.assertNever(check);
      }
    }
    return {
      status: status.value,
      value: new Date(input.data.getTime())
    };
  }
  _addCheck(check) {
    return new _ZodDate({
      ...this._def,
      checks: [...this._def.checks, check]
    });
  }
  min(minDate, message) {
    return this._addCheck({
      kind: "min",
      value: minDate.getTime(),
      message: errorUtil.toString(message)
    });
  }
  max(maxDate, message) {
    return this._addCheck({
      kind: "max",
      value: maxDate.getTime(),
      message: errorUtil.toString(message)
    });
  }
  get minDate() {
    let min = null;
    for (const ch of this._def.checks) {
      if (ch.kind === "min") {
        if (min === null || ch.value > min)
          min = ch.value;
      }
    }
    return min != null ? new Date(min) : null;
  }
  get maxDate() {
    let max = null;
    for (const ch of this._def.checks) {
      if (ch.kind === "max") {
        if (max === null || ch.value < max)
          max = ch.value;
      }
    }
    return max != null ? new Date(max) : null;
  }
};
ZodDate.create = (params) => {
  return new ZodDate({
    checks: [],
    coerce: (params === null || params === void 0 ? void 0 : params.coerce) || false,
    typeName: ZodFirstPartyTypeKind.ZodDate,
    ...processCreateParams(params)
  });
};
var ZodSymbol = class extends ZodType {
  _parse(input) {
    const parsedType = this._getType(input);
    if (parsedType !== ZodParsedType.symbol) {
      const ctx = this._getOrReturnCtx(input);
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.symbol,
        received: ctx.parsedType
      });
      return INVALID;
    }
    return OK(input.data);
  }
};
ZodSymbol.create = (params) => {
  return new ZodSymbol({
    typeName: ZodFirstPartyTypeKind.ZodSymbol,
    ...processCreateParams(params)
  });
};
var ZodUndefined = class extends ZodType {
  _parse(input) {
    const parsedType = this._getType(input);
    if (parsedType !== ZodParsedType.undefined) {
      const ctx = this._getOrReturnCtx(input);
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.undefined,
        received: ctx.parsedType
      });
      return INVALID;
    }
    return OK(input.data);
  }
};
ZodUndefined.create = (params) => {
  return new ZodUndefined({
    typeName: ZodFirstPartyTypeKind.ZodUndefined,
    ...processCreateParams(params)
  });
};
var ZodNull = class extends ZodType {
  _parse(input) {
    const parsedType = this._getType(input);
    if (parsedType !== ZodParsedType.null) {
      const ctx = this._getOrReturnCtx(input);
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.null,
        received: ctx.parsedType
      });
      return INVALID;
    }
    return OK(input.data);
  }
};
ZodNull.create = (params) => {
  return new ZodNull({
    typeName: ZodFirstPartyTypeKind.ZodNull,
    ...processCreateParams(params)
  });
};
var ZodAny = class extends ZodType {
  constructor() {
    super(...arguments);
    this._any = true;
  }
  _parse(input) {
    return OK(input.data);
  }
};
ZodAny.create = (params) => {
  return new ZodAny({
    typeName: ZodFirstPartyTypeKind.ZodAny,
    ...processCreateParams(params)
  });
};
var ZodUnknown = class extends ZodType {
  constructor() {
    super(...arguments);
    this._unknown = true;
  }
  _parse(input) {
    return OK(input.data);
  }
};
ZodUnknown.create = (params) => {
  return new ZodUnknown({
    typeName: ZodFirstPartyTypeKind.ZodUnknown,
    ...processCreateParams(params)
  });
};
var ZodNever = class extends ZodType {
  _parse(input) {
    const ctx = this._getOrReturnCtx(input);
    addIssueToContext(ctx, {
      code: ZodIssueCode.invalid_type,
      expected: ZodParsedType.never,
      received: ctx.parsedType
    });
    return INVALID;
  }
};
ZodNever.create = (params) => {
  return new ZodNever({
    typeName: ZodFirstPartyTypeKind.ZodNever,
    ...processCreateParams(params)
  });
};
var ZodVoid = class extends ZodType {
  _parse(input) {
    const parsedType = this._getType(input);
    if (parsedType !== ZodParsedType.undefined) {
      const ctx = this._getOrReturnCtx(input);
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.void,
        received: ctx.parsedType
      });
      return INVALID;
    }
    return OK(input.data);
  }
};
ZodVoid.create = (params) => {
  return new ZodVoid({
    typeName: ZodFirstPartyTypeKind.ZodVoid,
    ...processCreateParams(params)
  });
};
var ZodArray = class _ZodArray extends ZodType {
  _parse(input) {
    const { ctx, status } = this._processInputParams(input);
    const def = this._def;
    if (ctx.parsedType !== ZodParsedType.array) {
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.array,
        received: ctx.parsedType
      });
      return INVALID;
    }
    if (def.exactLength !== null) {
      const tooBig = ctx.data.length > def.exactLength.value;
      const tooSmall = ctx.data.length < def.exactLength.value;
      if (tooBig || tooSmall) {
        addIssueToContext(ctx, {
          code: tooBig ? ZodIssueCode.too_big : ZodIssueCode.too_small,
          minimum: tooSmall ? def.exactLength.value : void 0,
          maximum: tooBig ? def.exactLength.value : void 0,
          type: "array",
          inclusive: true,
          exact: true,
          message: def.exactLength.message
        });
        status.dirty();
      }
    }
    if (def.minLength !== null) {
      if (ctx.data.length < def.minLength.value) {
        addIssueToContext(ctx, {
          code: ZodIssueCode.too_small,
          minimum: def.minLength.value,
          type: "array",
          inclusive: true,
          exact: false,
          message: def.minLength.message
        });
        status.dirty();
      }
    }
    if (def.maxLength !== null) {
      if (ctx.data.length > def.maxLength.value) {
        addIssueToContext(ctx, {
          code: ZodIssueCode.too_big,
          maximum: def.maxLength.value,
          type: "array",
          inclusive: true,
          exact: false,
          message: def.maxLength.message
        });
        status.dirty();
      }
    }
    if (ctx.common.async) {
      return Promise.all([...ctx.data].map((item, i) => {
        return def.type._parseAsync(new ParseInputLazyPath(ctx, item, ctx.path, i));
      })).then((result2) => {
        return ParseStatus.mergeArray(status, result2);
      });
    }
    const result = [...ctx.data].map((item, i) => {
      return def.type._parseSync(new ParseInputLazyPath(ctx, item, ctx.path, i));
    });
    return ParseStatus.mergeArray(status, result);
  }
  get element() {
    return this._def.type;
  }
  min(minLength, message) {
    return new _ZodArray({
      ...this._def,
      minLength: { value: minLength, message: errorUtil.toString(message) }
    });
  }
  max(maxLength, message) {
    return new _ZodArray({
      ...this._def,
      maxLength: { value: maxLength, message: errorUtil.toString(message) }
    });
  }
  length(len, message) {
    return new _ZodArray({
      ...this._def,
      exactLength: { value: len, message: errorUtil.toString(message) }
    });
  }
  nonempty(message) {
    return this.min(1, message);
  }
};
ZodArray.create = (schema, params) => {
  return new ZodArray({
    type: schema,
    minLength: null,
    maxLength: null,
    exactLength: null,
    typeName: ZodFirstPartyTypeKind.ZodArray,
    ...processCreateParams(params)
  });
};
function deepPartialify(schema) {
  if (schema instanceof ZodObject) {
    const newShape = {};
    for (const key in schema.shape) {
      const fieldSchema = schema.shape[key];
      newShape[key] = ZodOptional.create(deepPartialify(fieldSchema));
    }
    return new ZodObject({
      ...schema._def,
      shape: () => newShape
    });
  } else if (schema instanceof ZodArray) {
    return new ZodArray({
      ...schema._def,
      type: deepPartialify(schema.element)
    });
  } else if (schema instanceof ZodOptional) {
    return ZodOptional.create(deepPartialify(schema.unwrap()));
  } else if (schema instanceof ZodNullable) {
    return ZodNullable.create(deepPartialify(schema.unwrap()));
  } else if (schema instanceof ZodTuple) {
    return ZodTuple.create(schema.items.map((item) => deepPartialify(item)));
  } else {
    return schema;
  }
}
var ZodObject = class _ZodObject extends ZodType {
  constructor() {
    super(...arguments);
    this._cached = null;
    this.nonstrict = this.passthrough;
    this.augment = this.extend;
  }
  _getCached() {
    if (this._cached !== null)
      return this._cached;
    const shape = this._def.shape();
    const keys = util.objectKeys(shape);
    return this._cached = { shape, keys };
  }
  _parse(input) {
    const parsedType = this._getType(input);
    if (parsedType !== ZodParsedType.object) {
      const ctx2 = this._getOrReturnCtx(input);
      addIssueToContext(ctx2, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.object,
        received: ctx2.parsedType
      });
      return INVALID;
    }
    const { status, ctx } = this._processInputParams(input);
    const { shape, keys: shapeKeys } = this._getCached();
    const extraKeys = [];
    if (!(this._def.catchall instanceof ZodNever && this._def.unknownKeys === "strip")) {
      for (const key in ctx.data) {
        if (!shapeKeys.includes(key)) {
          extraKeys.push(key);
        }
      }
    }
    const pairs = [];
    for (const key of shapeKeys) {
      const keyValidator = shape[key];
      const value = ctx.data[key];
      pairs.push({
        key: { status: "valid", value: key },
        value: keyValidator._parse(new ParseInputLazyPath(ctx, value, ctx.path, key)),
        alwaysSet: key in ctx.data
      });
    }
    if (this._def.catchall instanceof ZodNever) {
      const unknownKeys = this._def.unknownKeys;
      if (unknownKeys === "passthrough") {
        for (const key of extraKeys) {
          pairs.push({
            key: { status: "valid", value: key },
            value: { status: "valid", value: ctx.data[key] }
          });
        }
      } else if (unknownKeys === "strict") {
        if (extraKeys.length > 0) {
          addIssueToContext(ctx, {
            code: ZodIssueCode.unrecognized_keys,
            keys: extraKeys
          });
          status.dirty();
        }
      } else if (unknownKeys === "strip")
        ;
      else {
        throw new Error(`Internal ZodObject error: invalid unknownKeys value.`);
      }
    } else {
      const catchall = this._def.catchall;
      for (const key of extraKeys) {
        const value = ctx.data[key];
        pairs.push({
          key: { status: "valid", value: key },
          value: catchall._parse(
            new ParseInputLazyPath(ctx, value, ctx.path, key)
            //, ctx.child(key), value, getParsedType(value)
          ),
          alwaysSet: key in ctx.data
        });
      }
    }
    if (ctx.common.async) {
      return Promise.resolve().then(async () => {
        const syncPairs = [];
        for (const pair of pairs) {
          const key = await pair.key;
          syncPairs.push({
            key,
            value: await pair.value,
            alwaysSet: pair.alwaysSet
          });
        }
        return syncPairs;
      }).then((syncPairs) => {
        return ParseStatus.mergeObjectSync(status, syncPairs);
      });
    } else {
      return ParseStatus.mergeObjectSync(status, pairs);
    }
  }
  get shape() {
    return this._def.shape();
  }
  strict(message) {
    errorUtil.errToObj;
    return new _ZodObject({
      ...this._def,
      unknownKeys: "strict",
      ...message !== void 0 ? {
        errorMap: (issue, ctx) => {
          var _a, _b, _c, _d;
          const defaultError = (_c = (_b = (_a = this._def).errorMap) === null || _b === void 0 ? void 0 : _b.call(_a, issue, ctx).message) !== null && _c !== void 0 ? _c : ctx.defaultError;
          if (issue.code === "unrecognized_keys")
            return {
              message: (_d = errorUtil.errToObj(message).message) !== null && _d !== void 0 ? _d : defaultError
            };
          return {
            message: defaultError
          };
        }
      } : {}
    });
  }
  strip() {
    return new _ZodObject({
      ...this._def,
      unknownKeys: "strip"
    });
  }
  passthrough() {
    return new _ZodObject({
      ...this._def,
      unknownKeys: "passthrough"
    });
  }
  // const AugmentFactory =
  //   <Def extends ZodObjectDef>(def: Def) =>
  //   <Augmentation extends ZodRawShape>(
  //     augmentation: Augmentation
  //   ): ZodObject<
  //     extendShape<ReturnType<Def["shape"]>, Augmentation>,
  //     Def["unknownKeys"],
  //     Def["catchall"]
  //   > => {
  //     return new ZodObject({
  //       ...def,
  //       shape: () => ({
  //         ...def.shape(),
  //         ...augmentation,
  //       }),
  //     }) as any;
  //   };
  extend(augmentation) {
    return new _ZodObject({
      ...this._def,
      shape: () => ({
        ...this._def.shape(),
        ...augmentation
      })
    });
  }
  /**
   * Prior to zod@1.0.12 there was a bug in the
   * inferred type of merged objects. Please
   * upgrade if you are experiencing issues.
   */
  merge(merging) {
    const merged = new _ZodObject({
      unknownKeys: merging._def.unknownKeys,
      catchall: merging._def.catchall,
      shape: () => ({
        ...this._def.shape(),
        ...merging._def.shape()
      }),
      typeName: ZodFirstPartyTypeKind.ZodObject
    });
    return merged;
  }
  // merge<
  //   Incoming extends AnyZodObject,
  //   Augmentation extends Incoming["shape"],
  //   NewOutput extends {
  //     [k in keyof Augmentation | keyof Output]: k extends keyof Augmentation
  //       ? Augmentation[k]["_output"]
  //       : k extends keyof Output
  //       ? Output[k]
  //       : never;
  //   },
  //   NewInput extends {
  //     [k in keyof Augmentation | keyof Input]: k extends keyof Augmentation
  //       ? Augmentation[k]["_input"]
  //       : k extends keyof Input
  //       ? Input[k]
  //       : never;
  //   }
  // >(
  //   merging: Incoming
  // ): ZodObject<
  //   extendShape<T, ReturnType<Incoming["_def"]["shape"]>>,
  //   Incoming["_def"]["unknownKeys"],
  //   Incoming["_def"]["catchall"],
  //   NewOutput,
  //   NewInput
  // > {
  //   const merged: any = new ZodObject({
  //     unknownKeys: merging._def.unknownKeys,
  //     catchall: merging._def.catchall,
  //     shape: () =>
  //       objectUtil.mergeShapes(this._def.shape(), merging._def.shape()),
  //     typeName: ZodFirstPartyTypeKind.ZodObject,
  //   }) as any;
  //   return merged;
  // }
  setKey(key, schema) {
    return this.augment({ [key]: schema });
  }
  // merge<Incoming extends AnyZodObject>(
  //   merging: Incoming
  // ): //ZodObject<T & Incoming["_shape"], UnknownKeys, Catchall> = (merging) => {
  // ZodObject<
  //   extendShape<T, ReturnType<Incoming["_def"]["shape"]>>,
  //   Incoming["_def"]["unknownKeys"],
  //   Incoming["_def"]["catchall"]
  // > {
  //   // const mergedShape = objectUtil.mergeShapes(
  //   //   this._def.shape(),
  //   //   merging._def.shape()
  //   // );
  //   const merged: any = new ZodObject({
  //     unknownKeys: merging._def.unknownKeys,
  //     catchall: merging._def.catchall,
  //     shape: () =>
  //       objectUtil.mergeShapes(this._def.shape(), merging._def.shape()),
  //     typeName: ZodFirstPartyTypeKind.ZodObject,
  //   }) as any;
  //   return merged;
  // }
  catchall(index) {
    return new _ZodObject({
      ...this._def,
      catchall: index
    });
  }
  pick(mask) {
    const shape = {};
    util.objectKeys(mask).forEach((key) => {
      if (mask[key] && this.shape[key]) {
        shape[key] = this.shape[key];
      }
    });
    return new _ZodObject({
      ...this._def,
      shape: () => shape
    });
  }
  omit(mask) {
    const shape = {};
    util.objectKeys(this.shape).forEach((key) => {
      if (!mask[key]) {
        shape[key] = this.shape[key];
      }
    });
    return new _ZodObject({
      ...this._def,
      shape: () => shape
    });
  }
  /**
   * @deprecated
   */
  deepPartial() {
    return deepPartialify(this);
  }
  partial(mask) {
    const newShape = {};
    util.objectKeys(this.shape).forEach((key) => {
      const fieldSchema = this.shape[key];
      if (mask && !mask[key]) {
        newShape[key] = fieldSchema;
      } else {
        newShape[key] = fieldSchema.optional();
      }
    });
    return new _ZodObject({
      ...this._def,
      shape: () => newShape
    });
  }
  required(mask) {
    const newShape = {};
    util.objectKeys(this.shape).forEach((key) => {
      if (mask && !mask[key]) {
        newShape[key] = this.shape[key];
      } else {
        const fieldSchema = this.shape[key];
        let newField = fieldSchema;
        while (newField instanceof ZodOptional) {
          newField = newField._def.innerType;
        }
        newShape[key] = newField;
      }
    });
    return new _ZodObject({
      ...this._def,
      shape: () => newShape
    });
  }
  keyof() {
    return createZodEnum(util.objectKeys(this.shape));
  }
};
ZodObject.create = (shape, params) => {
  return new ZodObject({
    shape: () => shape,
    unknownKeys: "strip",
    catchall: ZodNever.create(),
    typeName: ZodFirstPartyTypeKind.ZodObject,
    ...processCreateParams(params)
  });
};
ZodObject.strictCreate = (shape, params) => {
  return new ZodObject({
    shape: () => shape,
    unknownKeys: "strict",
    catchall: ZodNever.create(),
    typeName: ZodFirstPartyTypeKind.ZodObject,
    ...processCreateParams(params)
  });
};
ZodObject.lazycreate = (shape, params) => {
  return new ZodObject({
    shape,
    unknownKeys: "strip",
    catchall: ZodNever.create(),
    typeName: ZodFirstPartyTypeKind.ZodObject,
    ...processCreateParams(params)
  });
};
var ZodUnion = class extends ZodType {
  _parse(input) {
    const { ctx } = this._processInputParams(input);
    const options = this._def.options;
    function handleResults(results) {
      for (const result of results) {
        if (result.result.status === "valid") {
          return result.result;
        }
      }
      for (const result of results) {
        if (result.result.status === "dirty") {
          ctx.common.issues.push(...result.ctx.common.issues);
          return result.result;
        }
      }
      const unionErrors = results.map((result) => new ZodError(result.ctx.common.issues));
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_union,
        unionErrors
      });
      return INVALID;
    }
    if (ctx.common.async) {
      return Promise.all(options.map(async (option) => {
        const childCtx = {
          ...ctx,
          common: {
            ...ctx.common,
            issues: []
          },
          parent: null
        };
        return {
          result: await option._parseAsync({
            data: ctx.data,
            path: ctx.path,
            parent: childCtx
          }),
          ctx: childCtx
        };
      })).then(handleResults);
    } else {
      let dirty = void 0;
      const issues = [];
      for (const option of options) {
        const childCtx = {
          ...ctx,
          common: {
            ...ctx.common,
            issues: []
          },
          parent: null
        };
        const result = option._parseSync({
          data: ctx.data,
          path: ctx.path,
          parent: childCtx
        });
        if (result.status === "valid") {
          return result;
        } else if (result.status === "dirty" && !dirty) {
          dirty = { result, ctx: childCtx };
        }
        if (childCtx.common.issues.length) {
          issues.push(childCtx.common.issues);
        }
      }
      if (dirty) {
        ctx.common.issues.push(...dirty.ctx.common.issues);
        return dirty.result;
      }
      const unionErrors = issues.map((issues2) => new ZodError(issues2));
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_union,
        unionErrors
      });
      return INVALID;
    }
  }
  get options() {
    return this._def.options;
  }
};
ZodUnion.create = (types, params) => {
  return new ZodUnion({
    options: types,
    typeName: ZodFirstPartyTypeKind.ZodUnion,
    ...processCreateParams(params)
  });
};
var getDiscriminator = (type) => {
  if (type instanceof ZodLazy) {
    return getDiscriminator(type.schema);
  } else if (type instanceof ZodEffects) {
    return getDiscriminator(type.innerType());
  } else if (type instanceof ZodLiteral) {
    return [type.value];
  } else if (type instanceof ZodEnum) {
    return type.options;
  } else if (type instanceof ZodNativeEnum) {
    return Object.keys(type.enum);
  } else if (type instanceof ZodDefault) {
    return getDiscriminator(type._def.innerType);
  } else if (type instanceof ZodUndefined) {
    return [void 0];
  } else if (type instanceof ZodNull) {
    return [null];
  } else {
    return null;
  }
};
var ZodDiscriminatedUnion = class _ZodDiscriminatedUnion extends ZodType {
  _parse(input) {
    const { ctx } = this._processInputParams(input);
    if (ctx.parsedType !== ZodParsedType.object) {
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.object,
        received: ctx.parsedType
      });
      return INVALID;
    }
    const discriminator = this.discriminator;
    const discriminatorValue = ctx.data[discriminator];
    const option = this.optionsMap.get(discriminatorValue);
    if (!option) {
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_union_discriminator,
        options: Array.from(this.optionsMap.keys()),
        path: [discriminator]
      });
      return INVALID;
    }
    if (ctx.common.async) {
      return option._parseAsync({
        data: ctx.data,
        path: ctx.path,
        parent: ctx
      });
    } else {
      return option._parseSync({
        data: ctx.data,
        path: ctx.path,
        parent: ctx
      });
    }
  }
  get discriminator() {
    return this._def.discriminator;
  }
  get options() {
    return this._def.options;
  }
  get optionsMap() {
    return this._def.optionsMap;
  }
  /**
   * The constructor of the discriminated union schema. Its behaviour is very similar to that of the normal z.union() constructor.
   * However, it only allows a union of objects, all of which need to share a discriminator property. This property must
   * have a different value for each object in the union.
   * @param discriminator the name of the discriminator property
   * @param types an array of object schemas
   * @param params
   */
  static create(discriminator, options, params) {
    const optionsMap = /* @__PURE__ */ new Map();
    for (const type of options) {
      const discriminatorValues = getDiscriminator(type.shape[discriminator]);
      if (!discriminatorValues) {
        throw new Error(`A discriminator value for key \`${discriminator}\` could not be extracted from all schema options`);
      }
      for (const value of discriminatorValues) {
        if (optionsMap.has(value)) {
          throw new Error(`Discriminator property ${String(discriminator)} has duplicate value ${String(value)}`);
        }
        optionsMap.set(value, type);
      }
    }
    return new _ZodDiscriminatedUnion({
      typeName: ZodFirstPartyTypeKind.ZodDiscriminatedUnion,
      discriminator,
      options,
      optionsMap,
      ...processCreateParams(params)
    });
  }
};
function mergeValues(a, b) {
  const aType = getParsedType(a);
  const bType = getParsedType(b);
  if (a === b) {
    return { valid: true, data: a };
  } else if (aType === ZodParsedType.object && bType === ZodParsedType.object) {
    const bKeys = util.objectKeys(b);
    const sharedKeys = util.objectKeys(a).filter((key) => bKeys.indexOf(key) !== -1);
    const newObj = { ...a, ...b };
    for (const key of sharedKeys) {
      const sharedValue = mergeValues(a[key], b[key]);
      if (!sharedValue.valid) {
        return { valid: false };
      }
      newObj[key] = sharedValue.data;
    }
    return { valid: true, data: newObj };
  } else if (aType === ZodParsedType.array && bType === ZodParsedType.array) {
    if (a.length !== b.length) {
      return { valid: false };
    }
    const newArray = [];
    for (let index = 0; index < a.length; index++) {
      const itemA = a[index];
      const itemB = b[index];
      const sharedValue = mergeValues(itemA, itemB);
      if (!sharedValue.valid) {
        return { valid: false };
      }
      newArray.push(sharedValue.data);
    }
    return { valid: true, data: newArray };
  } else if (aType === ZodParsedType.date && bType === ZodParsedType.date && +a === +b) {
    return { valid: true, data: a };
  } else {
    return { valid: false };
  }
}
var ZodIntersection = class extends ZodType {
  _parse(input) {
    const { status, ctx } = this._processInputParams(input);
    const handleParsed = (parsedLeft, parsedRight) => {
      if (isAborted(parsedLeft) || isAborted(parsedRight)) {
        return INVALID;
      }
      const merged = mergeValues(parsedLeft.value, parsedRight.value);
      if (!merged.valid) {
        addIssueToContext(ctx, {
          code: ZodIssueCode.invalid_intersection_types
        });
        return INVALID;
      }
      if (isDirty(parsedLeft) || isDirty(parsedRight)) {
        status.dirty();
      }
      return { status: status.value, value: merged.data };
    };
    if (ctx.common.async) {
      return Promise.all([
        this._def.left._parseAsync({
          data: ctx.data,
          path: ctx.path,
          parent: ctx
        }),
        this._def.right._parseAsync({
          data: ctx.data,
          path: ctx.path,
          parent: ctx
        })
      ]).then(([left, right]) => handleParsed(left, right));
    } else {
      return handleParsed(this._def.left._parseSync({
        data: ctx.data,
        path: ctx.path,
        parent: ctx
      }), this._def.right._parseSync({
        data: ctx.data,
        path: ctx.path,
        parent: ctx
      }));
    }
  }
};
ZodIntersection.create = (left, right, params) => {
  return new ZodIntersection({
    left,
    right,
    typeName: ZodFirstPartyTypeKind.ZodIntersection,
    ...processCreateParams(params)
  });
};
var ZodTuple = class _ZodTuple extends ZodType {
  _parse(input) {
    const { status, ctx } = this._processInputParams(input);
    if (ctx.parsedType !== ZodParsedType.array) {
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.array,
        received: ctx.parsedType
      });
      return INVALID;
    }
    if (ctx.data.length < this._def.items.length) {
      addIssueToContext(ctx, {
        code: ZodIssueCode.too_small,
        minimum: this._def.items.length,
        inclusive: true,
        exact: false,
        type: "array"
      });
      return INVALID;
    }
    const rest = this._def.rest;
    if (!rest && ctx.data.length > this._def.items.length) {
      addIssueToContext(ctx, {
        code: ZodIssueCode.too_big,
        maximum: this._def.items.length,
        inclusive: true,
        exact: false,
        type: "array"
      });
      status.dirty();
    }
    const items = [...ctx.data].map((item, itemIndex) => {
      const schema = this._def.items[itemIndex] || this._def.rest;
      if (!schema)
        return null;
      return schema._parse(new ParseInputLazyPath(ctx, item, ctx.path, itemIndex));
    }).filter((x) => !!x);
    if (ctx.common.async) {
      return Promise.all(items).then((results) => {
        return ParseStatus.mergeArray(status, results);
      });
    } else {
      return ParseStatus.mergeArray(status, items);
    }
  }
  get items() {
    return this._def.items;
  }
  rest(rest) {
    return new _ZodTuple({
      ...this._def,
      rest
    });
  }
};
ZodTuple.create = (schemas, params) => {
  if (!Array.isArray(schemas)) {
    throw new Error("You must pass an array of schemas to z.tuple([ ... ])");
  }
  return new ZodTuple({
    items: schemas,
    typeName: ZodFirstPartyTypeKind.ZodTuple,
    rest: null,
    ...processCreateParams(params)
  });
};
var ZodRecord = class _ZodRecord extends ZodType {
  get keySchema() {
    return this._def.keyType;
  }
  get valueSchema() {
    return this._def.valueType;
  }
  _parse(input) {
    const { status, ctx } = this._processInputParams(input);
    if (ctx.parsedType !== ZodParsedType.object) {
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.object,
        received: ctx.parsedType
      });
      return INVALID;
    }
    const pairs = [];
    const keyType = this._def.keyType;
    const valueType = this._def.valueType;
    for (const key in ctx.data) {
      pairs.push({
        key: keyType._parse(new ParseInputLazyPath(ctx, key, ctx.path, key)),
        value: valueType._parse(new ParseInputLazyPath(ctx, ctx.data[key], ctx.path, key))
      });
    }
    if (ctx.common.async) {
      return ParseStatus.mergeObjectAsync(status, pairs);
    } else {
      return ParseStatus.mergeObjectSync(status, pairs);
    }
  }
  get element() {
    return this._def.valueType;
  }
  static create(first, second, third) {
    if (second instanceof ZodType) {
      return new _ZodRecord({
        keyType: first,
        valueType: second,
        typeName: ZodFirstPartyTypeKind.ZodRecord,
        ...processCreateParams(third)
      });
    }
    return new _ZodRecord({
      keyType: ZodString.create(),
      valueType: first,
      typeName: ZodFirstPartyTypeKind.ZodRecord,
      ...processCreateParams(second)
    });
  }
};
var ZodMap = class extends ZodType {
  get keySchema() {
    return this._def.keyType;
  }
  get valueSchema() {
    return this._def.valueType;
  }
  _parse(input) {
    const { status, ctx } = this._processInputParams(input);
    if (ctx.parsedType !== ZodParsedType.map) {
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.map,
        received: ctx.parsedType
      });
      return INVALID;
    }
    const keyType = this._def.keyType;
    const valueType = this._def.valueType;
    const pairs = [...ctx.data.entries()].map(([key, value], index) => {
      return {
        key: keyType._parse(new ParseInputLazyPath(ctx, key, ctx.path, [index, "key"])),
        value: valueType._parse(new ParseInputLazyPath(ctx, value, ctx.path, [index, "value"]))
      };
    });
    if (ctx.common.async) {
      const finalMap = /* @__PURE__ */ new Map();
      return Promise.resolve().then(async () => {
        for (const pair of pairs) {
          const key = await pair.key;
          const value = await pair.value;
          if (key.status === "aborted" || value.status === "aborted") {
            return INVALID;
          }
          if (key.status === "dirty" || value.status === "dirty") {
            status.dirty();
          }
          finalMap.set(key.value, value.value);
        }
        return { status: status.value, value: finalMap };
      });
    } else {
      const finalMap = /* @__PURE__ */ new Map();
      for (const pair of pairs) {
        const key = pair.key;
        const value = pair.value;
        if (key.status === "aborted" || value.status === "aborted") {
          return INVALID;
        }
        if (key.status === "dirty" || value.status === "dirty") {
          status.dirty();
        }
        finalMap.set(key.value, value.value);
      }
      return { status: status.value, value: finalMap };
    }
  }
};
ZodMap.create = (keyType, valueType, params) => {
  return new ZodMap({
    valueType,
    keyType,
    typeName: ZodFirstPartyTypeKind.ZodMap,
    ...processCreateParams(params)
  });
};
var ZodSet = class _ZodSet extends ZodType {
  _parse(input) {
    const { status, ctx } = this._processInputParams(input);
    if (ctx.parsedType !== ZodParsedType.set) {
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.set,
        received: ctx.parsedType
      });
      return INVALID;
    }
    const def = this._def;
    if (def.minSize !== null) {
      if (ctx.data.size < def.minSize.value) {
        addIssueToContext(ctx, {
          code: ZodIssueCode.too_small,
          minimum: def.minSize.value,
          type: "set",
          inclusive: true,
          exact: false,
          message: def.minSize.message
        });
        status.dirty();
      }
    }
    if (def.maxSize !== null) {
      if (ctx.data.size > def.maxSize.value) {
        addIssueToContext(ctx, {
          code: ZodIssueCode.too_big,
          maximum: def.maxSize.value,
          type: "set",
          inclusive: true,
          exact: false,
          message: def.maxSize.message
        });
        status.dirty();
      }
    }
    const valueType = this._def.valueType;
    function finalizeSet(elements2) {
      const parsedSet = /* @__PURE__ */ new Set();
      for (const element of elements2) {
        if (element.status === "aborted")
          return INVALID;
        if (element.status === "dirty")
          status.dirty();
        parsedSet.add(element.value);
      }
      return { status: status.value, value: parsedSet };
    }
    const elements = [...ctx.data.values()].map((item, i) => valueType._parse(new ParseInputLazyPath(ctx, item, ctx.path, i)));
    if (ctx.common.async) {
      return Promise.all(elements).then((elements2) => finalizeSet(elements2));
    } else {
      return finalizeSet(elements);
    }
  }
  min(minSize, message) {
    return new _ZodSet({
      ...this._def,
      minSize: { value: minSize, message: errorUtil.toString(message) }
    });
  }
  max(maxSize, message) {
    return new _ZodSet({
      ...this._def,
      maxSize: { value: maxSize, message: errorUtil.toString(message) }
    });
  }
  size(size, message) {
    return this.min(size, message).max(size, message);
  }
  nonempty(message) {
    return this.min(1, message);
  }
};
ZodSet.create = (valueType, params) => {
  return new ZodSet({
    valueType,
    minSize: null,
    maxSize: null,
    typeName: ZodFirstPartyTypeKind.ZodSet,
    ...processCreateParams(params)
  });
};
var ZodFunction = class _ZodFunction extends ZodType {
  constructor() {
    super(...arguments);
    this.validate = this.implement;
  }
  _parse(input) {
    const { ctx } = this._processInputParams(input);
    if (ctx.parsedType !== ZodParsedType.function) {
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.function,
        received: ctx.parsedType
      });
      return INVALID;
    }
    function makeArgsIssue(args, error) {
      return makeIssue({
        data: args,
        path: ctx.path,
        errorMaps: [
          ctx.common.contextualErrorMap,
          ctx.schemaErrorMap,
          getErrorMap(),
          errorMap
        ].filter((x) => !!x),
        issueData: {
          code: ZodIssueCode.invalid_arguments,
          argumentsError: error
        }
      });
    }
    function makeReturnsIssue(returns, error) {
      return makeIssue({
        data: returns,
        path: ctx.path,
        errorMaps: [
          ctx.common.contextualErrorMap,
          ctx.schemaErrorMap,
          getErrorMap(),
          errorMap
        ].filter((x) => !!x),
        issueData: {
          code: ZodIssueCode.invalid_return_type,
          returnTypeError: error
        }
      });
    }
    const params = { errorMap: ctx.common.contextualErrorMap };
    const fn = ctx.data;
    if (this._def.returns instanceof ZodPromise) {
      const me = this;
      return OK(async function(...args) {
        const error = new ZodError([]);
        const parsedArgs = await me._def.args.parseAsync(args, params).catch((e) => {
          error.addIssue(makeArgsIssue(args, e));
          throw error;
        });
        const result = await Reflect.apply(fn, this, parsedArgs);
        const parsedReturns = await me._def.returns._def.type.parseAsync(result, params).catch((e) => {
          error.addIssue(makeReturnsIssue(result, e));
          throw error;
        });
        return parsedReturns;
      });
    } else {
      const me = this;
      return OK(function(...args) {
        const parsedArgs = me._def.args.safeParse(args, params);
        if (!parsedArgs.success) {
          throw new ZodError([makeArgsIssue(args, parsedArgs.error)]);
        }
        const result = Reflect.apply(fn, this, parsedArgs.data);
        const parsedReturns = me._def.returns.safeParse(result, params);
        if (!parsedReturns.success) {
          throw new ZodError([makeReturnsIssue(result, parsedReturns.error)]);
        }
        return parsedReturns.data;
      });
    }
  }
  parameters() {
    return this._def.args;
  }
  returnType() {
    return this._def.returns;
  }
  args(...items) {
    return new _ZodFunction({
      ...this._def,
      args: ZodTuple.create(items).rest(ZodUnknown.create())
    });
  }
  returns(returnType) {
    return new _ZodFunction({
      ...this._def,
      returns: returnType
    });
  }
  implement(func) {
    const validatedFunc = this.parse(func);
    return validatedFunc;
  }
  strictImplement(func) {
    const validatedFunc = this.parse(func);
    return validatedFunc;
  }
  static create(args, returns, params) {
    return new _ZodFunction({
      args: args ? args : ZodTuple.create([]).rest(ZodUnknown.create()),
      returns: returns || ZodUnknown.create(),
      typeName: ZodFirstPartyTypeKind.ZodFunction,
      ...processCreateParams(params)
    });
  }
};
var ZodLazy = class extends ZodType {
  get schema() {
    return this._def.getter();
  }
  _parse(input) {
    const { ctx } = this._processInputParams(input);
    const lazySchema = this._def.getter();
    return lazySchema._parse({ data: ctx.data, path: ctx.path, parent: ctx });
  }
};
ZodLazy.create = (getter, params) => {
  return new ZodLazy({
    getter,
    typeName: ZodFirstPartyTypeKind.ZodLazy,
    ...processCreateParams(params)
  });
};
var ZodLiteral = class extends ZodType {
  _parse(input) {
    if (input.data !== this._def.value) {
      const ctx = this._getOrReturnCtx(input);
      addIssueToContext(ctx, {
        received: ctx.data,
        code: ZodIssueCode.invalid_literal,
        expected: this._def.value
      });
      return INVALID;
    }
    return { status: "valid", value: input.data };
  }
  get value() {
    return this._def.value;
  }
};
ZodLiteral.create = (value, params) => {
  return new ZodLiteral({
    value,
    typeName: ZodFirstPartyTypeKind.ZodLiteral,
    ...processCreateParams(params)
  });
};
function createZodEnum(values, params) {
  return new ZodEnum({
    values,
    typeName: ZodFirstPartyTypeKind.ZodEnum,
    ...processCreateParams(params)
  });
}
var ZodEnum = class _ZodEnum extends ZodType {
  _parse(input) {
    if (typeof input.data !== "string") {
      const ctx = this._getOrReturnCtx(input);
      const expectedValues = this._def.values;
      addIssueToContext(ctx, {
        expected: util.joinValues(expectedValues),
        received: ctx.parsedType,
        code: ZodIssueCode.invalid_type
      });
      return INVALID;
    }
    if (this._def.values.indexOf(input.data) === -1) {
      const ctx = this._getOrReturnCtx(input);
      const expectedValues = this._def.values;
      addIssueToContext(ctx, {
        received: ctx.data,
        code: ZodIssueCode.invalid_enum_value,
        options: expectedValues
      });
      return INVALID;
    }
    return OK(input.data);
  }
  get options() {
    return this._def.values;
  }
  get enum() {
    const enumValues = {};
    for (const val of this._def.values) {
      enumValues[val] = val;
    }
    return enumValues;
  }
  get Values() {
    const enumValues = {};
    for (const val of this._def.values) {
      enumValues[val] = val;
    }
    return enumValues;
  }
  get Enum() {
    const enumValues = {};
    for (const val of this._def.values) {
      enumValues[val] = val;
    }
    return enumValues;
  }
  extract(values) {
    return _ZodEnum.create(values);
  }
  exclude(values) {
    return _ZodEnum.create(this.options.filter((opt) => !values.includes(opt)));
  }
};
ZodEnum.create = createZodEnum;
var ZodNativeEnum = class extends ZodType {
  _parse(input) {
    const nativeEnumValues = util.getValidEnumValues(this._def.values);
    const ctx = this._getOrReturnCtx(input);
    if (ctx.parsedType !== ZodParsedType.string && ctx.parsedType !== ZodParsedType.number) {
      const expectedValues = util.objectValues(nativeEnumValues);
      addIssueToContext(ctx, {
        expected: util.joinValues(expectedValues),
        received: ctx.parsedType,
        code: ZodIssueCode.invalid_type
      });
      return INVALID;
    }
    if (nativeEnumValues.indexOf(input.data) === -1) {
      const expectedValues = util.objectValues(nativeEnumValues);
      addIssueToContext(ctx, {
        received: ctx.data,
        code: ZodIssueCode.invalid_enum_value,
        options: expectedValues
      });
      return INVALID;
    }
    return OK(input.data);
  }
  get enum() {
    return this._def.values;
  }
};
ZodNativeEnum.create = (values, params) => {
  return new ZodNativeEnum({
    values,
    typeName: ZodFirstPartyTypeKind.ZodNativeEnum,
    ...processCreateParams(params)
  });
};
var ZodPromise = class extends ZodType {
  unwrap() {
    return this._def.type;
  }
  _parse(input) {
    const { ctx } = this._processInputParams(input);
    if (ctx.parsedType !== ZodParsedType.promise && ctx.common.async === false) {
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.promise,
        received: ctx.parsedType
      });
      return INVALID;
    }
    const promisified = ctx.parsedType === ZodParsedType.promise ? ctx.data : Promise.resolve(ctx.data);
    return OK(promisified.then((data) => {
      return this._def.type.parseAsync(data, {
        path: ctx.path,
        errorMap: ctx.common.contextualErrorMap
      });
    }));
  }
};
ZodPromise.create = (schema, params) => {
  return new ZodPromise({
    type: schema,
    typeName: ZodFirstPartyTypeKind.ZodPromise,
    ...processCreateParams(params)
  });
};
var ZodEffects = class extends ZodType {
  innerType() {
    return this._def.schema;
  }
  sourceType() {
    return this._def.schema._def.typeName === ZodFirstPartyTypeKind.ZodEffects ? this._def.schema.sourceType() : this._def.schema;
  }
  _parse(input) {
    const { status, ctx } = this._processInputParams(input);
    const effect = this._def.effect || null;
    const checkCtx = {
      addIssue: (arg) => {
        addIssueToContext(ctx, arg);
        if (arg.fatal) {
          status.abort();
        } else {
          status.dirty();
        }
      },
      get path() {
        return ctx.path;
      }
    };
    checkCtx.addIssue = checkCtx.addIssue.bind(checkCtx);
    if (effect.type === "preprocess") {
      const processed = effect.transform(ctx.data, checkCtx);
      if (ctx.common.issues.length) {
        return {
          status: "dirty",
          value: ctx.data
        };
      }
      if (ctx.common.async) {
        return Promise.resolve(processed).then((processed2) => {
          return this._def.schema._parseAsync({
            data: processed2,
            path: ctx.path,
            parent: ctx
          });
        });
      } else {
        return this._def.schema._parseSync({
          data: processed,
          path: ctx.path,
          parent: ctx
        });
      }
    }
    if (effect.type === "refinement") {
      const executeRefinement = (acc) => {
        const result = effect.refinement(acc, checkCtx);
        if (ctx.common.async) {
          return Promise.resolve(result);
        }
        if (result instanceof Promise) {
          throw new Error("Async refinement encountered during synchronous parse operation. Use .parseAsync instead.");
        }
        return acc;
      };
      if (ctx.common.async === false) {
        const inner = this._def.schema._parseSync({
          data: ctx.data,
          path: ctx.path,
          parent: ctx
        });
        if (inner.status === "aborted")
          return INVALID;
        if (inner.status === "dirty")
          status.dirty();
        executeRefinement(inner.value);
        return { status: status.value, value: inner.value };
      } else {
        return this._def.schema._parseAsync({ data: ctx.data, path: ctx.path, parent: ctx }).then((inner) => {
          if (inner.status === "aborted")
            return INVALID;
          if (inner.status === "dirty")
            status.dirty();
          return executeRefinement(inner.value).then(() => {
            return { status: status.value, value: inner.value };
          });
        });
      }
    }
    if (effect.type === "transform") {
      if (ctx.common.async === false) {
        const base = this._def.schema._parseSync({
          data: ctx.data,
          path: ctx.path,
          parent: ctx
        });
        if (!isValid(base))
          return base;
        const result = effect.transform(base.value, checkCtx);
        if (result instanceof Promise) {
          throw new Error(`Asynchronous transform encountered during synchronous parse operation. Use .parseAsync instead.`);
        }
        return { status: status.value, value: result };
      } else {
        return this._def.schema._parseAsync({ data: ctx.data, path: ctx.path, parent: ctx }).then((base) => {
          if (!isValid(base))
            return base;
          return Promise.resolve(effect.transform(base.value, checkCtx)).then((result) => ({ status: status.value, value: result }));
        });
      }
    }
    util.assertNever(effect);
  }
};
ZodEffects.create = (schema, effect, params) => {
  return new ZodEffects({
    schema,
    typeName: ZodFirstPartyTypeKind.ZodEffects,
    effect,
    ...processCreateParams(params)
  });
};
ZodEffects.createWithPreprocess = (preprocess, schema, params) => {
  return new ZodEffects({
    schema,
    effect: { type: "preprocess", transform: preprocess },
    typeName: ZodFirstPartyTypeKind.ZodEffects,
    ...processCreateParams(params)
  });
};
var ZodOptional = class extends ZodType {
  _parse(input) {
    const parsedType = this._getType(input);
    if (parsedType === ZodParsedType.undefined) {
      return OK(void 0);
    }
    return this._def.innerType._parse(input);
  }
  unwrap() {
    return this._def.innerType;
  }
};
ZodOptional.create = (type, params) => {
  return new ZodOptional({
    innerType: type,
    typeName: ZodFirstPartyTypeKind.ZodOptional,
    ...processCreateParams(params)
  });
};
var ZodNullable = class extends ZodType {
  _parse(input) {
    const parsedType = this._getType(input);
    if (parsedType === ZodParsedType.null) {
      return OK(null);
    }
    return this._def.innerType._parse(input);
  }
  unwrap() {
    return this._def.innerType;
  }
};
ZodNullable.create = (type, params) => {
  return new ZodNullable({
    innerType: type,
    typeName: ZodFirstPartyTypeKind.ZodNullable,
    ...processCreateParams(params)
  });
};
var ZodDefault = class extends ZodType {
  _parse(input) {
    const { ctx } = this._processInputParams(input);
    let data = ctx.data;
    if (ctx.parsedType === ZodParsedType.undefined) {
      data = this._def.defaultValue();
    }
    return this._def.innerType._parse({
      data,
      path: ctx.path,
      parent: ctx
    });
  }
  removeDefault() {
    return this._def.innerType;
  }
};
ZodDefault.create = (type, params) => {
  return new ZodDefault({
    innerType: type,
    typeName: ZodFirstPartyTypeKind.ZodDefault,
    defaultValue: typeof params.default === "function" ? params.default : () => params.default,
    ...processCreateParams(params)
  });
};
var ZodCatch = class extends ZodType {
  _parse(input) {
    const { ctx } = this._processInputParams(input);
    const newCtx = {
      ...ctx,
      common: {
        ...ctx.common,
        issues: []
      }
    };
    const result = this._def.innerType._parse({
      data: newCtx.data,
      path: newCtx.path,
      parent: {
        ...newCtx
      }
    });
    if (isAsync(result)) {
      return result.then((result2) => {
        return {
          status: "valid",
          value: result2.status === "valid" ? result2.value : this._def.catchValue({
            get error() {
              return new ZodError(newCtx.common.issues);
            },
            input: newCtx.data
          })
        };
      });
    } else {
      return {
        status: "valid",
        value: result.status === "valid" ? result.value : this._def.catchValue({
          get error() {
            return new ZodError(newCtx.common.issues);
          },
          input: newCtx.data
        })
      };
    }
  }
  removeCatch() {
    return this._def.innerType;
  }
};
ZodCatch.create = (type, params) => {
  return new ZodCatch({
    innerType: type,
    typeName: ZodFirstPartyTypeKind.ZodCatch,
    catchValue: typeof params.catch === "function" ? params.catch : () => params.catch,
    ...processCreateParams(params)
  });
};
var ZodNaN = class extends ZodType {
  _parse(input) {
    const parsedType = this._getType(input);
    if (parsedType !== ZodParsedType.nan) {
      const ctx = this._getOrReturnCtx(input);
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.nan,
        received: ctx.parsedType
      });
      return INVALID;
    }
    return { status: "valid", value: input.data };
  }
};
ZodNaN.create = (params) => {
  return new ZodNaN({
    typeName: ZodFirstPartyTypeKind.ZodNaN,
    ...processCreateParams(params)
  });
};
var BRAND = Symbol("zod_brand");
var ZodBranded = class extends ZodType {
  _parse(input) {
    const { ctx } = this._processInputParams(input);
    const data = ctx.data;
    return this._def.type._parse({
      data,
      path: ctx.path,
      parent: ctx
    });
  }
  unwrap() {
    return this._def.type;
  }
};
var ZodPipeline = class _ZodPipeline extends ZodType {
  _parse(input) {
    const { status, ctx } = this._processInputParams(input);
    if (ctx.common.async) {
      const handleAsync = async () => {
        const inResult = await this._def.in._parseAsync({
          data: ctx.data,
          path: ctx.path,
          parent: ctx
        });
        if (inResult.status === "aborted")
          return INVALID;
        if (inResult.status === "dirty") {
          status.dirty();
          return DIRTY(inResult.value);
        } else {
          return this._def.out._parseAsync({
            data: inResult.value,
            path: ctx.path,
            parent: ctx
          });
        }
      };
      return handleAsync();
    } else {
      const inResult = this._def.in._parseSync({
        data: ctx.data,
        path: ctx.path,
        parent: ctx
      });
      if (inResult.status === "aborted")
        return INVALID;
      if (inResult.status === "dirty") {
        status.dirty();
        return {
          status: "dirty",
          value: inResult.value
        };
      } else {
        return this._def.out._parseSync({
          data: inResult.value,
          path: ctx.path,
          parent: ctx
        });
      }
    }
  }
  static create(a, b) {
    return new _ZodPipeline({
      in: a,
      out: b,
      typeName: ZodFirstPartyTypeKind.ZodPipeline
    });
  }
};
var ZodReadonly = class extends ZodType {
  _parse(input) {
    const result = this._def.innerType._parse(input);
    if (isValid(result)) {
      result.value = Object.freeze(result.value);
    }
    return result;
  }
};
ZodReadonly.create = (type, params) => {
  return new ZodReadonly({
    innerType: type,
    typeName: ZodFirstPartyTypeKind.ZodReadonly,
    ...processCreateParams(params)
  });
};
var custom = (check, params = {}, fatal) => {
  if (check)
    return ZodAny.create().superRefine((data, ctx) => {
      var _a, _b;
      if (!check(data)) {
        const p = typeof params === "function" ? params(data) : typeof params === "string" ? { message: params } : params;
        const _fatal = (_b = (_a = p.fatal) !== null && _a !== void 0 ? _a : fatal) !== null && _b !== void 0 ? _b : true;
        const p2 = typeof p === "string" ? { message: p } : p;
        ctx.addIssue({ code: "custom", ...p2, fatal: _fatal });
      }
    });
  return ZodAny.create();
};
var late = {
  object: ZodObject.lazycreate
};
var ZodFirstPartyTypeKind;
(function(ZodFirstPartyTypeKind2) {
  ZodFirstPartyTypeKind2["ZodString"] = "ZodString";
  ZodFirstPartyTypeKind2["ZodNumber"] = "ZodNumber";
  ZodFirstPartyTypeKind2["ZodNaN"] = "ZodNaN";
  ZodFirstPartyTypeKind2["ZodBigInt"] = "ZodBigInt";
  ZodFirstPartyTypeKind2["ZodBoolean"] = "ZodBoolean";
  ZodFirstPartyTypeKind2["ZodDate"] = "ZodDate";
  ZodFirstPartyTypeKind2["ZodSymbol"] = "ZodSymbol";
  ZodFirstPartyTypeKind2["ZodUndefined"] = "ZodUndefined";
  ZodFirstPartyTypeKind2["ZodNull"] = "ZodNull";
  ZodFirstPartyTypeKind2["ZodAny"] = "ZodAny";
  ZodFirstPartyTypeKind2["ZodUnknown"] = "ZodUnknown";
  ZodFirstPartyTypeKind2["ZodNever"] = "ZodNever";
  ZodFirstPartyTypeKind2["ZodVoid"] = "ZodVoid";
  ZodFirstPartyTypeKind2["ZodArray"] = "ZodArray";
  ZodFirstPartyTypeKind2["ZodObject"] = "ZodObject";
  ZodFirstPartyTypeKind2["ZodUnion"] = "ZodUnion";
  ZodFirstPartyTypeKind2["ZodDiscriminatedUnion"] = "ZodDiscriminatedUnion";
  ZodFirstPartyTypeKind2["ZodIntersection"] = "ZodIntersection";
  ZodFirstPartyTypeKind2["ZodTuple"] = "ZodTuple";
  ZodFirstPartyTypeKind2["ZodRecord"] = "ZodRecord";
  ZodFirstPartyTypeKind2["ZodMap"] = "ZodMap";
  ZodFirstPartyTypeKind2["ZodSet"] = "ZodSet";
  ZodFirstPartyTypeKind2["ZodFunction"] = "ZodFunction";
  ZodFirstPartyTypeKind2["ZodLazy"] = "ZodLazy";
  ZodFirstPartyTypeKind2["ZodLiteral"] = "ZodLiteral";
  ZodFirstPartyTypeKind2["ZodEnum"] = "ZodEnum";
  ZodFirstPartyTypeKind2["ZodEffects"] = "ZodEffects";
  ZodFirstPartyTypeKind2["ZodNativeEnum"] = "ZodNativeEnum";
  ZodFirstPartyTypeKind2["ZodOptional"] = "ZodOptional";
  ZodFirstPartyTypeKind2["ZodNullable"] = "ZodNullable";
  ZodFirstPartyTypeKind2["ZodDefault"] = "ZodDefault";
  ZodFirstPartyTypeKind2["ZodCatch"] = "ZodCatch";
  ZodFirstPartyTypeKind2["ZodPromise"] = "ZodPromise";
  ZodFirstPartyTypeKind2["ZodBranded"] = "ZodBranded";
  ZodFirstPartyTypeKind2["ZodPipeline"] = "ZodPipeline";
  ZodFirstPartyTypeKind2["ZodReadonly"] = "ZodReadonly";
})(ZodFirstPartyTypeKind || (ZodFirstPartyTypeKind = {}));
var instanceOfType = (cls, params = {
  message: `Input not instance of ${cls.name}`
}) => custom((data) => data instanceof cls, params);
var stringType = ZodString.create;
var numberType = ZodNumber.create;
var nanType = ZodNaN.create;
var bigIntType = ZodBigInt.create;
var booleanType = ZodBoolean.create;
var dateType = ZodDate.create;
var symbolType = ZodSymbol.create;
var undefinedType = ZodUndefined.create;
var nullType = ZodNull.create;
var anyType = ZodAny.create;
var unknownType = ZodUnknown.create;
var neverType = ZodNever.create;
var voidType = ZodVoid.create;
var arrayType = ZodArray.create;
var objectType = ZodObject.create;
var strictObjectType = ZodObject.strictCreate;
var unionType = ZodUnion.create;
var discriminatedUnionType = ZodDiscriminatedUnion.create;
var intersectionType = ZodIntersection.create;
var tupleType = ZodTuple.create;
var recordType = ZodRecord.create;
var mapType = ZodMap.create;
var setType = ZodSet.create;
var functionType = ZodFunction.create;
var lazyType = ZodLazy.create;
var literalType = ZodLiteral.create;
var enumType = ZodEnum.create;
var nativeEnumType = ZodNativeEnum.create;
var promiseType = ZodPromise.create;
var effectsType = ZodEffects.create;
var optionalType = ZodOptional.create;
var nullableType = ZodNullable.create;
var preprocessType = ZodEffects.createWithPreprocess;
var pipelineType = ZodPipeline.create;
var ostring = () => stringType().optional();
var onumber = () => numberType().optional();
var oboolean = () => booleanType().optional();
var coerce = {
  string: (arg) => ZodString.create({ ...arg, coerce: true }),
  number: (arg) => ZodNumber.create({ ...arg, coerce: true }),
  boolean: (arg) => ZodBoolean.create({
    ...arg,
    coerce: true
  }),
  bigint: (arg) => ZodBigInt.create({ ...arg, coerce: true }),
  date: (arg) => ZodDate.create({ ...arg, coerce: true })
};
var NEVER = INVALID;
var z = Object.freeze({
  __proto__: null,
  defaultErrorMap: errorMap,
  setErrorMap,
  getErrorMap,
  makeIssue,
  EMPTY_PATH,
  addIssueToContext,
  ParseStatus,
  INVALID,
  DIRTY,
  OK,
  isAborted,
  isDirty,
  isValid,
  isAsync,
  get util() {
    return util;
  },
  get objectUtil() {
    return objectUtil;
  },
  ZodParsedType,
  getParsedType,
  ZodType,
  ZodString,
  ZodNumber,
  ZodBigInt,
  ZodBoolean,
  ZodDate,
  ZodSymbol,
  ZodUndefined,
  ZodNull,
  ZodAny,
  ZodUnknown,
  ZodNever,
  ZodVoid,
  ZodArray,
  ZodObject,
  ZodUnion,
  ZodDiscriminatedUnion,
  ZodIntersection,
  ZodTuple,
  ZodRecord,
  ZodMap,
  ZodSet,
  ZodFunction,
  ZodLazy,
  ZodLiteral,
  ZodEnum,
  ZodNativeEnum,
  ZodPromise,
  ZodEffects,
  ZodTransformer: ZodEffects,
  ZodOptional,
  ZodNullable,
  ZodDefault,
  ZodCatch,
  ZodNaN,
  BRAND,
  ZodBranded,
  ZodPipeline,
  ZodReadonly,
  custom,
  Schema: ZodType,
  ZodSchema: ZodType,
  late,
  get ZodFirstPartyTypeKind() {
    return ZodFirstPartyTypeKind;
  },
  coerce,
  any: anyType,
  array: arrayType,
  bigint: bigIntType,
  boolean: booleanType,
  date: dateType,
  discriminatedUnion: discriminatedUnionType,
  effect: effectsType,
  "enum": enumType,
  "function": functionType,
  "instanceof": instanceOfType,
  intersection: intersectionType,
  lazy: lazyType,
  literal: literalType,
  map: mapType,
  nan: nanType,
  nativeEnum: nativeEnumType,
  never: neverType,
  "null": nullType,
  nullable: nullableType,
  number: numberType,
  object: objectType,
  oboolean,
  onumber,
  optional: optionalType,
  ostring,
  pipeline: pipelineType,
  preprocess: preprocessType,
  promise: promiseType,
  record: recordType,
  set: setType,
  strictObject: strictObjectType,
  string: stringType,
  symbol: symbolType,
  transformer: effectsType,
  tuple: tupleType,
  "undefined": undefinedType,
  union: unionType,
  unknown: unknownType,
  "void": voidType,
  NEVER,
  ZodIssueCode,
  quotelessJson,
  ZodError
});

// node_modules/uuid/dist/esm-browser/index.js
init_shim();

// node_modules/uuid/dist/esm-browser/v1.js
init_shim();

// node_modules/uuid/dist/esm-browser/rng.js
init_shim();
var getRandomValues;
var rnds8 = new Uint8Array(16);
function rng() {
  if (!getRandomValues) {
    getRandomValues = typeof crypto !== "undefined" && crypto.getRandomValues && crypto.getRandomValues.bind(crypto);
    if (!getRandomValues) {
      throw new Error("crypto.getRandomValues() not supported. See https://github.com/uuidjs/uuid#getrandomvalues-not-supported");
    }
  }
  return getRandomValues(rnds8);
}

// node_modules/uuid/dist/esm-browser/stringify.js
init_shim();

// node_modules/uuid/dist/esm-browser/validate.js
init_shim();

// node_modules/uuid/dist/esm-browser/regex.js
init_shim();
var regex_default = /^(?:[0-9a-f]{8}-[0-9a-f]{4}-[1-5][0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}|00000000-0000-0000-0000-000000000000)$/i;

// node_modules/uuid/dist/esm-browser/validate.js
function validate(uuid) {
  return typeof uuid === "string" && regex_default.test(uuid);
}
var validate_default = validate;

// node_modules/uuid/dist/esm-browser/stringify.js
var byteToHex = [];
for (let i = 0; i < 256; ++i) {
  byteToHex.push((i + 256).toString(16).slice(1));
}
function unsafeStringify(arr, offset = 0) {
  return byteToHex[arr[offset + 0]] + byteToHex[arr[offset + 1]] + byteToHex[arr[offset + 2]] + byteToHex[arr[offset + 3]] + "-" + byteToHex[arr[offset + 4]] + byteToHex[arr[offset + 5]] + "-" + byteToHex[arr[offset + 6]] + byteToHex[arr[offset + 7]] + "-" + byteToHex[arr[offset + 8]] + byteToHex[arr[offset + 9]] + "-" + byteToHex[arr[offset + 10]] + byteToHex[arr[offset + 11]] + byteToHex[arr[offset + 12]] + byteToHex[arr[offset + 13]] + byteToHex[arr[offset + 14]] + byteToHex[arr[offset + 15]];
}

// node_modules/uuid/dist/esm-browser/v3.js
init_shim();

// node_modules/uuid/dist/esm-browser/v35.js
init_shim();

// node_modules/uuid/dist/esm-browser/parse.js
init_shim();
function parse(uuid) {
  if (!validate_default(uuid)) {
    throw TypeError("Invalid UUID");
  }
  let v;
  const arr = new Uint8Array(16);
  arr[0] = (v = parseInt(uuid.slice(0, 8), 16)) >>> 24;
  arr[1] = v >>> 16 & 255;
  arr[2] = v >>> 8 & 255;
  arr[3] = v & 255;
  arr[4] = (v = parseInt(uuid.slice(9, 13), 16)) >>> 8;
  arr[5] = v & 255;
  arr[6] = (v = parseInt(uuid.slice(14, 18), 16)) >>> 8;
  arr[7] = v & 255;
  arr[8] = (v = parseInt(uuid.slice(19, 23), 16)) >>> 8;
  arr[9] = v & 255;
  arr[10] = (v = parseInt(uuid.slice(24, 36), 16)) / 1099511627776 & 255;
  arr[11] = v / 4294967296 & 255;
  arr[12] = v >>> 24 & 255;
  arr[13] = v >>> 16 & 255;
  arr[14] = v >>> 8 & 255;
  arr[15] = v & 255;
  return arr;
}
var parse_default = parse;

// node_modules/uuid/dist/esm-browser/v35.js
function stringToBytes(str) {
  str = unescape(encodeURIComponent(str));
  const bytes = [];
  for (let i = 0; i < str.length; ++i) {
    bytes.push(str.charCodeAt(i));
  }
  return bytes;
}
var DNS = "6ba7b810-9dad-11d1-80b4-00c04fd430c8";
var URL2 = "6ba7b811-9dad-11d1-80b4-00c04fd430c8";
function v35(name, version, hashfunc) {
  function generateUUID(value, namespace, buf, offset) {
    var _namespace;
    if (typeof value === "string") {
      value = stringToBytes(value);
    }
    if (typeof namespace === "string") {
      namespace = parse_default(namespace);
    }
    if (((_namespace = namespace) === null || _namespace === void 0 ? void 0 : _namespace.length) !== 16) {
      throw TypeError("Namespace must be array-like (16 iterable integer values, 0-255)");
    }
    let bytes = new Uint8Array(16 + value.length);
    bytes.set(namespace);
    bytes.set(value, namespace.length);
    bytes = hashfunc(bytes);
    bytes[6] = bytes[6] & 15 | version;
    bytes[8] = bytes[8] & 63 | 128;
    if (buf) {
      offset = offset || 0;
      for (let i = 0; i < 16; ++i) {
        buf[offset + i] = bytes[i];
      }
      return buf;
    }
    return unsafeStringify(bytes);
  }
  try {
    generateUUID.name = name;
  } catch (err) {
  }
  generateUUID.DNS = DNS;
  generateUUID.URL = URL2;
  return generateUUID;
}

// node_modules/uuid/dist/esm-browser/md5.js
init_shim();
function md5(bytes) {
  if (typeof bytes === "string") {
    const msg = unescape(encodeURIComponent(bytes));
    bytes = new Uint8Array(msg.length);
    for (let i = 0; i < msg.length; ++i) {
      bytes[i] = msg.charCodeAt(i);
    }
  }
  return md5ToHexEncodedArray(wordsToMd5(bytesToWords(bytes), bytes.length * 8));
}
function md5ToHexEncodedArray(input) {
  const output = [];
  const length32 = input.length * 32;
  const hexTab = "0123456789abcdef";
  for (let i = 0; i < length32; i += 8) {
    const x = input[i >> 5] >>> i % 32 & 255;
    const hex = parseInt(hexTab.charAt(x >>> 4 & 15) + hexTab.charAt(x & 15), 16);
    output.push(hex);
  }
  return output;
}
function getOutputLength(inputLength8) {
  return (inputLength8 + 64 >>> 9 << 4) + 14 + 1;
}
function wordsToMd5(x, len) {
  x[len >> 5] |= 128 << len % 32;
  x[getOutputLength(len) - 1] = len;
  let a = 1732584193;
  let b = -271733879;
  let c = -1732584194;
  let d = 271733878;
  for (let i = 0; i < x.length; i += 16) {
    const olda = a;
    const oldb = b;
    const oldc = c;
    const oldd = d;
    a = md5ff(a, b, c, d, x[i], 7, -680876936);
    d = md5ff(d, a, b, c, x[i + 1], 12, -389564586);
    c = md5ff(c, d, a, b, x[i + 2], 17, 606105819);
    b = md5ff(b, c, d, a, x[i + 3], 22, -1044525330);
    a = md5ff(a, b, c, d, x[i + 4], 7, -176418897);
    d = md5ff(d, a, b, c, x[i + 5], 12, 1200080426);
    c = md5ff(c, d, a, b, x[i + 6], 17, -1473231341);
    b = md5ff(b, c, d, a, x[i + 7], 22, -45705983);
    a = md5ff(a, b, c, d, x[i + 8], 7, 1770035416);
    d = md5ff(d, a, b, c, x[i + 9], 12, -1958414417);
    c = md5ff(c, d, a, b, x[i + 10], 17, -42063);
    b = md5ff(b, c, d, a, x[i + 11], 22, -1990404162);
    a = md5ff(a, b, c, d, x[i + 12], 7, 1804603682);
    d = md5ff(d, a, b, c, x[i + 13], 12, -40341101);
    c = md5ff(c, d, a, b, x[i + 14], 17, -1502002290);
    b = md5ff(b, c, d, a, x[i + 15], 22, 1236535329);
    a = md5gg(a, b, c, d, x[i + 1], 5, -165796510);
    d = md5gg(d, a, b, c, x[i + 6], 9, -1069501632);
    c = md5gg(c, d, a, b, x[i + 11], 14, 643717713);
    b = md5gg(b, c, d, a, x[i], 20, -373897302);
    a = md5gg(a, b, c, d, x[i + 5], 5, -701558691);
    d = md5gg(d, a, b, c, x[i + 10], 9, 38016083);
    c = md5gg(c, d, a, b, x[i + 15], 14, -660478335);
    b = md5gg(b, c, d, a, x[i + 4], 20, -405537848);
    a = md5gg(a, b, c, d, x[i + 9], 5, 568446438);
    d = md5gg(d, a, b, c, x[i + 14], 9, -1019803690);
    c = md5gg(c, d, a, b, x[i + 3], 14, -187363961);
    b = md5gg(b, c, d, a, x[i + 8], 20, 1163531501);
    a = md5gg(a, b, c, d, x[i + 13], 5, -1444681467);
    d = md5gg(d, a, b, c, x[i + 2], 9, -51403784);
    c = md5gg(c, d, a, b, x[i + 7], 14, 1735328473);
    b = md5gg(b, c, d, a, x[i + 12], 20, -1926607734);
    a = md5hh(a, b, c, d, x[i + 5], 4, -378558);
    d = md5hh(d, a, b, c, x[i + 8], 11, -2022574463);
    c = md5hh(c, d, a, b, x[i + 11], 16, 1839030562);
    b = md5hh(b, c, d, a, x[i + 14], 23, -35309556);
    a = md5hh(a, b, c, d, x[i + 1], 4, -1530992060);
    d = md5hh(d, a, b, c, x[i + 4], 11, 1272893353);
    c = md5hh(c, d, a, b, x[i + 7], 16, -155497632);
    b = md5hh(b, c, d, a, x[i + 10], 23, -1094730640);
    a = md5hh(a, b, c, d, x[i + 13], 4, 681279174);
    d = md5hh(d, a, b, c, x[i], 11, -358537222);
    c = md5hh(c, d, a, b, x[i + 3], 16, -722521979);
    b = md5hh(b, c, d, a, x[i + 6], 23, 76029189);
    a = md5hh(a, b, c, d, x[i + 9], 4, -640364487);
    d = md5hh(d, a, b, c, x[i + 12], 11, -421815835);
    c = md5hh(c, d, a, b, x[i + 15], 16, 530742520);
    b = md5hh(b, c, d, a, x[i + 2], 23, -995338651);
    a = md5ii(a, b, c, d, x[i], 6, -198630844);
    d = md5ii(d, a, b, c, x[i + 7], 10, 1126891415);
    c = md5ii(c, d, a, b, x[i + 14], 15, -1416354905);
    b = md5ii(b, c, d, a, x[i + 5], 21, -57434055);
    a = md5ii(a, b, c, d, x[i + 12], 6, 1700485571);
    d = md5ii(d, a, b, c, x[i + 3], 10, -1894986606);
    c = md5ii(c, d, a, b, x[i + 10], 15, -1051523);
    b = md5ii(b, c, d, a, x[i + 1], 21, -2054922799);
    a = md5ii(a, b, c, d, x[i + 8], 6, 1873313359);
    d = md5ii(d, a, b, c, x[i + 15], 10, -30611744);
    c = md5ii(c, d, a, b, x[i + 6], 15, -1560198380);
    b = md5ii(b, c, d, a, x[i + 13], 21, 1309151649);
    a = md5ii(a, b, c, d, x[i + 4], 6, -145523070);
    d = md5ii(d, a, b, c, x[i + 11], 10, -1120210379);
    c = md5ii(c, d, a, b, x[i + 2], 15, 718787259);
    b = md5ii(b, c, d, a, x[i + 9], 21, -343485551);
    a = safeAdd(a, olda);
    b = safeAdd(b, oldb);
    c = safeAdd(c, oldc);
    d = safeAdd(d, oldd);
  }
  return [a, b, c, d];
}
function bytesToWords(input) {
  if (input.length === 0) {
    return [];
  }
  const length8 = input.length * 8;
  const output = new Uint32Array(getOutputLength(length8));
  for (let i = 0; i < length8; i += 8) {
    output[i >> 5] |= (input[i / 8] & 255) << i % 32;
  }
  return output;
}
function safeAdd(x, y) {
  const lsw = (x & 65535) + (y & 65535);
  const msw = (x >> 16) + (y >> 16) + (lsw >> 16);
  return msw << 16 | lsw & 65535;
}
function bitRotateLeft(num, cnt) {
  return num << cnt | num >>> 32 - cnt;
}
function md5cmn(q, a, b, x, s, t) {
  return safeAdd(bitRotateLeft(safeAdd(safeAdd(a, q), safeAdd(x, t)), s), b);
}
function md5ff(a, b, c, d, x, s, t) {
  return md5cmn(b & c | ~b & d, a, b, x, s, t);
}
function md5gg(a, b, c, d, x, s, t) {
  return md5cmn(b & d | c & ~d, a, b, x, s, t);
}
function md5hh(a, b, c, d, x, s, t) {
  return md5cmn(b ^ c ^ d, a, b, x, s, t);
}
function md5ii(a, b, c, d, x, s, t) {
  return md5cmn(c ^ (b | ~d), a, b, x, s, t);
}
var md5_default = md5;

// node_modules/uuid/dist/esm-browser/v3.js
var v3 = v35("v3", 48, md5_default);

// node_modules/uuid/dist/esm-browser/v4.js
init_shim();

// node_modules/uuid/dist/esm-browser/native.js
init_shim();
var randomUUID = typeof crypto !== "undefined" && crypto.randomUUID && crypto.randomUUID.bind(crypto);
var native_default = {
  randomUUID
};

// node_modules/uuid/dist/esm-browser/v4.js
function v4(options, buf, offset) {
  if (native_default.randomUUID && !buf && !options) {
    return native_default.randomUUID();
  }
  options = options || {};
  const rnds = options.random || (options.rng || rng)();
  rnds[6] = rnds[6] & 15 | 64;
  rnds[8] = rnds[8] & 63 | 128;
  if (buf) {
    offset = offset || 0;
    for (let i = 0; i < 16; ++i) {
      buf[offset + i] = rnds[i];
    }
    return buf;
  }
  return unsafeStringify(rnds);
}
var v4_default = v4;

// node_modules/uuid/dist/esm-browser/v5.js
init_shim();

// node_modules/uuid/dist/esm-browser/sha1.js
init_shim();
function f(s, x, y, z2) {
  switch (s) {
    case 0:
      return x & y ^ ~x & z2;
    case 1:
      return x ^ y ^ z2;
    case 2:
      return x & y ^ x & z2 ^ y & z2;
    case 3:
      return x ^ y ^ z2;
  }
}
function ROTL(x, n) {
  return x << n | x >>> 32 - n;
}
function sha1(bytes) {
  const K = [1518500249, 1859775393, 2400959708, 3395469782];
  const H = [1732584193, 4023233417, 2562383102, 271733878, 3285377520];
  if (typeof bytes === "string") {
    const msg = unescape(encodeURIComponent(bytes));
    bytes = [];
    for (let i = 0; i < msg.length; ++i) {
      bytes.push(msg.charCodeAt(i));
    }
  } else if (!Array.isArray(bytes)) {
    bytes = Array.prototype.slice.call(bytes);
  }
  bytes.push(128);
  const l = bytes.length / 4 + 2;
  const N = Math.ceil(l / 16);
  const M = new Array(N);
  for (let i = 0; i < N; ++i) {
    const arr = new Uint32Array(16);
    for (let j = 0; j < 16; ++j) {
      arr[j] = bytes[i * 64 + j * 4] << 24 | bytes[i * 64 + j * 4 + 1] << 16 | bytes[i * 64 + j * 4 + 2] << 8 | bytes[i * 64 + j * 4 + 3];
    }
    M[i] = arr;
  }
  M[N - 1][14] = (bytes.length - 1) * 8 / Math.pow(2, 32);
  M[N - 1][14] = Math.floor(M[N - 1][14]);
  M[N - 1][15] = (bytes.length - 1) * 8 & 4294967295;
  for (let i = 0; i < N; ++i) {
    const W = new Uint32Array(80);
    for (let t = 0; t < 16; ++t) {
      W[t] = M[i][t];
    }
    for (let t = 16; t < 80; ++t) {
      W[t] = ROTL(W[t - 3] ^ W[t - 8] ^ W[t - 14] ^ W[t - 16], 1);
    }
    let a = H[0];
    let b = H[1];
    let c = H[2];
    let d = H[3];
    let e = H[4];
    for (let t = 0; t < 80; ++t) {
      const s = Math.floor(t / 20);
      const T = ROTL(a, 5) + f(s, b, c, d) + e + K[s] + W[t] >>> 0;
      e = d;
      d = c;
      c = ROTL(b, 30) >>> 0;
      b = a;
      a = T;
    }
    H[0] = H[0] + a >>> 0;
    H[1] = H[1] + b >>> 0;
    H[2] = H[2] + c >>> 0;
    H[3] = H[3] + d >>> 0;
    H[4] = H[4] + e >>> 0;
  }
  return [H[0] >> 24 & 255, H[0] >> 16 & 255, H[0] >> 8 & 255, H[0] & 255, H[1] >> 24 & 255, H[1] >> 16 & 255, H[1] >> 8 & 255, H[1] & 255, H[2] >> 24 & 255, H[2] >> 16 & 255, H[2] >> 8 & 255, H[2] & 255, H[3] >> 24 & 255, H[3] >> 16 & 255, H[3] >> 8 & 255, H[3] & 255, H[4] >> 24 & 255, H[4] >> 16 & 255, H[4] >> 8 & 255, H[4] & 255];
}
var sha1_default = sha1;

// node_modules/uuid/dist/esm-browser/v5.js
var v5 = v35("v5", 80, sha1_default);

// node_modules/uuid/dist/esm-browser/nil.js
init_shim();

// node_modules/uuid/dist/esm-browser/version.js
init_shim();

// node_modules/tiny-invariant/dist/esm/tiny-invariant.js
init_shim();
var isProduction = import_process.default.env.NODE_ENV === "production";
var prefix = "Invariant failed";
function invariant(condition, message) {
  if (condition) {
    return;
  }
  if (isProduction) {
    throw new Error(prefix);
  }
  var provided = typeof message === "function" ? message() : message;
  var value = provided ? "".concat(prefix, ": ").concat(provided) : prefix;
  throw new Error(value);
}

// node_modules/@thirdweb-dev/sdk/dist/QueryParams-39bcad7a.browser.esm.js
init_shim();
var import_bn = __toESM(require_bn());
init_lib();
var FileOrBufferUnionSchema = (() => z.instanceof(File))();
var FileOrBufferSchema = (() => z.union([FileOrBufferUnionSchema, z.object({
  data: z.union([FileOrBufferUnionSchema, z.string()]),
  name: z.string()
})]))();
var FileOrBufferOrStringSchema = (() => z.union([FileOrBufferSchema, z.string()]))();
var MAX_BPS = 1e4;
var BytesLikeSchema = (() => z.union([z.array(z.number()), z.string()]))();
var BigNumberTransformSchema = (() => z.union([z.bigint(), z.custom((data) => {
  return BigNumber.isBigNumber(data);
}), z.custom((data) => {
  return import_bn.default.isBN(data);
})]).transform((arg) => {
  if (import_bn.default.isBN(arg)) {
    return new import_bn.default(arg).toString();
  }
  return BigNumber.from(arg).toString();
}))();
var BasisPointsSchema = z.number().max(MAX_BPS, "Cannot exceed 100%").min(0, "Cannot be below 0%");
var PercentSchema = z.number().max(100, "Cannot exceed 100%").min(0, "Cannot be below 0%");
var HexColor = (() => z.union([z.string().regex(/^([A-Fa-f0-9]{6}|[A-Fa-f0-9]{3})$/, "Invalid hex color"), z.string().regex(/^#([A-Fa-f0-9]{6}|[A-Fa-f0-9]{3})$/, "Invalid hex color").transform((val) => val.replace("#", "")), z.string().length(0)]))();
var AmountSchema = (() => z.union([z.string().regex(/^([0-9]+\.?[0-9]*|\.[0-9]+)$/, "Invalid amount"), z.number().min(0, "Amount cannot be negative")]).transform((arg) => typeof arg === "number" ? arg.toString() : arg))();
var QuantitySchema = (() => z.union([AmountSchema, z.literal("unlimited")]).default("unlimited"))();
var PropertiesInput = (() => z.object({}).catchall(z.union([BigNumberTransformSchema, z.unknown()])))();
var OptionalPropertiesInput = (() => z.union([z.array(PropertiesInput), PropertiesInput]).optional().nullable())();
var BasicNFTInput = (() => z.object({
  name: z.union([z.string(), z.number()]).optional().nullable(),
  description: z.string().nullable().optional().nullable(),
  image: FileOrBufferOrStringSchema.nullable().optional(),
  animation_url: FileOrBufferOrStringSchema.optional().nullable()
}))();
var CommonNFTInput = (() => BasicNFTInput.extend({
  external_url: FileOrBufferOrStringSchema.nullable().optional(),
  background_color: HexColor.optional().nullable(),
  properties: OptionalPropertiesInput,
  attributes: OptionalPropertiesInput
}).catchall(z.union([BigNumberTransformSchema, z.unknown()])))();
var NFTInputOrUriSchema = (() => z.union([CommonNFTInput, z.string()]))();
var CommonNFTOutput = (() => CommonNFTInput.extend({
  id: z.string(),
  uri: z.string(),
  image: z.string().nullable().optional(),
  external_url: z.string().nullable().optional(),
  animation_url: z.string().nullable().optional()
}))();
var DEFAULT_QUERY_ALL_COUNT = 100;
var QueryAllParamsSchema = (() => z.object({
  start: z.number().default(0),
  count: z.number().default(DEFAULT_QUERY_ALL_COUNT)
}).default({
  start: 0,
  count: DEFAULT_QUERY_ALL_COUNT
}))();

// node_modules/@thirdweb-dev/storage/dist/thirdweb-dev-storage.browser.esm.js
init_shim();
var import_cid_tool = __toESM(require_src6());
var import_cross_fetch = __toESM(require_browser_ponyfill());
var import_form_data = __toESM(require_browser());
function getProcessEnv(key) {
  let defaultValue = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : "";
  if (typeof import_process.default !== "undefined") {
    if (import_process.default.env[key]) {
      return import_process.default.env[key];
    }
  }
  return defaultValue;
}
var TW_HOSTNAME_SUFFIX = ".ipfscdn.io";
var TW_STAGINGHOSTNAME_SUFFIX = ".thirdwebstorage-staging.com";
var TW_GATEWAY_URLS = [`https://{clientId}${TW_HOSTNAME_SUFFIX}/ipfs/{cid}/{path}`];
function isTwGatewayUrl(url) {
  const hostname = new URL(url).hostname;
  const isProd = hostname.endsWith(TW_HOSTNAME_SUFFIX);
  if (isProd) {
    return true;
  }
  return hostname.endsWith(TW_STAGINGHOSTNAME_SUFFIX);
}
var PUBLIC_GATEWAY_URLS = ["https://{cid}.ipfs.cf-ipfs.com/{path}", "https://{cid}.ipfs.dweb.link/{path}", "https://ipfs.io/ipfs/{cid}/{path}", "https://cloudflare-ipfs.com/ipfs/{cid}/{path}", "https://{cid}.ipfs.w3s.link/{path}", "https://w3s.link/ipfs/{cid}/{path}", "https://nftstorage.link/ipfs/{cid}/{path}", "https://gateway.pinata.cloud/ipfs/{cid}/{path}"];
var DEFAULT_GATEWAY_URLS = {
  // Note: Gateway URLs should have trailing slashes (we clean this on user input)
  "ipfs://": [...TW_GATEWAY_URLS, ...PUBLIC_GATEWAY_URLS]
};
var TW_UPLOAD_SERVER_URL = getProcessEnv("CUSTOM_UPLOAD_SERVER_URL", "https://storage.thirdweb.com");
function parseGatewayUrls(gatewayUrls) {
  if (Array.isArray(gatewayUrls)) {
    return {
      "ipfs://": gatewayUrls
    };
  }
  return gatewayUrls || {};
}
function getGatewayUrlForCid(gatewayUrl, cid, clientId) {
  const parts = cid.split("/");
  const hash = convertCidToV1(parts[0]);
  const filePath = parts.slice(1).join("/");
  let url = gatewayUrl;
  if (gatewayUrl.includes("{cid}") && gatewayUrl.includes("{path}")) {
    url = url.replace("{cid}", hash).replace("{path}", filePath);
  } else if (gatewayUrl.includes("{cid}")) {
    url = url.replace("{cid}", hash);
  } else {
    url += `${hash}/${filePath}`;
  }
  if (gatewayUrl.includes("{clientId}")) {
    if (!clientId) {
      throw new Error("Cannot use {clientId} in gateway URL without providing a client ID");
    }
    url = url.replace("{clientId}", clientId);
  }
  return url;
}
function prepareGatewayUrls(gatewayUrls, clientId, secretKey) {
  const allGatewayUrls = {
    ...DEFAULT_GATEWAY_URLS,
    ...gatewayUrls
  };
  for (const key of Object.keys(allGatewayUrls)) {
    const cleanedGatewayUrls = allGatewayUrls[key].map((url) => {
      if (clientId && url.includes("{clientId}")) {
        return url.replace("{clientId}", clientId);
      } else if (secretKey && url.includes("{clientId}")) {
        {
          throw new Error("Cannot use secretKey in browser context");
        }
      } else if (url.includes("{clientId}")) {
        return void 0;
      } else {
        return url;
      }
    }).filter((url) => url !== void 0);
    allGatewayUrls[key] = cleanedGatewayUrls;
  }
  return allGatewayUrls;
}
function convertCidToV1(cid) {
  let normalized;
  try {
    const hash = cid.split("/")[0];
    normalized = import_cid_tool.default.base32(hash);
  } catch (e) {
    throw new Error(`The CID ${cid} is not valid.`);
  }
  return normalized;
}
function isBrowser() {
  return true;
}
function isFileInstance(data) {
  return global.File && data instanceof File;
}
function isBufferInstance(data) {
  return global.Buffer && data instanceof import_buffer.Buffer;
}
function isBufferOrStringWithName(data) {
  return !!(data && data.name && data.data && typeof data.name === "string" && (typeof data.data === "string" || isBufferInstance(data.data)));
}
function isFileOrBuffer(data) {
  return isFileInstance(data) || isBufferInstance(data) || isBufferOrStringWithName(data);
}
function isFileBufferOrStringEqual(input1, input2) {
  if (isFileInstance(input1) && isFileInstance(input2)) {
    if (input1.name === input2.name && input1.lastModified === input2.lastModified && input1.size === input2.size) {
      return true;
    }
  } else if (isBufferInstance(input1) && isBufferInstance(input2)) {
    return input1.equals(input2);
  } else if (isBufferOrStringWithName(input1) && isBufferOrStringWithName(input2)) {
    if (input1.name === input2.name) {
      if (typeof input1.data === "string" && typeof input2.data === "string") {
        return input1.data === input2.data;
      } else if (isBufferInstance(input1.data) && isBufferInstance(input2.data)) {
        return input1.data.equals(input2.data);
      }
    }
  }
  return false;
}
function parseCidAndPath(gatewayUrl, uri) {
  var _a, _b;
  const regexString = gatewayUrl.replace("{cid}", "(?<hash>[^/]+)").replace("{path}", "(?<path>[^?#]+)");
  const regex = new RegExp(regexString);
  const match = uri.match(regex);
  if (match) {
    const hash = (_a = match.groups) == null ? void 0 : _a.hash;
    const path = (_b = match.groups) == null ? void 0 : _b.path;
    const queryString = uri.includes("?") ? uri.substring(uri.indexOf("?") + 1) : "";
    return {
      hash,
      path,
      query: queryString
    };
  }
}
function replaceGatewayUrlWithScheme(uri, gatewayUrls) {
  for (const scheme of Object.keys(gatewayUrls)) {
    for (const gatewayUrl of gatewayUrls[scheme]) {
      if (gatewayUrl.includes("{cid}")) {
        const parsed = parseCidAndPath(gatewayUrl, uri);
        if ((parsed == null ? void 0 : parsed.hash) && (parsed == null ? void 0 : parsed.path)) {
          const queryString = (parsed == null ? void 0 : parsed.query) ? `?${parsed == null ? void 0 : parsed.query}` : "";
          return `${scheme}${parsed == null ? void 0 : parsed.hash}/${parsed == null ? void 0 : parsed.path}${queryString}`;
        } else {
          return uri;
        }
      } else if (uri.startsWith(gatewayUrl)) {
        return uri.replace(gatewayUrl, scheme);
      }
    }
  }
  return uri;
}
function replaceSchemeWithGatewayUrl(uri, gatewayUrls) {
  let index = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : 0;
  let clientId = arguments.length > 3 ? arguments[3] : void 0;
  const scheme = Object.keys(gatewayUrls).find((s) => uri.startsWith(s));
  const schemeGatewayUrls = scheme ? gatewayUrls[scheme] : [];
  if (!scheme && index > 0 || scheme && index >= schemeGatewayUrls.length) {
    return void 0;
  }
  if (!scheme) {
    return uri;
  }
  const path = uri.replace(scheme, "");
  return getGatewayUrlForCid(schemeGatewayUrls[index], path, clientId);
}
function replaceObjectGatewayUrlsWithSchemes(data, gatewayUrls) {
  if (typeof data === "string") {
    return replaceGatewayUrlWithScheme(data, gatewayUrls);
  }
  if (typeof data === "object") {
    if (!data) {
      return data;
    }
    if (isFileOrBuffer(data)) {
      return data;
    }
    if (Array.isArray(data)) {
      return data.map((entry) => replaceObjectGatewayUrlsWithSchemes(entry, gatewayUrls));
    }
    return Object.fromEntries(Object.entries(data).map((_ref) => {
      let [key, value] = _ref;
      return [key, replaceObjectGatewayUrlsWithSchemes(value, gatewayUrls)];
    }));
  }
  return data;
}
function replaceObjectSchemesWithGatewayUrls(data, gatewayUrls, clientId) {
  if (typeof data === "string") {
    return replaceSchemeWithGatewayUrl(data, gatewayUrls, 0, clientId);
  }
  if (typeof data === "object") {
    if (!data) {
      return data;
    }
    if (isFileOrBuffer(data)) {
      return data;
    }
    if (Array.isArray(data)) {
      return data.map((entry) => replaceObjectSchemesWithGatewayUrls(entry, gatewayUrls, clientId));
    }
    return Object.fromEntries(Object.entries(data).map((_ref2) => {
      let [key, value] = _ref2;
      return [key, replaceObjectSchemesWithGatewayUrls(value, gatewayUrls, clientId)];
    }));
  }
  return data;
}
function extractObjectFiles(data) {
  let files = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : [];
  if (isFileOrBuffer(data)) {
    files.push(data);
    return files;
  }
  if (typeof data === "object") {
    if (!data) {
      return files;
    }
    if (Array.isArray(data)) {
      data.forEach((entry) => extractObjectFiles(entry, files));
    } else {
      Object.keys(data).map((key) => extractObjectFiles(data[key], files));
    }
  }
  return files;
}
function replaceObjectFilesWithUris(data, uris) {
  if (isFileOrBuffer(data)) {
    if (uris.length) {
      data = uris.shift();
      return data;
    } else {
      console.warn("Not enough URIs to replace all files in object.");
    }
  }
  if (typeof data === "object") {
    if (!data) {
      return data;
    }
    if (Array.isArray(data)) {
      return data.map((entry) => replaceObjectFilesWithUris(entry, uris));
    } else {
      return Object.fromEntries(Object.entries(data).map((_ref3) => {
        let [key, value] = _ref3;
        return [key, replaceObjectFilesWithUris(value, uris)];
      }));
    }
  }
  return data;
}
var pkg = {
  name: "@thirdweb-dev/storage",
  version: "1.2.11",
  main: "dist/thirdweb-dev-storage.cjs.js",
  module: "dist/thirdweb-dev-storage.esm.js",
  browser: {
    "./dist/thirdweb-dev-storage.esm.js": "./dist/thirdweb-dev-storage.browser.esm.js"
  },
  exports: {
    ".": {
      module: {
        browser: "./dist/thirdweb-dev-storage.browser.esm.js",
        "default": "./dist/thirdweb-dev-storage.esm.js"
      },
      "default": "./dist/thirdweb-dev-storage.cjs.js"
    },
    "./package.json": "./package.json"
  },
  repository: "https://github.com/thirdweb-dev/js/tree/main/packages/storage",
  author: "thirdweb eng <eng@thirdweb.com>",
  license: "Apache-2.0",
  sideEffects: false,
  scripts: {
    format: "prettier --write 'src/**/*'",
    lint: "eslint src/",
    fix: "eslint src/ --fix",
    "generate-docs": "api-extractor run --local && api-documenter markdown -i ./temp -o ./docs",
    clean: "rm -rf dist/",
    build: "tsc && preconstruct build",
    "test:all": "NODE_ENV=test SWC_NODE_PROJECT=./tsconfig.test.json mocha --timeout 30000 --parallel './test/**/*.test.ts'",
    test: "pnpm test:all",
    "test:single": "NODE_ENV=test SWC_NODE_PROJECT=./tsconfig.test.json mocha --timeout 30000",
    push: "yalc push"
  },
  files: [
    "dist/"
  ],
  preconstruct: {
    exports: {
      envConditions: [
        "browser"
      ]
    }
  },
  devDependencies: {
    "@babel/preset-env": "^7.22.9",
    "@babel/preset-typescript": "^7.22.5",
    "@microsoft/api-documenter": "^7.22.30",
    "@microsoft/api-extractor": "^7.36.3",
    "@microsoft/tsdoc": "^0.14.1",
    "@preconstruct/cli": "2.7.0",
    "@swc-node/register": "^1.6.6",
    "@thirdweb-dev/tsconfig": "workspace:*",
    "@types/chai": "^4.3.5",
    "@types/mocha": "^10.0.0",
    "@types/uuid": "^9.0.2",
    "@typescript-eslint/eslint-plugin": "^6.2.0",
    "@typescript-eslint/parser": "^6.2.0",
    chai: "^4.3.6",
    eslint: "^8.45.0",
    "eslint-config-thirdweb": "workspace:*",
    esm: "^3.2.25",
    mocha: "^10.2.0",
    typescript: "^5.1.6"
  },
  dependencies: {
    "cid-tool": "^3.0.0",
    "cross-fetch": "^3.1.8",
    "form-data": "^4.0.0",
    uuid: "^9.0.0"
  }
};
var StorageDownloader = class {
  constructor(options) {
    __publicField(this, "DEFAULT_TIMEOUT_IN_SECONDS", 60);
    __publicField(this, "DEFAULT_MAX_RETRIES", 3);
    this.secretKey = options.secretKey;
    this.clientId = options.clientId;
    this.defaultTimeout = options.timeoutInSeconds || this.DEFAULT_TIMEOUT_IN_SECONDS;
  }
  async download(uri, gatewayUrls, options) {
    let attempts = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : 0;
    const maxRetries = (options == null ? void 0 : options.maxRetries) || this.DEFAULT_MAX_RETRIES;
    if (attempts > maxRetries) {
      console.error("[FAILED_TO_DOWNLOAD_ERROR] Failed to download from URI - too many attempts failed.");
      return new import_cross_fetch.Response(JSON.stringify({
        error: "Not Found"
      }), {
        status: 404,
        headers: {
          "Content-Type": "application/json"
        }
      });
    }
    let resolvedUri = replaceSchemeWithGatewayUrl(uri, gatewayUrls, attempts, this.clientId);
    if (!resolvedUri) {
      console.error("[FAILED_TO_DOWNLOAD_ERROR] Unable to download from URI - all gateway URLs failed to respond.");
      return new import_cross_fetch.Response(JSON.stringify({
        error: "Not Found"
      }), {
        status: 404,
        headers: {
          "Content-Type": "application/json"
        }
      });
    } else if (attempts > 0) {
      console.warn(`Retrying download with backup gateway URL: ${resolvedUri}`);
    }
    let headers = {};
    if (isTwGatewayUrl(resolvedUri)) {
      const bundleId = typeof globalThis !== "undefined" && "APP_BUNDLE_ID" in globalThis ? globalThis.APP_BUNDLE_ID : void 0;
      if (this.secretKey) {
        headers = {
          "x-secret-key": this.secretKey
        };
      } else if (this.clientId) {
        if (!resolvedUri.includes("bundleId")) {
          resolvedUri = resolvedUri + (bundleId ? `?bundleId=${bundleId}` : "");
        }
        headers["x-client-Id"] = this.clientId;
      }
      if (typeof globalThis !== "undefined" && "TW_AUTH_TOKEN" in globalThis && typeof globalThis.TW_AUTH_TOKEN === "string") {
        headers = {
          ...headers,
          authorization: `Bearer ${globalThis.TW_AUTH_TOKEN}`
        };
      }
      if (typeof globalThis !== "undefined" && "TW_CLI_AUTH_TOKEN" in globalThis && typeof globalThis.TW_CLI_AUTH_TOKEN === "string") {
        headers = {
          ...headers,
          authorization: `Bearer ${globalThis.TW_CLI_AUTH_TOKEN}`
        };
        headers["x-authorize-wallet"] = "true";
      }
      headers["x-sdk-version"] = pkg.version;
      headers["x-sdk-name"] = pkg.name;
      headers["x-sdk-platform"] = bundleId ? "react-native" : window.bridge !== void 0 ? "webGL" : "browser";
    }
    if (isTooManyRequests(resolvedUri)) {
      return this.download(uri, gatewayUrls, options, attempts + 1);
    }
    const controller = new AbortController();
    const timeoutInSeconds = (options == null ? void 0 : options.timeoutInSeconds) || this.defaultTimeout;
    const timeout = setTimeout(() => controller.abort(), timeoutInSeconds * 1e3);
    const resOrErr = await (0, import_cross_fetch.default)(resolvedUri, {
      headers,
      signal: controller.signal
    }).catch((err) => err);
    if (timeout) {
      clearTimeout(timeout);
    }
    if (!("status" in resOrErr)) {
      throw new Error(`Request timed out after ${timeoutInSeconds} seconds. ${isTwGatewayUrl(resolvedUri) ? "You can update the timeoutInSeconds option to increase the timeout." : "You're using a public IPFS gateway, pass in a clientId or secretKey for a reliable IPFS gateway."}`);
    }
    if (resOrErr.ok) {
      return resOrErr;
    }
    if (resOrErr.status === 429) {
      tooManyRequestsBackOff(resolvedUri, resOrErr);
      return this.download(uri, gatewayUrls, options, attempts + 1);
    }
    if (resOrErr.status === 410) {
      console.error(`Request to ${resolvedUri} failed because this content seems to be blocklisted. Search VirusTotal for this URL to confirm: ${resolvedUri} `);
      return resOrErr;
    }
    console.warn(`Request to ${resolvedUri} failed with status ${resOrErr.status} - ${resOrErr.statusText}`);
    if (resOrErr.status === 404 && isTwGatewayUrl(resolvedUri)) {
      return resOrErr;
    }
    if (resOrErr.status !== 408 && resOrErr.status !== 429 && resOrErr.status < 500) {
      return resOrErr;
    }
    return this.download(uri, gatewayUrls, options, attempts + 1);
  }
};
var TOO_MANY_REQUESTS_TRACKER = /* @__PURE__ */ new Map();
function isTooManyRequests(gatewayUrl) {
  return TOO_MANY_REQUESTS_TRACKER.has(gatewayUrl);
}
var TIMEOUT_MAP = /* @__PURE__ */ new Map();
function tooManyRequestsBackOff(gatewayUrl, response) {
  if (TIMEOUT_MAP.has(gatewayUrl)) {
    clearTimeout(TIMEOUT_MAP.get(gatewayUrl));
  }
  const retryAfter = response.headers.get("Retry-After");
  let backOff = 5e3;
  if (retryAfter) {
    const retryAfterSeconds = parseInt(retryAfter);
    if (!isNaN(retryAfterSeconds)) {
      backOff = retryAfterSeconds * 1e3;
    }
  }
  TOO_MANY_REQUESTS_TRACKER.set(gatewayUrl, true);
  TIMEOUT_MAP.set(gatewayUrl, setTimeout(() => TOO_MANY_REQUESTS_TRACKER.delete(gatewayUrl), backOff));
}
var IpfsUploader = class {
  constructor(options) {
    this.uploadWithGatewayUrl = (options == null ? void 0 : options.uploadWithGatewayUrl) || false;
    this.uploadServerUrl = (options == null ? void 0 : options.uploadServerUrl) || TW_UPLOAD_SERVER_URL;
    this.clientId = options == null ? void 0 : options.clientId;
    this.secretKey = options == null ? void 0 : options.secretKey;
  }
  async uploadBatch(data, options) {
    if ((options == null ? void 0 : options.uploadWithoutDirectory) && data.length > 1) {
      throw new Error("[UPLOAD_WITHOUT_DIRECTORY_ERROR] Cannot upload more than one file or object without directory!");
    }
    const formData = new import_form_data.default();
    const {
      form,
      fileNames
    } = this.buildFormData(formData, data, options);
    {
      return this.uploadBatchBrowser(form, fileNames, options);
    }
  }
  buildFormData(form, files, options) {
    const fileNameToFileMap = /* @__PURE__ */ new Map();
    const fileNames = [];
    for (let i = 0; i < files.length; i++) {
      const file = files[i];
      let fileName = "";
      let fileData = file;
      if (isFileInstance(file)) {
        if (options == null ? void 0 : options.rewriteFileNames) {
          let extensions = "";
          if (file.name) {
            const extensionStartIndex = file.name.lastIndexOf(".");
            if (extensionStartIndex > -1) {
              extensions = file.name.substring(extensionStartIndex);
            }
          }
          fileName = `${i + options.rewriteFileNames.fileStartNumber}${extensions}`;
        } else {
          fileName = `${file.name}`;
        }
      } else if (isBufferOrStringWithName(file)) {
        fileData = file.data;
        if (options == null ? void 0 : options.rewriteFileNames) {
          fileName = `${i + options.rewriteFileNames.fileStartNumber}`;
        } else {
          fileName = `${file.name}`;
        }
      } else {
        if (options == null ? void 0 : options.rewriteFileNames) {
          fileName = `${i + options.rewriteFileNames.fileStartNumber}`;
        } else {
          fileName = `${i}`;
        }
      }
      const filepath = (options == null ? void 0 : options.uploadWithoutDirectory) ? `files` : `files/${fileName}`;
      if (fileNameToFileMap.has(fileName)) {
        if (isFileBufferOrStringEqual(fileNameToFileMap.get(fileName), file)) {
          fileNames.push(fileName);
          continue;
        }
        throw new Error(`[DUPLICATE_FILE_NAME_ERROR] File name ${fileName} was passed for more than one different file.`);
      }
      fileNameToFileMap.set(fileName, file);
      fileNames.push(fileName);
      {
        form.append("file", new Blob([fileData]), filepath);
      }
    }
    const metadata = {
      name: `Storage SDK`,
      keyvalues: {
        ...options == null ? void 0 : options.metadata
      }
    };
    form.append("pinataMetadata", JSON.stringify(metadata));
    if (options == null ? void 0 : options.uploadWithoutDirectory) {
      form.append("pinataOptions", JSON.stringify({
        wrapWithDirectory: false
      }));
    }
    return {
      form,
      // encode the file names on the way out (which is what the upload backend expects)
      fileNames: fileNames.map((fName) => encodeURIComponent(fName))
    };
  }
  async uploadBatchBrowser(form, fileNames, options) {
    return new Promise((resolve, reject) => {
      const xhr = new XMLHttpRequest();
      let timer = setTimeout(() => {
        xhr.abort();
        reject(new Error("Request to upload timed out! No upload progress received in 30s"));
      }, 3e4);
      xhr.upload.addEventListener("loadstart", () => {
        console.log(`[${Date.now()}] [IPFS] Started`);
      });
      xhr.upload.addEventListener("progress", (event) => {
        console.log(`[IPFS] Progress Event ${event.loaded}/${event.total}`);
        clearTimeout(timer);
        if (event.loaded < event.total) {
          timer = setTimeout(() => {
            xhr.abort();
            reject(new Error("Request to upload timed out! No upload progress received in 30s"));
          }, 3e4);
        } else {
          console.log(`[${Date.now()}] [IPFS] Uploaded files. Waiting for response.`);
        }
        if (event.lengthComputable && (options == null ? void 0 : options.onProgress)) {
          options == null ? void 0 : options.onProgress({
            progress: event.loaded,
            total: event.total
          });
        }
      });
      xhr.addEventListener("load", () => {
        console.log(`[${Date.now()}] [IPFS] Load`);
        clearTimeout(timer);
        if (xhr.status >= 200 && xhr.status < 300) {
          let body;
          try {
            body = JSON.parse(xhr.responseText);
          } catch (err) {
            return reject(new Error("Failed to parse JSON from upload response"));
          }
          const cid = body.IpfsHash;
          if (!cid) {
            throw new Error("Failed to get IPFS hash from upload response");
          }
          if (options == null ? void 0 : options.uploadWithoutDirectory) {
            return resolve([`ipfs://${cid}`]);
          } else {
            return resolve(fileNames.map((n) => `ipfs://${cid}/${n}`));
          }
        }
        return reject(new Error(`Upload failed with status ${xhr.status} - ${xhr.responseText}`));
      });
      xhr.addEventListener("error", () => {
        console.log("[IPFS] Load");
        clearTimeout(timer);
        if (xhr.readyState !== 0 && xhr.readyState !== 4 || xhr.status === 0) {
          return reject(new Error("Upload failed due to a network error."));
        }
        return reject(new Error("Unknown upload error occured"));
      });
      xhr.open("POST", `${this.uploadServerUrl}/ipfs/upload`);
      if (this.secretKey) {
        xhr.setRequestHeader("x-secret-key", this.secretKey);
      } else if (this.clientId) {
        xhr.setRequestHeader("x-client-id", this.clientId);
      }
      const bundleId = typeof globalThis !== "undefined" && "APP_BUNDLE_ID" in globalThis ? globalThis.APP_BUNDLE_ID : void 0;
      if (bundleId) {
        xhr.setRequestHeader("x-bundle-id", bundleId);
      }
      xhr.setRequestHeader("x-sdk-version", pkg.version);
      xhr.setRequestHeader("x-sdk-name", pkg.name);
      xhr.setRequestHeader("x-sdk-platform", bundleId ? "react-native" : window.bridge !== void 0 ? "webGL" : "browser");
      if (typeof globalThis !== "undefined" && "TW_AUTH_TOKEN" in globalThis && typeof globalThis.TW_AUTH_TOKEN === "string") {
        xhr.setRequestHeader("authorization", `Bearer ${globalThis.TW_AUTH_TOKEN}`);
      }
      if (typeof globalThis !== "undefined" && "TW_CLI_AUTH_TOKEN" in globalThis && typeof globalThis.TW_CLI_AUTH_TOKEN === "string") {
        xhr.setRequestHeader("authorization", `Bearer ${globalThis.TW_CLI_AUTH_TOKEN}`);
        xhr.setRequestHeader("x-authorize-wallet", `true`);
      }
      xhr.send(form);
    });
  }
  async uploadBatchNode(form, fileNames, options) {
    if (options == null ? void 0 : options.onProgress) {
      console.warn("The onProgress option is only supported in the browser");
    }
    const headers = {};
    if (this.secretKey) {
      headers["x-secret-key"] = this.secretKey;
    } else if (this.clientId) {
      headers["x-client-id"] = this.clientId;
    }
    if (typeof globalThis !== "undefined" && "APP_BUNDLE_ID" in globalThis) {
      headers["x-bundle-id"] = globalThis.APP_BUNDLE_ID;
    }
    if (typeof globalThis !== "undefined" && "TW_AUTH_TOKEN" in globalThis && typeof globalThis.TW_AUTH_TOKEN === "string") {
      headers["authorization"] = `Bearer ${globalThis.TW_AUTH_TOKEN}`;
    }
    if (typeof globalThis !== "undefined" && "TW_CLI_AUTH_TOKEN" in globalThis && typeof globalThis.TW_CLI_AUTH_TOKEN === "string") {
      headers["authorization"] = `Bearer ${globalThis.TW_CLI_AUTH_TOKEN}`;
      headers["x-authorize-wallet"] = "true";
    }
    const res = await (0, import_cross_fetch.default)(`${this.uploadServerUrl}/ipfs/upload`, {
      method: "POST",
      headers: {
        ...headers,
        ...form.getHeaders()
      },
      body: form.getBuffer()
    });
    if (!res.ok) {
      if (res.status === 401) {
        throw new Error("Unauthorized - You don't have permission to use this service.");
      }
      throw new Error(`Failed to upload files to IPFS - ${res.status} - ${res.statusText} - ${await res.text()}`);
    }
    const body = await res.json();
    const cid = body.IpfsHash;
    if (!cid) {
      throw new Error("Failed to upload files to IPFS - Bad CID");
    }
    if (options == null ? void 0 : options.uploadWithoutDirectory) {
      return [`ipfs://${cid}`];
    } else {
      return fileNames.map((name) => `ipfs://${cid}/${name}`);
    }
  }
};
var ThirdwebStorage = class {
  constructor(options) {
    this.uploader = (options == null ? void 0 : options.uploader) || new IpfsUploader({
      clientId: options == null ? void 0 : options.clientId,
      secretKey: options == null ? void 0 : options.secretKey,
      uploadServerUrl: options == null ? void 0 : options.uploadServerUrl
    });
    this.downloader = (options == null ? void 0 : options.downloader) || new StorageDownloader({
      secretKey: options == null ? void 0 : options.secretKey,
      clientId: options == null ? void 0 : options.clientId
    });
    this.gatewayUrls = prepareGatewayUrls(parseGatewayUrls(options == null ? void 0 : options.gatewayUrls), options == null ? void 0 : options.clientId, options == null ? void 0 : options.secretKey);
    this.clientId = options == null ? void 0 : options.clientId;
  }
  /**
   * Resolve any scheme on a URL to get a retrievable URL for the data
   *
   * @param url - The URL to resolve the scheme of
   * @returns The URL with its scheme resolved
   *
   * @example
   * ```jsx
   * const uri = "ipfs://example";
   * const url = storage.resolveScheme(uri);
   * console.log(url);
   * ```
   */
  resolveScheme(url) {
    return replaceSchemeWithGatewayUrl(url, this.gatewayUrls, 0, this.clientId);
  }
  /**
   * Downloads arbitrary data from any URL scheme.
   *
   * @param url - The URL of the data to download
   * @returns The response object fetched from the resolved URL
   *
   * @example
   * ```jsx
   * const uri = "ipfs://example";
   * const data = await storage.download(uri);
   * ```
   */
  async download(url, options) {
    return this.downloader.download(url, this.gatewayUrls, options);
  }
  /**
   * Downloads JSON data from any URL scheme.
   * Resolves any URLs with schemes to retrievable gateway URLs.
   *
   * @param url - The URL of the JSON data to download
   * @returns The JSON data fetched from the resolved URL
   *
   * @example
   * ```jsx
   * const uri = "ipfs://example";
   * const json = await storage.downloadJSON(uri);
   * ```
   */
  async downloadJSON(url, options) {
    const res = await this.download(url, options);
    const json = await res.json();
    return replaceObjectSchemesWithGatewayUrls(json, this.gatewayUrls, this.clientId);
  }
  /**
   * Upload arbitrary file or JSON data using the configured decentralized storage system.
   * Automatically uploads any file data within JSON objects and replaces them with hashes.
   *
   * @param data - Arbitrary file or JSON data to upload
   * @param options - Options to pass through to the storage uploader class
   * @returns - The URI of the uploaded data
   *
   * @example
   * ```jsx
   * // Upload file data
   * const file = readFileSync("../file.jpg");
   * const fileUri = await storage.upload(file);
   *
   * // Or upload a JSON object
   * const json = { name: "JSON", image: file };
   * const jsonUri = await storage.upload(json);
   * ```
   */
  async upload(data, options) {
    const [uri] = await this.uploadBatch([data], options);
    return uri;
  }
  /**
   * Batch upload arbitrary file or JSON data using the configured decentralized storage system.
   * Automatically uploads any file data within JSON objects and replaces them with hashes.
   *
   * @param data - Array of arbitrary file or JSON data to upload
   * @param options - Options to pass through to the storage uploader class
   * @returns - The URIs of the uploaded data
   *
   * @example
   * ```jsx
   * // Upload an array of file data
   * const files = [
   *  readFileSync("../file1.jpg"),
   *  readFileSync("../file2.jpg"),
   * ];
   * const fileUris = await storage.uploadBatch(files);
   *
   * // Upload an array of JSON objects
   * const objects = [
   *  { name: "JSON 1", image: files[0] },
   *  { name: "JSON 2", image: files[1] },
   * ];
   * const jsonUris = await storage.uploadBatch(objects);
   * ```
   */
  async uploadBatch(data, options) {
    data = data.filter((item) => item !== void 0);
    if (!data.length) {
      return [];
    }
    const isFileArray = data.map((item) => isFileOrBuffer(item) || typeof item === "string").every((item) => !!item);
    let uris = [];
    if (isFileArray) {
      uris = await this.uploader.uploadBatch(data, options);
    } else {
      const metadata = (await this.uploadAndReplaceFilesWithHashes(data, options)).map((item) => {
        if (typeof item === "string") {
          return item;
        }
        return JSON.stringify(item);
      });
      uris = await this.uploader.uploadBatch(metadata, options);
    }
    if ((options == null ? void 0 : options.uploadWithGatewayUrl) || this.uploader.uploadWithGatewayUrl) {
      return uris.map((uri) => this.resolveScheme(uri));
    } else {
      return uris;
    }
  }
  getGatewayUrls() {
    return this.gatewayUrls;
  }
  async uploadAndReplaceFilesWithHashes(data, options) {
    let cleaned = data;
    cleaned = replaceObjectGatewayUrlsWithSchemes(cleaned, this.gatewayUrls);
    const files = extractObjectFiles(cleaned);
    if (files.length) {
      const uris = await this.uploader.uploadBatch(files, options);
      cleaned = replaceObjectFilesWithUris(cleaned, uris);
    }
    if ((options == null ? void 0 : options.uploadWithGatewayUrl) || this.uploader.uploadWithGatewayUrl) {
      cleaned = replaceObjectSchemesWithGatewayUrls(cleaned, this.gatewayUrls, this.clientId);
    }
    return cleaned;
  }
};

// node_modules/@thirdweb-dev/contracts-js/dist/abis/IERC165.json
var IERC165_default = [
  {
    inputs: [
      {
        internalType: "bytes4",
        name: "interfaceId",
        type: "bytes4"
      }
    ],
    name: "supportsInterface",
    outputs: [
      {
        internalType: "bool",
        name: "",
        type: "bool"
      }
    ],
    stateMutability: "view",
    type: "function"
  }
];

// node_modules/@thirdweb-dev/contracts-js/dist/abis/IERC721Metadata.json
var IERC721Metadata_default = [
  {
    inputs: [],
    name: "name",
    outputs: [
      {
        internalType: "string",
        name: "",
        type: "string"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [],
    name: "symbol",
    outputs: [
      {
        internalType: "string",
        name: "",
        type: "string"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "uint256",
        name: "_tokenId",
        type: "uint256"
      }
    ],
    name: "tokenURI",
    outputs: [
      {
        internalType: "string",
        name: "",
        type: "string"
      }
    ],
    stateMutability: "view",
    type: "function"
  }
];

// node_modules/@thirdweb-dev/contracts-js/dist/abis/IERC1155Metadata.json
var IERC1155Metadata_default = [
  {
    inputs: [
      {
        internalType: "uint256",
        name: "_id",
        type: "uint256"
      }
    ],
    name: "uri",
    outputs: [
      {
        internalType: "string",
        name: "",
        type: "string"
      }
    ],
    stateMutability: "view",
    type: "function"
  }
];

// node_modules/@thirdweb-dev/contracts-js/dist/abis/IERC20.json
var IERC20_default = [
  {
    anonymous: false,
    inputs: [
      {
        indexed: true,
        internalType: "address",
        name: "owner",
        type: "address"
      },
      {
        indexed: true,
        internalType: "address",
        name: "spender",
        type: "address"
      },
      {
        indexed: false,
        internalType: "uint256",
        name: "value",
        type: "uint256"
      }
    ],
    name: "Approval",
    type: "event"
  },
  {
    anonymous: false,
    inputs: [
      {
        indexed: true,
        internalType: "address",
        name: "from",
        type: "address"
      },
      {
        indexed: true,
        internalType: "address",
        name: "to",
        type: "address"
      },
      {
        indexed: false,
        internalType: "uint256",
        name: "value",
        type: "uint256"
      }
    ],
    name: "Transfer",
    type: "event"
  },
  {
    inputs: [
      {
        internalType: "address",
        name: "owner",
        type: "address"
      },
      {
        internalType: "address",
        name: "spender",
        type: "address"
      }
    ],
    name: "allowance",
    outputs: [
      {
        internalType: "uint256",
        name: "",
        type: "uint256"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "address",
        name: "spender",
        type: "address"
      },
      {
        internalType: "uint256",
        name: "value",
        type: "uint256"
      }
    ],
    name: "approve",
    outputs: [
      {
        internalType: "bool",
        name: "",
        type: "bool"
      }
    ],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "address",
        name: "who",
        type: "address"
      }
    ],
    name: "balanceOf",
    outputs: [
      {
        internalType: "uint256",
        name: "",
        type: "uint256"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [],
    name: "totalSupply",
    outputs: [
      {
        internalType: "uint256",
        name: "",
        type: "uint256"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "address",
        name: "to",
        type: "address"
      },
      {
        internalType: "uint256",
        name: "value",
        type: "uint256"
      }
    ],
    name: "transfer",
    outputs: [
      {
        internalType: "bool",
        name: "",
        type: "bool"
      }
    ],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "address",
        name: "from",
        type: "address"
      },
      {
        internalType: "address",
        name: "to",
        type: "address"
      },
      {
        internalType: "uint256",
        name: "value",
        type: "uint256"
      }
    ],
    name: "transferFrom",
    outputs: [
      {
        internalType: "bool",
        name: "",
        type: "bool"
      }
    ],
    stateMutability: "nonpayable",
    type: "function"
  }
];

// node_modules/@thirdweb-dev/contracts-js/dist/abis/IERC20Metadata.json
var IERC20Metadata_default = [
  {
    inputs: [],
    name: "decimals",
    outputs: [
      {
        internalType: "uint8",
        name: "",
        type: "uint8"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [],
    name: "name",
    outputs: [
      {
        internalType: "string",
        name: "",
        type: "string"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [],
    name: "symbol",
    outputs: [
      {
        internalType: "string",
        name: "",
        type: "string"
      }
    ],
    stateMutability: "view",
    type: "function"
  }
];

// node_modules/@thirdweb-dev/contracts-js/dist/abis/IThirdwebContract.json
var IThirdwebContract_default = [
  {
    inputs: [],
    name: "contractType",
    outputs: [
      {
        internalType: "bytes32",
        name: "",
        type: "bytes32"
      }
    ],
    stateMutability: "pure",
    type: "function"
  },
  {
    inputs: [],
    name: "contractURI",
    outputs: [
      {
        internalType: "string",
        name: "",
        type: "string"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [],
    name: "contractVersion",
    outputs: [
      {
        internalType: "uint8",
        name: "",
        type: "uint8"
      }
    ],
    stateMutability: "pure",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "string",
        name: "_uri",
        type: "string"
      }
    ],
    name: "setContractURI",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  }
];

// node_modules/@thirdweb-dev/contracts-js/dist/abis/IDelayedRevealDeprecated.json
var IDelayedRevealDeprecated_default = [
  {
    anonymous: false,
    inputs: [
      {
        indexed: true,
        internalType: "uint256",
        name: "index",
        type: "uint256"
      },
      {
        indexed: false,
        internalType: "string",
        name: "revealedURI",
        type: "string"
      }
    ],
    name: "TokenURIRevealed",
    type: "event"
  },
  {
    inputs: [
      {
        internalType: "bytes",
        name: "data",
        type: "bytes"
      },
      {
        internalType: "bytes",
        name: "key",
        type: "bytes"
      }
    ],
    name: "encryptDecrypt",
    outputs: [
      {
        internalType: "bytes",
        name: "result",
        type: "bytes"
      }
    ],
    stateMutability: "pure",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "uint256",
        name: "identifier",
        type: "uint256"
      }
    ],
    name: "encryptedBaseURI",
    outputs: [
      {
        internalType: "bytes",
        name: "",
        type: "bytes"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "uint256",
        name: "identifier",
        type: "uint256"
      },
      {
        internalType: "bytes",
        name: "key",
        type: "bytes"
      }
    ],
    name: "reveal",
    outputs: [
      {
        internalType: "string",
        name: "revealedURI",
        type: "string"
      }
    ],
    stateMutability: "nonpayable",
    type: "function"
  }
];

// node_modules/@thirdweb-dev/contracts-js/dist/abis/IERC1155.json
var IERC1155_default = [
  {
    anonymous: false,
    inputs: [
      {
        indexed: true,
        internalType: "address",
        name: "_owner",
        type: "address"
      },
      {
        indexed: true,
        internalType: "address",
        name: "_operator",
        type: "address"
      },
      {
        indexed: false,
        internalType: "bool",
        name: "_approved",
        type: "bool"
      }
    ],
    name: "ApprovalForAll",
    type: "event"
  },
  {
    anonymous: false,
    inputs: [
      {
        indexed: true,
        internalType: "address",
        name: "_operator",
        type: "address"
      },
      {
        indexed: true,
        internalType: "address",
        name: "_from",
        type: "address"
      },
      {
        indexed: true,
        internalType: "address",
        name: "_to",
        type: "address"
      },
      {
        indexed: false,
        internalType: "uint256[]",
        name: "_ids",
        type: "uint256[]"
      },
      {
        indexed: false,
        internalType: "uint256[]",
        name: "_values",
        type: "uint256[]"
      }
    ],
    name: "TransferBatch",
    type: "event"
  },
  {
    anonymous: false,
    inputs: [
      {
        indexed: true,
        internalType: "address",
        name: "_operator",
        type: "address"
      },
      {
        indexed: true,
        internalType: "address",
        name: "_from",
        type: "address"
      },
      {
        indexed: true,
        internalType: "address",
        name: "_to",
        type: "address"
      },
      {
        indexed: false,
        internalType: "uint256",
        name: "_id",
        type: "uint256"
      },
      {
        indexed: false,
        internalType: "uint256",
        name: "_value",
        type: "uint256"
      }
    ],
    name: "TransferSingle",
    type: "event"
  },
  {
    anonymous: false,
    inputs: [
      {
        indexed: false,
        internalType: "string",
        name: "_value",
        type: "string"
      },
      {
        indexed: true,
        internalType: "uint256",
        name: "_id",
        type: "uint256"
      }
    ],
    name: "URI",
    type: "event"
  },
  {
    inputs: [
      {
        internalType: "address",
        name: "_owner",
        type: "address"
      },
      {
        internalType: "uint256",
        name: "_id",
        type: "uint256"
      }
    ],
    name: "balanceOf",
    outputs: [
      {
        internalType: "uint256",
        name: "",
        type: "uint256"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "address[]",
        name: "_owners",
        type: "address[]"
      },
      {
        internalType: "uint256[]",
        name: "_ids",
        type: "uint256[]"
      }
    ],
    name: "balanceOfBatch",
    outputs: [
      {
        internalType: "uint256[]",
        name: "",
        type: "uint256[]"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "address",
        name: "_owner",
        type: "address"
      },
      {
        internalType: "address",
        name: "_operator",
        type: "address"
      }
    ],
    name: "isApprovedForAll",
    outputs: [
      {
        internalType: "bool",
        name: "",
        type: "bool"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "address",
        name: "_from",
        type: "address"
      },
      {
        internalType: "address",
        name: "_to",
        type: "address"
      },
      {
        internalType: "uint256[]",
        name: "_ids",
        type: "uint256[]"
      },
      {
        internalType: "uint256[]",
        name: "_values",
        type: "uint256[]"
      },
      {
        internalType: "bytes",
        name: "_data",
        type: "bytes"
      }
    ],
    name: "safeBatchTransferFrom",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "address",
        name: "_from",
        type: "address"
      },
      {
        internalType: "address",
        name: "_to",
        type: "address"
      },
      {
        internalType: "uint256",
        name: "_id",
        type: "uint256"
      },
      {
        internalType: "uint256",
        name: "_value",
        type: "uint256"
      },
      {
        internalType: "bytes",
        name: "_data",
        type: "bytes"
      }
    ],
    name: "safeTransferFrom",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "address",
        name: "_operator",
        type: "address"
      },
      {
        internalType: "bool",
        name: "_approved",
        type: "bool"
      }
    ],
    name: "setApprovalForAll",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  }
];

// node_modules/@thirdweb-dev/contracts-js/dist/abis/IERC721.json
var IERC721_default = [
  {
    anonymous: false,
    inputs: [
      {
        indexed: true,
        internalType: "address",
        name: "owner",
        type: "address"
      },
      {
        indexed: true,
        internalType: "address",
        name: "approved",
        type: "address"
      },
      {
        indexed: true,
        internalType: "uint256",
        name: "tokenId",
        type: "uint256"
      }
    ],
    name: "Approval",
    type: "event"
  },
  {
    anonymous: false,
    inputs: [
      {
        indexed: true,
        internalType: "address",
        name: "owner",
        type: "address"
      },
      {
        indexed: true,
        internalType: "address",
        name: "operator",
        type: "address"
      },
      {
        indexed: false,
        internalType: "bool",
        name: "approved",
        type: "bool"
      }
    ],
    name: "ApprovalForAll",
    type: "event"
  },
  {
    anonymous: false,
    inputs: [
      {
        indexed: true,
        internalType: "address",
        name: "from",
        type: "address"
      },
      {
        indexed: true,
        internalType: "address",
        name: "to",
        type: "address"
      },
      {
        indexed: true,
        internalType: "uint256",
        name: "tokenId",
        type: "uint256"
      }
    ],
    name: "Transfer",
    type: "event"
  },
  {
    inputs: [
      {
        internalType: "address",
        name: "to",
        type: "address"
      },
      {
        internalType: "uint256",
        name: "tokenId",
        type: "uint256"
      }
    ],
    name: "approve",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "address",
        name: "owner",
        type: "address"
      }
    ],
    name: "balanceOf",
    outputs: [
      {
        internalType: "uint256",
        name: "",
        type: "uint256"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "uint256",
        name: "tokenId",
        type: "uint256"
      }
    ],
    name: "getApproved",
    outputs: [
      {
        internalType: "address",
        name: "",
        type: "address"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "address",
        name: "owner",
        type: "address"
      },
      {
        internalType: "address",
        name: "operator",
        type: "address"
      }
    ],
    name: "isApprovedForAll",
    outputs: [
      {
        internalType: "bool",
        name: "",
        type: "bool"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "uint256",
        name: "tokenId",
        type: "uint256"
      }
    ],
    name: "ownerOf",
    outputs: [
      {
        internalType: "address",
        name: "",
        type: "address"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "address",
        name: "from",
        type: "address"
      },
      {
        internalType: "address",
        name: "to",
        type: "address"
      },
      {
        internalType: "uint256",
        name: "tokenId",
        type: "uint256"
      }
    ],
    name: "safeTransferFrom",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "address",
        name: "from",
        type: "address"
      },
      {
        internalType: "address",
        name: "to",
        type: "address"
      },
      {
        internalType: "uint256",
        name: "tokenId",
        type: "uint256"
      },
      {
        internalType: "bytes",
        name: "data",
        type: "bytes"
      }
    ],
    name: "safeTransferFrom",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "address",
        name: "operator",
        type: "address"
      },
      {
        internalType: "bool",
        name: "_approved",
        type: "bool"
      }
    ],
    name: "setApprovalForAll",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "address",
        name: "from",
        type: "address"
      },
      {
        internalType: "address",
        name: "to",
        type: "address"
      },
      {
        internalType: "uint256",
        name: "tokenId",
        type: "uint256"
      }
    ],
    name: "transferFrom",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  }
];

// node_modules/@thirdweb-dev/contracts-js/dist/abis/ContractPublisher.json
var ContractPublisher_default = [
  {
    inputs: [
      {
        internalType: "address",
        name: "_trustedForwarder",
        type: "address"
      },
      {
        internalType: "contract IContractPublisher",
        name: "_prevPublisher",
        type: "address"
      }
    ],
    stateMutability: "nonpayable",
    type: "constructor"
  },
  {
    anonymous: false,
    inputs: [
      {
        indexed: true,
        internalType: "address",
        name: "operator",
        type: "address"
      },
      {
        indexed: true,
        internalType: "address",
        name: "publisher",
        type: "address"
      },
      {
        components: [
          {
            internalType: "string",
            name: "contractId",
            type: "string"
          },
          {
            internalType: "uint256",
            name: "publishTimestamp",
            type: "uint256"
          },
          {
            internalType: "string",
            name: "publishMetadataUri",
            type: "string"
          },
          {
            internalType: "bytes32",
            name: "bytecodeHash",
            type: "bytes32"
          },
          {
            internalType: "address",
            name: "implementation",
            type: "address"
          }
        ],
        indexed: false,
        internalType: "struct IContractPublisher.CustomContractInstance",
        name: "publishedContract",
        type: "tuple"
      }
    ],
    name: "ContractPublished",
    type: "event"
  },
  {
    anonymous: false,
    inputs: [
      {
        indexed: true,
        internalType: "address",
        name: "operator",
        type: "address"
      },
      {
        indexed: true,
        internalType: "address",
        name: "publisher",
        type: "address"
      },
      {
        indexed: true,
        internalType: "string",
        name: "contractId",
        type: "string"
      }
    ],
    name: "ContractUnpublished",
    type: "event"
  },
  {
    anonymous: false,
    inputs: [
      {
        indexed: false,
        internalType: "bool",
        name: "isPaused",
        type: "bool"
      }
    ],
    name: "Paused",
    type: "event"
  },
  {
    anonymous: false,
    inputs: [
      {
        indexed: true,
        internalType: "address",
        name: "publisher",
        type: "address"
      },
      {
        indexed: false,
        internalType: "string",
        name: "prevURI",
        type: "string"
      },
      {
        indexed: false,
        internalType: "string",
        name: "newURI",
        type: "string"
      }
    ],
    name: "PublisherProfileUpdated",
    type: "event"
  },
  {
    anonymous: false,
    inputs: [
      {
        indexed: true,
        internalType: "bytes32",
        name: "role",
        type: "bytes32"
      },
      {
        indexed: true,
        internalType: "bytes32",
        name: "previousAdminRole",
        type: "bytes32"
      },
      {
        indexed: true,
        internalType: "bytes32",
        name: "newAdminRole",
        type: "bytes32"
      }
    ],
    name: "RoleAdminChanged",
    type: "event"
  },
  {
    anonymous: false,
    inputs: [
      {
        indexed: true,
        internalType: "bytes32",
        name: "role",
        type: "bytes32"
      },
      {
        indexed: true,
        internalType: "address",
        name: "account",
        type: "address"
      },
      {
        indexed: true,
        internalType: "address",
        name: "sender",
        type: "address"
      }
    ],
    name: "RoleGranted",
    type: "event"
  },
  {
    anonymous: false,
    inputs: [
      {
        indexed: true,
        internalType: "bytes32",
        name: "role",
        type: "bytes32"
      },
      {
        indexed: true,
        internalType: "address",
        name: "account",
        type: "address"
      },
      {
        indexed: true,
        internalType: "address",
        name: "sender",
        type: "address"
      }
    ],
    name: "RoleRevoked",
    type: "event"
  },
  {
    inputs: [],
    name: "DEFAULT_ADMIN_ROLE",
    outputs: [
      {
        internalType: "bytes32",
        name: "",
        type: "bytes32"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "address",
        name: "_publisher",
        type: "address"
      }
    ],
    name: "getAllPublishedContracts",
    outputs: [
      {
        components: [
          {
            internalType: "string",
            name: "contractId",
            type: "string"
          },
          {
            internalType: "uint256",
            name: "publishTimestamp",
            type: "uint256"
          },
          {
            internalType: "string",
            name: "publishMetadataUri",
            type: "string"
          },
          {
            internalType: "bytes32",
            name: "bytecodeHash",
            type: "bytes32"
          },
          {
            internalType: "address",
            name: "implementation",
            type: "address"
          }
        ],
        internalType: "struct IContractPublisher.CustomContractInstance[]",
        name: "published",
        type: "tuple[]"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "address",
        name: "_publisher",
        type: "address"
      },
      {
        internalType: "string",
        name: "_contractId",
        type: "string"
      }
    ],
    name: "getPublishedContract",
    outputs: [
      {
        components: [
          {
            internalType: "string",
            name: "contractId",
            type: "string"
          },
          {
            internalType: "uint256",
            name: "publishTimestamp",
            type: "uint256"
          },
          {
            internalType: "string",
            name: "publishMetadataUri",
            type: "string"
          },
          {
            internalType: "bytes32",
            name: "bytecodeHash",
            type: "bytes32"
          },
          {
            internalType: "address",
            name: "implementation",
            type: "address"
          }
        ],
        internalType: "struct IContractPublisher.CustomContractInstance",
        name: "published",
        type: "tuple"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "address",
        name: "_publisher",
        type: "address"
      },
      {
        internalType: "string",
        name: "_contractId",
        type: "string"
      }
    ],
    name: "getPublishedContractVersions",
    outputs: [
      {
        components: [
          {
            internalType: "string",
            name: "contractId",
            type: "string"
          },
          {
            internalType: "uint256",
            name: "publishTimestamp",
            type: "uint256"
          },
          {
            internalType: "string",
            name: "publishMetadataUri",
            type: "string"
          },
          {
            internalType: "bytes32",
            name: "bytecodeHash",
            type: "bytes32"
          },
          {
            internalType: "address",
            name: "implementation",
            type: "address"
          }
        ],
        internalType: "struct IContractPublisher.CustomContractInstance[]",
        name: "published",
        type: "tuple[]"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "string",
        name: "compilerMetadataUri",
        type: "string"
      }
    ],
    name: "getPublishedUriFromCompilerUri",
    outputs: [
      {
        internalType: "string[]",
        name: "publishedMetadataUris",
        type: "string[]"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "address",
        name: "publisher",
        type: "address"
      }
    ],
    name: "getPublisherProfileUri",
    outputs: [
      {
        internalType: "string",
        name: "uri",
        type: "string"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "bytes32",
        name: "role",
        type: "bytes32"
      }
    ],
    name: "getRoleAdmin",
    outputs: [
      {
        internalType: "bytes32",
        name: "",
        type: "bytes32"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "bytes32",
        name: "role",
        type: "bytes32"
      },
      {
        internalType: "uint256",
        name: "index",
        type: "uint256"
      }
    ],
    name: "getRoleMember",
    outputs: [
      {
        internalType: "address",
        name: "",
        type: "address"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "bytes32",
        name: "role",
        type: "bytes32"
      }
    ],
    name: "getRoleMemberCount",
    outputs: [
      {
        internalType: "uint256",
        name: "",
        type: "uint256"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "bytes32",
        name: "role",
        type: "bytes32"
      },
      {
        internalType: "address",
        name: "account",
        type: "address"
      }
    ],
    name: "grantRole",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "bytes32",
        name: "role",
        type: "bytes32"
      },
      {
        internalType: "address",
        name: "account",
        type: "address"
      }
    ],
    name: "hasRole",
    outputs: [
      {
        internalType: "bool",
        name: "",
        type: "bool"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [],
    name: "isPaused",
    outputs: [
      {
        internalType: "bool",
        name: "",
        type: "bool"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "address",
        name: "forwarder",
        type: "address"
      }
    ],
    name: "isTrustedForwarder",
    outputs: [
      {
        internalType: "bool",
        name: "",
        type: "bool"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "bytes[]",
        name: "data",
        type: "bytes[]"
      }
    ],
    name: "multicall",
    outputs: [
      {
        internalType: "bytes[]",
        name: "results",
        type: "bytes[]"
      }
    ],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [],
    name: "prevPublisher",
    outputs: [
      {
        internalType: "contract IContractPublisher",
        name: "",
        type: "address"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "address",
        name: "_publisher",
        type: "address"
      },
      {
        internalType: "string",
        name: "_contractId",
        type: "string"
      },
      {
        internalType: "string",
        name: "_publishMetadataUri",
        type: "string"
      },
      {
        internalType: "string",
        name: "_compilerMetadataUri",
        type: "string"
      },
      {
        internalType: "bytes32",
        name: "_bytecodeHash",
        type: "bytes32"
      },
      {
        internalType: "address",
        name: "_implementation",
        type: "address"
      }
    ],
    name: "publishContract",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "bytes32",
        name: "role",
        type: "bytes32"
      },
      {
        internalType: "address",
        name: "account",
        type: "address"
      }
    ],
    name: "renounceRole",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "bytes32",
        name: "role",
        type: "bytes32"
      },
      {
        internalType: "address",
        name: "account",
        type: "address"
      }
    ],
    name: "revokeRole",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "bool",
        name: "_pause",
        type: "bool"
      }
    ],
    name: "setPause",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "address",
        name: "publisher",
        type: "address"
      },
      {
        internalType: "string",
        name: "uri",
        type: "string"
      }
    ],
    name: "setPublisherProfileUri",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "bytes4",
        name: "interfaceId",
        type: "bytes4"
      }
    ],
    name: "supportsInterface",
    outputs: [
      {
        internalType: "bool",
        name: "",
        type: "bool"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "address",
        name: "_publisher",
        type: "address"
      },
      {
        internalType: "string",
        name: "_contractId",
        type: "string"
      }
    ],
    name: "unpublishContract",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  }
];

// node_modules/@thirdweb-dev/contracts-js/dist/abis/TWMultichainRegistryLogic.json
var TWMultichainRegistryLogic_default = [
  {
    anonymous: false,
    inputs: [
      {
        indexed: true,
        internalType: "address",
        name: "deployer",
        type: "address"
      },
      {
        indexed: true,
        internalType: "address",
        name: "deployment",
        type: "address"
      },
      {
        indexed: true,
        internalType: "uint256",
        name: "chainId",
        type: "uint256"
      },
      {
        indexed: false,
        internalType: "string",
        name: "metadataUri",
        type: "string"
      }
    ],
    name: "Added",
    type: "event"
  },
  {
    anonymous: false,
    inputs: [
      {
        indexed: true,
        internalType: "address",
        name: "deployer",
        type: "address"
      },
      {
        indexed: true,
        internalType: "address",
        name: "deployment",
        type: "address"
      },
      {
        indexed: true,
        internalType: "uint256",
        name: "chainId",
        type: "uint256"
      }
    ],
    name: "Deleted",
    type: "event"
  },
  {
    inputs: [],
    name: "OPERATOR_ROLE",
    outputs: [
      {
        internalType: "bytes32",
        name: "",
        type: "bytes32"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [],
    name: "_msgData",
    outputs: [
      {
        internalType: "bytes",
        name: "",
        type: "bytes"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [],
    name: "_msgSender",
    outputs: [
      {
        internalType: "address",
        name: "sender",
        type: "address"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "address",
        name: "_deployer",
        type: "address"
      },
      {
        internalType: "address",
        name: "_deployment",
        type: "address"
      },
      {
        internalType: "uint256",
        name: "_chainId",
        type: "uint256"
      },
      {
        internalType: "string",
        name: "metadataUri",
        type: "string"
      }
    ],
    name: "add",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [],
    name: "contractType",
    outputs: [
      {
        internalType: "bytes32",
        name: "",
        type: "bytes32"
      }
    ],
    stateMutability: "pure",
    type: "function"
  },
  {
    inputs: [],
    name: "contractVersion",
    outputs: [
      {
        internalType: "uint8",
        name: "",
        type: "uint8"
      }
    ],
    stateMutability: "pure",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "address",
        name: "_deployer",
        type: "address"
      }
    ],
    name: "count",
    outputs: [
      {
        internalType: "uint256",
        name: "deploymentCount",
        type: "uint256"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "address",
        name: "_deployer",
        type: "address"
      }
    ],
    name: "getAll",
    outputs: [
      {
        components: [
          {
            internalType: "address",
            name: "deploymentAddress",
            type: "address"
          },
          {
            internalType: "uint256",
            name: "chainId",
            type: "uint256"
          },
          {
            internalType: "string",
            name: "metadataURI",
            type: "string"
          }
        ],
        internalType: "struct ITWMultichainRegistry.Deployment[]",
        name: "allDeployments",
        type: "tuple[]"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "uint256",
        name: "_chainId",
        type: "uint256"
      },
      {
        internalType: "address",
        name: "_deployment",
        type: "address"
      }
    ],
    name: "getMetadataUri",
    outputs: [
      {
        internalType: "string",
        name: "metadataUri",
        type: "string"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "address",
        name: "_deployer",
        type: "address"
      },
      {
        internalType: "address",
        name: "_deployment",
        type: "address"
      },
      {
        internalType: "uint256",
        name: "_chainId",
        type: "uint256"
      }
    ],
    name: "remove",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  }
];

// node_modules/@thirdweb-dev/contracts-js/dist/abis/IBurnableERC20.json
var IBurnableERC20_default = [
  {
    inputs: [
      {
        internalType: "uint256",
        name: "amount",
        type: "uint256"
      }
    ],
    name: "burn",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "address",
        name: "account",
        type: "address"
      },
      {
        internalType: "uint256",
        name: "amount",
        type: "uint256"
      }
    ],
    name: "burnFrom",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  }
];

// node_modules/@thirdweb-dev/contracts-js/dist/abis/IDrop.json
var IDrop_default = [
  {
    anonymous: false,
    inputs: [
      {
        components: [
          {
            internalType: "uint256",
            name: "startTimestamp",
            type: "uint256"
          },
          {
            internalType: "uint256",
            name: "maxClaimableSupply",
            type: "uint256"
          },
          {
            internalType: "uint256",
            name: "supplyClaimed",
            type: "uint256"
          },
          {
            internalType: "uint256",
            name: "quantityLimitPerWallet",
            type: "uint256"
          },
          {
            internalType: "bytes32",
            name: "merkleRoot",
            type: "bytes32"
          },
          {
            internalType: "uint256",
            name: "pricePerToken",
            type: "uint256"
          },
          {
            internalType: "address",
            name: "currency",
            type: "address"
          },
          {
            internalType: "string",
            name: "metadata",
            type: "string"
          }
        ],
        indexed: false,
        internalType: "struct IClaimCondition.ClaimCondition[]",
        name: "claimConditions",
        type: "tuple[]"
      },
      {
        indexed: false,
        internalType: "bool",
        name: "resetEligibility",
        type: "bool"
      }
    ],
    name: "ClaimConditionsUpdated",
    type: "event"
  },
  {
    anonymous: false,
    inputs: [
      {
        indexed: true,
        internalType: "uint256",
        name: "claimConditionIndex",
        type: "uint256"
      },
      {
        indexed: true,
        internalType: "address",
        name: "claimer",
        type: "address"
      },
      {
        indexed: true,
        internalType: "address",
        name: "receiver",
        type: "address"
      },
      {
        indexed: false,
        internalType: "uint256",
        name: "startTokenId",
        type: "uint256"
      },
      {
        indexed: false,
        internalType: "uint256",
        name: "quantityClaimed",
        type: "uint256"
      }
    ],
    name: "TokensClaimed",
    type: "event"
  },
  {
    inputs: [
      {
        internalType: "address",
        name: "receiver",
        type: "address"
      },
      {
        internalType: "uint256",
        name: "quantity",
        type: "uint256"
      },
      {
        internalType: "address",
        name: "currency",
        type: "address"
      },
      {
        internalType: "uint256",
        name: "pricePerToken",
        type: "uint256"
      },
      {
        components: [
          {
            internalType: "bytes32[]",
            name: "proof",
            type: "bytes32[]"
          },
          {
            internalType: "uint256",
            name: "quantityLimitPerWallet",
            type: "uint256"
          },
          {
            internalType: "uint256",
            name: "pricePerToken",
            type: "uint256"
          },
          {
            internalType: "address",
            name: "currency",
            type: "address"
          }
        ],
        internalType: "struct IDrop.AllowlistProof",
        name: "allowlistProof",
        type: "tuple"
      },
      {
        internalType: "bytes",
        name: "data",
        type: "bytes"
      }
    ],
    name: "claim",
    outputs: [],
    stateMutability: "payable",
    type: "function"
  },
  {
    inputs: [
      {
        components: [
          {
            internalType: "uint256",
            name: "startTimestamp",
            type: "uint256"
          },
          {
            internalType: "uint256",
            name: "maxClaimableSupply",
            type: "uint256"
          },
          {
            internalType: "uint256",
            name: "supplyClaimed",
            type: "uint256"
          },
          {
            internalType: "uint256",
            name: "quantityLimitPerWallet",
            type: "uint256"
          },
          {
            internalType: "bytes32",
            name: "merkleRoot",
            type: "bytes32"
          },
          {
            internalType: "uint256",
            name: "pricePerToken",
            type: "uint256"
          },
          {
            internalType: "address",
            name: "currency",
            type: "address"
          },
          {
            internalType: "string",
            name: "metadata",
            type: "string"
          }
        ],
        internalType: "struct IClaimCondition.ClaimCondition[]",
        name: "phases",
        type: "tuple[]"
      },
      {
        internalType: "bool",
        name: "resetClaimEligibility",
        type: "bool"
      }
    ],
    name: "setClaimConditions",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  }
];

// node_modules/@thirdweb-dev/contracts-js/dist/abis/IDropERC20_V2.json
var IDropERC20_V2_default = [
  {
    anonymous: false,
    inputs: [
      {
        indexed: true,
        internalType: "address",
        name: "owner",
        type: "address"
      },
      {
        indexed: true,
        internalType: "address",
        name: "spender",
        type: "address"
      },
      {
        indexed: false,
        internalType: "uint256",
        name: "value",
        type: "uint256"
      }
    ],
    name: "Approval",
    type: "event"
  },
  {
    anonymous: false,
    inputs: [
      {
        components: [
          {
            internalType: "uint256",
            name: "startTimestamp",
            type: "uint256"
          },
          {
            internalType: "uint256",
            name: "maxClaimableSupply",
            type: "uint256"
          },
          {
            internalType: "uint256",
            name: "supplyClaimed",
            type: "uint256"
          },
          {
            internalType: "uint256",
            name: "quantityLimitPerTransaction",
            type: "uint256"
          },
          {
            internalType: "uint256",
            name: "waitTimeInSecondsBetweenClaims",
            type: "uint256"
          },
          {
            internalType: "bytes32",
            name: "merkleRoot",
            type: "bytes32"
          },
          {
            internalType: "uint256",
            name: "pricePerToken",
            type: "uint256"
          },
          {
            internalType: "address",
            name: "currency",
            type: "address"
          }
        ],
        indexed: false,
        internalType: "struct IDropClaimCondition_V2.ClaimCondition[]",
        name: "claimConditions",
        type: "tuple[]"
      }
    ],
    name: "ClaimConditionsUpdated",
    type: "event"
  },
  {
    anonymous: false,
    inputs: [
      {
        indexed: false,
        internalType: "string",
        name: "prevURI",
        type: "string"
      },
      {
        indexed: false,
        internalType: "string",
        name: "newURI",
        type: "string"
      }
    ],
    name: "ContractURIUpdated",
    type: "event"
  },
  {
    anonymous: false,
    inputs: [
      {
        indexed: false,
        internalType: "uint256",
        name: "maxTotalSupply",
        type: "uint256"
      }
    ],
    name: "MaxTotalSupplyUpdated",
    type: "event"
  },
  {
    anonymous: false,
    inputs: [
      {
        indexed: false,
        internalType: "uint256",
        name: "count",
        type: "uint256"
      }
    ],
    name: "MaxWalletClaimCountUpdated",
    type: "event"
  },
  {
    anonymous: false,
    inputs: [
      {
        indexed: true,
        internalType: "uint256",
        name: "claimConditionIndex",
        type: "uint256"
      },
      {
        indexed: true,
        internalType: "address",
        name: "claimer",
        type: "address"
      },
      {
        indexed: true,
        internalType: "address",
        name: "receiver",
        type: "address"
      },
      {
        indexed: false,
        internalType: "uint256",
        name: "quantityClaimed",
        type: "uint256"
      }
    ],
    name: "TokensClaimed",
    type: "event"
  },
  {
    anonymous: false,
    inputs: [
      {
        indexed: true,
        internalType: "address",
        name: "from",
        type: "address"
      },
      {
        indexed: true,
        internalType: "address",
        name: "to",
        type: "address"
      },
      {
        indexed: false,
        internalType: "uint256",
        name: "value",
        type: "uint256"
      }
    ],
    name: "Transfer",
    type: "event"
  },
  {
    anonymous: false,
    inputs: [
      {
        indexed: true,
        internalType: "address",
        name: "wallet",
        type: "address"
      },
      {
        indexed: false,
        internalType: "uint256",
        name: "count",
        type: "uint256"
      }
    ],
    name: "WalletClaimCountUpdated",
    type: "event"
  },
  {
    inputs: [
      {
        internalType: "address",
        name: "owner",
        type: "address"
      },
      {
        internalType: "address",
        name: "spender",
        type: "address"
      }
    ],
    name: "allowance",
    outputs: [
      {
        internalType: "uint256",
        name: "",
        type: "uint256"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "address",
        name: "spender",
        type: "address"
      },
      {
        internalType: "uint256",
        name: "amount",
        type: "uint256"
      }
    ],
    name: "approve",
    outputs: [
      {
        internalType: "bool",
        name: "",
        type: "bool"
      }
    ],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "address",
        name: "account",
        type: "address"
      }
    ],
    name: "balanceOf",
    outputs: [
      {
        internalType: "uint256",
        name: "",
        type: "uint256"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "address",
        name: "receiver",
        type: "address"
      },
      {
        internalType: "uint256",
        name: "quantity",
        type: "uint256"
      },
      {
        internalType: "address",
        name: "currency",
        type: "address"
      },
      {
        internalType: "uint256",
        name: "pricePerToken",
        type: "uint256"
      },
      {
        internalType: "bytes32[]",
        name: "proofs",
        type: "bytes32[]"
      },
      {
        internalType: "uint256",
        name: "proofMaxQuantityPerTransaction",
        type: "uint256"
      }
    ],
    name: "claim",
    outputs: [],
    stateMutability: "payable",
    type: "function"
  },
  {
    inputs: [
      {
        components: [
          {
            internalType: "uint256",
            name: "startTimestamp",
            type: "uint256"
          },
          {
            internalType: "uint256",
            name: "maxClaimableSupply",
            type: "uint256"
          },
          {
            internalType: "uint256",
            name: "supplyClaimed",
            type: "uint256"
          },
          {
            internalType: "uint256",
            name: "quantityLimitPerTransaction",
            type: "uint256"
          },
          {
            internalType: "uint256",
            name: "waitTimeInSecondsBetweenClaims",
            type: "uint256"
          },
          {
            internalType: "bytes32",
            name: "merkleRoot",
            type: "bytes32"
          },
          {
            internalType: "uint256",
            name: "pricePerToken",
            type: "uint256"
          },
          {
            internalType: "address",
            name: "currency",
            type: "address"
          }
        ],
        internalType: "struct IDropClaimCondition_V2.ClaimCondition[]",
        name: "phases",
        type: "tuple[]"
      },
      {
        internalType: "bool",
        name: "resetClaimEligibility",
        type: "bool"
      }
    ],
    name: "setClaimConditions",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [],
    name: "totalSupply",
    outputs: [
      {
        internalType: "uint256",
        name: "",
        type: "uint256"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "address",
        name: "to",
        type: "address"
      },
      {
        internalType: "uint256",
        name: "amount",
        type: "uint256"
      }
    ],
    name: "transfer",
    outputs: [
      {
        internalType: "bool",
        name: "",
        type: "bool"
      }
    ],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "address",
        name: "from",
        type: "address"
      },
      {
        internalType: "address",
        name: "to",
        type: "address"
      },
      {
        internalType: "uint256",
        name: "amount",
        type: "uint256"
      }
    ],
    name: "transferFrom",
    outputs: [
      {
        internalType: "bool",
        name: "",
        type: "bool"
      }
    ],
    stateMutability: "nonpayable",
    type: "function"
  }
];

// node_modules/@thirdweb-dev/contracts-js/dist/abis/IDropSinglePhase.json
var IDropSinglePhase_default = [
  {
    anonymous: false,
    inputs: [
      {
        components: [
          {
            internalType: "uint256",
            name: "startTimestamp",
            type: "uint256"
          },
          {
            internalType: "uint256",
            name: "maxClaimableSupply",
            type: "uint256"
          },
          {
            internalType: "uint256",
            name: "supplyClaimed",
            type: "uint256"
          },
          {
            internalType: "uint256",
            name: "quantityLimitPerWallet",
            type: "uint256"
          },
          {
            internalType: "bytes32",
            name: "merkleRoot",
            type: "bytes32"
          },
          {
            internalType: "uint256",
            name: "pricePerToken",
            type: "uint256"
          },
          {
            internalType: "address",
            name: "currency",
            type: "address"
          },
          {
            internalType: "string",
            name: "metadata",
            type: "string"
          }
        ],
        indexed: false,
        internalType: "struct IClaimCondition.ClaimCondition",
        name: "condition",
        type: "tuple"
      },
      {
        indexed: false,
        internalType: "bool",
        name: "resetEligibility",
        type: "bool"
      }
    ],
    name: "ClaimConditionUpdated",
    type: "event"
  },
  {
    anonymous: false,
    inputs: [
      {
        indexed: true,
        internalType: "address",
        name: "claimer",
        type: "address"
      },
      {
        indexed: true,
        internalType: "address",
        name: "receiver",
        type: "address"
      },
      {
        indexed: true,
        internalType: "uint256",
        name: "startTokenId",
        type: "uint256"
      },
      {
        indexed: false,
        internalType: "uint256",
        name: "quantityClaimed",
        type: "uint256"
      }
    ],
    name: "TokensClaimed",
    type: "event"
  },
  {
    inputs: [
      {
        internalType: "address",
        name: "receiver",
        type: "address"
      },
      {
        internalType: "uint256",
        name: "quantity",
        type: "uint256"
      },
      {
        internalType: "address",
        name: "currency",
        type: "address"
      },
      {
        internalType: "uint256",
        name: "pricePerToken",
        type: "uint256"
      },
      {
        components: [
          {
            internalType: "bytes32[]",
            name: "proof",
            type: "bytes32[]"
          },
          {
            internalType: "uint256",
            name: "quantityLimitPerWallet",
            type: "uint256"
          },
          {
            internalType: "uint256",
            name: "pricePerToken",
            type: "uint256"
          },
          {
            internalType: "address",
            name: "currency",
            type: "address"
          }
        ],
        internalType: "struct IDropSinglePhase.AllowlistProof",
        name: "allowlistProof",
        type: "tuple"
      },
      {
        internalType: "bytes",
        name: "data",
        type: "bytes"
      }
    ],
    name: "claim",
    outputs: [],
    stateMutability: "payable",
    type: "function"
  },
  {
    inputs: [
      {
        components: [
          {
            internalType: "uint256",
            name: "startTimestamp",
            type: "uint256"
          },
          {
            internalType: "uint256",
            name: "maxClaimableSupply",
            type: "uint256"
          },
          {
            internalType: "uint256",
            name: "supplyClaimed",
            type: "uint256"
          },
          {
            internalType: "uint256",
            name: "quantityLimitPerWallet",
            type: "uint256"
          },
          {
            internalType: "bytes32",
            name: "merkleRoot",
            type: "bytes32"
          },
          {
            internalType: "uint256",
            name: "pricePerToken",
            type: "uint256"
          },
          {
            internalType: "address",
            name: "currency",
            type: "address"
          },
          {
            internalType: "string",
            name: "metadata",
            type: "string"
          }
        ],
        internalType: "struct IClaimCondition.ClaimCondition",
        name: "phase",
        type: "tuple"
      },
      {
        internalType: "bool",
        name: "resetClaimEligibility",
        type: "bool"
      }
    ],
    name: "setClaimConditions",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  }
];

// node_modules/@thirdweb-dev/contracts-js/dist/abis/IDropSinglePhase_V1.json
var IDropSinglePhase_V1_default = [
  {
    anonymous: false,
    inputs: [
      {
        components: [
          {
            internalType: "uint256",
            name: "startTimestamp",
            type: "uint256"
          },
          {
            internalType: "uint256",
            name: "maxClaimableSupply",
            type: "uint256"
          },
          {
            internalType: "uint256",
            name: "supplyClaimed",
            type: "uint256"
          },
          {
            internalType: "uint256",
            name: "quantityLimitPerTransaction",
            type: "uint256"
          },
          {
            internalType: "uint256",
            name: "waitTimeInSecondsBetweenClaims",
            type: "uint256"
          },
          {
            internalType: "bytes32",
            name: "merkleRoot",
            type: "bytes32"
          },
          {
            internalType: "uint256",
            name: "pricePerToken",
            type: "uint256"
          },
          {
            internalType: "address",
            name: "currency",
            type: "address"
          }
        ],
        indexed: false,
        internalType: "struct IClaimCondition_V1.ClaimCondition",
        name: "condition",
        type: "tuple"
      },
      {
        indexed: false,
        internalType: "bool",
        name: "resetEligibility",
        type: "bool"
      }
    ],
    name: "ClaimConditionUpdated",
    type: "event"
  },
  {
    anonymous: false,
    inputs: [
      {
        indexed: true,
        internalType: "address",
        name: "claimer",
        type: "address"
      },
      {
        indexed: true,
        internalType: "address",
        name: "receiver",
        type: "address"
      },
      {
        indexed: true,
        internalType: "uint256",
        name: "startTokenId",
        type: "uint256"
      },
      {
        indexed: false,
        internalType: "uint256",
        name: "quantityClaimed",
        type: "uint256"
      }
    ],
    name: "TokensClaimed",
    type: "event"
  },
  {
    inputs: [
      {
        internalType: "address",
        name: "receiver",
        type: "address"
      },
      {
        internalType: "uint256",
        name: "quantity",
        type: "uint256"
      },
      {
        internalType: "address",
        name: "currency",
        type: "address"
      },
      {
        internalType: "uint256",
        name: "pricePerToken",
        type: "uint256"
      },
      {
        components: [
          {
            internalType: "bytes32[]",
            name: "proof",
            type: "bytes32[]"
          },
          {
            internalType: "uint256",
            name: "maxQuantityInAllowlist",
            type: "uint256"
          }
        ],
        internalType: "struct IDropSinglePhase_V1.AllowlistProof",
        name: "allowlistProof",
        type: "tuple"
      },
      {
        internalType: "bytes",
        name: "data",
        type: "bytes"
      }
    ],
    name: "claim",
    outputs: [],
    stateMutability: "payable",
    type: "function"
  },
  {
    inputs: [
      {
        components: [
          {
            internalType: "uint256",
            name: "startTimestamp",
            type: "uint256"
          },
          {
            internalType: "uint256",
            name: "maxClaimableSupply",
            type: "uint256"
          },
          {
            internalType: "uint256",
            name: "supplyClaimed",
            type: "uint256"
          },
          {
            internalType: "uint256",
            name: "quantityLimitPerTransaction",
            type: "uint256"
          },
          {
            internalType: "uint256",
            name: "waitTimeInSecondsBetweenClaims",
            type: "uint256"
          },
          {
            internalType: "bytes32",
            name: "merkleRoot",
            type: "bytes32"
          },
          {
            internalType: "uint256",
            name: "pricePerToken",
            type: "uint256"
          },
          {
            internalType: "address",
            name: "currency",
            type: "address"
          }
        ],
        internalType: "struct IClaimCondition_V1.ClaimCondition",
        name: "phase",
        type: "tuple"
      },
      {
        internalType: "bool",
        name: "resetClaimEligibility",
        type: "bool"
      }
    ],
    name: "setClaimConditions",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  }
];

// node_modules/@thirdweb-dev/contracts-js/dist/abis/IERC20Permit.json
var IERC20Permit_default = [
  {
    inputs: [],
    name: "DOMAIN_SEPARATOR",
    outputs: [
      {
        internalType: "bytes32",
        name: "",
        type: "bytes32"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "address",
        name: "owner",
        type: "address"
      }
    ],
    name: "nonces",
    outputs: [
      {
        internalType: "uint256",
        name: "",
        type: "uint256"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "address",
        name: "owner",
        type: "address"
      },
      {
        internalType: "address",
        name: "spender",
        type: "address"
      },
      {
        internalType: "uint256",
        name: "value",
        type: "uint256"
      },
      {
        internalType: "uint256",
        name: "deadline",
        type: "uint256"
      },
      {
        internalType: "uint8",
        name: "v",
        type: "uint8"
      },
      {
        internalType: "bytes32",
        name: "r",
        type: "bytes32"
      },
      {
        internalType: "bytes32",
        name: "s",
        type: "bytes32"
      }
    ],
    name: "permit",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  }
];

// node_modules/@thirdweb-dev/contracts-js/dist/abis/IMintableERC20.json
var IMintableERC20_default = [
  {
    anonymous: false,
    inputs: [
      {
        indexed: true,
        internalType: "address",
        name: "mintedTo",
        type: "address"
      },
      {
        indexed: false,
        internalType: "uint256",
        name: "quantityMinted",
        type: "uint256"
      }
    ],
    name: "TokensMinted",
    type: "event"
  },
  {
    inputs: [
      {
        internalType: "address",
        name: "to",
        type: "address"
      },
      {
        internalType: "uint256",
        name: "amount",
        type: "uint256"
      }
    ],
    name: "mintTo",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  }
];

// node_modules/@thirdweb-dev/contracts-js/dist/abis/IMulticall.json
var IMulticall_default = [
  {
    inputs: [
      {
        internalType: "bytes[]",
        name: "data",
        type: "bytes[]"
      }
    ],
    name: "multicall",
    outputs: [
      {
        internalType: "bytes[]",
        name: "results",
        type: "bytes[]"
      }
    ],
    stateMutability: "nonpayable",
    type: "function"
  }
];

// node_modules/@thirdweb-dev/contracts-js/dist/abis/ISignatureMintERC20.json
var ISignatureMintERC20_default = [
  {
    anonymous: false,
    inputs: [
      {
        indexed: true,
        internalType: "address",
        name: "signer",
        type: "address"
      },
      {
        indexed: true,
        internalType: "address",
        name: "mintedTo",
        type: "address"
      },
      {
        components: [
          {
            internalType: "address",
            name: "to",
            type: "address"
          },
          {
            internalType: "address",
            name: "primarySaleRecipient",
            type: "address"
          },
          {
            internalType: "uint256",
            name: "quantity",
            type: "uint256"
          },
          {
            internalType: "uint256",
            name: "price",
            type: "uint256"
          },
          {
            internalType: "address",
            name: "currency",
            type: "address"
          },
          {
            internalType: "uint128",
            name: "validityStartTimestamp",
            type: "uint128"
          },
          {
            internalType: "uint128",
            name: "validityEndTimestamp",
            type: "uint128"
          },
          {
            internalType: "bytes32",
            name: "uid",
            type: "bytes32"
          }
        ],
        indexed: false,
        internalType: "struct ISignatureMintERC20.MintRequest",
        name: "mintRequest",
        type: "tuple"
      }
    ],
    name: "TokensMintedWithSignature",
    type: "event"
  },
  {
    inputs: [
      {
        components: [
          {
            internalType: "address",
            name: "to",
            type: "address"
          },
          {
            internalType: "address",
            name: "primarySaleRecipient",
            type: "address"
          },
          {
            internalType: "uint256",
            name: "quantity",
            type: "uint256"
          },
          {
            internalType: "uint256",
            name: "price",
            type: "uint256"
          },
          {
            internalType: "address",
            name: "currency",
            type: "address"
          },
          {
            internalType: "uint128",
            name: "validityStartTimestamp",
            type: "uint128"
          },
          {
            internalType: "uint128",
            name: "validityEndTimestamp",
            type: "uint128"
          },
          {
            internalType: "bytes32",
            name: "uid",
            type: "bytes32"
          }
        ],
        internalType: "struct ISignatureMintERC20.MintRequest",
        name: "req",
        type: "tuple"
      },
      {
        internalType: "bytes",
        name: "signature",
        type: "bytes"
      }
    ],
    name: "mintWithSignature",
    outputs: [
      {
        internalType: "address",
        name: "signer",
        type: "address"
      }
    ],
    stateMutability: "payable",
    type: "function"
  },
  {
    inputs: [
      {
        components: [
          {
            internalType: "address",
            name: "to",
            type: "address"
          },
          {
            internalType: "address",
            name: "primarySaleRecipient",
            type: "address"
          },
          {
            internalType: "uint256",
            name: "quantity",
            type: "uint256"
          },
          {
            internalType: "uint256",
            name: "price",
            type: "uint256"
          },
          {
            internalType: "address",
            name: "currency",
            type: "address"
          },
          {
            internalType: "uint128",
            name: "validityStartTimestamp",
            type: "uint128"
          },
          {
            internalType: "uint128",
            name: "validityEndTimestamp",
            type: "uint128"
          },
          {
            internalType: "bytes32",
            name: "uid",
            type: "bytes32"
          }
        ],
        internalType: "struct ISignatureMintERC20.MintRequest",
        name: "req",
        type: "tuple"
      },
      {
        internalType: "bytes",
        name: "signature",
        type: "bytes"
      }
    ],
    name: "verify",
    outputs: [
      {
        internalType: "bool",
        name: "success",
        type: "bool"
      },
      {
        internalType: "address",
        name: "signer",
        type: "address"
      }
    ],
    stateMutability: "view",
    type: "function"
  }
];

// node_modules/@thirdweb-dev/contracts-js/dist/abis/IBurnableERC721.json
var IBurnableERC721_default = [
  {
    inputs: [
      {
        internalType: "uint256",
        name: "tokenId",
        type: "uint256"
      }
    ],
    name: "burn",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  }
];

// node_modules/@thirdweb-dev/contracts-js/dist/abis/IClaimableERC721.json
var IClaimableERC721_default = [
  {
    anonymous: false,
    inputs: [
      {
        indexed: true,
        internalType: "address",
        name: "claimer",
        type: "address"
      },
      {
        indexed: true,
        internalType: "address",
        name: "receiver",
        type: "address"
      },
      {
        indexed: true,
        internalType: "uint256",
        name: "startTokenId",
        type: "uint256"
      },
      {
        indexed: false,
        internalType: "uint256",
        name: "quantityClaimed",
        type: "uint256"
      }
    ],
    name: "TokensClaimed",
    type: "event"
  },
  {
    inputs: [
      {
        internalType: "address",
        name: "_receiver",
        type: "address"
      },
      {
        internalType: "uint256",
        name: "_quantity",
        type: "uint256"
      }
    ],
    name: "claim",
    outputs: [],
    stateMutability: "payable",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "address",
        name: "_claimer",
        type: "address"
      },
      {
        internalType: "uint256",
        name: "_quantity",
        type: "uint256"
      }
    ],
    name: "verifyClaim",
    outputs: [],
    stateMutability: "view",
    type: "function"
  }
];

// node_modules/@thirdweb-dev/contracts-js/dist/abis/IDelayedReveal.json
var IDelayedReveal_default = [
  {
    anonymous: false,
    inputs: [
      {
        indexed: true,
        internalType: "uint256",
        name: "index",
        type: "uint256"
      },
      {
        indexed: false,
        internalType: "string",
        name: "revealedURI",
        type: "string"
      }
    ],
    name: "TokenURIRevealed",
    type: "event"
  },
  {
    inputs: [
      {
        internalType: "bytes",
        name: "data",
        type: "bytes"
      },
      {
        internalType: "bytes",
        name: "key",
        type: "bytes"
      }
    ],
    name: "encryptDecrypt",
    outputs: [
      {
        internalType: "bytes",
        name: "result",
        type: "bytes"
      }
    ],
    stateMutability: "pure",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "uint256",
        name: "identifier",
        type: "uint256"
      },
      {
        internalType: "bytes",
        name: "key",
        type: "bytes"
      }
    ],
    name: "reveal",
    outputs: [
      {
        internalType: "string",
        name: "revealedURI",
        type: "string"
      }
    ],
    stateMutability: "nonpayable",
    type: "function"
  }
];

// node_modules/@thirdweb-dev/contracts-js/dist/abis/IDropERC721_V3.json
var IDropERC721_V3_default = [
  {
    anonymous: false,
    inputs: [
      {
        indexed: true,
        internalType: "address",
        name: "owner",
        type: "address"
      },
      {
        indexed: true,
        internalType: "address",
        name: "approved",
        type: "address"
      },
      {
        indexed: true,
        internalType: "uint256",
        name: "tokenId",
        type: "uint256"
      }
    ],
    name: "Approval",
    type: "event"
  },
  {
    anonymous: false,
    inputs: [
      {
        indexed: true,
        internalType: "address",
        name: "owner",
        type: "address"
      },
      {
        indexed: true,
        internalType: "address",
        name: "operator",
        type: "address"
      },
      {
        indexed: false,
        internalType: "bool",
        name: "approved",
        type: "bool"
      }
    ],
    name: "ApprovalForAll",
    type: "event"
  },
  {
    anonymous: false,
    inputs: [
      {
        components: [
          {
            internalType: "uint256",
            name: "startTimestamp",
            type: "uint256"
          },
          {
            internalType: "uint256",
            name: "maxClaimableSupply",
            type: "uint256"
          },
          {
            internalType: "uint256",
            name: "supplyClaimed",
            type: "uint256"
          },
          {
            internalType: "uint256",
            name: "quantityLimitPerTransaction",
            type: "uint256"
          },
          {
            internalType: "uint256",
            name: "waitTimeInSecondsBetweenClaims",
            type: "uint256"
          },
          {
            internalType: "bytes32",
            name: "merkleRoot",
            type: "bytes32"
          },
          {
            internalType: "uint256",
            name: "pricePerToken",
            type: "uint256"
          },
          {
            internalType: "address",
            name: "currency",
            type: "address"
          }
        ],
        indexed: false,
        internalType: "struct IDropClaimCondition_V2.ClaimCondition[]",
        name: "claimConditions",
        type: "tuple[]"
      }
    ],
    name: "ClaimConditionsUpdated",
    type: "event"
  },
  {
    anonymous: false,
    inputs: [
      {
        indexed: false,
        internalType: "uint256",
        name: "maxTotalSupply",
        type: "uint256"
      }
    ],
    name: "MaxTotalSupplyUpdated",
    type: "event"
  },
  {
    anonymous: false,
    inputs: [
      {
        indexed: false,
        internalType: "uint256",
        name: "count",
        type: "uint256"
      }
    ],
    name: "MaxWalletClaimCountUpdated",
    type: "event"
  },
  {
    anonymous: false,
    inputs: [
      {
        indexed: false,
        internalType: "uint256",
        name: "endTokenId",
        type: "uint256"
      },
      {
        indexed: false,
        internalType: "string",
        name: "revealedURI",
        type: "string"
      }
    ],
    name: "NFTRevealed",
    type: "event"
  },
  {
    anonymous: false,
    inputs: [
      {
        indexed: true,
        internalType: "uint256",
        name: "claimConditionIndex",
        type: "uint256"
      },
      {
        indexed: true,
        internalType: "address",
        name: "claimer",
        type: "address"
      },
      {
        indexed: true,
        internalType: "address",
        name: "receiver",
        type: "address"
      },
      {
        indexed: false,
        internalType: "uint256",
        name: "startTokenId",
        type: "uint256"
      },
      {
        indexed: false,
        internalType: "uint256",
        name: "quantityClaimed",
        type: "uint256"
      }
    ],
    name: "TokensClaimed",
    type: "event"
  },
  {
    anonymous: false,
    inputs: [
      {
        indexed: false,
        internalType: "uint256",
        name: "startTokenId",
        type: "uint256"
      },
      {
        indexed: false,
        internalType: "uint256",
        name: "endTokenId",
        type: "uint256"
      },
      {
        indexed: false,
        internalType: "string",
        name: "baseURI",
        type: "string"
      },
      {
        indexed: false,
        internalType: "bytes",
        name: "encryptedBaseURI",
        type: "bytes"
      }
    ],
    name: "TokensLazyMinted",
    type: "event"
  },
  {
    anonymous: false,
    inputs: [
      {
        indexed: true,
        internalType: "address",
        name: "from",
        type: "address"
      },
      {
        indexed: true,
        internalType: "address",
        name: "to",
        type: "address"
      },
      {
        indexed: true,
        internalType: "uint256",
        name: "tokenId",
        type: "uint256"
      }
    ],
    name: "Transfer",
    type: "event"
  },
  {
    anonymous: false,
    inputs: [
      {
        indexed: true,
        internalType: "address",
        name: "wallet",
        type: "address"
      },
      {
        indexed: false,
        internalType: "uint256",
        name: "count",
        type: "uint256"
      }
    ],
    name: "WalletClaimCountUpdated",
    type: "event"
  },
  {
    inputs: [
      {
        internalType: "address",
        name: "to",
        type: "address"
      },
      {
        internalType: "uint256",
        name: "tokenId",
        type: "uint256"
      }
    ],
    name: "approve",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "address",
        name: "owner",
        type: "address"
      }
    ],
    name: "balanceOf",
    outputs: [
      {
        internalType: "uint256",
        name: "balance",
        type: "uint256"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "address",
        name: "receiver",
        type: "address"
      },
      {
        internalType: "uint256",
        name: "quantity",
        type: "uint256"
      },
      {
        internalType: "address",
        name: "currency",
        type: "address"
      },
      {
        internalType: "uint256",
        name: "pricePerToken",
        type: "uint256"
      },
      {
        internalType: "bytes32[]",
        name: "proofs",
        type: "bytes32[]"
      },
      {
        internalType: "uint256",
        name: "proofMaxQuantityPerTransaction",
        type: "uint256"
      }
    ],
    name: "claim",
    outputs: [],
    stateMutability: "payable",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "uint256",
        name: "tokenId",
        type: "uint256"
      }
    ],
    name: "getApproved",
    outputs: [
      {
        internalType: "address",
        name: "operator",
        type: "address"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "address",
        name: "owner",
        type: "address"
      },
      {
        internalType: "address",
        name: "operator",
        type: "address"
      }
    ],
    name: "isApprovedForAll",
    outputs: [
      {
        internalType: "bool",
        name: "",
        type: "bool"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "uint256",
        name: "amount",
        type: "uint256"
      },
      {
        internalType: "string",
        name: "baseURIForTokens",
        type: "string"
      },
      {
        internalType: "bytes",
        name: "encryptedBaseURI",
        type: "bytes"
      }
    ],
    name: "lazyMint",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "uint256",
        name: "tokenId",
        type: "uint256"
      }
    ],
    name: "ownerOf",
    outputs: [
      {
        internalType: "address",
        name: "owner",
        type: "address"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "address",
        name: "from",
        type: "address"
      },
      {
        internalType: "address",
        name: "to",
        type: "address"
      },
      {
        internalType: "uint256",
        name: "tokenId",
        type: "uint256"
      }
    ],
    name: "safeTransferFrom",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "address",
        name: "from",
        type: "address"
      },
      {
        internalType: "address",
        name: "to",
        type: "address"
      },
      {
        internalType: "uint256",
        name: "tokenId",
        type: "uint256"
      },
      {
        internalType: "bytes",
        name: "data",
        type: "bytes"
      }
    ],
    name: "safeTransferFrom",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "address",
        name: "operator",
        type: "address"
      },
      {
        internalType: "bool",
        name: "_approved",
        type: "bool"
      }
    ],
    name: "setApprovalForAll",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [
      {
        components: [
          {
            internalType: "uint256",
            name: "startTimestamp",
            type: "uint256"
          },
          {
            internalType: "uint256",
            name: "maxClaimableSupply",
            type: "uint256"
          },
          {
            internalType: "uint256",
            name: "supplyClaimed",
            type: "uint256"
          },
          {
            internalType: "uint256",
            name: "quantityLimitPerTransaction",
            type: "uint256"
          },
          {
            internalType: "uint256",
            name: "waitTimeInSecondsBetweenClaims",
            type: "uint256"
          },
          {
            internalType: "bytes32",
            name: "merkleRoot",
            type: "bytes32"
          },
          {
            internalType: "uint256",
            name: "pricePerToken",
            type: "uint256"
          },
          {
            internalType: "address",
            name: "currency",
            type: "address"
          }
        ],
        internalType: "struct IDropClaimCondition_V2.ClaimCondition[]",
        name: "phases",
        type: "tuple[]"
      },
      {
        internalType: "bool",
        name: "resetClaimEligibility",
        type: "bool"
      }
    ],
    name: "setClaimConditions",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "bytes4",
        name: "interfaceId",
        type: "bytes4"
      }
    ],
    name: "supportsInterface",
    outputs: [
      {
        internalType: "bool",
        name: "",
        type: "bool"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "address",
        name: "from",
        type: "address"
      },
      {
        internalType: "address",
        name: "to",
        type: "address"
      },
      {
        internalType: "uint256",
        name: "tokenId",
        type: "uint256"
      }
    ],
    name: "transferFrom",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  }
];

// node_modules/@thirdweb-dev/contracts-js/dist/abis/IERC721Enumerable.json
var IERC721Enumerable_default = [
  {
    inputs: [
      {
        internalType: "uint256",
        name: "_index",
        type: "uint256"
      }
    ],
    name: "tokenByIndex",
    outputs: [
      {
        internalType: "uint256",
        name: "",
        type: "uint256"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "address",
        name: "_owner",
        type: "address"
      },
      {
        internalType: "uint256",
        name: "_index",
        type: "uint256"
      }
    ],
    name: "tokenOfOwnerByIndex",
    outputs: [
      {
        internalType: "uint256",
        name: "",
        type: "uint256"
      }
    ],
    stateMutability: "view",
    type: "function"
  }
];

// node_modules/@thirdweb-dev/contracts-js/dist/abis/IERC721AQueryableUpgradeable.json
var IERC721AQueryableUpgradeable_default = [
  {
    inputs: [],
    name: "ApprovalCallerNotOwnerNorApproved",
    type: "error"
  },
  {
    inputs: [],
    name: "ApprovalQueryForNonexistentToken",
    type: "error"
  },
  {
    inputs: [],
    name: "BalanceQueryForZeroAddress",
    type: "error"
  },
  {
    inputs: [],
    name: "InvalidQueryRange",
    type: "error"
  },
  {
    inputs: [],
    name: "MintERC2309QuantityExceedsLimit",
    type: "error"
  },
  {
    inputs: [],
    name: "MintToZeroAddress",
    type: "error"
  },
  {
    inputs: [],
    name: "MintZeroQuantity",
    type: "error"
  },
  {
    inputs: [],
    name: "OwnerQueryForNonexistentToken",
    type: "error"
  },
  {
    inputs: [],
    name: "OwnershipNotInitializedForExtraData",
    type: "error"
  },
  {
    inputs: [],
    name: "TransferCallerNotOwnerNorApproved",
    type: "error"
  },
  {
    inputs: [],
    name: "TransferFromIncorrectOwner",
    type: "error"
  },
  {
    inputs: [],
    name: "TransferToNonERC721ReceiverImplementer",
    type: "error"
  },
  {
    inputs: [],
    name: "TransferToZeroAddress",
    type: "error"
  },
  {
    inputs: [],
    name: "URIQueryForNonexistentToken",
    type: "error"
  },
  {
    anonymous: false,
    inputs: [
      {
        indexed: true,
        internalType: "address",
        name: "owner",
        type: "address"
      },
      {
        indexed: true,
        internalType: "address",
        name: "approved",
        type: "address"
      },
      {
        indexed: true,
        internalType: "uint256",
        name: "tokenId",
        type: "uint256"
      }
    ],
    name: "Approval",
    type: "event"
  },
  {
    anonymous: false,
    inputs: [
      {
        indexed: true,
        internalType: "address",
        name: "owner",
        type: "address"
      },
      {
        indexed: true,
        internalType: "address",
        name: "operator",
        type: "address"
      },
      {
        indexed: false,
        internalType: "bool",
        name: "approved",
        type: "bool"
      }
    ],
    name: "ApprovalForAll",
    type: "event"
  },
  {
    anonymous: false,
    inputs: [
      {
        indexed: true,
        internalType: "uint256",
        name: "fromTokenId",
        type: "uint256"
      },
      {
        indexed: false,
        internalType: "uint256",
        name: "toTokenId",
        type: "uint256"
      },
      {
        indexed: true,
        internalType: "address",
        name: "from",
        type: "address"
      },
      {
        indexed: true,
        internalType: "address",
        name: "to",
        type: "address"
      }
    ],
    name: "ConsecutiveTransfer",
    type: "event"
  },
  {
    anonymous: false,
    inputs: [
      {
        indexed: true,
        internalType: "address",
        name: "from",
        type: "address"
      },
      {
        indexed: true,
        internalType: "address",
        name: "to",
        type: "address"
      },
      {
        indexed: true,
        internalType: "uint256",
        name: "tokenId",
        type: "uint256"
      }
    ],
    name: "Transfer",
    type: "event"
  },
  {
    inputs: [
      {
        internalType: "address",
        name: "to",
        type: "address"
      },
      {
        internalType: "uint256",
        name: "tokenId",
        type: "uint256"
      }
    ],
    name: "approve",
    outputs: [],
    stateMutability: "payable",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "address",
        name: "owner",
        type: "address"
      }
    ],
    name: "balanceOf",
    outputs: [
      {
        internalType: "uint256",
        name: "balance",
        type: "uint256"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "uint256",
        name: "tokenId",
        type: "uint256"
      }
    ],
    name: "explicitOwnershipOf",
    outputs: [
      {
        components: [
          {
            internalType: "address",
            name: "addr",
            type: "address"
          },
          {
            internalType: "uint64",
            name: "startTimestamp",
            type: "uint64"
          },
          {
            internalType: "bool",
            name: "burned",
            type: "bool"
          },
          {
            internalType: "uint24",
            name: "extraData",
            type: "uint24"
          }
        ],
        internalType: "struct IERC721AUpgradeable.TokenOwnership",
        name: "",
        type: "tuple"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "uint256",
        name: "tokenId",
        type: "uint256"
      }
    ],
    name: "getApproved",
    outputs: [
      {
        internalType: "address",
        name: "operator",
        type: "address"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "address",
        name: "owner",
        type: "address"
      },
      {
        internalType: "address",
        name: "operator",
        type: "address"
      }
    ],
    name: "isApprovedForAll",
    outputs: [
      {
        internalType: "bool",
        name: "",
        type: "bool"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [],
    name: "name",
    outputs: [
      {
        internalType: "string",
        name: "",
        type: "string"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "uint256",
        name: "tokenId",
        type: "uint256"
      }
    ],
    name: "ownerOf",
    outputs: [
      {
        internalType: "address",
        name: "owner",
        type: "address"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "address",
        name: "from",
        type: "address"
      },
      {
        internalType: "address",
        name: "to",
        type: "address"
      },
      {
        internalType: "uint256",
        name: "tokenId",
        type: "uint256"
      }
    ],
    name: "safeTransferFrom",
    outputs: [],
    stateMutability: "payable",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "address",
        name: "from",
        type: "address"
      },
      {
        internalType: "address",
        name: "to",
        type: "address"
      },
      {
        internalType: "uint256",
        name: "tokenId",
        type: "uint256"
      },
      {
        internalType: "bytes",
        name: "data",
        type: "bytes"
      }
    ],
    name: "safeTransferFrom",
    outputs: [],
    stateMutability: "payable",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "address",
        name: "operator",
        type: "address"
      },
      {
        internalType: "bool",
        name: "_approved",
        type: "bool"
      }
    ],
    name: "setApprovalForAll",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "bytes4",
        name: "interfaceId",
        type: "bytes4"
      }
    ],
    name: "supportsInterface",
    outputs: [
      {
        internalType: "bool",
        name: "",
        type: "bool"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [],
    name: "symbol",
    outputs: [
      {
        internalType: "string",
        name: "",
        type: "string"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "uint256",
        name: "tokenId",
        type: "uint256"
      }
    ],
    name: "tokenURI",
    outputs: [
      {
        internalType: "string",
        name: "",
        type: "string"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "address",
        name: "owner",
        type: "address"
      }
    ],
    name: "tokensOfOwner",
    outputs: [
      {
        internalType: "uint256[]",
        name: "",
        type: "uint256[]"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "address",
        name: "owner",
        type: "address"
      },
      {
        internalType: "uint256",
        name: "start",
        type: "uint256"
      },
      {
        internalType: "uint256",
        name: "stop",
        type: "uint256"
      }
    ],
    name: "tokensOfOwnerIn",
    outputs: [
      {
        internalType: "uint256[]",
        name: "",
        type: "uint256[]"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [],
    name: "totalSupply",
    outputs: [
      {
        internalType: "uint256",
        name: "",
        type: "uint256"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "address",
        name: "from",
        type: "address"
      },
      {
        internalType: "address",
        name: "to",
        type: "address"
      },
      {
        internalType: "uint256",
        name: "tokenId",
        type: "uint256"
      }
    ],
    name: "transferFrom",
    outputs: [],
    stateMutability: "payable",
    type: "function"
  }
];

// node_modules/@thirdweb-dev/contracts-js/dist/abis/IERC721Supply.json
var IERC721Supply_default = [
  {
    inputs: [],
    name: "totalSupply",
    outputs: [
      {
        internalType: "uint256",
        name: "",
        type: "uint256"
      }
    ],
    stateMutability: "view",
    type: "function"
  }
];

// node_modules/@thirdweb-dev/contracts-js/dist/abis/ILazyMint.json
var ILazyMint_default = [
  {
    anonymous: false,
    inputs: [
      {
        indexed: true,
        internalType: "uint256",
        name: "startTokenId",
        type: "uint256"
      },
      {
        indexed: false,
        internalType: "uint256",
        name: "endTokenId",
        type: "uint256"
      },
      {
        indexed: false,
        internalType: "string",
        name: "baseURI",
        type: "string"
      },
      {
        indexed: false,
        internalType: "bytes",
        name: "encryptedBaseURI",
        type: "bytes"
      }
    ],
    name: "TokensLazyMinted",
    type: "event"
  },
  {
    inputs: [
      {
        internalType: "uint256",
        name: "amount",
        type: "uint256"
      },
      {
        internalType: "string",
        name: "baseURIForTokens",
        type: "string"
      },
      {
        internalType: "bytes",
        name: "extraData",
        type: "bytes"
      }
    ],
    name: "lazyMint",
    outputs: [
      {
        internalType: "uint256",
        name: "batchId",
        type: "uint256"
      }
    ],
    stateMutability: "nonpayable",
    type: "function"
  }
];

// node_modules/@thirdweb-dev/contracts-js/dist/abis/IMintableERC721.json
var IMintableERC721_default = [
  {
    anonymous: false,
    inputs: [
      {
        indexed: true,
        internalType: "address",
        name: "mintedTo",
        type: "address"
      },
      {
        indexed: true,
        internalType: "uint256",
        name: "tokenIdMinted",
        type: "uint256"
      },
      {
        indexed: false,
        internalType: "string",
        name: "uri",
        type: "string"
      }
    ],
    name: "TokensMinted",
    type: "event"
  },
  {
    inputs: [
      {
        internalType: "address",
        name: "to",
        type: "address"
      },
      {
        internalType: "string",
        name: "uri",
        type: "string"
      }
    ],
    name: "mintTo",
    outputs: [
      {
        internalType: "uint256",
        name: "",
        type: "uint256"
      }
    ],
    stateMutability: "nonpayable",
    type: "function"
  }
];

// node_modules/@thirdweb-dev/contracts-js/dist/abis/ISignatureMintERC721.json
var ISignatureMintERC721_default = [
  {
    anonymous: false,
    inputs: [
      {
        indexed: true,
        internalType: "address",
        name: "signer",
        type: "address"
      },
      {
        indexed: true,
        internalType: "address",
        name: "mintedTo",
        type: "address"
      },
      {
        indexed: true,
        internalType: "uint256",
        name: "tokenIdMinted",
        type: "uint256"
      },
      {
        components: [
          {
            internalType: "address",
            name: "to",
            type: "address"
          },
          {
            internalType: "address",
            name: "royaltyRecipient",
            type: "address"
          },
          {
            internalType: "uint256",
            name: "royaltyBps",
            type: "uint256"
          },
          {
            internalType: "address",
            name: "primarySaleRecipient",
            type: "address"
          },
          {
            internalType: "string",
            name: "uri",
            type: "string"
          },
          {
            internalType: "uint256",
            name: "quantity",
            type: "uint256"
          },
          {
            internalType: "uint256",
            name: "pricePerToken",
            type: "uint256"
          },
          {
            internalType: "address",
            name: "currency",
            type: "address"
          },
          {
            internalType: "uint128",
            name: "validityStartTimestamp",
            type: "uint128"
          },
          {
            internalType: "uint128",
            name: "validityEndTimestamp",
            type: "uint128"
          },
          {
            internalType: "bytes32",
            name: "uid",
            type: "bytes32"
          }
        ],
        indexed: false,
        internalType: "struct ISignatureMintERC721.MintRequest",
        name: "mintRequest",
        type: "tuple"
      }
    ],
    name: "TokensMintedWithSignature",
    type: "event"
  },
  {
    inputs: [
      {
        components: [
          {
            internalType: "address",
            name: "to",
            type: "address"
          },
          {
            internalType: "address",
            name: "royaltyRecipient",
            type: "address"
          },
          {
            internalType: "uint256",
            name: "royaltyBps",
            type: "uint256"
          },
          {
            internalType: "address",
            name: "primarySaleRecipient",
            type: "address"
          },
          {
            internalType: "string",
            name: "uri",
            type: "string"
          },
          {
            internalType: "uint256",
            name: "quantity",
            type: "uint256"
          },
          {
            internalType: "uint256",
            name: "pricePerToken",
            type: "uint256"
          },
          {
            internalType: "address",
            name: "currency",
            type: "address"
          },
          {
            internalType: "uint128",
            name: "validityStartTimestamp",
            type: "uint128"
          },
          {
            internalType: "uint128",
            name: "validityEndTimestamp",
            type: "uint128"
          },
          {
            internalType: "bytes32",
            name: "uid",
            type: "bytes32"
          }
        ],
        internalType: "struct ISignatureMintERC721.MintRequest",
        name: "req",
        type: "tuple"
      },
      {
        internalType: "bytes",
        name: "signature",
        type: "bytes"
      }
    ],
    name: "mintWithSignature",
    outputs: [
      {
        internalType: "address",
        name: "signer",
        type: "address"
      }
    ],
    stateMutability: "payable",
    type: "function"
  },
  {
    inputs: [
      {
        components: [
          {
            internalType: "address",
            name: "to",
            type: "address"
          },
          {
            internalType: "address",
            name: "royaltyRecipient",
            type: "address"
          },
          {
            internalType: "uint256",
            name: "royaltyBps",
            type: "uint256"
          },
          {
            internalType: "address",
            name: "primarySaleRecipient",
            type: "address"
          },
          {
            internalType: "string",
            name: "uri",
            type: "string"
          },
          {
            internalType: "uint256",
            name: "quantity",
            type: "uint256"
          },
          {
            internalType: "uint256",
            name: "pricePerToken",
            type: "uint256"
          },
          {
            internalType: "address",
            name: "currency",
            type: "address"
          },
          {
            internalType: "uint128",
            name: "validityStartTimestamp",
            type: "uint128"
          },
          {
            internalType: "uint128",
            name: "validityEndTimestamp",
            type: "uint128"
          },
          {
            internalType: "bytes32",
            name: "uid",
            type: "bytes32"
          }
        ],
        internalType: "struct ISignatureMintERC721.MintRequest",
        name: "req",
        type: "tuple"
      },
      {
        internalType: "bytes",
        name: "signature",
        type: "bytes"
      }
    ],
    name: "verify",
    outputs: [
      {
        internalType: "bool",
        name: "success",
        type: "bool"
      },
      {
        internalType: "address",
        name: "signer",
        type: "address"
      }
    ],
    stateMutability: "view",
    type: "function"
  }
];

// node_modules/@thirdweb-dev/contracts-js/dist/abis/ISignatureMintERC721_V1.json
var ISignatureMintERC721_V1_default = [
  {
    inputs: [
      {
        components: [
          {
            internalType: "address",
            name: "to",
            type: "address"
          },
          {
            internalType: "address",
            name: "royaltyRecipient",
            type: "address"
          },
          {
            internalType: "uint256",
            name: "royaltyBps",
            type: "uint256"
          },
          {
            internalType: "address",
            name: "primarySaleRecipient",
            type: "address"
          },
          {
            internalType: "string",
            name: "uri",
            type: "string"
          },
          {
            internalType: "uint256",
            name: "price",
            type: "uint256"
          },
          {
            internalType: "address",
            name: "currency",
            type: "address"
          },
          {
            internalType: "uint128",
            name: "validityStartTimestamp",
            type: "uint128"
          },
          {
            internalType: "uint128",
            name: "validityEndTimestamp",
            type: "uint128"
          },
          {
            internalType: "bytes32",
            name: "uid",
            type: "bytes32"
          }
        ],
        internalType: "struct ITokenERC721.MintRequest",
        name: "_req",
        type: "tuple"
      },
      {
        internalType: "bytes",
        name: "_signature",
        type: "bytes"
      }
    ],
    name: "mintWithSignature",
    outputs: [
      {
        internalType: "uint256",
        name: "tokenIdMinted",
        type: "uint256"
      }
    ],
    stateMutability: "payable",
    type: "function"
  },
  {
    inputs: [
      {
        components: [
          {
            internalType: "address",
            name: "to",
            type: "address"
          },
          {
            internalType: "address",
            name: "royaltyRecipient",
            type: "address"
          },
          {
            internalType: "uint256",
            name: "royaltyBps",
            type: "uint256"
          },
          {
            internalType: "address",
            name: "primarySaleRecipient",
            type: "address"
          },
          {
            internalType: "string",
            name: "uri",
            type: "string"
          },
          {
            internalType: "uint256",
            name: "price",
            type: "uint256"
          },
          {
            internalType: "address",
            name: "currency",
            type: "address"
          },
          {
            internalType: "uint128",
            name: "validityStartTimestamp",
            type: "uint128"
          },
          {
            internalType: "uint128",
            name: "validityEndTimestamp",
            type: "uint128"
          },
          {
            internalType: "bytes32",
            name: "uid",
            type: "bytes32"
          }
        ],
        internalType: "struct ITokenERC721.MintRequest",
        name: "_req",
        type: "tuple"
      },
      {
        internalType: "bytes",
        name: "_signature",
        type: "bytes"
      }
    ],
    name: "verify",
    outputs: [
      {
        internalType: "bool",
        name: "",
        type: "bool"
      },
      {
        internalType: "address",
        name: "",
        type: "address"
      }
    ],
    stateMutability: "view",
    type: "function"
  }
];

// node_modules/@thirdweb-dev/contracts-js/dist/abis/LazyMintWithTier.json
var LazyMintWithTier_default = [
  {
    anonymous: false,
    inputs: [
      {
        indexed: true,
        internalType: "string",
        name: "tier",
        type: "string"
      },
      {
        indexed: true,
        internalType: "uint256",
        name: "startTokenId",
        type: "uint256"
      },
      {
        indexed: false,
        internalType: "uint256",
        name: "endTokenId",
        type: "uint256"
      },
      {
        indexed: false,
        internalType: "string",
        name: "baseURI",
        type: "string"
      },
      {
        indexed: false,
        internalType: "bytes",
        name: "encryptedBaseURI",
        type: "bytes"
      }
    ],
    name: "TokensLazyMinted",
    type: "event"
  },
  {
    inputs: [],
    name: "getBaseURICount",
    outputs: [
      {
        internalType: "uint256",
        name: "",
        type: "uint256"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "uint256",
        name: "_index",
        type: "uint256"
      }
    ],
    name: "getBatchIdAtIndex",
    outputs: [
      {
        internalType: "uint256",
        name: "",
        type: "uint256"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [],
    name: "getMetadataForAllTiers",
    outputs: [
      {
        components: [
          {
            internalType: "string",
            name: "tier",
            type: "string"
          },
          {
            components: [
              {
                internalType: "uint256",
                name: "startIdInclusive",
                type: "uint256"
              },
              {
                internalType: "uint256",
                name: "endIdNonInclusive",
                type: "uint256"
              }
            ],
            internalType: "struct LazyMintWithTier.TokenRange[]",
            name: "ranges",
            type: "tuple[]"
          },
          {
            internalType: "string[]",
            name: "baseURIs",
            type: "string[]"
          }
        ],
        internalType: "struct LazyMintWithTier.TierMetadata[]",
        name: "metadataForAllTiers",
        type: "tuple[]"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "uint256",
        name: "_amount",
        type: "uint256"
      },
      {
        internalType: "string",
        name: "_baseURIForTokens",
        type: "string"
      },
      {
        internalType: "string",
        name: "_tier",
        type: "string"
      },
      {
        internalType: "bytes",
        name: "_data",
        type: "bytes"
      }
    ],
    name: "lazyMint",
    outputs: [
      {
        internalType: "uint256",
        name: "batchId",
        type: "uint256"
      }
    ],
    stateMutability: "nonpayable",
    type: "function"
  }
];

// node_modules/@thirdweb-dev/contracts-js/dist/abis/SharedMetadata.json
var SharedMetadata_default = [
  {
    anonymous: false,
    inputs: [
      {
        indexed: false,
        internalType: "uint256",
        name: "_fromTokenId",
        type: "uint256"
      },
      {
        indexed: false,
        internalType: "uint256",
        name: "_toTokenId",
        type: "uint256"
      }
    ],
    name: "BatchMetadataUpdate",
    type: "event"
  },
  {
    anonymous: false,
    inputs: [
      {
        indexed: false,
        internalType: "uint256",
        name: "_tokenId",
        type: "uint256"
      }
    ],
    name: "MetadataUpdate",
    type: "event"
  },
  {
    anonymous: false,
    inputs: [
      {
        indexed: false,
        internalType: "string",
        name: "name",
        type: "string"
      },
      {
        indexed: false,
        internalType: "string",
        name: "description",
        type: "string"
      },
      {
        indexed: false,
        internalType: "string",
        name: "imageURI",
        type: "string"
      },
      {
        indexed: false,
        internalType: "string",
        name: "animationURI",
        type: "string"
      }
    ],
    name: "SharedMetadataUpdated",
    type: "event"
  },
  {
    inputs: [
      {
        components: [
          {
            internalType: "string",
            name: "name",
            type: "string"
          },
          {
            internalType: "string",
            name: "description",
            type: "string"
          },
          {
            internalType: "string",
            name: "imageURI",
            type: "string"
          },
          {
            internalType: "string",
            name: "animationURI",
            type: "string"
          }
        ],
        internalType: "struct ISharedMetadata.SharedMetadataInfo",
        name: "_metadata",
        type: "tuple"
      }
    ],
    name: "setSharedMetadata",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [],
    name: "sharedMetadata",
    outputs: [
      {
        internalType: "string",
        name: "name",
        type: "string"
      },
      {
        internalType: "string",
        name: "description",
        type: "string"
      },
      {
        internalType: "string",
        name: "imageURI",
        type: "string"
      },
      {
        internalType: "string",
        name: "animationURI",
        type: "string"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "bytes4",
        name: "interfaceId",
        type: "bytes4"
      }
    ],
    name: "supportsInterface",
    outputs: [
      {
        internalType: "bool",
        name: "",
        type: "bool"
      }
    ],
    stateMutability: "view",
    type: "function"
  }
];

// node_modules/@thirdweb-dev/contracts-js/dist/abis/zora_IERC721Drop.json
var zora_IERC721Drop_default = [
  {
    inputs: [
      {
        internalType: "bytes32",
        name: "role",
        type: "bytes32"
      }
    ],
    name: "Access_MissingRoleOrAdmin",
    type: "error"
  },
  {
    inputs: [],
    name: "Access_OnlyAdmin",
    type: "error"
  },
  {
    inputs: [],
    name: "Access_WithdrawNotAllowed",
    type: "error"
  },
  {
    inputs: [
      {
        internalType: "address",
        name: "proposedAddress",
        type: "address"
      }
    ],
    name: "Admin_InvalidUpgradeAddress",
    type: "error"
  },
  {
    inputs: [],
    name: "Admin_UnableToFinalizeNotOpenEdition",
    type: "error"
  },
  {
    inputs: [],
    name: "ExternalMetadataRenderer_CallFailed",
    type: "error"
  },
  {
    inputs: [],
    name: "InvalidMintSchedule",
    type: "error"
  },
  {
    inputs: [],
    name: "MarketFilterDAOAddressNotSupportedForChain",
    type: "error"
  },
  {
    inputs: [],
    name: "MintFee_FundsSendFailure",
    type: "error"
  },
  {
    inputs: [],
    name: "Mint_SoldOut",
    type: "error"
  },
  {
    inputs: [
      {
        internalType: "address",
        name: "operator",
        type: "address"
      }
    ],
    name: "OperatorNotAllowed",
    type: "error"
  },
  {
    inputs: [],
    name: "Presale_Inactive",
    type: "error"
  },
  {
    inputs: [],
    name: "Presale_MerkleNotApproved",
    type: "error"
  },
  {
    inputs: [],
    name: "Presale_TooManyForAddress",
    type: "error"
  },
  {
    inputs: [],
    name: "Purchase_TooManyForAddress",
    type: "error"
  },
  {
    inputs: [
      {
        internalType: "uint256",
        name: "correctPrice",
        type: "uint256"
      }
    ],
    name: "Purchase_WrongPrice",
    type: "error"
  },
  {
    inputs: [],
    name: "RemoteOperatorFilterRegistryCallFailed",
    type: "error"
  },
  {
    inputs: [],
    name: "Sale_Inactive",
    type: "error"
  },
  {
    inputs: [
      {
        internalType: "uint16",
        name: "maxRoyaltyBPS",
        type: "uint16"
      }
    ],
    name: "Setup_RoyaltyPercentageTooHigh",
    type: "error"
  },
  {
    inputs: [],
    name: "Withdraw_FundsSendFailure",
    type: "error"
  },
  {
    anonymous: false,
    inputs: [
      {
        indexed: true,
        internalType: "address",
        name: "newAddress",
        type: "address"
      },
      {
        indexed: true,
        internalType: "address",
        name: "changedBy",
        type: "address"
      }
    ],
    name: "FundsRecipientChanged",
    type: "event"
  },
  {
    anonymous: false,
    inputs: [
      {
        indexed: true,
        internalType: "address",
        name: "withdrawnBy",
        type: "address"
      },
      {
        indexed: true,
        internalType: "address",
        name: "withdrawnTo",
        type: "address"
      },
      {
        indexed: false,
        internalType: "uint256",
        name: "amount",
        type: "uint256"
      },
      {
        indexed: false,
        internalType: "address",
        name: "feeRecipient",
        type: "address"
      },
      {
        indexed: false,
        internalType: "uint256",
        name: "feeAmount",
        type: "uint256"
      }
    ],
    name: "FundsWithdrawn",
    type: "event"
  },
  {
    anonymous: false,
    inputs: [
      {
        indexed: true,
        internalType: "address",
        name: "sender",
        type: "address"
      },
      {
        indexed: true,
        internalType: "address",
        name: "tokenContract",
        type: "address"
      },
      {
        indexed: true,
        internalType: "uint256",
        name: "tokenId",
        type: "uint256"
      },
      {
        indexed: false,
        internalType: "uint256",
        name: "quantity",
        type: "uint256"
      },
      {
        indexed: false,
        internalType: "string",
        name: "comment",
        type: "string"
      }
    ],
    name: "MintComment",
    type: "event"
  },
  {
    anonymous: false,
    inputs: [
      {
        indexed: false,
        internalType: "uint256",
        name: "mintFeeAmount",
        type: "uint256"
      },
      {
        indexed: false,
        internalType: "address",
        name: "mintFeeRecipient",
        type: "address"
      },
      {
        indexed: false,
        internalType: "bool",
        name: "success",
        type: "bool"
      }
    ],
    name: "MintFeePayout",
    type: "event"
  },
  {
    anonymous: false,
    inputs: [
      {
        indexed: true,
        internalType: "address",
        name: "sender",
        type: "address"
      },
      {
        indexed: false,
        internalType: "uint256",
        name: "numberOfMints",
        type: "uint256"
      }
    ],
    name: "OpenMintFinalized",
    type: "event"
  },
  {
    anonymous: false,
    inputs: [
      {
        indexed: true,
        internalType: "address",
        name: "to",
        type: "address"
      },
      {
        indexed: true,
        internalType: "uint256",
        name: "quantity",
        type: "uint256"
      },
      {
        indexed: true,
        internalType: "uint256",
        name: "pricePerToken",
        type: "uint256"
      },
      {
        indexed: false,
        internalType: "uint256",
        name: "firstPurchasedTokenId",
        type: "uint256"
      }
    ],
    name: "Sale",
    type: "event"
  },
  {
    anonymous: false,
    inputs: [
      {
        indexed: true,
        internalType: "address",
        name: "changedBy",
        type: "address"
      }
    ],
    name: "SalesConfigChanged",
    type: "event"
  },
  {
    anonymous: false,
    inputs: [
      {
        indexed: false,
        internalType: "address",
        name: "sender",
        type: "address"
      },
      {
        indexed: false,
        internalType: "contract IMetadataRenderer",
        name: "renderer",
        type: "address"
      }
    ],
    name: "UpdatedMetadataRenderer",
    type: "event"
  },
  {
    inputs: [
      {
        internalType: "address",
        name: "to",
        type: "address"
      },
      {
        internalType: "uint256",
        name: "quantity",
        type: "uint256"
      }
    ],
    name: "adminMint",
    outputs: [
      {
        internalType: "uint256",
        name: "",
        type: "uint256"
      }
    ],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "address[]",
        name: "to",
        type: "address[]"
      }
    ],
    name: "adminMintAirdrop",
    outputs: [
      {
        internalType: "uint256",
        name: "",
        type: "uint256"
      }
    ],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "address",
        name: "user",
        type: "address"
      }
    ],
    name: "isAdmin",
    outputs: [
      {
        internalType: "bool",
        name: "",
        type: "bool"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "address",
        name: "minter",
        type: "address"
      }
    ],
    name: "mintedPerAddress",
    outputs: [
      {
        components: [
          {
            internalType: "uint256",
            name: "totalMints",
            type: "uint256"
          },
          {
            internalType: "uint256",
            name: "presaleMints",
            type: "uint256"
          },
          {
            internalType: "uint256",
            name: "publicMints",
            type: "uint256"
          }
        ],
        internalType: "struct IERC721Drop.AddressMintDetails",
        name: "",
        type: "tuple"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [],
    name: "owner",
    outputs: [
      {
        internalType: "address",
        name: "",
        type: "address"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "uint256",
        name: "quantity",
        type: "uint256"
      }
    ],
    name: "purchase",
    outputs: [
      {
        internalType: "uint256",
        name: "",
        type: "uint256"
      }
    ],
    stateMutability: "payable",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "uint256",
        name: "quantity",
        type: "uint256"
      },
      {
        internalType: "uint256",
        name: "maxQuantity",
        type: "uint256"
      },
      {
        internalType: "uint256",
        name: "pricePerToken",
        type: "uint256"
      },
      {
        internalType: "bytes32[]",
        name: "merkleProof",
        type: "bytes32[]"
      }
    ],
    name: "purchasePresale",
    outputs: [
      {
        internalType: "uint256",
        name: "",
        type: "uint256"
      }
    ],
    stateMutability: "payable",
    type: "function"
  },
  {
    inputs: [],
    name: "saleDetails",
    outputs: [
      {
        components: [
          {
            internalType: "bool",
            name: "publicSaleActive",
            type: "bool"
          },
          {
            internalType: "bool",
            name: "presaleActive",
            type: "bool"
          },
          {
            internalType: "uint256",
            name: "publicSalePrice",
            type: "uint256"
          },
          {
            internalType: "uint64",
            name: "publicSaleStart",
            type: "uint64"
          },
          {
            internalType: "uint64",
            name: "publicSaleEnd",
            type: "uint64"
          },
          {
            internalType: "uint64",
            name: "presaleStart",
            type: "uint64"
          },
          {
            internalType: "uint64",
            name: "presaleEnd",
            type: "uint64"
          },
          {
            internalType: "bytes32",
            name: "presaleMerkleRoot",
            type: "bytes32"
          },
          {
            internalType: "uint256",
            name: "maxSalePurchasePerAddress",
            type: "uint256"
          },
          {
            internalType: "uint256",
            name: "totalMinted",
            type: "uint256"
          },
          {
            internalType: "uint256",
            name: "maxSupply",
            type: "uint256"
          }
        ],
        internalType: "struct IERC721Drop.SaleDetails",
        name: "",
        type: "tuple"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "contract IMetadataRenderer",
        name: "newRenderer",
        type: "address"
      },
      {
        internalType: "bytes",
        name: "setupRenderer",
        type: "bytes"
      }
    ],
    name: "setMetadataRenderer",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "uint104",
        name: "publicSalePrice",
        type: "uint104"
      },
      {
        internalType: "uint32",
        name: "maxSalePurchasePerAddress",
        type: "uint32"
      },
      {
        internalType: "uint64",
        name: "publicSaleStart",
        type: "uint64"
      },
      {
        internalType: "uint64",
        name: "publicSaleEnd",
        type: "uint64"
      },
      {
        internalType: "uint64",
        name: "presaleStart",
        type: "uint64"
      },
      {
        internalType: "uint64",
        name: "presaleEnd",
        type: "uint64"
      },
      {
        internalType: "bytes32",
        name: "presaleMerkleRoot",
        type: "bytes32"
      }
    ],
    name: "setSaleConfiguration",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  }
];

// node_modules/@thirdweb-dev/contracts-js/dist/abis/ILoyaltyCard.json
var ILoyaltyCard_default = [
  {
    anonymous: false,
    inputs: [
      {
        indexed: true,
        internalType: "address",
        name: "mintedTo",
        type: "address"
      },
      {
        indexed: true,
        internalType: "uint256",
        name: "tokenIdMinted",
        type: "uint256"
      },
      {
        indexed: false,
        internalType: "string",
        name: "uri",
        type: "string"
      }
    ],
    name: "TokensMinted",
    type: "event"
  },
  {
    inputs: [
      {
        internalType: "uint256",
        name: "tokenId",
        type: "uint256"
      }
    ],
    name: "cancel",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "address",
        name: "to",
        type: "address"
      },
      {
        internalType: "string",
        name: "uri",
        type: "string"
      }
    ],
    name: "mintTo",
    outputs: [
      {
        internalType: "uint256",
        name: "",
        type: "uint256"
      }
    ],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "uint256",
        name: "tokenId",
        type: "uint256"
      }
    ],
    name: "revoke",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  }
];

// node_modules/@thirdweb-dev/contracts-js/dist/abis/INFTMetadata.json
var INFTMetadata_default = [
  {
    anonymous: false,
    inputs: [
      {
        indexed: false,
        internalType: "uint256",
        name: "_fromTokenId",
        type: "uint256"
      },
      {
        indexed: false,
        internalType: "uint256",
        name: "_toTokenId",
        type: "uint256"
      }
    ],
    name: "BatchMetadataUpdate",
    type: "event"
  },
  {
    anonymous: false,
    inputs: [
      {
        indexed: false,
        internalType: "uint256",
        name: "_tokenId",
        type: "uint256"
      }
    ],
    name: "MetadataUpdate",
    type: "event"
  },
  {
    inputs: [
      {
        internalType: "uint256",
        name: "_tokenId",
        type: "uint256"
      },
      {
        internalType: "string",
        name: "_uri",
        type: "string"
      }
    ],
    name: "setTokenURI",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "bytes4",
        name: "interfaceId",
        type: "bytes4"
      }
    ],
    name: "supportsInterface",
    outputs: [
      {
        internalType: "bool",
        name: "",
        type: "bool"
      }
    ],
    stateMutability: "view",
    type: "function"
  }
];

// node_modules/@thirdweb-dev/contracts-js/dist/abis/IBurnableERC1155.json
var IBurnableERC1155_default = [
  {
    inputs: [
      {
        internalType: "address",
        name: "account",
        type: "address"
      },
      {
        internalType: "uint256",
        name: "id",
        type: "uint256"
      },
      {
        internalType: "uint256",
        name: "value",
        type: "uint256"
      }
    ],
    name: "burn",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "address",
        name: "account",
        type: "address"
      },
      {
        internalType: "uint256[]",
        name: "ids",
        type: "uint256[]"
      },
      {
        internalType: "uint256[]",
        name: "values",
        type: "uint256[]"
      }
    ],
    name: "burnBatch",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  }
];

// node_modules/@thirdweb-dev/contracts-js/dist/abis/IClaimableERC1155.json
var IClaimableERC1155_default = [
  {
    anonymous: false,
    inputs: [
      {
        indexed: true,
        internalType: "address",
        name: "claimer",
        type: "address"
      },
      {
        indexed: true,
        internalType: "address",
        name: "receiver",
        type: "address"
      },
      {
        indexed: true,
        internalType: "uint256",
        name: "tokenId",
        type: "uint256"
      },
      {
        indexed: false,
        internalType: "uint256",
        name: "quantityClaimed",
        type: "uint256"
      }
    ],
    name: "TokensClaimed",
    type: "event"
  },
  {
    inputs: [
      {
        internalType: "address",
        name: "_receiver",
        type: "address"
      },
      {
        internalType: "uint256",
        name: "_tokenId",
        type: "uint256"
      },
      {
        internalType: "uint256",
        name: "_quantity",
        type: "uint256"
      }
    ],
    name: "claim",
    outputs: [],
    stateMutability: "payable",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "address",
        name: "_claimer",
        type: "address"
      },
      {
        internalType: "uint256",
        name: "_tokenId",
        type: "uint256"
      },
      {
        internalType: "uint256",
        name: "_quantity",
        type: "uint256"
      }
    ],
    name: "verifyClaim",
    outputs: [],
    stateMutability: "view",
    type: "function"
  }
];

// node_modules/@thirdweb-dev/contracts-js/dist/abis/IDrop1155.json
var IDrop1155_default = [
  {
    anonymous: false,
    inputs: [
      {
        indexed: true,
        internalType: "uint256",
        name: "tokenId",
        type: "uint256"
      },
      {
        components: [
          {
            internalType: "uint256",
            name: "startTimestamp",
            type: "uint256"
          },
          {
            internalType: "uint256",
            name: "maxClaimableSupply",
            type: "uint256"
          },
          {
            internalType: "uint256",
            name: "supplyClaimed",
            type: "uint256"
          },
          {
            internalType: "uint256",
            name: "quantityLimitPerWallet",
            type: "uint256"
          },
          {
            internalType: "bytes32",
            name: "merkleRoot",
            type: "bytes32"
          },
          {
            internalType: "uint256",
            name: "pricePerToken",
            type: "uint256"
          },
          {
            internalType: "address",
            name: "currency",
            type: "address"
          },
          {
            internalType: "string",
            name: "metadata",
            type: "string"
          }
        ],
        indexed: false,
        internalType: "struct IClaimCondition.ClaimCondition[]",
        name: "claimConditions",
        type: "tuple[]"
      },
      {
        indexed: false,
        internalType: "bool",
        name: "resetEligibility",
        type: "bool"
      }
    ],
    name: "ClaimConditionsUpdated",
    type: "event"
  },
  {
    anonymous: false,
    inputs: [
      {
        indexed: true,
        internalType: "uint256",
        name: "claimConditionIndex",
        type: "uint256"
      },
      {
        indexed: true,
        internalType: "address",
        name: "claimer",
        type: "address"
      },
      {
        indexed: true,
        internalType: "address",
        name: "receiver",
        type: "address"
      },
      {
        indexed: false,
        internalType: "uint256",
        name: "tokenId",
        type: "uint256"
      },
      {
        indexed: false,
        internalType: "uint256",
        name: "quantityClaimed",
        type: "uint256"
      }
    ],
    name: "TokensClaimed",
    type: "event"
  },
  {
    inputs: [
      {
        internalType: "address",
        name: "receiver",
        type: "address"
      },
      {
        internalType: "uint256",
        name: "tokenId",
        type: "uint256"
      },
      {
        internalType: "uint256",
        name: "quantity",
        type: "uint256"
      },
      {
        internalType: "address",
        name: "currency",
        type: "address"
      },
      {
        internalType: "uint256",
        name: "pricePerToken",
        type: "uint256"
      },
      {
        components: [
          {
            internalType: "bytes32[]",
            name: "proof",
            type: "bytes32[]"
          },
          {
            internalType: "uint256",
            name: "quantityLimitPerWallet",
            type: "uint256"
          },
          {
            internalType: "uint256",
            name: "pricePerToken",
            type: "uint256"
          },
          {
            internalType: "address",
            name: "currency",
            type: "address"
          }
        ],
        internalType: "struct IDrop1155.AllowlistProof",
        name: "allowlistProof",
        type: "tuple"
      },
      {
        internalType: "bytes",
        name: "data",
        type: "bytes"
      }
    ],
    name: "claim",
    outputs: [],
    stateMutability: "payable",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "uint256",
        name: "tokenId",
        type: "uint256"
      },
      {
        components: [
          {
            internalType: "uint256",
            name: "startTimestamp",
            type: "uint256"
          },
          {
            internalType: "uint256",
            name: "maxClaimableSupply",
            type: "uint256"
          },
          {
            internalType: "uint256",
            name: "supplyClaimed",
            type: "uint256"
          },
          {
            internalType: "uint256",
            name: "quantityLimitPerWallet",
            type: "uint256"
          },
          {
            internalType: "bytes32",
            name: "merkleRoot",
            type: "bytes32"
          },
          {
            internalType: "uint256",
            name: "pricePerToken",
            type: "uint256"
          },
          {
            internalType: "address",
            name: "currency",
            type: "address"
          },
          {
            internalType: "string",
            name: "metadata",
            type: "string"
          }
        ],
        internalType: "struct IClaimCondition.ClaimCondition[]",
        name: "phases",
        type: "tuple[]"
      },
      {
        internalType: "bool",
        name: "resetClaimEligibility",
        type: "bool"
      }
    ],
    name: "setClaimConditions",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  }
];

// node_modules/@thirdweb-dev/contracts-js/dist/abis/IDropERC1155_V2.json
var IDropERC1155_V2_default = [
  {
    anonymous: false,
    inputs: [
      {
        indexed: true,
        internalType: "address",
        name: "account",
        type: "address"
      },
      {
        indexed: true,
        internalType: "address",
        name: "operator",
        type: "address"
      },
      {
        indexed: false,
        internalType: "bool",
        name: "approved",
        type: "bool"
      }
    ],
    name: "ApprovalForAll",
    type: "event"
  },
  {
    anonymous: false,
    inputs: [
      {
        indexed: true,
        internalType: "uint256",
        name: "tokenId",
        type: "uint256"
      },
      {
        components: [
          {
            internalType: "uint256",
            name: "startTimestamp",
            type: "uint256"
          },
          {
            internalType: "uint256",
            name: "maxClaimableSupply",
            type: "uint256"
          },
          {
            internalType: "uint256",
            name: "supplyClaimed",
            type: "uint256"
          },
          {
            internalType: "uint256",
            name: "quantityLimitPerTransaction",
            type: "uint256"
          },
          {
            internalType: "uint256",
            name: "waitTimeInSecondsBetweenClaims",
            type: "uint256"
          },
          {
            internalType: "bytes32",
            name: "merkleRoot",
            type: "bytes32"
          },
          {
            internalType: "uint256",
            name: "pricePerToken",
            type: "uint256"
          },
          {
            internalType: "address",
            name: "currency",
            type: "address"
          }
        ],
        indexed: false,
        internalType: "struct IDropClaimCondition_V2.ClaimCondition[]",
        name: "claimConditions",
        type: "tuple[]"
      }
    ],
    name: "ClaimConditionsUpdated",
    type: "event"
  },
  {
    anonymous: false,
    inputs: [
      {
        indexed: false,
        internalType: "uint256",
        name: "tokenId",
        type: "uint256"
      },
      {
        indexed: false,
        internalType: "uint256",
        name: "maxTotalSupply",
        type: "uint256"
      }
    ],
    name: "MaxTotalSupplyUpdated",
    type: "event"
  },
  {
    anonymous: false,
    inputs: [
      {
        indexed: false,
        internalType: "uint256",
        name: "tokenId",
        type: "uint256"
      },
      {
        indexed: false,
        internalType: "uint256",
        name: "count",
        type: "uint256"
      }
    ],
    name: "MaxWalletClaimCountUpdated",
    type: "event"
  },
  {
    anonymous: false,
    inputs: [
      {
        indexed: true,
        internalType: "uint256",
        name: "tokenId",
        type: "uint256"
      },
      {
        indexed: false,
        internalType: "address",
        name: "saleRecipient",
        type: "address"
      }
    ],
    name: "SaleRecipientForTokenUpdated",
    type: "event"
  },
  {
    anonymous: false,
    inputs: [
      {
        indexed: true,
        internalType: "uint256",
        name: "claimConditionIndex",
        type: "uint256"
      },
      {
        indexed: true,
        internalType: "uint256",
        name: "tokenId",
        type: "uint256"
      },
      {
        indexed: true,
        internalType: "address",
        name: "claimer",
        type: "address"
      },
      {
        indexed: false,
        internalType: "address",
        name: "receiver",
        type: "address"
      },
      {
        indexed: false,
        internalType: "uint256",
        name: "quantityClaimed",
        type: "uint256"
      }
    ],
    name: "TokensClaimed",
    type: "event"
  },
  {
    anonymous: false,
    inputs: [
      {
        indexed: false,
        internalType: "uint256",
        name: "startTokenId",
        type: "uint256"
      },
      {
        indexed: false,
        internalType: "uint256",
        name: "endTokenId",
        type: "uint256"
      },
      {
        indexed: false,
        internalType: "string",
        name: "baseURI",
        type: "string"
      }
    ],
    name: "TokensLazyMinted",
    type: "event"
  },
  {
    anonymous: false,
    inputs: [
      {
        indexed: true,
        internalType: "address",
        name: "operator",
        type: "address"
      },
      {
        indexed: true,
        internalType: "address",
        name: "from",
        type: "address"
      },
      {
        indexed: true,
        internalType: "address",
        name: "to",
        type: "address"
      },
      {
        indexed: false,
        internalType: "uint256[]",
        name: "ids",
        type: "uint256[]"
      },
      {
        indexed: false,
        internalType: "uint256[]",
        name: "values",
        type: "uint256[]"
      }
    ],
    name: "TransferBatch",
    type: "event"
  },
  {
    anonymous: false,
    inputs: [
      {
        indexed: true,
        internalType: "address",
        name: "operator",
        type: "address"
      },
      {
        indexed: true,
        internalType: "address",
        name: "from",
        type: "address"
      },
      {
        indexed: true,
        internalType: "address",
        name: "to",
        type: "address"
      },
      {
        indexed: false,
        internalType: "uint256",
        name: "id",
        type: "uint256"
      },
      {
        indexed: false,
        internalType: "uint256",
        name: "value",
        type: "uint256"
      }
    ],
    name: "TransferSingle",
    type: "event"
  },
  {
    anonymous: false,
    inputs: [
      {
        indexed: false,
        internalType: "string",
        name: "value",
        type: "string"
      },
      {
        indexed: true,
        internalType: "uint256",
        name: "id",
        type: "uint256"
      }
    ],
    name: "URI",
    type: "event"
  },
  {
    anonymous: false,
    inputs: [
      {
        indexed: false,
        internalType: "uint256",
        name: "tokenId",
        type: "uint256"
      },
      {
        indexed: true,
        internalType: "address",
        name: "wallet",
        type: "address"
      },
      {
        indexed: false,
        internalType: "uint256",
        name: "count",
        type: "uint256"
      }
    ],
    name: "WalletClaimCountUpdated",
    type: "event"
  },
  {
    inputs: [
      {
        internalType: "address",
        name: "account",
        type: "address"
      },
      {
        internalType: "uint256",
        name: "id",
        type: "uint256"
      }
    ],
    name: "balanceOf",
    outputs: [
      {
        internalType: "uint256",
        name: "",
        type: "uint256"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "address[]",
        name: "accounts",
        type: "address[]"
      },
      {
        internalType: "uint256[]",
        name: "ids",
        type: "uint256[]"
      }
    ],
    name: "balanceOfBatch",
    outputs: [
      {
        internalType: "uint256[]",
        name: "",
        type: "uint256[]"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "address",
        name: "receiver",
        type: "address"
      },
      {
        internalType: "uint256",
        name: "tokenId",
        type: "uint256"
      },
      {
        internalType: "uint256",
        name: "quantity",
        type: "uint256"
      },
      {
        internalType: "address",
        name: "currency",
        type: "address"
      },
      {
        internalType: "uint256",
        name: "pricePerToken",
        type: "uint256"
      },
      {
        internalType: "bytes32[]",
        name: "proofs",
        type: "bytes32[]"
      },
      {
        internalType: "uint256",
        name: "proofMaxQuantityPerTransaction",
        type: "uint256"
      }
    ],
    name: "claim",
    outputs: [],
    stateMutability: "payable",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "address",
        name: "account",
        type: "address"
      },
      {
        internalType: "address",
        name: "operator",
        type: "address"
      }
    ],
    name: "isApprovedForAll",
    outputs: [
      {
        internalType: "bool",
        name: "",
        type: "bool"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "uint256",
        name: "amount",
        type: "uint256"
      },
      {
        internalType: "string",
        name: "baseURIForTokens",
        type: "string"
      }
    ],
    name: "lazyMint",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "address",
        name: "from",
        type: "address"
      },
      {
        internalType: "address",
        name: "to",
        type: "address"
      },
      {
        internalType: "uint256[]",
        name: "ids",
        type: "uint256[]"
      },
      {
        internalType: "uint256[]",
        name: "amounts",
        type: "uint256[]"
      },
      {
        internalType: "bytes",
        name: "data",
        type: "bytes"
      }
    ],
    name: "safeBatchTransferFrom",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "address",
        name: "from",
        type: "address"
      },
      {
        internalType: "address",
        name: "to",
        type: "address"
      },
      {
        internalType: "uint256",
        name: "id",
        type: "uint256"
      },
      {
        internalType: "uint256",
        name: "amount",
        type: "uint256"
      },
      {
        internalType: "bytes",
        name: "data",
        type: "bytes"
      }
    ],
    name: "safeTransferFrom",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "address",
        name: "operator",
        type: "address"
      },
      {
        internalType: "bool",
        name: "approved",
        type: "bool"
      }
    ],
    name: "setApprovalForAll",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "uint256",
        name: "tokenId",
        type: "uint256"
      },
      {
        components: [
          {
            internalType: "uint256",
            name: "startTimestamp",
            type: "uint256"
          },
          {
            internalType: "uint256",
            name: "maxClaimableSupply",
            type: "uint256"
          },
          {
            internalType: "uint256",
            name: "supplyClaimed",
            type: "uint256"
          },
          {
            internalType: "uint256",
            name: "quantityLimitPerTransaction",
            type: "uint256"
          },
          {
            internalType: "uint256",
            name: "waitTimeInSecondsBetweenClaims",
            type: "uint256"
          },
          {
            internalType: "bytes32",
            name: "merkleRoot",
            type: "bytes32"
          },
          {
            internalType: "uint256",
            name: "pricePerToken",
            type: "uint256"
          },
          {
            internalType: "address",
            name: "currency",
            type: "address"
          }
        ],
        internalType: "struct IDropClaimCondition_V2.ClaimCondition[]",
        name: "phases",
        type: "tuple[]"
      },
      {
        internalType: "bool",
        name: "resetClaimEligibility",
        type: "bool"
      }
    ],
    name: "setClaimConditions",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "bytes4",
        name: "interfaceId",
        type: "bytes4"
      }
    ],
    name: "supportsInterface",
    outputs: [
      {
        internalType: "bool",
        name: "",
        type: "bool"
      }
    ],
    stateMutability: "view",
    type: "function"
  }
];

// node_modules/@thirdweb-dev/contracts-js/dist/abis/IDropSinglePhase1155.json
var IDropSinglePhase1155_default = [
  {
    anonymous: false,
    inputs: [
      {
        indexed: true,
        internalType: "uint256",
        name: "tokenId",
        type: "uint256"
      },
      {
        components: [
          {
            internalType: "uint256",
            name: "startTimestamp",
            type: "uint256"
          },
          {
            internalType: "uint256",
            name: "maxClaimableSupply",
            type: "uint256"
          },
          {
            internalType: "uint256",
            name: "supplyClaimed",
            type: "uint256"
          },
          {
            internalType: "uint256",
            name: "quantityLimitPerWallet",
            type: "uint256"
          },
          {
            internalType: "bytes32",
            name: "merkleRoot",
            type: "bytes32"
          },
          {
            internalType: "uint256",
            name: "pricePerToken",
            type: "uint256"
          },
          {
            internalType: "address",
            name: "currency",
            type: "address"
          },
          {
            internalType: "string",
            name: "metadata",
            type: "string"
          }
        ],
        indexed: false,
        internalType: "struct IClaimCondition.ClaimCondition",
        name: "condition",
        type: "tuple"
      },
      {
        indexed: false,
        internalType: "bool",
        name: "resetEligibility",
        type: "bool"
      }
    ],
    name: "ClaimConditionUpdated",
    type: "event"
  },
  {
    anonymous: false,
    inputs: [
      {
        indexed: true,
        internalType: "address",
        name: "claimer",
        type: "address"
      },
      {
        indexed: true,
        internalType: "address",
        name: "receiver",
        type: "address"
      },
      {
        indexed: true,
        internalType: "uint256",
        name: "tokenId",
        type: "uint256"
      },
      {
        indexed: false,
        internalType: "uint256",
        name: "quantityClaimed",
        type: "uint256"
      }
    ],
    name: "TokensClaimed",
    type: "event"
  },
  {
    inputs: [
      {
        internalType: "address",
        name: "receiver",
        type: "address"
      },
      {
        internalType: "uint256",
        name: "tokenId",
        type: "uint256"
      },
      {
        internalType: "uint256",
        name: "quantity",
        type: "uint256"
      },
      {
        internalType: "address",
        name: "currency",
        type: "address"
      },
      {
        internalType: "uint256",
        name: "pricePerToken",
        type: "uint256"
      },
      {
        components: [
          {
            internalType: "bytes32[]",
            name: "proof",
            type: "bytes32[]"
          },
          {
            internalType: "uint256",
            name: "quantityLimitPerWallet",
            type: "uint256"
          },
          {
            internalType: "uint256",
            name: "pricePerToken",
            type: "uint256"
          },
          {
            internalType: "address",
            name: "currency",
            type: "address"
          }
        ],
        internalType: "struct IDropSinglePhase1155.AllowlistProof",
        name: "allowlistProof",
        type: "tuple"
      },
      {
        internalType: "bytes",
        name: "data",
        type: "bytes"
      }
    ],
    name: "claim",
    outputs: [],
    stateMutability: "payable",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "uint256",
        name: "tokenId",
        type: "uint256"
      },
      {
        components: [
          {
            internalType: "uint256",
            name: "startTimestamp",
            type: "uint256"
          },
          {
            internalType: "uint256",
            name: "maxClaimableSupply",
            type: "uint256"
          },
          {
            internalType: "uint256",
            name: "supplyClaimed",
            type: "uint256"
          },
          {
            internalType: "uint256",
            name: "quantityLimitPerWallet",
            type: "uint256"
          },
          {
            internalType: "bytes32",
            name: "merkleRoot",
            type: "bytes32"
          },
          {
            internalType: "uint256",
            name: "pricePerToken",
            type: "uint256"
          },
          {
            internalType: "address",
            name: "currency",
            type: "address"
          },
          {
            internalType: "string",
            name: "metadata",
            type: "string"
          }
        ],
        internalType: "struct IClaimCondition.ClaimCondition",
        name: "phase",
        type: "tuple"
      },
      {
        internalType: "bool",
        name: "resetClaimEligibility",
        type: "bool"
      }
    ],
    name: "setClaimConditions",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  }
];

// node_modules/@thirdweb-dev/contracts-js/dist/abis/IDropSinglePhase1155_V1.json
var IDropSinglePhase1155_V1_default = [
  {
    anonymous: false,
    inputs: [
      {
        indexed: true,
        internalType: "uint256",
        name: "tokenId",
        type: "uint256"
      },
      {
        components: [
          {
            internalType: "uint256",
            name: "startTimestamp",
            type: "uint256"
          },
          {
            internalType: "uint256",
            name: "maxClaimableSupply",
            type: "uint256"
          },
          {
            internalType: "uint256",
            name: "supplyClaimed",
            type: "uint256"
          },
          {
            internalType: "uint256",
            name: "quantityLimitPerTransaction",
            type: "uint256"
          },
          {
            internalType: "uint256",
            name: "waitTimeInSecondsBetweenClaims",
            type: "uint256"
          },
          {
            internalType: "bytes32",
            name: "merkleRoot",
            type: "bytes32"
          },
          {
            internalType: "uint256",
            name: "pricePerToken",
            type: "uint256"
          },
          {
            internalType: "address",
            name: "currency",
            type: "address"
          }
        ],
        indexed: false,
        internalType: "struct IClaimCondition_V1.ClaimCondition",
        name: "condition",
        type: "tuple"
      },
      {
        indexed: false,
        internalType: "bool",
        name: "resetEligibility",
        type: "bool"
      }
    ],
    name: "ClaimConditionUpdated",
    type: "event"
  },
  {
    anonymous: false,
    inputs: [
      {
        indexed: true,
        internalType: "address",
        name: "claimer",
        type: "address"
      },
      {
        indexed: true,
        internalType: "address",
        name: "receiver",
        type: "address"
      },
      {
        indexed: true,
        internalType: "uint256",
        name: "tokenId",
        type: "uint256"
      },
      {
        indexed: false,
        internalType: "uint256",
        name: "quantityClaimed",
        type: "uint256"
      }
    ],
    name: "TokensClaimed",
    type: "event"
  },
  {
    inputs: [
      {
        internalType: "address",
        name: "receiver",
        type: "address"
      },
      {
        internalType: "uint256",
        name: "tokenId",
        type: "uint256"
      },
      {
        internalType: "uint256",
        name: "quantity",
        type: "uint256"
      },
      {
        internalType: "address",
        name: "currency",
        type: "address"
      },
      {
        internalType: "uint256",
        name: "pricePerToken",
        type: "uint256"
      },
      {
        components: [
          {
            internalType: "bytes32[]",
            name: "proof",
            type: "bytes32[]"
          },
          {
            internalType: "uint256",
            name: "maxQuantityInAllowlist",
            type: "uint256"
          }
        ],
        internalType: "struct IDropSinglePhase1155_V1.AllowlistProof",
        name: "allowlistProof",
        type: "tuple"
      },
      {
        internalType: "bytes",
        name: "data",
        type: "bytes"
      }
    ],
    name: "claim",
    outputs: [],
    stateMutability: "payable",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "uint256",
        name: "tokenId",
        type: "uint256"
      },
      {
        components: [
          {
            internalType: "uint256",
            name: "startTimestamp",
            type: "uint256"
          },
          {
            internalType: "uint256",
            name: "maxClaimableSupply",
            type: "uint256"
          },
          {
            internalType: "uint256",
            name: "supplyClaimed",
            type: "uint256"
          },
          {
            internalType: "uint256",
            name: "quantityLimitPerTransaction",
            type: "uint256"
          },
          {
            internalType: "uint256",
            name: "waitTimeInSecondsBetweenClaims",
            type: "uint256"
          },
          {
            internalType: "bytes32",
            name: "merkleRoot",
            type: "bytes32"
          },
          {
            internalType: "uint256",
            name: "pricePerToken",
            type: "uint256"
          },
          {
            internalType: "address",
            name: "currency",
            type: "address"
          }
        ],
        internalType: "struct IClaimCondition_V1.ClaimCondition",
        name: "phase",
        type: "tuple"
      },
      {
        internalType: "bool",
        name: "resetClaimEligibility",
        type: "bool"
      }
    ],
    name: "setClaimConditions",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  }
];

// node_modules/@thirdweb-dev/contracts-js/dist/abis/IERC1155Supply.json
var IERC1155Supply_default = [
  {
    inputs: [
      {
        internalType: "uint256",
        name: "id",
        type: "uint256"
      }
    ],
    name: "totalSupply",
    outputs: [
      {
        internalType: "uint256",
        name: "",
        type: "uint256"
      }
    ],
    stateMutability: "view",
    type: "function"
  }
];

// node_modules/@thirdweb-dev/contracts-js/dist/abis/IERC1155Enumerable.json
var IERC1155Enumerable_default = [
  {
    inputs: [],
    name: "nextTokenIdToMint",
    outputs: [
      {
        internalType: "uint256",
        name: "",
        type: "uint256"
      }
    ],
    stateMutability: "view",
    type: "function"
  }
];

// node_modules/@thirdweb-dev/contracts-js/dist/abis/IMintableERC1155.json
var IMintableERC1155_default = [
  {
    anonymous: false,
    inputs: [
      {
        indexed: true,
        internalType: "address",
        name: "mintedTo",
        type: "address"
      },
      {
        indexed: true,
        internalType: "uint256",
        name: "tokenIdMinted",
        type: "uint256"
      },
      {
        indexed: false,
        internalType: "string",
        name: "uri",
        type: "string"
      },
      {
        indexed: false,
        internalType: "uint256",
        name: "quantityMinted",
        type: "uint256"
      }
    ],
    name: "TokensMinted",
    type: "event"
  },
  {
    inputs: [
      {
        internalType: "address",
        name: "to",
        type: "address"
      },
      {
        internalType: "uint256",
        name: "tokenId",
        type: "uint256"
      },
      {
        internalType: "string",
        name: "uri",
        type: "string"
      },
      {
        internalType: "uint256",
        name: "amount",
        type: "uint256"
      }
    ],
    name: "mintTo",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  }
];

// node_modules/@thirdweb-dev/contracts-js/dist/abis/ISignatureMintERC1155.json
var ISignatureMintERC1155_default = [
  {
    anonymous: false,
    inputs: [
      {
        indexed: true,
        internalType: "address",
        name: "signer",
        type: "address"
      },
      {
        indexed: true,
        internalType: "address",
        name: "mintedTo",
        type: "address"
      },
      {
        indexed: true,
        internalType: "uint256",
        name: "tokenIdMinted",
        type: "uint256"
      },
      {
        components: [
          {
            internalType: "address",
            name: "to",
            type: "address"
          },
          {
            internalType: "address",
            name: "royaltyRecipient",
            type: "address"
          },
          {
            internalType: "uint256",
            name: "royaltyBps",
            type: "uint256"
          },
          {
            internalType: "address",
            name: "primarySaleRecipient",
            type: "address"
          },
          {
            internalType: "uint256",
            name: "tokenId",
            type: "uint256"
          },
          {
            internalType: "string",
            name: "uri",
            type: "string"
          },
          {
            internalType: "uint256",
            name: "quantity",
            type: "uint256"
          },
          {
            internalType: "uint256",
            name: "pricePerToken",
            type: "uint256"
          },
          {
            internalType: "address",
            name: "currency",
            type: "address"
          },
          {
            internalType: "uint128",
            name: "validityStartTimestamp",
            type: "uint128"
          },
          {
            internalType: "uint128",
            name: "validityEndTimestamp",
            type: "uint128"
          },
          {
            internalType: "bytes32",
            name: "uid",
            type: "bytes32"
          }
        ],
        indexed: false,
        internalType: "struct ISignatureMintERC1155.MintRequest",
        name: "mintRequest",
        type: "tuple"
      }
    ],
    name: "TokensMintedWithSignature",
    type: "event"
  },
  {
    inputs: [
      {
        components: [
          {
            internalType: "address",
            name: "to",
            type: "address"
          },
          {
            internalType: "address",
            name: "royaltyRecipient",
            type: "address"
          },
          {
            internalType: "uint256",
            name: "royaltyBps",
            type: "uint256"
          },
          {
            internalType: "address",
            name: "primarySaleRecipient",
            type: "address"
          },
          {
            internalType: "uint256",
            name: "tokenId",
            type: "uint256"
          },
          {
            internalType: "string",
            name: "uri",
            type: "string"
          },
          {
            internalType: "uint256",
            name: "quantity",
            type: "uint256"
          },
          {
            internalType: "uint256",
            name: "pricePerToken",
            type: "uint256"
          },
          {
            internalType: "address",
            name: "currency",
            type: "address"
          },
          {
            internalType: "uint128",
            name: "validityStartTimestamp",
            type: "uint128"
          },
          {
            internalType: "uint128",
            name: "validityEndTimestamp",
            type: "uint128"
          },
          {
            internalType: "bytes32",
            name: "uid",
            type: "bytes32"
          }
        ],
        internalType: "struct ISignatureMintERC1155.MintRequest",
        name: "req",
        type: "tuple"
      },
      {
        internalType: "bytes",
        name: "signature",
        type: "bytes"
      }
    ],
    name: "mintWithSignature",
    outputs: [
      {
        internalType: "address",
        name: "signer",
        type: "address"
      }
    ],
    stateMutability: "payable",
    type: "function"
  },
  {
    inputs: [
      {
        components: [
          {
            internalType: "address",
            name: "to",
            type: "address"
          },
          {
            internalType: "address",
            name: "royaltyRecipient",
            type: "address"
          },
          {
            internalType: "uint256",
            name: "royaltyBps",
            type: "uint256"
          },
          {
            internalType: "address",
            name: "primarySaleRecipient",
            type: "address"
          },
          {
            internalType: "uint256",
            name: "tokenId",
            type: "uint256"
          },
          {
            internalType: "string",
            name: "uri",
            type: "string"
          },
          {
            internalType: "uint256",
            name: "quantity",
            type: "uint256"
          },
          {
            internalType: "uint256",
            name: "pricePerToken",
            type: "uint256"
          },
          {
            internalType: "address",
            name: "currency",
            type: "address"
          },
          {
            internalType: "uint128",
            name: "validityStartTimestamp",
            type: "uint128"
          },
          {
            internalType: "uint128",
            name: "validityEndTimestamp",
            type: "uint128"
          },
          {
            internalType: "bytes32",
            name: "uid",
            type: "bytes32"
          }
        ],
        internalType: "struct ISignatureMintERC1155.MintRequest",
        name: "req",
        type: "tuple"
      },
      {
        internalType: "bytes",
        name: "signature",
        type: "bytes"
      }
    ],
    name: "verify",
    outputs: [
      {
        internalType: "bool",
        name: "success",
        type: "bool"
      },
      {
        internalType: "address",
        name: "signer",
        type: "address"
      }
    ],
    stateMutability: "view",
    type: "function"
  }
];

// node_modules/@thirdweb-dev/contracts-js/dist/abis/IERC2771Context.json
var IERC2771Context_default = [
  {
    inputs: [
      {
        internalType: "address",
        name: "forwarder",
        type: "address"
      }
    ],
    name: "isTrustedForwarder",
    outputs: [
      {
        internalType: "bool",
        name: "",
        type: "bool"
      }
    ],
    stateMutability: "view",
    type: "function"
  }
];

// node_modules/@thirdweb-dev/contracts-js/dist/abis/IAppURI.json
var IAppURI_default = [
  {
    anonymous: false,
    inputs: [
      {
        indexed: false,
        internalType: "string",
        name: "prevURI",
        type: "string"
      },
      {
        indexed: false,
        internalType: "string",
        name: "newURI",
        type: "string"
      }
    ],
    name: "AppURIUpdated",
    type: "event"
  },
  {
    inputs: [],
    name: "appURI",
    outputs: [
      {
        internalType: "string",
        name: "",
        type: "string"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "string",
        name: "_uri",
        type: "string"
      }
    ],
    name: "setAppURI",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  }
];

// node_modules/@thirdweb-dev/contracts-js/dist/abis/IContractMetadata.json
var IContractMetadata_default = [
  {
    anonymous: false,
    inputs: [
      {
        indexed: false,
        internalType: "string",
        name: "prevURI",
        type: "string"
      },
      {
        indexed: false,
        internalType: "string",
        name: "newURI",
        type: "string"
      }
    ],
    name: "ContractURIUpdated",
    type: "event"
  },
  {
    inputs: [],
    name: "contractURI",
    outputs: [
      {
        internalType: "string",
        name: "",
        type: "string"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "string",
        name: "_uri",
        type: "string"
      }
    ],
    name: "setContractURI",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  }
];

// node_modules/@thirdweb-dev/contracts-js/dist/abis/IDirectListings.json
var IDirectListings_default = [
  {
    anonymous: false,
    inputs: [
      {
        indexed: true,
        internalType: "uint256",
        name: "listingId",
        type: "uint256"
      },
      {
        indexed: true,
        internalType: "address",
        name: "buyer",
        type: "address"
      },
      {
        indexed: false,
        internalType: "bool",
        name: "approved",
        type: "bool"
      }
    ],
    name: "BuyerApprovedForListing",
    type: "event"
  },
  {
    anonymous: false,
    inputs: [
      {
        indexed: true,
        internalType: "address",
        name: "listingCreator",
        type: "address"
      },
      {
        indexed: true,
        internalType: "uint256",
        name: "listingId",
        type: "uint256"
      }
    ],
    name: "CancelledListing",
    type: "event"
  },
  {
    anonymous: false,
    inputs: [
      {
        indexed: true,
        internalType: "uint256",
        name: "listingId",
        type: "uint256"
      },
      {
        indexed: true,
        internalType: "address",
        name: "currency",
        type: "address"
      },
      {
        indexed: false,
        internalType: "uint256",
        name: "pricePerToken",
        type: "uint256"
      }
    ],
    name: "CurrencyApprovedForListing",
    type: "event"
  },
  {
    anonymous: false,
    inputs: [
      {
        indexed: true,
        internalType: "address",
        name: "listingCreator",
        type: "address"
      },
      {
        indexed: true,
        internalType: "uint256",
        name: "listingId",
        type: "uint256"
      },
      {
        indexed: true,
        internalType: "address",
        name: "assetContract",
        type: "address"
      },
      {
        components: [
          {
            internalType: "uint256",
            name: "listingId",
            type: "uint256"
          },
          {
            internalType: "address",
            name: "listingCreator",
            type: "address"
          },
          {
            internalType: "address",
            name: "assetContract",
            type: "address"
          },
          {
            internalType: "uint256",
            name: "tokenId",
            type: "uint256"
          },
          {
            internalType: "uint256",
            name: "quantity",
            type: "uint256"
          },
          {
            internalType: "address",
            name: "currency",
            type: "address"
          },
          {
            internalType: "uint256",
            name: "pricePerToken",
            type: "uint256"
          },
          {
            internalType: "uint128",
            name: "startTimestamp",
            type: "uint128"
          },
          {
            internalType: "uint128",
            name: "endTimestamp",
            type: "uint128"
          },
          {
            internalType: "bool",
            name: "reserved",
            type: "bool"
          },
          {
            internalType: "enum IDirectListings.TokenType",
            name: "tokenType",
            type: "uint8"
          },
          {
            internalType: "enum IDirectListings.Status",
            name: "status",
            type: "uint8"
          }
        ],
        indexed: false,
        internalType: "struct IDirectListings.Listing",
        name: "listing",
        type: "tuple"
      }
    ],
    name: "NewListing",
    type: "event"
  },
  {
    anonymous: false,
    inputs: [
      {
        indexed: true,
        internalType: "address",
        name: "listingCreator",
        type: "address"
      },
      {
        indexed: true,
        internalType: "uint256",
        name: "listingId",
        type: "uint256"
      },
      {
        indexed: true,
        internalType: "address",
        name: "assetContract",
        type: "address"
      },
      {
        indexed: false,
        internalType: "uint256",
        name: "tokenId",
        type: "uint256"
      },
      {
        indexed: false,
        internalType: "address",
        name: "buyer",
        type: "address"
      },
      {
        indexed: false,
        internalType: "uint256",
        name: "quantityBought",
        type: "uint256"
      },
      {
        indexed: false,
        internalType: "uint256",
        name: "totalPricePaid",
        type: "uint256"
      }
    ],
    name: "NewSale",
    type: "event"
  },
  {
    anonymous: false,
    inputs: [
      {
        indexed: true,
        internalType: "address",
        name: "listingCreator",
        type: "address"
      },
      {
        indexed: true,
        internalType: "uint256",
        name: "listingId",
        type: "uint256"
      },
      {
        indexed: true,
        internalType: "address",
        name: "assetContract",
        type: "address"
      },
      {
        components: [
          {
            internalType: "uint256",
            name: "listingId",
            type: "uint256"
          },
          {
            internalType: "address",
            name: "listingCreator",
            type: "address"
          },
          {
            internalType: "address",
            name: "assetContract",
            type: "address"
          },
          {
            internalType: "uint256",
            name: "tokenId",
            type: "uint256"
          },
          {
            internalType: "uint256",
            name: "quantity",
            type: "uint256"
          },
          {
            internalType: "address",
            name: "currency",
            type: "address"
          },
          {
            internalType: "uint256",
            name: "pricePerToken",
            type: "uint256"
          },
          {
            internalType: "uint128",
            name: "startTimestamp",
            type: "uint128"
          },
          {
            internalType: "uint128",
            name: "endTimestamp",
            type: "uint128"
          },
          {
            internalType: "bool",
            name: "reserved",
            type: "bool"
          },
          {
            internalType: "enum IDirectListings.TokenType",
            name: "tokenType",
            type: "uint8"
          },
          {
            internalType: "enum IDirectListings.Status",
            name: "status",
            type: "uint8"
          }
        ],
        indexed: false,
        internalType: "struct IDirectListings.Listing",
        name: "listing",
        type: "tuple"
      }
    ],
    name: "UpdatedListing",
    type: "event"
  },
  {
    inputs: [
      {
        internalType: "uint256",
        name: "_listingId",
        type: "uint256"
      },
      {
        internalType: "address",
        name: "_buyer",
        type: "address"
      },
      {
        internalType: "bool",
        name: "_toApprove",
        type: "bool"
      }
    ],
    name: "approveBuyerForListing",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "uint256",
        name: "_listingId",
        type: "uint256"
      },
      {
        internalType: "address",
        name: "_currency",
        type: "address"
      },
      {
        internalType: "uint256",
        name: "_pricePerTokenInCurrency",
        type: "uint256"
      }
    ],
    name: "approveCurrencyForListing",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "uint256",
        name: "_listingId",
        type: "uint256"
      },
      {
        internalType: "address",
        name: "_buyFor",
        type: "address"
      },
      {
        internalType: "uint256",
        name: "_quantity",
        type: "uint256"
      },
      {
        internalType: "address",
        name: "_currency",
        type: "address"
      },
      {
        internalType: "uint256",
        name: "_expectedTotalPrice",
        type: "uint256"
      }
    ],
    name: "buyFromListing",
    outputs: [],
    stateMutability: "payable",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "uint256",
        name: "_listingId",
        type: "uint256"
      }
    ],
    name: "cancelListing",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [
      {
        components: [
          {
            internalType: "address",
            name: "assetContract",
            type: "address"
          },
          {
            internalType: "uint256",
            name: "tokenId",
            type: "uint256"
          },
          {
            internalType: "uint256",
            name: "quantity",
            type: "uint256"
          },
          {
            internalType: "address",
            name: "currency",
            type: "address"
          },
          {
            internalType: "uint256",
            name: "pricePerToken",
            type: "uint256"
          },
          {
            internalType: "uint128",
            name: "startTimestamp",
            type: "uint128"
          },
          {
            internalType: "uint128",
            name: "endTimestamp",
            type: "uint128"
          },
          {
            internalType: "bool",
            name: "reserved",
            type: "bool"
          }
        ],
        internalType: "struct IDirectListings.ListingParameters",
        name: "_params",
        type: "tuple"
      }
    ],
    name: "createListing",
    outputs: [
      {
        internalType: "uint256",
        name: "listingId",
        type: "uint256"
      }
    ],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "uint256",
        name: "_startId",
        type: "uint256"
      },
      {
        internalType: "uint256",
        name: "_endId",
        type: "uint256"
      }
    ],
    name: "getAllListings",
    outputs: [
      {
        components: [
          {
            internalType: "uint256",
            name: "listingId",
            type: "uint256"
          },
          {
            internalType: "address",
            name: "listingCreator",
            type: "address"
          },
          {
            internalType: "address",
            name: "assetContract",
            type: "address"
          },
          {
            internalType: "uint256",
            name: "tokenId",
            type: "uint256"
          },
          {
            internalType: "uint256",
            name: "quantity",
            type: "uint256"
          },
          {
            internalType: "address",
            name: "currency",
            type: "address"
          },
          {
            internalType: "uint256",
            name: "pricePerToken",
            type: "uint256"
          },
          {
            internalType: "uint128",
            name: "startTimestamp",
            type: "uint128"
          },
          {
            internalType: "uint128",
            name: "endTimestamp",
            type: "uint128"
          },
          {
            internalType: "bool",
            name: "reserved",
            type: "bool"
          },
          {
            internalType: "enum IDirectListings.TokenType",
            name: "tokenType",
            type: "uint8"
          },
          {
            internalType: "enum IDirectListings.Status",
            name: "status",
            type: "uint8"
          }
        ],
        internalType: "struct IDirectListings.Listing[]",
        name: "listings",
        type: "tuple[]"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "uint256",
        name: "_startId",
        type: "uint256"
      },
      {
        internalType: "uint256",
        name: "_endId",
        type: "uint256"
      }
    ],
    name: "getAllValidListings",
    outputs: [
      {
        components: [
          {
            internalType: "uint256",
            name: "listingId",
            type: "uint256"
          },
          {
            internalType: "address",
            name: "listingCreator",
            type: "address"
          },
          {
            internalType: "address",
            name: "assetContract",
            type: "address"
          },
          {
            internalType: "uint256",
            name: "tokenId",
            type: "uint256"
          },
          {
            internalType: "uint256",
            name: "quantity",
            type: "uint256"
          },
          {
            internalType: "address",
            name: "currency",
            type: "address"
          },
          {
            internalType: "uint256",
            name: "pricePerToken",
            type: "uint256"
          },
          {
            internalType: "uint128",
            name: "startTimestamp",
            type: "uint128"
          },
          {
            internalType: "uint128",
            name: "endTimestamp",
            type: "uint128"
          },
          {
            internalType: "bool",
            name: "reserved",
            type: "bool"
          },
          {
            internalType: "enum IDirectListings.TokenType",
            name: "tokenType",
            type: "uint8"
          },
          {
            internalType: "enum IDirectListings.Status",
            name: "status",
            type: "uint8"
          }
        ],
        internalType: "struct IDirectListings.Listing[]",
        name: "listings",
        type: "tuple[]"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "uint256",
        name: "_listingId",
        type: "uint256"
      }
    ],
    name: "getListing",
    outputs: [
      {
        components: [
          {
            internalType: "uint256",
            name: "listingId",
            type: "uint256"
          },
          {
            internalType: "address",
            name: "listingCreator",
            type: "address"
          },
          {
            internalType: "address",
            name: "assetContract",
            type: "address"
          },
          {
            internalType: "uint256",
            name: "tokenId",
            type: "uint256"
          },
          {
            internalType: "uint256",
            name: "quantity",
            type: "uint256"
          },
          {
            internalType: "address",
            name: "currency",
            type: "address"
          },
          {
            internalType: "uint256",
            name: "pricePerToken",
            type: "uint256"
          },
          {
            internalType: "uint128",
            name: "startTimestamp",
            type: "uint128"
          },
          {
            internalType: "uint128",
            name: "endTimestamp",
            type: "uint128"
          },
          {
            internalType: "bool",
            name: "reserved",
            type: "bool"
          },
          {
            internalType: "enum IDirectListings.TokenType",
            name: "tokenType",
            type: "uint8"
          },
          {
            internalType: "enum IDirectListings.Status",
            name: "status",
            type: "uint8"
          }
        ],
        internalType: "struct IDirectListings.Listing",
        name: "listing",
        type: "tuple"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [],
    name: "totalListings",
    outputs: [
      {
        internalType: "uint256",
        name: "",
        type: "uint256"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "uint256",
        name: "_listingId",
        type: "uint256"
      },
      {
        components: [
          {
            internalType: "address",
            name: "assetContract",
            type: "address"
          },
          {
            internalType: "uint256",
            name: "tokenId",
            type: "uint256"
          },
          {
            internalType: "uint256",
            name: "quantity",
            type: "uint256"
          },
          {
            internalType: "address",
            name: "currency",
            type: "address"
          },
          {
            internalType: "uint256",
            name: "pricePerToken",
            type: "uint256"
          },
          {
            internalType: "uint128",
            name: "startTimestamp",
            type: "uint128"
          },
          {
            internalType: "uint128",
            name: "endTimestamp",
            type: "uint128"
          },
          {
            internalType: "bool",
            name: "reserved",
            type: "bool"
          }
        ],
        internalType: "struct IDirectListings.ListingParameters",
        name: "_params",
        type: "tuple"
      }
    ],
    name: "updateListing",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  }
];

// node_modules/@thirdweb-dev/contracts-js/dist/abis/IEnglishAuctions.json
var IEnglishAuctions_default = [
  {
    anonymous: false,
    inputs: [
      {
        indexed: true,
        internalType: "uint256",
        name: "auctionId",
        type: "uint256"
      },
      {
        indexed: true,
        internalType: "address",
        name: "assetContract",
        type: "address"
      },
      {
        indexed: true,
        internalType: "address",
        name: "closer",
        type: "address"
      },
      {
        indexed: false,
        internalType: "uint256",
        name: "tokenId",
        type: "uint256"
      },
      {
        indexed: false,
        internalType: "address",
        name: "auctionCreator",
        type: "address"
      },
      {
        indexed: false,
        internalType: "address",
        name: "winningBidder",
        type: "address"
      }
    ],
    name: "AuctionClosed",
    type: "event"
  },
  {
    anonymous: false,
    inputs: [
      {
        indexed: true,
        internalType: "address",
        name: "auctionCreator",
        type: "address"
      },
      {
        indexed: true,
        internalType: "uint256",
        name: "auctionId",
        type: "uint256"
      }
    ],
    name: "CancelledAuction",
    type: "event"
  },
  {
    anonymous: false,
    inputs: [
      {
        indexed: true,
        internalType: "address",
        name: "auctionCreator",
        type: "address"
      },
      {
        indexed: true,
        internalType: "uint256",
        name: "auctionId",
        type: "uint256"
      },
      {
        indexed: true,
        internalType: "address",
        name: "assetContract",
        type: "address"
      },
      {
        components: [
          {
            internalType: "uint256",
            name: "auctionId",
            type: "uint256"
          },
          {
            internalType: "address",
            name: "auctionCreator",
            type: "address"
          },
          {
            internalType: "address",
            name: "assetContract",
            type: "address"
          },
          {
            internalType: "uint256",
            name: "tokenId",
            type: "uint256"
          },
          {
            internalType: "uint256",
            name: "quantity",
            type: "uint256"
          },
          {
            internalType: "address",
            name: "currency",
            type: "address"
          },
          {
            internalType: "uint256",
            name: "minimumBidAmount",
            type: "uint256"
          },
          {
            internalType: "uint256",
            name: "buyoutBidAmount",
            type: "uint256"
          },
          {
            internalType: "uint64",
            name: "timeBufferInSeconds",
            type: "uint64"
          },
          {
            internalType: "uint64",
            name: "bidBufferBps",
            type: "uint64"
          },
          {
            internalType: "uint64",
            name: "startTimestamp",
            type: "uint64"
          },
          {
            internalType: "uint64",
            name: "endTimestamp",
            type: "uint64"
          },
          {
            internalType: "enum IEnglishAuctions.TokenType",
            name: "tokenType",
            type: "uint8"
          },
          {
            internalType: "enum IEnglishAuctions.Status",
            name: "status",
            type: "uint8"
          }
        ],
        indexed: false,
        internalType: "struct IEnglishAuctions.Auction",
        name: "auction",
        type: "tuple"
      }
    ],
    name: "NewAuction",
    type: "event"
  },
  {
    anonymous: false,
    inputs: [
      {
        indexed: true,
        internalType: "uint256",
        name: "auctionId",
        type: "uint256"
      },
      {
        indexed: true,
        internalType: "address",
        name: "bidder",
        type: "address"
      },
      {
        indexed: true,
        internalType: "address",
        name: "assetContract",
        type: "address"
      },
      {
        indexed: false,
        internalType: "uint256",
        name: "bidAmount",
        type: "uint256"
      },
      {
        components: [
          {
            internalType: "uint256",
            name: "auctionId",
            type: "uint256"
          },
          {
            internalType: "address",
            name: "auctionCreator",
            type: "address"
          },
          {
            internalType: "address",
            name: "assetContract",
            type: "address"
          },
          {
            internalType: "uint256",
            name: "tokenId",
            type: "uint256"
          },
          {
            internalType: "uint256",
            name: "quantity",
            type: "uint256"
          },
          {
            internalType: "address",
            name: "currency",
            type: "address"
          },
          {
            internalType: "uint256",
            name: "minimumBidAmount",
            type: "uint256"
          },
          {
            internalType: "uint256",
            name: "buyoutBidAmount",
            type: "uint256"
          },
          {
            internalType: "uint64",
            name: "timeBufferInSeconds",
            type: "uint64"
          },
          {
            internalType: "uint64",
            name: "bidBufferBps",
            type: "uint64"
          },
          {
            internalType: "uint64",
            name: "startTimestamp",
            type: "uint64"
          },
          {
            internalType: "uint64",
            name: "endTimestamp",
            type: "uint64"
          },
          {
            internalType: "enum IEnglishAuctions.TokenType",
            name: "tokenType",
            type: "uint8"
          },
          {
            internalType: "enum IEnglishAuctions.Status",
            name: "status",
            type: "uint8"
          }
        ],
        indexed: false,
        internalType: "struct IEnglishAuctions.Auction",
        name: "auction",
        type: "tuple"
      }
    ],
    name: "NewBid",
    type: "event"
  },
  {
    inputs: [
      {
        internalType: "uint256",
        name: "_auctionId",
        type: "uint256"
      },
      {
        internalType: "uint256",
        name: "_bidAmount",
        type: "uint256"
      }
    ],
    name: "bidInAuction",
    outputs: [],
    stateMutability: "payable",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "uint256",
        name: "_auctionId",
        type: "uint256"
      }
    ],
    name: "cancelAuction",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "uint256",
        name: "_auctionId",
        type: "uint256"
      }
    ],
    name: "collectAuctionPayout",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "uint256",
        name: "_auctionId",
        type: "uint256"
      }
    ],
    name: "collectAuctionTokens",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [
      {
        components: [
          {
            internalType: "address",
            name: "assetContract",
            type: "address"
          },
          {
            internalType: "uint256",
            name: "tokenId",
            type: "uint256"
          },
          {
            internalType: "uint256",
            name: "quantity",
            type: "uint256"
          },
          {
            internalType: "address",
            name: "currency",
            type: "address"
          },
          {
            internalType: "uint256",
            name: "minimumBidAmount",
            type: "uint256"
          },
          {
            internalType: "uint256",
            name: "buyoutBidAmount",
            type: "uint256"
          },
          {
            internalType: "uint64",
            name: "timeBufferInSeconds",
            type: "uint64"
          },
          {
            internalType: "uint64",
            name: "bidBufferBps",
            type: "uint64"
          },
          {
            internalType: "uint64",
            name: "startTimestamp",
            type: "uint64"
          },
          {
            internalType: "uint64",
            name: "endTimestamp",
            type: "uint64"
          }
        ],
        internalType: "struct IEnglishAuctions.AuctionParameters",
        name: "_params",
        type: "tuple"
      }
    ],
    name: "createAuction",
    outputs: [
      {
        internalType: "uint256",
        name: "auctionId",
        type: "uint256"
      }
    ],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "uint256",
        name: "_startId",
        type: "uint256"
      },
      {
        internalType: "uint256",
        name: "_endId",
        type: "uint256"
      }
    ],
    name: "getAllAuctions",
    outputs: [
      {
        components: [
          {
            internalType: "uint256",
            name: "auctionId",
            type: "uint256"
          },
          {
            internalType: "address",
            name: "auctionCreator",
            type: "address"
          },
          {
            internalType: "address",
            name: "assetContract",
            type: "address"
          },
          {
            internalType: "uint256",
            name: "tokenId",
            type: "uint256"
          },
          {
            internalType: "uint256",
            name: "quantity",
            type: "uint256"
          },
          {
            internalType: "address",
            name: "currency",
            type: "address"
          },
          {
            internalType: "uint256",
            name: "minimumBidAmount",
            type: "uint256"
          },
          {
            internalType: "uint256",
            name: "buyoutBidAmount",
            type: "uint256"
          },
          {
            internalType: "uint64",
            name: "timeBufferInSeconds",
            type: "uint64"
          },
          {
            internalType: "uint64",
            name: "bidBufferBps",
            type: "uint64"
          },
          {
            internalType: "uint64",
            name: "startTimestamp",
            type: "uint64"
          },
          {
            internalType: "uint64",
            name: "endTimestamp",
            type: "uint64"
          },
          {
            internalType: "enum IEnglishAuctions.TokenType",
            name: "tokenType",
            type: "uint8"
          },
          {
            internalType: "enum IEnglishAuctions.Status",
            name: "status",
            type: "uint8"
          }
        ],
        internalType: "struct IEnglishAuctions.Auction[]",
        name: "auctions",
        type: "tuple[]"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "uint256",
        name: "_startId",
        type: "uint256"
      },
      {
        internalType: "uint256",
        name: "_endId",
        type: "uint256"
      }
    ],
    name: "getAllValidAuctions",
    outputs: [
      {
        components: [
          {
            internalType: "uint256",
            name: "auctionId",
            type: "uint256"
          },
          {
            internalType: "address",
            name: "auctionCreator",
            type: "address"
          },
          {
            internalType: "address",
            name: "assetContract",
            type: "address"
          },
          {
            internalType: "uint256",
            name: "tokenId",
            type: "uint256"
          },
          {
            internalType: "uint256",
            name: "quantity",
            type: "uint256"
          },
          {
            internalType: "address",
            name: "currency",
            type: "address"
          },
          {
            internalType: "uint256",
            name: "minimumBidAmount",
            type: "uint256"
          },
          {
            internalType: "uint256",
            name: "buyoutBidAmount",
            type: "uint256"
          },
          {
            internalType: "uint64",
            name: "timeBufferInSeconds",
            type: "uint64"
          },
          {
            internalType: "uint64",
            name: "bidBufferBps",
            type: "uint64"
          },
          {
            internalType: "uint64",
            name: "startTimestamp",
            type: "uint64"
          },
          {
            internalType: "uint64",
            name: "endTimestamp",
            type: "uint64"
          },
          {
            internalType: "enum IEnglishAuctions.TokenType",
            name: "tokenType",
            type: "uint8"
          },
          {
            internalType: "enum IEnglishAuctions.Status",
            name: "status",
            type: "uint8"
          }
        ],
        internalType: "struct IEnglishAuctions.Auction[]",
        name: "auctions",
        type: "tuple[]"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "uint256",
        name: "_auctionId",
        type: "uint256"
      }
    ],
    name: "getAuction",
    outputs: [
      {
        components: [
          {
            internalType: "uint256",
            name: "auctionId",
            type: "uint256"
          },
          {
            internalType: "address",
            name: "auctionCreator",
            type: "address"
          },
          {
            internalType: "address",
            name: "assetContract",
            type: "address"
          },
          {
            internalType: "uint256",
            name: "tokenId",
            type: "uint256"
          },
          {
            internalType: "uint256",
            name: "quantity",
            type: "uint256"
          },
          {
            internalType: "address",
            name: "currency",
            type: "address"
          },
          {
            internalType: "uint256",
            name: "minimumBidAmount",
            type: "uint256"
          },
          {
            internalType: "uint256",
            name: "buyoutBidAmount",
            type: "uint256"
          },
          {
            internalType: "uint64",
            name: "timeBufferInSeconds",
            type: "uint64"
          },
          {
            internalType: "uint64",
            name: "bidBufferBps",
            type: "uint64"
          },
          {
            internalType: "uint64",
            name: "startTimestamp",
            type: "uint64"
          },
          {
            internalType: "uint64",
            name: "endTimestamp",
            type: "uint64"
          },
          {
            internalType: "enum IEnglishAuctions.TokenType",
            name: "tokenType",
            type: "uint8"
          },
          {
            internalType: "enum IEnglishAuctions.Status",
            name: "status",
            type: "uint8"
          }
        ],
        internalType: "struct IEnglishAuctions.Auction",
        name: "auction",
        type: "tuple"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "uint256",
        name: "_auctionId",
        type: "uint256"
      }
    ],
    name: "getWinningBid",
    outputs: [
      {
        internalType: "address",
        name: "bidder",
        type: "address"
      },
      {
        internalType: "address",
        name: "currency",
        type: "address"
      },
      {
        internalType: "uint256",
        name: "bidAmount",
        type: "uint256"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "uint256",
        name: "_auctionId",
        type: "uint256"
      }
    ],
    name: "isAuctionExpired",
    outputs: [
      {
        internalType: "bool",
        name: "",
        type: "bool"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "uint256",
        name: "_auctionId",
        type: "uint256"
      },
      {
        internalType: "uint256",
        name: "_bidAmount",
        type: "uint256"
      }
    ],
    name: "isNewWinningBid",
    outputs: [
      {
        internalType: "bool",
        name: "",
        type: "bool"
      }
    ],
    stateMutability: "view",
    type: "function"
  }
];

// node_modules/@thirdweb-dev/contracts-js/dist/abis/IOffers.json
var IOffers_default = [
  {
    anonymous: false,
    inputs: [
      {
        indexed: true,
        internalType: "address",
        name: "offeror",
        type: "address"
      },
      {
        indexed: true,
        internalType: "uint256",
        name: "offerId",
        type: "uint256"
      },
      {
        indexed: true,
        internalType: "address",
        name: "assetContract",
        type: "address"
      },
      {
        indexed: false,
        internalType: "uint256",
        name: "tokenId",
        type: "uint256"
      },
      {
        indexed: false,
        internalType: "address",
        name: "seller",
        type: "address"
      },
      {
        indexed: false,
        internalType: "uint256",
        name: "quantityBought",
        type: "uint256"
      },
      {
        indexed: false,
        internalType: "uint256",
        name: "totalPricePaid",
        type: "uint256"
      }
    ],
    name: "AcceptedOffer",
    type: "event"
  },
  {
    anonymous: false,
    inputs: [
      {
        indexed: true,
        internalType: "address",
        name: "offeror",
        type: "address"
      },
      {
        indexed: true,
        internalType: "uint256",
        name: "offerId",
        type: "uint256"
      }
    ],
    name: "CancelledOffer",
    type: "event"
  },
  {
    anonymous: false,
    inputs: [
      {
        indexed: true,
        internalType: "address",
        name: "offeror",
        type: "address"
      },
      {
        indexed: true,
        internalType: "uint256",
        name: "offerId",
        type: "uint256"
      },
      {
        indexed: true,
        internalType: "address",
        name: "assetContract",
        type: "address"
      },
      {
        components: [
          {
            internalType: "uint256",
            name: "offerId",
            type: "uint256"
          },
          {
            internalType: "address",
            name: "offeror",
            type: "address"
          },
          {
            internalType: "address",
            name: "assetContract",
            type: "address"
          },
          {
            internalType: "uint256",
            name: "tokenId",
            type: "uint256"
          },
          {
            internalType: "uint256",
            name: "quantity",
            type: "uint256"
          },
          {
            internalType: "address",
            name: "currency",
            type: "address"
          },
          {
            internalType: "uint256",
            name: "totalPrice",
            type: "uint256"
          },
          {
            internalType: "uint256",
            name: "expirationTimestamp",
            type: "uint256"
          },
          {
            internalType: "enum IOffers.TokenType",
            name: "tokenType",
            type: "uint8"
          },
          {
            internalType: "enum IOffers.Status",
            name: "status",
            type: "uint8"
          }
        ],
        indexed: false,
        internalType: "struct IOffers.Offer",
        name: "offer",
        type: "tuple"
      }
    ],
    name: "NewOffer",
    type: "event"
  },
  {
    inputs: [
      {
        internalType: "uint256",
        name: "_offerId",
        type: "uint256"
      }
    ],
    name: "acceptOffer",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "uint256",
        name: "_offerId",
        type: "uint256"
      }
    ],
    name: "cancelOffer",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "uint256",
        name: "_startId",
        type: "uint256"
      },
      {
        internalType: "uint256",
        name: "_endId",
        type: "uint256"
      }
    ],
    name: "getAllOffers",
    outputs: [
      {
        components: [
          {
            internalType: "uint256",
            name: "offerId",
            type: "uint256"
          },
          {
            internalType: "address",
            name: "offeror",
            type: "address"
          },
          {
            internalType: "address",
            name: "assetContract",
            type: "address"
          },
          {
            internalType: "uint256",
            name: "tokenId",
            type: "uint256"
          },
          {
            internalType: "uint256",
            name: "quantity",
            type: "uint256"
          },
          {
            internalType: "address",
            name: "currency",
            type: "address"
          },
          {
            internalType: "uint256",
            name: "totalPrice",
            type: "uint256"
          },
          {
            internalType: "uint256",
            name: "expirationTimestamp",
            type: "uint256"
          },
          {
            internalType: "enum IOffers.TokenType",
            name: "tokenType",
            type: "uint8"
          },
          {
            internalType: "enum IOffers.Status",
            name: "status",
            type: "uint8"
          }
        ],
        internalType: "struct IOffers.Offer[]",
        name: "offers",
        type: "tuple[]"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "uint256",
        name: "_startId",
        type: "uint256"
      },
      {
        internalType: "uint256",
        name: "_endId",
        type: "uint256"
      }
    ],
    name: "getAllValidOffers",
    outputs: [
      {
        components: [
          {
            internalType: "uint256",
            name: "offerId",
            type: "uint256"
          },
          {
            internalType: "address",
            name: "offeror",
            type: "address"
          },
          {
            internalType: "address",
            name: "assetContract",
            type: "address"
          },
          {
            internalType: "uint256",
            name: "tokenId",
            type: "uint256"
          },
          {
            internalType: "uint256",
            name: "quantity",
            type: "uint256"
          },
          {
            internalType: "address",
            name: "currency",
            type: "address"
          },
          {
            internalType: "uint256",
            name: "totalPrice",
            type: "uint256"
          },
          {
            internalType: "uint256",
            name: "expirationTimestamp",
            type: "uint256"
          },
          {
            internalType: "enum IOffers.TokenType",
            name: "tokenType",
            type: "uint8"
          },
          {
            internalType: "enum IOffers.Status",
            name: "status",
            type: "uint8"
          }
        ],
        internalType: "struct IOffers.Offer[]",
        name: "offers",
        type: "tuple[]"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "uint256",
        name: "_offerId",
        type: "uint256"
      }
    ],
    name: "getOffer",
    outputs: [
      {
        components: [
          {
            internalType: "uint256",
            name: "offerId",
            type: "uint256"
          },
          {
            internalType: "address",
            name: "offeror",
            type: "address"
          },
          {
            internalType: "address",
            name: "assetContract",
            type: "address"
          },
          {
            internalType: "uint256",
            name: "tokenId",
            type: "uint256"
          },
          {
            internalType: "uint256",
            name: "quantity",
            type: "uint256"
          },
          {
            internalType: "address",
            name: "currency",
            type: "address"
          },
          {
            internalType: "uint256",
            name: "totalPrice",
            type: "uint256"
          },
          {
            internalType: "uint256",
            name: "expirationTimestamp",
            type: "uint256"
          },
          {
            internalType: "enum IOffers.TokenType",
            name: "tokenType",
            type: "uint8"
          },
          {
            internalType: "enum IOffers.Status",
            name: "status",
            type: "uint8"
          }
        ],
        internalType: "struct IOffers.Offer",
        name: "offer",
        type: "tuple"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [
      {
        components: [
          {
            internalType: "address",
            name: "assetContract",
            type: "address"
          },
          {
            internalType: "uint256",
            name: "tokenId",
            type: "uint256"
          },
          {
            internalType: "uint256",
            name: "quantity",
            type: "uint256"
          },
          {
            internalType: "address",
            name: "currency",
            type: "address"
          },
          {
            internalType: "uint256",
            name: "totalPrice",
            type: "uint256"
          },
          {
            internalType: "uint256",
            name: "expirationTimestamp",
            type: "uint256"
          }
        ],
        internalType: "struct IOffers.OfferParams",
        name: "_params",
        type: "tuple"
      }
    ],
    name: "makeOffer",
    outputs: [
      {
        internalType: "uint256",
        name: "offerId",
        type: "uint256"
      }
    ],
    stateMutability: "nonpayable",
    type: "function"
  }
];

// node_modules/@thirdweb-dev/contracts-js/dist/abis/IPackVRFDirect.json
var IPackVRFDirect_default = [
  {
    anonymous: false,
    inputs: [
      {
        indexed: true,
        internalType: "uint256",
        name: "packId",
        type: "uint256"
      },
      {
        indexed: false,
        internalType: "address",
        name: "recipient",
        type: "address"
      },
      {
        indexed: false,
        internalType: "uint256",
        name: "totalPacksCreated",
        type: "uint256"
      }
    ],
    name: "PackCreated",
    type: "event"
  },
  {
    anonymous: false,
    inputs: [
      {
        indexed: true,
        internalType: "address",
        name: "opener",
        type: "address"
      },
      {
        indexed: true,
        internalType: "uint256",
        name: "packId",
        type: "uint256"
      },
      {
        indexed: false,
        internalType: "uint256",
        name: "amountToOpen",
        type: "uint256"
      },
      {
        indexed: false,
        internalType: "uint256",
        name: "requestId",
        type: "uint256"
      }
    ],
    name: "PackOpenRequested",
    type: "event"
  },
  {
    anonymous: false,
    inputs: [
      {
        indexed: true,
        internalType: "uint256",
        name: "packId",
        type: "uint256"
      },
      {
        indexed: true,
        internalType: "address",
        name: "opener",
        type: "address"
      },
      {
        indexed: false,
        internalType: "uint256",
        name: "numOfPacksOpened",
        type: "uint256"
      },
      {
        components: [
          {
            internalType: "address",
            name: "assetContract",
            type: "address"
          },
          {
            internalType: "enum ITokenBundle.TokenType",
            name: "tokenType",
            type: "uint8"
          },
          {
            internalType: "uint256",
            name: "tokenId",
            type: "uint256"
          },
          {
            internalType: "uint256",
            name: "totalAmount",
            type: "uint256"
          }
        ],
        indexed: false,
        internalType: "struct ITokenBundle.Token[]",
        name: "rewardUnitsDistributed",
        type: "tuple[]"
      }
    ],
    name: "PackOpened",
    type: "event"
  },
  {
    anonymous: false,
    inputs: [
      {
        indexed: true,
        internalType: "uint256",
        name: "packId",
        type: "uint256"
      },
      {
        indexed: true,
        internalType: "uint256",
        name: "requestId",
        type: "uint256"
      }
    ],
    name: "PackRandomnessFulfilled",
    type: "event"
  },
  {
    inputs: [
      {
        internalType: "address",
        name: "_opener",
        type: "address"
      }
    ],
    name: "canClaimRewards",
    outputs: [
      {
        internalType: "bool",
        name: "",
        type: "bool"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [],
    name: "claimRewards",
    outputs: [
      {
        components: [
          {
            internalType: "address",
            name: "assetContract",
            type: "address"
          },
          {
            internalType: "enum ITokenBundle.TokenType",
            name: "tokenType",
            type: "uint8"
          },
          {
            internalType: "uint256",
            name: "tokenId",
            type: "uint256"
          },
          {
            internalType: "uint256",
            name: "totalAmount",
            type: "uint256"
          }
        ],
        internalType: "struct ITokenBundle.Token[]",
        name: "rewardUnits",
        type: "tuple[]"
      }
    ],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [
      {
        components: [
          {
            internalType: "address",
            name: "assetContract",
            type: "address"
          },
          {
            internalType: "enum ITokenBundle.TokenType",
            name: "tokenType",
            type: "uint8"
          },
          {
            internalType: "uint256",
            name: "tokenId",
            type: "uint256"
          },
          {
            internalType: "uint256",
            name: "totalAmount",
            type: "uint256"
          }
        ],
        internalType: "struct ITokenBundle.Token[]",
        name: "contents",
        type: "tuple[]"
      },
      {
        internalType: "uint256[]",
        name: "numOfRewardUnits",
        type: "uint256[]"
      },
      {
        internalType: "string",
        name: "packUri",
        type: "string"
      },
      {
        internalType: "uint128",
        name: "openStartTimestamp",
        type: "uint128"
      },
      {
        internalType: "uint128",
        name: "amountDistributedPerOpen",
        type: "uint128"
      },
      {
        internalType: "address",
        name: "recipient",
        type: "address"
      }
    ],
    name: "createPack",
    outputs: [
      {
        internalType: "uint256",
        name: "packId",
        type: "uint256"
      },
      {
        internalType: "uint256",
        name: "packTotalSupply",
        type: "uint256"
      }
    ],
    stateMutability: "payable",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "uint256",
        name: "packId",
        type: "uint256"
      },
      {
        internalType: "uint256",
        name: "amountToOpen",
        type: "uint256"
      }
    ],
    name: "openPack",
    outputs: [
      {
        internalType: "uint256",
        name: "requestId",
        type: "uint256"
      }
    ],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "uint256",
        name: "_packId",
        type: "uint256"
      },
      {
        internalType: "uint256",
        name: "_amountToOpen",
        type: "uint256"
      },
      {
        internalType: "uint32",
        name: "_callBackGasLimit",
        type: "uint32"
      }
    ],
    name: "openPackAndClaimRewards",
    outputs: [
      {
        internalType: "uint256",
        name: "",
        type: "uint256"
      }
    ],
    stateMutability: "nonpayable",
    type: "function"
  }
];

// node_modules/@thirdweb-dev/contracts-js/dist/abis/IPermissions.json
var IPermissions_default = [
  {
    anonymous: false,
    inputs: [
      {
        indexed: true,
        internalType: "bytes32",
        name: "role",
        type: "bytes32"
      },
      {
        indexed: true,
        internalType: "bytes32",
        name: "previousAdminRole",
        type: "bytes32"
      },
      {
        indexed: true,
        internalType: "bytes32",
        name: "newAdminRole",
        type: "bytes32"
      }
    ],
    name: "RoleAdminChanged",
    type: "event"
  },
  {
    anonymous: false,
    inputs: [
      {
        indexed: true,
        internalType: "bytes32",
        name: "role",
        type: "bytes32"
      },
      {
        indexed: true,
        internalType: "address",
        name: "account",
        type: "address"
      },
      {
        indexed: true,
        internalType: "address",
        name: "sender",
        type: "address"
      }
    ],
    name: "RoleGranted",
    type: "event"
  },
  {
    anonymous: false,
    inputs: [
      {
        indexed: true,
        internalType: "bytes32",
        name: "role",
        type: "bytes32"
      },
      {
        indexed: true,
        internalType: "address",
        name: "account",
        type: "address"
      },
      {
        indexed: true,
        internalType: "address",
        name: "sender",
        type: "address"
      }
    ],
    name: "RoleRevoked",
    type: "event"
  },
  {
    inputs: [
      {
        internalType: "bytes32",
        name: "role",
        type: "bytes32"
      }
    ],
    name: "getRoleAdmin",
    outputs: [
      {
        internalType: "bytes32",
        name: "",
        type: "bytes32"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "bytes32",
        name: "role",
        type: "bytes32"
      },
      {
        internalType: "address",
        name: "account",
        type: "address"
      }
    ],
    name: "grantRole",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "bytes32",
        name: "role",
        type: "bytes32"
      },
      {
        internalType: "address",
        name: "account",
        type: "address"
      }
    ],
    name: "hasRole",
    outputs: [
      {
        internalType: "bool",
        name: "",
        type: "bool"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "bytes32",
        name: "role",
        type: "bytes32"
      },
      {
        internalType: "address",
        name: "account",
        type: "address"
      }
    ],
    name: "renounceRole",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "bytes32",
        name: "role",
        type: "bytes32"
      },
      {
        internalType: "address",
        name: "account",
        type: "address"
      }
    ],
    name: "revokeRole",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  }
];

// node_modules/@thirdweb-dev/contracts-js/dist/abis/IPermissionsEnumerable.json
var IPermissionsEnumerable_default = [
  {
    anonymous: false,
    inputs: [
      {
        indexed: true,
        internalType: "bytes32",
        name: "role",
        type: "bytes32"
      },
      {
        indexed: true,
        internalType: "bytes32",
        name: "previousAdminRole",
        type: "bytes32"
      },
      {
        indexed: true,
        internalType: "bytes32",
        name: "newAdminRole",
        type: "bytes32"
      }
    ],
    name: "RoleAdminChanged",
    type: "event"
  },
  {
    anonymous: false,
    inputs: [
      {
        indexed: true,
        internalType: "bytes32",
        name: "role",
        type: "bytes32"
      },
      {
        indexed: true,
        internalType: "address",
        name: "account",
        type: "address"
      },
      {
        indexed: true,
        internalType: "address",
        name: "sender",
        type: "address"
      }
    ],
    name: "RoleGranted",
    type: "event"
  },
  {
    anonymous: false,
    inputs: [
      {
        indexed: true,
        internalType: "bytes32",
        name: "role",
        type: "bytes32"
      },
      {
        indexed: true,
        internalType: "address",
        name: "account",
        type: "address"
      },
      {
        indexed: true,
        internalType: "address",
        name: "sender",
        type: "address"
      }
    ],
    name: "RoleRevoked",
    type: "event"
  },
  {
    inputs: [
      {
        internalType: "bytes32",
        name: "role",
        type: "bytes32"
      }
    ],
    name: "getRoleAdmin",
    outputs: [
      {
        internalType: "bytes32",
        name: "",
        type: "bytes32"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "bytes32",
        name: "role",
        type: "bytes32"
      },
      {
        internalType: "uint256",
        name: "index",
        type: "uint256"
      }
    ],
    name: "getRoleMember",
    outputs: [
      {
        internalType: "address",
        name: "",
        type: "address"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "bytes32",
        name: "role",
        type: "bytes32"
      }
    ],
    name: "getRoleMemberCount",
    outputs: [
      {
        internalType: "uint256",
        name: "",
        type: "uint256"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "bytes32",
        name: "role",
        type: "bytes32"
      },
      {
        internalType: "address",
        name: "account",
        type: "address"
      }
    ],
    name: "grantRole",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "bytes32",
        name: "role",
        type: "bytes32"
      },
      {
        internalType: "address",
        name: "account",
        type: "address"
      }
    ],
    name: "hasRole",
    outputs: [
      {
        internalType: "bool",
        name: "",
        type: "bool"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "bytes32",
        name: "role",
        type: "bytes32"
      },
      {
        internalType: "address",
        name: "account",
        type: "address"
      }
    ],
    name: "renounceRole",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "bytes32",
        name: "role",
        type: "bytes32"
      },
      {
        internalType: "address",
        name: "account",
        type: "address"
      }
    ],
    name: "revokeRole",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  }
];

// node_modules/@thirdweb-dev/contracts-js/dist/abis/IPlatformFee.json
var IPlatformFee_default = [
  {
    anonymous: false,
    inputs: [
      {
        indexed: false,
        internalType: "address",
        name: "platformFeeRecipient",
        type: "address"
      },
      {
        indexed: false,
        internalType: "uint256",
        name: "flatFee",
        type: "uint256"
      }
    ],
    name: "FlatPlatformFeeUpdated",
    type: "event"
  },
  {
    anonymous: false,
    inputs: [
      {
        indexed: true,
        internalType: "address",
        name: "platformFeeRecipient",
        type: "address"
      },
      {
        indexed: false,
        internalType: "uint256",
        name: "platformFeeBps",
        type: "uint256"
      }
    ],
    name: "PlatformFeeInfoUpdated",
    type: "event"
  },
  {
    anonymous: false,
    inputs: [
      {
        indexed: false,
        internalType: "enum IPlatformFee.PlatformFeeType",
        name: "feeType",
        type: "uint8"
      }
    ],
    name: "PlatformFeeTypeUpdated",
    type: "event"
  },
  {
    inputs: [],
    name: "getPlatformFeeInfo",
    outputs: [
      {
        internalType: "address",
        name: "",
        type: "address"
      },
      {
        internalType: "uint16",
        name: "",
        type: "uint16"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "address",
        name: "_platformFeeRecipient",
        type: "address"
      },
      {
        internalType: "uint256",
        name: "_platformFeeBps",
        type: "uint256"
      }
    ],
    name: "setPlatformFeeInfo",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  }
];

// node_modules/@thirdweb-dev/contracts-js/dist/abis/IPrimarySale.json
var IPrimarySale_default = [
  {
    anonymous: false,
    inputs: [
      {
        indexed: true,
        internalType: "address",
        name: "recipient",
        type: "address"
      }
    ],
    name: "PrimarySaleRecipientUpdated",
    type: "event"
  },
  {
    inputs: [],
    name: "primarySaleRecipient",
    outputs: [
      {
        internalType: "address",
        name: "",
        type: "address"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "address",
        name: "_saleRecipient",
        type: "address"
      }
    ],
    name: "setPrimarySaleRecipient",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  }
];

// node_modules/@thirdweb-dev/contracts-js/dist/abis/IRoyalty.json
var IRoyalty_default = [
  {
    anonymous: false,
    inputs: [
      {
        indexed: true,
        internalType: "address",
        name: "newRoyaltyRecipient",
        type: "address"
      },
      {
        indexed: false,
        internalType: "uint256",
        name: "newRoyaltyBps",
        type: "uint256"
      }
    ],
    name: "DefaultRoyalty",
    type: "event"
  },
  {
    anonymous: false,
    inputs: [
      {
        indexed: true,
        internalType: "uint256",
        name: "tokenId",
        type: "uint256"
      },
      {
        indexed: true,
        internalType: "address",
        name: "royaltyRecipient",
        type: "address"
      },
      {
        indexed: false,
        internalType: "uint256",
        name: "royaltyBps",
        type: "uint256"
      }
    ],
    name: "RoyaltyForToken",
    type: "event"
  },
  {
    inputs: [],
    name: "getDefaultRoyaltyInfo",
    outputs: [
      {
        internalType: "address",
        name: "",
        type: "address"
      },
      {
        internalType: "uint16",
        name: "",
        type: "uint16"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "uint256",
        name: "tokenId",
        type: "uint256"
      }
    ],
    name: "getRoyaltyInfoForToken",
    outputs: [
      {
        internalType: "address",
        name: "",
        type: "address"
      },
      {
        internalType: "uint16",
        name: "",
        type: "uint16"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "uint256",
        name: "tokenId",
        type: "uint256"
      },
      {
        internalType: "uint256",
        name: "salePrice",
        type: "uint256"
      }
    ],
    name: "royaltyInfo",
    outputs: [
      {
        internalType: "address",
        name: "receiver",
        type: "address"
      },
      {
        internalType: "uint256",
        name: "royaltyAmount",
        type: "uint256"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "address",
        name: "_royaltyRecipient",
        type: "address"
      },
      {
        internalType: "uint256",
        name: "_royaltyBps",
        type: "uint256"
      }
    ],
    name: "setDefaultRoyaltyInfo",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "uint256",
        name: "tokenId",
        type: "uint256"
      },
      {
        internalType: "address",
        name: "recipient",
        type: "address"
      },
      {
        internalType: "uint256",
        name: "bps",
        type: "uint256"
      }
    ],
    name: "setRoyaltyInfoForToken",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "bytes4",
        name: "interfaceId",
        type: "bytes4"
      }
    ],
    name: "supportsInterface",
    outputs: [
      {
        internalType: "bool",
        name: "",
        type: "bool"
      }
    ],
    stateMutability: "view",
    type: "function"
  }
];

// node_modules/@thirdweb-dev/contracts-js/dist/abis/Ownable.json
var Ownable_default = [
  {
    anonymous: false,
    inputs: [
      {
        indexed: true,
        internalType: "address",
        name: "prevOwner",
        type: "address"
      },
      {
        indexed: true,
        internalType: "address",
        name: "newOwner",
        type: "address"
      }
    ],
    name: "OwnerUpdated",
    type: "event"
  },
  {
    inputs: [],
    name: "owner",
    outputs: [
      {
        internalType: "address",
        name: "",
        type: "address"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "address",
        name: "_newOwner",
        type: "address"
      }
    ],
    name: "setOwner",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  }
];

// node_modules/@thirdweb-dev/contracts-js/dist/abis/IAirdropERC20.json
var IAirdropERC20_default = [
  {
    anonymous: false,
    inputs: [
      {
        indexed: true,
        internalType: "address",
        name: "tokenAddress",
        type: "address"
      },
      {
        indexed: true,
        internalType: "address",
        name: "tokenOwner",
        type: "address"
      },
      {
        indexed: true,
        internalType: "address",
        name: "recipient",
        type: "address"
      },
      {
        indexed: false,
        internalType: "uint256",
        name: "amount",
        type: "uint256"
      }
    ],
    name: "AirdropFailed",
    type: "event"
  },
  {
    inputs: [
      {
        internalType: "address",
        name: "tokenAddress",
        type: "address"
      },
      {
        internalType: "address",
        name: "tokenOwner",
        type: "address"
      },
      {
        components: [
          {
            internalType: "address",
            name: "recipient",
            type: "address"
          },
          {
            internalType: "uint256",
            name: "amount",
            type: "uint256"
          }
        ],
        internalType: "struct IAirdropERC20.AirdropContent[]",
        name: "contents",
        type: "tuple[]"
      }
    ],
    name: "airdropERC20",
    outputs: [],
    stateMutability: "payable",
    type: "function"
  }
];

// node_modules/@thirdweb-dev/contracts-js/dist/abis/IAirdropERC721.json
var IAirdropERC721_default = [
  {
    anonymous: false,
    inputs: [
      {
        indexed: true,
        internalType: "address",
        name: "tokenAddress",
        type: "address"
      },
      {
        indexed: true,
        internalType: "address",
        name: "tokenOwner",
        type: "address"
      },
      {
        indexed: true,
        internalType: "address",
        name: "recipient",
        type: "address"
      },
      {
        indexed: false,
        internalType: "uint256",
        name: "tokenId",
        type: "uint256"
      }
    ],
    name: "AirdropFailed",
    type: "event"
  },
  {
    inputs: [
      {
        internalType: "address",
        name: "tokenAddress",
        type: "address"
      },
      {
        internalType: "address",
        name: "tokenOwner",
        type: "address"
      },
      {
        components: [
          {
            internalType: "address",
            name: "recipient",
            type: "address"
          },
          {
            internalType: "uint256",
            name: "tokenId",
            type: "uint256"
          }
        ],
        internalType: "struct IAirdropERC721.AirdropContent[]",
        name: "contents",
        type: "tuple[]"
      }
    ],
    name: "airdropERC721",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  }
];

// node_modules/@thirdweb-dev/contracts-js/dist/abis/IAirdropERC1155.json
var IAirdropERC1155_default = [
  {
    anonymous: false,
    inputs: [
      {
        indexed: true,
        internalType: "address",
        name: "tokenAddress",
        type: "address"
      },
      {
        indexed: true,
        internalType: "address",
        name: "tokenOwner",
        type: "address"
      },
      {
        indexed: true,
        internalType: "address",
        name: "recipient",
        type: "address"
      },
      {
        indexed: false,
        internalType: "uint256",
        name: "tokenId",
        type: "uint256"
      },
      {
        indexed: false,
        internalType: "uint256",
        name: "amount",
        type: "uint256"
      }
    ],
    name: "AirdropFailed",
    type: "event"
  },
  {
    inputs: [
      {
        internalType: "address",
        name: "tokenAddress",
        type: "address"
      },
      {
        internalType: "address",
        name: "tokenOwner",
        type: "address"
      },
      {
        components: [
          {
            internalType: "address",
            name: "recipient",
            type: "address"
          },
          {
            internalType: "uint256",
            name: "tokenId",
            type: "uint256"
          },
          {
            internalType: "uint256",
            name: "amount",
            type: "uint256"
          }
        ],
        internalType: "struct IAirdropERC1155.AirdropContent[]",
        name: "contents",
        type: "tuple[]"
      }
    ],
    name: "airdropERC1155",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  }
];

// node_modules/@thirdweb-dev/contracts-js/dist/abis/IAccountFactoryCore.json
var IAccountFactoryCore_default = [
  {
    anonymous: false,
    inputs: [
      {
        indexed: true,
        internalType: "address",
        name: "account",
        type: "address"
      },
      {
        indexed: true,
        internalType: "address",
        name: "accountAdmin",
        type: "address"
      }
    ],
    name: "AccountCreated",
    type: "event"
  },
  {
    anonymous: false,
    inputs: [
      {
        indexed: true,
        internalType: "address",
        name: "account",
        type: "address"
      },
      {
        indexed: true,
        internalType: "address",
        name: "signer",
        type: "address"
      }
    ],
    name: "SignerAdded",
    type: "event"
  },
  {
    anonymous: false,
    inputs: [
      {
        indexed: true,
        internalType: "address",
        name: "account",
        type: "address"
      },
      {
        indexed: true,
        internalType: "address",
        name: "signer",
        type: "address"
      }
    ],
    name: "SignerRemoved",
    type: "event"
  },
  {
    inputs: [],
    name: "accountImplementation",
    outputs: [
      {
        internalType: "address",
        name: "",
        type: "address"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "address",
        name: "admin",
        type: "address"
      },
      {
        internalType: "bytes",
        name: "_data",
        type: "bytes"
      }
    ],
    name: "createAccount",
    outputs: [
      {
        internalType: "address",
        name: "account",
        type: "address"
      }
    ],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "address",
        name: "signer",
        type: "address"
      }
    ],
    name: "getAccountsOfSigner",
    outputs: [
      {
        internalType: "address[]",
        name: "accounts",
        type: "address[]"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "address",
        name: "adminSigner",
        type: "address"
      },
      {
        internalType: "bytes",
        name: "data",
        type: "bytes"
      }
    ],
    name: "getAddress",
    outputs: [
      {
        internalType: "address",
        name: "",
        type: "address"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [],
    name: "getAllAccounts",
    outputs: [
      {
        internalType: "address[]",
        name: "",
        type: "address[]"
      }
    ],
    stateMutability: "view",
    type: "function"
  }
];

// node_modules/@thirdweb-dev/contracts-js/dist/abis/IAccountPermissions.json
var IAccountPermissions_default = [
  {
    anonymous: false,
    inputs: [
      {
        indexed: true,
        internalType: "address",
        name: "signer",
        type: "address"
      },
      {
        indexed: false,
        internalType: "bool",
        name: "isAdmin",
        type: "bool"
      }
    ],
    name: "AdminUpdated",
    type: "event"
  },
  {
    anonymous: false,
    inputs: [
      {
        indexed: true,
        internalType: "address",
        name: "authorizingSigner",
        type: "address"
      },
      {
        indexed: true,
        internalType: "address",
        name: "targetSigner",
        type: "address"
      },
      {
        components: [
          {
            internalType: "address",
            name: "signer",
            type: "address"
          },
          {
            internalType: "address[]",
            name: "approvedTargets",
            type: "address[]"
          },
          {
            internalType: "uint256",
            name: "nativeTokenLimitPerTransaction",
            type: "uint256"
          },
          {
            internalType: "uint128",
            name: "permissionStartTimestamp",
            type: "uint128"
          },
          {
            internalType: "uint128",
            name: "permissionEndTimestamp",
            type: "uint128"
          },
          {
            internalType: "uint128",
            name: "reqValidityStartTimestamp",
            type: "uint128"
          },
          {
            internalType: "uint128",
            name: "reqValidityEndTimestamp",
            type: "uint128"
          },
          {
            internalType: "bytes32",
            name: "uid",
            type: "bytes32"
          }
        ],
        indexed: false,
        internalType: "struct IAccountPermissions.SignerPermissionRequest",
        name: "permissions",
        type: "tuple"
      }
    ],
    name: "SignerPermissionsUpdated",
    type: "event"
  },
  {
    inputs: [],
    name: "getAllActiveSigners",
    outputs: [
      {
        components: [
          {
            internalType: "address",
            name: "signer",
            type: "address"
          },
          {
            internalType: "address[]",
            name: "approvedTargets",
            type: "address[]"
          },
          {
            internalType: "uint256",
            name: "nativeTokenLimitPerTransaction",
            type: "uint256"
          },
          {
            internalType: "uint128",
            name: "startTimestamp",
            type: "uint128"
          },
          {
            internalType: "uint128",
            name: "endTimestamp",
            type: "uint128"
          }
        ],
        internalType: "struct IAccountPermissions.SignerPermissions[]",
        name: "signers",
        type: "tuple[]"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [],
    name: "getAllAdmins",
    outputs: [
      {
        internalType: "address[]",
        name: "admins",
        type: "address[]"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [],
    name: "getAllSigners",
    outputs: [
      {
        components: [
          {
            internalType: "address",
            name: "signer",
            type: "address"
          },
          {
            internalType: "address[]",
            name: "approvedTargets",
            type: "address[]"
          },
          {
            internalType: "uint256",
            name: "nativeTokenLimitPerTransaction",
            type: "uint256"
          },
          {
            internalType: "uint128",
            name: "startTimestamp",
            type: "uint128"
          },
          {
            internalType: "uint128",
            name: "endTimestamp",
            type: "uint128"
          }
        ],
        internalType: "struct IAccountPermissions.SignerPermissions[]",
        name: "signers",
        type: "tuple[]"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "address",
        name: "signer",
        type: "address"
      }
    ],
    name: "getPermissionsForSigner",
    outputs: [
      {
        components: [
          {
            internalType: "address",
            name: "signer",
            type: "address"
          },
          {
            internalType: "address[]",
            name: "approvedTargets",
            type: "address[]"
          },
          {
            internalType: "uint256",
            name: "nativeTokenLimitPerTransaction",
            type: "uint256"
          },
          {
            internalType: "uint128",
            name: "startTimestamp",
            type: "uint128"
          },
          {
            internalType: "uint128",
            name: "endTimestamp",
            type: "uint128"
          }
        ],
        internalType: "struct IAccountPermissions.SignerPermissions",
        name: "permissions",
        type: "tuple"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "address",
        name: "signer",
        type: "address"
      }
    ],
    name: "isActiveSigner",
    outputs: [
      {
        internalType: "bool",
        name: "",
        type: "bool"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "address",
        name: "signer",
        type: "address"
      }
    ],
    name: "isAdmin",
    outputs: [
      {
        internalType: "bool",
        name: "",
        type: "bool"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "address",
        name: "account",
        type: "address"
      },
      {
        internalType: "bool",
        name: "isAdmin",
        type: "bool"
      }
    ],
    name: "setAdmin",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [
      {
        components: [
          {
            internalType: "address",
            name: "signer",
            type: "address"
          },
          {
            internalType: "address[]",
            name: "approvedTargets",
            type: "address[]"
          },
          {
            internalType: "uint256",
            name: "nativeTokenLimitPerTransaction",
            type: "uint256"
          },
          {
            internalType: "uint128",
            name: "permissionStartTimestamp",
            type: "uint128"
          },
          {
            internalType: "uint128",
            name: "permissionEndTimestamp",
            type: "uint128"
          },
          {
            internalType: "uint128",
            name: "reqValidityStartTimestamp",
            type: "uint128"
          },
          {
            internalType: "uint128",
            name: "reqValidityEndTimestamp",
            type: "uint128"
          },
          {
            internalType: "bytes32",
            name: "uid",
            type: "bytes32"
          }
        ],
        internalType: "struct IAccountPermissions.SignerPermissionRequest",
        name: "req",
        type: "tuple"
      },
      {
        internalType: "bytes",
        name: "signature",
        type: "bytes"
      }
    ],
    name: "setPermissionsForSigner",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [
      {
        components: [
          {
            internalType: "address",
            name: "signer",
            type: "address"
          },
          {
            internalType: "address[]",
            name: "approvedTargets",
            type: "address[]"
          },
          {
            internalType: "uint256",
            name: "nativeTokenLimitPerTransaction",
            type: "uint256"
          },
          {
            internalType: "uint128",
            name: "permissionStartTimestamp",
            type: "uint128"
          },
          {
            internalType: "uint128",
            name: "permissionEndTimestamp",
            type: "uint128"
          },
          {
            internalType: "uint128",
            name: "reqValidityStartTimestamp",
            type: "uint128"
          },
          {
            internalType: "uint128",
            name: "reqValidityEndTimestamp",
            type: "uint128"
          },
          {
            internalType: "bytes32",
            name: "uid",
            type: "bytes32"
          }
        ],
        internalType: "struct IAccountPermissions.SignerPermissionRequest",
        name: "req",
        type: "tuple"
      },
      {
        internalType: "bytes",
        name: "signature",
        type: "bytes"
      }
    ],
    name: "verifySignerPermissionRequest",
    outputs: [
      {
        internalType: "bool",
        name: "success",
        type: "bool"
      },
      {
        internalType: "address",
        name: "signer",
        type: "address"
      }
    ],
    stateMutability: "view",
    type: "function"
  }
];

// node_modules/@thirdweb-dev/contracts-js/dist/abis/IAccount.json
var IAccount_default = [
  {
    inputs: [
      {
        components: [
          {
            internalType: "address",
            name: "sender",
            type: "address"
          },
          {
            internalType: "uint256",
            name: "nonce",
            type: "uint256"
          },
          {
            internalType: "bytes",
            name: "initCode",
            type: "bytes"
          },
          {
            internalType: "bytes",
            name: "callData",
            type: "bytes"
          },
          {
            internalType: "uint256",
            name: "callGasLimit",
            type: "uint256"
          },
          {
            internalType: "uint256",
            name: "verificationGasLimit",
            type: "uint256"
          },
          {
            internalType: "uint256",
            name: "preVerificationGas",
            type: "uint256"
          },
          {
            internalType: "uint256",
            name: "maxFeePerGas",
            type: "uint256"
          },
          {
            internalType: "uint256",
            name: "maxPriorityFeePerGas",
            type: "uint256"
          },
          {
            internalType: "bytes",
            name: "paymasterAndData",
            type: "bytes"
          },
          {
            internalType: "bytes",
            name: "signature",
            type: "bytes"
          }
        ],
        internalType: "struct UserOperation",
        name: "userOp",
        type: "tuple"
      },
      {
        internalType: "bytes32",
        name: "userOpHash",
        type: "bytes32"
      },
      {
        internalType: "uint256",
        name: "missingAccountFunds",
        type: "uint256"
      }
    ],
    name: "validateUserOp",
    outputs: [
      {
        internalType: "uint256",
        name: "validationData",
        type: "uint256"
      }
    ],
    stateMutability: "nonpayable",
    type: "function"
  }
];

// node_modules/@thirdweb-dev/contracts-js/dist/abis/Forwarder.json
var Forwarder_default = [
  {
    inputs: [],
    stateMutability: "nonpayable",
    type: "constructor"
  },
  {
    inputs: [
      {
        components: [
          {
            internalType: "address",
            name: "from",
            type: "address"
          },
          {
            internalType: "address",
            name: "to",
            type: "address"
          },
          {
            internalType: "uint256",
            name: "value",
            type: "uint256"
          },
          {
            internalType: "uint256",
            name: "gas",
            type: "uint256"
          },
          {
            internalType: "uint256",
            name: "nonce",
            type: "uint256"
          },
          {
            internalType: "bytes",
            name: "data",
            type: "bytes"
          }
        ],
        internalType: "struct Forwarder.ForwardRequest",
        name: "req",
        type: "tuple"
      },
      {
        internalType: "bytes",
        name: "signature",
        type: "bytes"
      }
    ],
    name: "execute",
    outputs: [
      {
        internalType: "bool",
        name: "",
        type: "bool"
      },
      {
        internalType: "bytes",
        name: "",
        type: "bytes"
      }
    ],
    stateMutability: "payable",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "address",
        name: "from",
        type: "address"
      }
    ],
    name: "getNonce",
    outputs: [
      {
        internalType: "uint256",
        name: "",
        type: "uint256"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [
      {
        components: [
          {
            internalType: "address",
            name: "from",
            type: "address"
          },
          {
            internalType: "address",
            name: "to",
            type: "address"
          },
          {
            internalType: "uint256",
            name: "value",
            type: "uint256"
          },
          {
            internalType: "uint256",
            name: "gas",
            type: "uint256"
          },
          {
            internalType: "uint256",
            name: "nonce",
            type: "uint256"
          },
          {
            internalType: "bytes",
            name: "data",
            type: "bytes"
          }
        ],
        internalType: "struct Forwarder.ForwardRequest",
        name: "req",
        type: "tuple"
      },
      {
        internalType: "bytes",
        name: "signature",
        type: "bytes"
      }
    ],
    name: "verify",
    outputs: [
      {
        internalType: "bool",
        name: "",
        type: "bool"
      }
    ],
    stateMutability: "view",
    type: "function"
  }
];

// node_modules/@thirdweb-dev/sdk/dist/contract-publisher-1ff1fe07.browser.esm.js
init_shim();
init_lib();
var import_fast_deep_equal = __toESM(require_fast_deep_equal());
var import_merkletreejs = __toESM(require_dist());
var import_bs58 = __toESM(require_bs58());
var import_utils = __toESM(require_utils());
var import_cross_fetch2 = __toESM(require_browser_ponyfill());
var MAX_LENGTH = 256;
var NUMERIC_IDENTIFIER = "0|[1-9]\\d*";
var MAIN_VERSION_IDENTIFIER = `(${NUMERIC_IDENTIFIER})\\.(${NUMERIC_IDENTIFIER})\\.(${NUMERIC_IDENTIFIER})`;
var REGEX_MAIN_VERSION = new RegExp(MAIN_VERSION_IDENTIFIER);
function toSemver(version) {
  if (version.length > MAX_LENGTH) {
    throw new Error(`version is longer than ${MAX_LENGTH} characters`);
  }
  const matches = version.trim().match(REGEX_MAIN_VERSION);
  if (!matches || (matches == null ? void 0 : matches.length) !== 4) {
    throw new Error(`${version} is not a valid semantic version. Should be in the format of major.minor.patch. Ex: 0.4.1`);
  }
  const major = Number(matches[1]);
  const minor = Number(matches[2]);
  const patch = Number(matches[3]);
  const versionString = [major, minor, patch].join(".");
  return {
    major,
    minor,
    patch,
    versionString
  };
}
function isIncrementalVersion(current, next) {
  const currentSemver = toSemver(current);
  const nextSemver = toSemver(next);
  if (nextSemver.major > currentSemver.major) {
    return true;
  }
  const eqMajor = nextSemver.major === currentSemver.major;
  if (eqMajor && nextSemver.minor > currentSemver.minor) {
    return true;
  }
  const eqMinor = nextSemver.minor === currentSemver.minor;
  return eqMajor && eqMinor && nextSemver.patch > currentSemver.patch;
}
function isDowngradeVersion(current, next) {
  const currentSemver = toSemver(current);
  const nextSemver = toSemver(next);
  if (nextSemver.major < currentSemver.major) {
    return true;
  }
  const eqMajor = nextSemver.major === currentSemver.major;
  if (eqMajor && nextSemver.minor < currentSemver.minor) {
    return true;
  }
  const eqMinor = nextSemver.minor === currentSemver.minor;
  return eqMajor && eqMinor && nextSemver.patch < currentSemver.patch;
}
var BigNumberSchema = (() => z.union([z.string(), z.number(), z.bigint(), z.custom((data) => {
  return BigNumber.isBigNumber(data);
})]).transform((arg) => BigNumber.from(arg)))();
var BigNumberishSchema = BigNumberSchema.transform((arg) => arg.toString());
var BigNumberTransformSchema2 = (() => z.union([z.bigint(), z.custom((data) => {
  return BigNumber.isBigNumber(data);
})]).transform((arg) => {
  return BigNumber.from(arg).toString();
}))();
function isSigner(value) {
  return !!(value && value._isSigner);
}
function isProvider(value) {
  return !!(value && value._isProvider);
}
var DEFAULT_BATCH_TIME_LIMIT_MS = 50;
var DEFAULT_BATCH_SIZE_LIMIT = 250;
var DEFAULT_BATCH_OPTIONS = {
  timeLimitMs: DEFAULT_BATCH_TIME_LIMIT_MS,
  sizeLimit: DEFAULT_BATCH_SIZE_LIMIT
};
var StaticJsonRpcBatchProvider = class extends lib_exports2.StaticJsonRpcProvider {
  constructor(url, network) {
    let batchOptions = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : DEFAULT_BATCH_OPTIONS;
    super(url, network);
    this._timeLimitMs = batchOptions.timeLimitMs || DEFAULT_BATCH_SIZE_LIMIT;
    this._sizeLimit = batchOptions.sizeLimit || DEFAULT_BATCH_TIME_LIMIT_MS;
    this._pendingBatchAggregator = null;
    this._pendingBatch = null;
  }
  sendCurrentBatch(request) {
    if (this._pendingBatchAggregator) {
      clearTimeout(this._pendingBatchAggregator);
    }
    const batch = this._pendingBatch || [];
    this._pendingBatch = null;
    this._pendingBatchAggregator = null;
    const request_ = batch.map((inflight) => inflight.request);
    this.emit("debug", {
      action: "requestBatch",
      request: utils_exports.deepCopy(request),
      provider: this
    });
    return utils_exports.fetchJson(this.connection, JSON.stringify(request_)).then((result) => {
      this.emit("debug", {
        action: "response",
        request: request_,
        response: result,
        provider: this
      });
      batch.forEach((inflightRequest_, index) => {
        const payload = result[index];
        if (payload) {
          if (payload.error) {
            const error = new Error(payload.error.message);
            error.code = payload.error.code;
            error.data = payload.error.data;
            inflightRequest_.reject(error);
          } else {
            inflightRequest_.resolve(payload.result);
          }
        } else {
          inflightRequest_.reject(new Error("No response for request"));
        }
      });
    }, (error) => {
      this.emit("debug", {
        action: "response",
        error,
        request: request_,
        provider: this
      });
      batch.forEach((inflightRequest_) => {
        inflightRequest_.reject(error);
      });
    });
  }
  send(method, params) {
    const request = {
      method,
      params,
      id: this._nextId++,
      jsonrpc: "2.0"
    };
    if (this._pendingBatch === null) {
      this._pendingBatch = [];
    }
    const inflightRequest = {
      request,
      resolve: null,
      reject: null
    };
    const promise = new Promise((resolve, reject) => {
      inflightRequest.resolve = resolve;
      inflightRequest.reject = reject;
    });
    this._pendingBatch.push(inflightRequest);
    if (this._pendingBatch.length === this._sizeLimit) {
      this.sendCurrentBatch(request);
    }
    if (!this._pendingBatchAggregator) {
      this._pendingBatchAggregator = setTimeout(() => {
        this.sendCurrentBatch(request);
      }, this._timeLimitMs);
    }
    return promise;
  }
};
var ChainInfoInputSchema = (() => z.object({
  rpc: z.array(z.string().url()),
  chainId: z.number(),
  nativeCurrency: z.object({
    name: z.string(),
    symbol: z.string(),
    decimals: z.number()
  }),
  slug: z.string()
}))();
var SDKOptionsSchema = (() => z.object({
  // @ts-expect-error - zod doesn't know anything about readonly
  supportedChains: z.array(ChainInfoInputSchema).default(defaultChains),
  clientId: z.string().optional(),
  secretKey: z.string().optional(),
  readonlySettings: z.object({
    rpcUrl: z.string().url(),
    chainId: z.number().optional()
  }).optional(),
  gasSettings: z.object({
    maxPriceInGwei: z.number().min(1, "gas price cannot be less than 1").default(300),
    speed: z.enum(["standard", "fast", "fastest"]).default("fastest")
  }).default({
    maxPriceInGwei: 300,
    speed: "fastest"
  }),
  gasless: z.union([z.object({
    openzeppelin: z.object({
      relayerUrl: z.string().url(),
      relayerForwarderAddress: z.string().optional(),
      useEOAForwarder: z.boolean().default(false),
      domainName: z.string().default("GSNv2 Forwarder"),
      domainVersion: z.string().default("0.0.1")
    }),
    experimentalChainlessSupport: z.boolean().default(false)
  }), z.object({
    biconomy: z.object({
      apiId: z.string(),
      apiKey: z.string(),
      deadlineSeconds: z.number().min(1, "deadlineSeconds cannot be les than 1").default(3600)
    })
  })]).optional(),
  gatewayUrls: z.array(z.string()).optional()
}).default({
  gasSettings: {
    maxPriceInGwei: 300,
    speed: "fastest"
  }
}))();
var pkg2 = {
  name: "@thirdweb-dev/sdk",
  version: "3.10.67",
  description: "The main thirdweb SDK.",
  repository: "https://github.com/thirdweb-dev/js/tree/main/packages/sdk",
  license: "Apache-2.0",
  main: "dist/thirdweb-dev-sdk.cjs.js",
  module: "dist/thirdweb-dev-sdk.esm.js",
  browser: {
    "./dist/thirdweb-dev-sdk.esm.js": "./dist/thirdweb-dev-sdk.browser.esm.js"
  },
  exports: {
    ".": {
      module: {
        browser: "./dist/thirdweb-dev-sdk.browser.esm.js",
        "default": "./dist/thirdweb-dev-sdk.esm.js"
      },
      "default": "./dist/thirdweb-dev-sdk.cjs.js"
    },
    "./evm": {
      module: {
        browser: "./evm/dist/thirdweb-dev-sdk-evm.browser.esm.js",
        "default": "./evm/dist/thirdweb-dev-sdk-evm.esm.js"
      },
      "default": "./evm/dist/thirdweb-dev-sdk-evm.cjs.js"
    },
    "./solana": {
      module: {
        browser: "./solana/dist/thirdweb-dev-sdk-solana.browser.esm.js",
        "default": "./solana/dist/thirdweb-dev-sdk-solana.esm.js"
      },
      "default": "./solana/dist/thirdweb-dev-sdk-solana.cjs.js"
    },
    "./evm/zksync": {
      module: {
        browser: "./evm/zksync/dist/thirdweb-dev-sdk-evm-zksync.browser.esm.js",
        "default": "./evm/zksync/dist/thirdweb-dev-sdk-evm-zksync.esm.js"
      },
      "default": "./evm/zksync/dist/thirdweb-dev-sdk-evm-zksync.cjs.js"
    },
    "./evm/functions": {
      module: {
        browser: "./evm/functions/dist/thirdweb-dev-sdk-evm-functions.browser.esm.js",
        "default": "./evm/functions/dist/thirdweb-dev-sdk-evm-functions.esm.js"
      },
      "default": "./evm/functions/dist/thirdweb-dev-sdk-evm-functions.cjs.js"
    },
    "./solana/server": {
      module: {
        browser: "./solana/server/dist/thirdweb-dev-sdk-solana-server.browser.esm.js",
        "default": "./solana/server/dist/thirdweb-dev-sdk-solana-server.esm.js"
      },
      "default": "./solana/server/dist/thirdweb-dev-sdk-solana-server.cjs.js"
    },
    "./package.json": "./package.json"
  },
  files: [
    "dist/",
    "evm/",
    "solana/",
    "server/"
  ],
  preconstruct: {
    entrypoints: [
      "index.ts",
      "evm/index.ts",
      "evm/functions/index.ts",
      "evm/zksync/index.ts",
      "solana/index.ts",
      "solana/server/index.ts"
    ],
    exports: {
      envConditions: [
        "browser"
      ]
    }
  },
  sideEffects: false,
  scripts: {
    format: "prettier --write 'src/**/*'",
    lint: "eslint src/",
    fix: "eslint src/ --fix",
    clean: "rm -rf dist/",
    "generate-docs": "pnpm generate-docs:evm && pnpm generate-docs:solana && pnpm generate-snippets",
    "generate-docs:evm": "api-extractor run --local --config ./config/api-extractor-evm.json && api-documenter markdown -i ./temp -o ./docs/evm && rm -rf ./temp-evm && mv ./temp ./temp-evm",
    "generate-docs:solana": "api-extractor run --local --config ./config/api-extractor-solana.json && api-documenter markdown -i ./temp -o ./docs/solana && rm -rf ./temp-solana && mv ./temp ./temp-solana",
    "generate-snippets": "node ./scripts/generate-snippets.mjs && node ./scripts/generate-feature-snippets-evm.mjs",
    build: "tsc && preconstruct build",
    "test:evm:all": "SWC_NODE_PROJECT=./tsconfig.test.json nyc --reporter lcovonly --report-dir ./coverage/evm mocha --config './test/evm/.mocharc.json' --timeout 90000 --parallel './test/evm/**/*.test.ts'",
    "test:evm": "make test-evm",
    "test:evm:single": "SWC_NODE_PROJECT=./tsconfig.test.json mocha --config './test/evm/.mocharc.json' --timeout 90000",
    "node:solana:start": "DEBUG='amman:(info|error|debug)' amman start --forceClone",
    "node:solana:stop": "amman stop",
    "test:solana:all": "SWC_NODE_PROJECT=./tsconfig.test.json nyc --reporter lcovonly --report-dir ./coverage/solana  mocha --config './test/solana/.mocharc.json' --timeout 30000 --parallel './test/solana/**/*.test.ts'",
    "test:solana": "make test-sol",
    "test:solana:single": "SWC_NODE_PROJECT=./tsconfig.test.json mocha --config './test/solana/.mocharc.json' --timeout 30000",
    push: "yalc push"
  },
  devDependencies: {
    "@aws-sdk/client-secrets-manager": "^3.378.0",
    "@ethersproject/abstract-provider": "^5.7.0",
    "@metaplex-foundation/amman": "^0.12.1",
    "@metaplex-foundation/amman-client": "^0.2.4",
    "@metaplex-foundation/js": "^0.19.2",
    "@metaplex-foundation/mpl-token-metadata": "^2.12.0",
    "@microsoft/api-documenter": "^7.22.30",
    "@microsoft/api-extractor": "^7.36.3",
    "@microsoft/tsdoc": "^0.14.1",
    "@nomiclabs/hardhat-ethers": "^2.2.3",
    "@preconstruct/cli": "2.7.0",
    "@project-serum/anchor": "^0.25.0",
    "@solana/spl-token": "^0.3.5",
    "@solana/web3.js": "^1.62.0",
    "@swc-node/register": "^1.6.6",
    "@swc/core": "^1.3.71",
    "@thirdweb-dev/tsconfig": "workspace:*",
    "@types/bn.js": "^5.1.1",
    "@types/chai": "^4.3.5",
    "@types/deep-equal-in-any-order": "^1.0.1",
    "@types/mocha": "^10.0.0",
    "@types/node": "^18.17.1",
    "@types/uuid": "^9.0.2",
    "@typescript-eslint/eslint-plugin": "^6.2.0",
    "@typescript-eslint/parser": "^6.2.0",
    chai: "^4.3.6",
    "deep-equal-in-any-order": "^1.1.18",
    "dotenv-mono": "^1.3.10",
    eslint: "^8.45.0",
    "eslint-config-prettier": "^8.9.0",
    "eslint-config-thirdweb": "workspace:*",
    "eslint-plugin-better-tree-shaking": "0.0.3",
    "eslint-plugin-import": "^2.26.0",
    "eslint-plugin-inclusive-language": "^2.2.0",
    "eslint-plugin-prettier": "^5.0.0",
    "eslint-plugin-tsdoc": "^0.2.16",
    ethers: "^5.7.2",
    "ethers-aws-kms-signer": "^1.3.2",
    hardhat: "^2.17.0",
    mocha: "^10.2.0",
    nyc: "^15.1.0",
    prettier: "^3.0.0",
    typescript: "^5.1.6",
    "zksync-web3": "^0.14.3"
  },
  peerDependencies: {
    "@aws-sdk/client-secrets-manager": "^3.215.0",
    "@metaplex-foundation/js": "^0.17.6",
    "@metaplex-foundation/mpl-token-metadata": "^2.3.3",
    "@project-serum/anchor": "^0.25.0",
    "@solana/spl-token": "^0.3.5",
    "@solana/web3.js": "^1.62.0",
    ethers: "^5",
    "ethers-aws-kms-signer": "^1.3.2",
    "zksync-web3": "^0.14.3"
  },
  peerDependenciesMeta: {
    "@aws-sdk/client-secrets-manager": {
      optional: true
    },
    "ethers-aws-kms-signer": {
      optional: true
    },
    "@solana/spl-token": {
      optional: true
    },
    "@solana/web3.js": {
      optional: true
    },
    "@project-serum/anchor": {
      optional: true
    },
    "@metaplex-foundation/mpl-token-metadata": {
      optional: true
    },
    "@metaplex-foundation/js": {
      optional: true
    },
    "zksync-web3": {
      optional: true
    }
  },
  dependencies: {
    "@thirdweb-dev/chains": "workspace:*",
    "@thirdweb-dev/contracts-js": "workspace:*",
    "@thirdweb-dev/generated-abis": "workspace:*",
    "@thirdweb-dev/storage": "workspace:*",
    abitype: "^0.2.5",
    "bn.js": "^5.2.1",
    bs58: "^5.0.0",
    buffer: "^6.0.3",
    "cross-fetch": "^3.1.8",
    eventemitter3: "^5.0.1",
    "fast-deep-equal": "^3.1.3",
    merkletreejs: "^0.2.24",
    "tiny-invariant": "^1.2.0",
    tweetnacl: "^1.0.3",
    uuid: "^9.0.0",
    yaml: "^2.3.1",
    zod: "^3.20.2"
  },
  bugs: {
    url: "https://github.com/thirdweb-dev/js/issues"
  },
  author: "thirdweb eng <eng@thirdweb.com>"
};
function buildDefaultMap(options) {
  return options.supportedChains.reduce((previousValue, currentValue) => {
    previousValue[currentValue.chainId] = currentValue;
    return previousValue;
  }, {});
}
function getChainProvider(network, sdkOptions) {
  if (typeof network === "string" && isRpcUrl(network)) {
    return getProviderFromRpcUrl(network, sdkOptions);
  }
  const options = SDKOptionsSchema.parse(sdkOptions);
  if (isChainConfig(network)) {
    options.supportedChains = [
      // @ts-expect-error - we know this is a chain and it will work to build the map
      network,
      ...options.supportedChains.filter((c) => c.chainId !== network.chainId)
    ];
  }
  const rpcMap = buildDefaultMap(options);
  let rpcUrl = "";
  let chainId;
  try {
    chainId = getChainIdFromNetwork(network, options);
    rpcUrl = getValidChainRPCs(rpcMap[chainId], options.clientId)[0];
  } catch (e) {
  }
  if (!rpcUrl) {
    rpcUrl = `https://${chainId || network}.rpc.thirdweb.com/${options.clientId || ""}`;
  }
  if (!rpcUrl) {
    throw new Error(`No rpc url found for chain ${network}. Please provide a valid rpc url via the 'supportedChains' property of the sdk options.`);
  }
  return getProviderFromRpcUrl(rpcUrl, sdkOptions, chainId);
}
function getChainIdFromNetwork(network, options) {
  if (isChainConfig(network)) {
    return network.chainId;
  } else if (typeof network === "number") {
    return network;
  } else {
    const chainNameToId = options.supportedChains.reduce((acc, curr) => {
      acc[curr.slug] = curr.chainId;
      return acc;
    }, {});
    if (network in chainNameToId) {
      return chainNameToId[network];
    }
  }
  throw new Error(`Cannot resolve chainId from: ${network} - please pass the chainId instead and specify it in the 'supportedChains' property of the SDK options.`);
}
async function getChainIdOrName(network) {
  if (isChainConfig(network)) {
    return network.chainId;
  } else if (typeof network === "number") {
    return network;
  } else if (typeof network === "number") {
    return network;
  } else if (isProvider(network)) {
    return network.getNetwork().then((n) => n.chainId);
  } else if (isSigner(network)) {
    if (!network.provider) {
      throw new Error("Signer does not have a provider");
    }
    return network.provider.getNetwork().then((n) => n.chainId);
  }
  throw new Error(`Cannot resolve chainId from: ${network}.`);
}
function isChainConfig(network) {
  return typeof network !== "string" && typeof network !== "number" && !isSigner(network) && !isProvider(network);
}
function isRpcUrl(url) {
  const match = url.match(/^(ws|http)s?:/i);
  if (match) {
    switch (match[1].toLowerCase()) {
      case "http":
      case "https":
      case "ws":
      case "wss":
        return true;
    }
  }
  return false;
}
var RPC_PROVIDER_MAP = /* @__PURE__ */ new Map();
function getProviderFromRpcUrl(rpcUrl, sdkOptions, chainId) {
  try {
    const headers = {};
    let authStrategy = "none";
    if (isTwUrl(rpcUrl)) {
      if (sdkOptions == null ? void 0 : sdkOptions.secretKey) {
        if (true) {
          throw new Error("Cannot use secretKey in browser context");
        }
        const pto = "pto";
        const crypto2 = __require("cry" + pto);
        const hashedSecretKey = crypto2.createHash("sha256").update(sdkOptions.secretKey).digest("hex");
        const derivedClientId = hashedSecretKey.slice(0, 32);
        const utilizedRpcUrl = new URL(rpcUrl);
        utilizedRpcUrl.pathname = derivedClientId;
        headers["x-client-id"] = derivedClientId;
        headers["x-secret-key"] = sdkOptions.secretKey;
        rpcUrl = utilizedRpcUrl.toString();
        authStrategy = "secretKey";
      } else if (sdkOptions == null ? void 0 : sdkOptions.clientId) {
        const utilizedRpcUrl = new URL(rpcUrl);
        utilizedRpcUrl.pathname = sdkOptions.clientId;
        headers["x-client-id"] = sdkOptions.clientId;
        rpcUrl = utilizedRpcUrl.toString();
        authStrategy = "clientId";
      }
      if (typeof globalThis !== "undefined" && "TW_AUTH_TOKEN" in globalThis && typeof globalThis.TW_AUTH_TOKEN === "string") {
        headers["authorization"] = `Bearer ${globalThis.TW_AUTH_TOKEN}`;
        authStrategy = "twAuthToken";
      }
      if (typeof globalThis !== "undefined" && "TW_CLI_AUTH_TOKEN" in globalThis && typeof globalThis.TW_CLI_AUTH_TOKEN === "string") {
        headers["x-authorize-wallet"] = "true";
      }
      const bundleId = typeof globalThis !== "undefined" && "APP_BUNDLE_ID" in globalThis ? globalThis.APP_BUNDLE_ID : void 0;
      if (!rpcUrl.includes("bundleId")) {
        rpcUrl = rpcUrl + (bundleId ? `?bundleId=${bundleId}` : "");
      }
      headers["x-sdk-version"] = pkg2.version;
      headers["x-sdk-name"] = pkg2.name;
      headers["x-sdk-platform"] = bundleId ? "react-native" : isBrowser() ? window.bridge !== void 0 ? "webGL" : "browser" : "node";
    }
    const match = rpcUrl.match(/^(ws|http)s?:/i);
    if (match) {
      switch (match[1].toLowerCase()) {
        case "http":
        case "https":
          const seralizedOpts = `${rpcUrl}-${chainId || -1}-${authStrategy}`;
          const existingProvider = RPC_PROVIDER_MAP.get(seralizedOpts);
          if (existingProvider) {
            return existingProvider;
          }
          const newProvider = chainId ? (
            // If we know the chainId we should use the StaticJsonRpcBatchProvider
            new StaticJsonRpcBatchProvider({
              url: rpcUrl,
              headers
            }, chainId)
          ) : (
            // Otherwise fall back to the built in json rpc batch provider
            new lib_exports2.JsonRpcBatchProvider({
              url: rpcUrl,
              headers
            })
          );
          RPC_PROVIDER_MAP.set(seralizedOpts, newProvider);
          return newProvider;
        case "ws":
        case "wss":
          return new lib_exports2.WebSocketProvider(rpcUrl, chainId);
      }
    }
  } catch (e) {
  }
  return lib_exports2.getDefaultProvider(rpcUrl);
}
function isTwUrl(url) {
  return new URL(url).hostname.endsWith(".thirdweb.com");
}
function getSignerAndProvider(network, options) {
  let signer;
  let provider2;
  if (isSigner(network)) {
    signer = network;
    if (network.provider) {
      provider2 = network.provider;
    }
  } else if (isProvider(network)) {
    provider2 = network;
  } else {
    provider2 = getChainProvider(network, options);
  }
  if (options == null ? void 0 : options.readonlySettings) {
    provider2 = getProviderFromRpcUrl(options.readonlySettings.rpcUrl, options, options.readonlySettings.chainId);
  }
  if (!provider2) {
    if (signer) {
      throw new Error("No provider passed to the SDK! Please make sure that your signer is connected to a provider!");
    }
    throw new Error("No provider found! Make sure to specify which network to connect to, or pass a signer or provider to the SDK!");
  }
  return [signer, provider2];
}
var provider;
var ENS_CACHE = /* @__PURE__ */ new Map();
async function resolveEns(ens) {
  let depth = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 0;
  if (!provider) {
    provider = getSignerAndProvider("ethereum")[1];
  }
  let ensPromise;
  if (ENS_CACHE.has(ens)) {
    ensPromise = ENS_CACHE.get(ens);
  } else {
    ensPromise = provider.resolveName(ens).then((address) => {
      if (!address) {
        return {
          address: null,
          expirationTime: new Date(Date.now() + 1e3 * 30)
        };
      }
      return {
        address,
        expirationTime: new Date(Date.now() + 1e3 * 60 * 5)
      };
    });
  }
  const resolvedPromise = await ensPromise;
  if (resolvedPromise.expirationTime < /* @__PURE__ */ new Date()) {
    ENS_CACHE.delete(ens);
    if (depth === 0) {
      resolveEns(ens, depth + 1);
    }
  }
  return resolvedPromise.address;
}
var EnsSchema = (() => z.custom((ens) => typeof ens === "string" && (ens.endsWith(".eth") || ens.endsWith(".cb.id"))).transform(async (ens) => resolveEns(ens)).refine((address) => !!address && utils_exports.isAddress(address), {
  message: "Provided value was not a valid ENS name"
}))();
var AddressSchema = z.custom((address) => typeof address === "string" && utils_exports.isAddress(address), (out) => {
  return {
    message: `${out} is not a valid address`
  };
});
var AddressOrEnsSchema = z.union([AddressSchema, EnsSchema], {
  invalid_type_error: "Provided value was not a valid address or ENS name"
});
var ChainId = function(ChainId2) {
  ChainId2[ChainId2["Mainnet"] = 1] = "Mainnet";
  ChainId2[ChainId2["Goerli"] = 5] = "Goerli";
  ChainId2[ChainId2["Polygon"] = 137] = "Polygon";
  ChainId2[ChainId2["Mumbai"] = 80001] = "Mumbai";
  ChainId2[ChainId2["Localhost"] = 1337] = "Localhost";
  ChainId2[ChainId2["Hardhat"] = 31337] = "Hardhat";
  ChainId2[ChainId2["Fantom"] = 250] = "Fantom";
  ChainId2[ChainId2["FantomTestnet"] = 4002] = "FantomTestnet";
  ChainId2[ChainId2["Avalanche"] = 43114] = "Avalanche";
  ChainId2[ChainId2["AvalancheFujiTestnet"] = 43113] = "AvalancheFujiTestnet";
  ChainId2[ChainId2["Optimism"] = 10] = "Optimism";
  ChainId2[ChainId2["OptimismGoerli"] = 420] = "OptimismGoerli";
  ChainId2[ChainId2["Arbitrum"] = 42161] = "Arbitrum";
  ChainId2[ChainId2["ArbitrumGoerli"] = 421613] = "ArbitrumGoerli";
  ChainId2[ChainId2["BinanceSmartChainMainnet"] = 56] = "BinanceSmartChainMainnet";
  ChainId2[ChainId2["BinanceSmartChainTestnet"] = 97] = "BinanceSmartChainTestnet";
  return ChainId2;
}({});
var supportedChains = defaultChains;
function setSupportedChains(chains) {
  if (chains && chains.length > 0) {
    supportedChains = chains;
  } else {
    supportedChains = defaultChains;
  }
}
function getSupportedChains() {
  return supportedChains;
}
var NATIVE_TOKEN_ADDRESS = "0xeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeee";
var NATIVE_TOKENS = {
  [ChainId.Mainnet]: {
    name: "Ether",
    symbol: "ETH",
    decimals: 18,
    wrapped: {
      address: "0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2",
      name: "Wrapped Ether",
      symbol: "WETH"
    }
  },
  [ChainId.Goerli]: {
    name: "Görli Ether",
    symbol: "GOR",
    decimals: 18,
    wrapped: {
      address: "0xb4fbf271143f4fbf7b91a5ded31805e42b2208d6",
      name: "Wrapped Ether",
      symbol: "WETH"
    }
  },
  11155111: {
    name: "Sepolia Ether",
    symbol: "SEP",
    decimals: 18,
    wrapped: {
      address: "0x7b79995e5f793A07Bc00c21412e50Ecae098E7f9",
      name: "Wrapped Ether",
      symbol: "WETH"
    }
  },
  [ChainId.Polygon]: {
    name: "Matic",
    symbol: "MATIC",
    decimals: 18,
    wrapped: {
      address: "0x0d500B1d8E8eF31E21C99d1Db9A6444d3ADf1270",
      name: "Wrapped Matic",
      symbol: "WMATIC"
    }
  },
  [ChainId.Mumbai]: {
    name: "Matic",
    symbol: "MATIC",
    decimals: 18,
    wrapped: {
      address: "0x9c3C9283D3e44854697Cd22D3Faa240Cfb032889",
      name: "Wrapped Matic",
      symbol: "WMATIC"
    }
  },
  [ChainId.Avalanche]: {
    name: "Avalanche",
    symbol: "AVAX",
    decimals: 18,
    wrapped: {
      address: "0xB31f66AA3C1e785363F0875A1B74E27b85FD66c7",
      name: "Wrapped AVAX",
      symbol: "WAVAX"
    }
  },
  [ChainId.AvalancheFujiTestnet]: {
    name: "Avalanche",
    symbol: "AVAX",
    decimals: 18,
    wrapped: {
      address: "0xd00ae08403B9bbb9124bB305C09058E32C39A48c",
      name: "Wrapped AVAX",
      symbol: "WAVAX"
    }
  },
  [ChainId.Fantom]: {
    name: "Fantom",
    symbol: "FTM",
    decimals: 18,
    wrapped: {
      address: "0x21be370D5312f44cB42ce377BC9b8a0cEF1A4C83",
      name: "Wrapped Fantom",
      symbol: "WFTM"
    }
  },
  [ChainId.FantomTestnet]: {
    name: "Fantom",
    symbol: "FTM",
    decimals: 18,
    wrapped: {
      address: "0xf1277d1Ed8AD466beddF92ef448A132661956621",
      name: "Wrapped Fantom",
      symbol: "WFTM"
    }
  },
  [ChainId.Arbitrum]: {
    name: "Ether",
    symbol: "ETH",
    decimals: 18,
    wrapped: {
      address: "0x82af49447d8a07e3bd95bd0d56f35241523fbab1",
      name: "Wrapped Ether",
      symbol: "WETH"
    }
  },
  [ChainId.ArbitrumGoerli]: {
    name: "Arbitrum Goerli Ether",
    symbol: "AGOR",
    decimals: 18,
    wrapped: {
      address: "0xe39Ab88f8A4777030A534146A9Ca3B52bd5D43A3",
      name: "Wrapped Ether",
      symbol: "WETH"
    }
  },
  [ChainId.Optimism]: {
    name: "Ether",
    symbol: "ETH",
    decimals: 18,
    wrapped: {
      address: "0x4200000000000000000000000000000000000006",
      name: "Wrapped Ether",
      symbol: "WETH"
    }
  },
  [ChainId.OptimismGoerli]: {
    name: "Goerli Ether",
    symbol: "ETH",
    decimals: 18,
    wrapped: {
      address: "0x4200000000000000000000000000000000000006",
      name: "Wrapped Ether",
      symbol: "WETH"
    }
  },
  [ChainId.BinanceSmartChainMainnet]: {
    name: "Binance Chain Native Token",
    symbol: "BNB",
    decimals: 18,
    wrapped: {
      address: "0xbb4CdB9CBd36B01bD1cBaEBF2De08d9173bc095c",
      name: "Wrapped Binance Chain Token",
      symbol: "WBNB"
    }
  },
  [ChainId.BinanceSmartChainTestnet]: {
    name: "Binance Chain Native Token",
    symbol: "TBNB",
    decimals: 18,
    wrapped: {
      address: "0xae13d989daC2f0dEbFf460aC112a837C89BAa7cd",
      name: "Wrapped Binance Chain Testnet Token",
      symbol: "WBNB"
    }
  },
  [ChainId.Hardhat]: {
    name: "Ether",
    symbol: "ETH",
    decimals: 18,
    wrapped: {
      address: "0x5FbDB2315678afecb367f032d93F642f64180aa3",
      name: "Wrapped Ether",
      symbol: "WETH"
    }
  },
  [ChainId.Localhost]: {
    name: "Ether",
    symbol: "ETH",
    decimals: 18,
    wrapped: {
      address: "0x5FbDB2315678afecb367f032d93F642f64180aa3",
      name: "Wrapped Ether",
      symbol: "WETH"
    }
  },
  84531: {
    name: "Base Goerli Testnet",
    symbol: "ETH",
    decimals: 18,
    wrapped: {
      address: "0x4200000000000000000000000000000000000006",
      name: "Wrapped Ether",
      symbol: "WETH"
    }
  },
  // eslint-disable-next-line no-useless-computed-key
  [280]: {
    name: "zkSync Era Testnet",
    symbol: "ETH",
    decimals: 18,
    wrapped: {
      address: "0x5AEa5775959fBC2557Cc8789bC1bf90A239D9a91",
      name: "Wrapped Ether",
      symbol: "WETH"
    }
  }
};
function getNativeTokenByChainId(chainId) {
  const chain = getSupportedChains().find((c) => c.chainId === chainId);
  if (chain && chain.nativeCurrency) {
    return {
      name: chain.nativeCurrency.name,
      symbol: chain.nativeCurrency.symbol,
      decimals: 18,
      wrapped: {
        address: lib_exports.AddressZero,
        name: `Wrapped ${chain.nativeCurrency.name}`,
        symbol: `W${chain.nativeCurrency.symbol}`
      }
    };
  }
  return NATIVE_TOKENS[chainId] || {
    name: "Ether",
    symbol: "ETH",
    decimals: 18,
    wrapped: {
      address: lib_exports.AddressZero,
      name: "Wrapped Ether",
      symbol: "WETH"
    }
  };
}
var LINK_TOKEN_ADDRESS = {
  [ChainId.Mainnet]: "0x514910771AF9Ca656af840dff83E8264EcF986CA",
  [ChainId.Goerli]: "0x326C977E6efc84E512bB9C30f76E30c160eD06FB",
  [ChainId.BinanceSmartChainMainnet]: "0x404460C6A5EdE2D891e8297795264fDe62ADBB75",
  [ChainId.Polygon]: "0xb0897686c545045aFc77CF20eC7A532E3120E0F1",
  [ChainId.Mumbai]: "0x326C977E6efc84E512bB9C30f76E30c160eD06FB",
  [ChainId.Avalanche]: "0x5947BB275c521040051D82396192181b413227A3",
  [ChainId.AvalancheFujiTestnet]: "0x0b9d5D9136855f6FEc3c0993feE6E9CE8a297846",
  [ChainId.Fantom]: "0x6F43FF82CCA38001B6699a8AC47A2d0E66939407",
  [ChainId.FantomTestnet]: "0xfaFedb041c0DD4fA2Dc0d87a6B0979Ee6FA7af5F"
};
var RawDateSchema = (() => z.union([z.date().transform((i) => {
  return BigNumber.from(Math.floor(i.getTime() / 1e3));
}), z.number().transform((i) => {
  return BigNumber.from(i);
})]))();
var StartDateSchema = (() => RawDateSchema.default(/* @__PURE__ */ new Date(0)))();
var EndDateSchema = (() => RawDateSchema.default(new Date(Date.now() + 1e3 * 60 * 60 * 24 * 365 * 10)))();
var CurrencySchema = (() => z.object({
  name: z.string(),
  symbol: z.string(),
  decimals: z.number()
}))();
var CurrencyValueSchema = (() => CurrencySchema.extend({
  value: BigNumberSchema,
  displayValue: z.string()
}))();
var MerkleSchema = (() => z.object({
  merkle: z.record(z.string()).default({})
}))();
var SnapshotEntryInput = (() => z.object({
  address: AddressOrEnsSchema,
  maxClaimable: QuantitySchema.default(0),
  // defaults to 0
  price: QuantitySchema.optional(),
  // defaults to unlimited, but can be undefined in old snapshots
  currencyAddress: AddressOrEnsSchema.default(lib_exports.AddressZero).optional()
  // defaults to AddressZero, but can be undefined for old snapshots
}))();
var SnapshotInputSchema = (() => z.union([z.array(z.string()).transform(async (strings) => await Promise.all(strings.map((address) => SnapshotEntryInput.parseAsync({
  address
})))), z.array(SnapshotEntryInput)]))();
var SnapshotEntryWithProofSchema = (() => SnapshotEntryInput.extend({
  proof: z.array(z.string())
}))();
var SnapshotSchema = (() => z.object({
  /**
   * The merkle root
   */
  merkleRoot: z.string(),
  claims: z.array(SnapshotEntryWithProofSchema)
}))();
var SnapshotInfoSchema = (() => z.object({
  merkleRoot: z.string(),
  snapshotUri: z.string()
}))();
var ClaimConditionMetadataSchema = (() => z.object({
  name: z.string().optional()
}).catchall(z.unknown()))();
var ClaimConditionInputSchema = (() => z.object({
  startTime: StartDateSchema,
  currencyAddress: z.string().default(NATIVE_TOKEN_ADDRESS),
  price: AmountSchema.default(0),
  maxClaimableSupply: QuantitySchema,
  maxClaimablePerWallet: QuantitySchema,
  waitInSeconds: BigNumberishSchema.default(0),
  merkleRootHash: BytesLikeSchema.default(utils_exports.hexZeroPad([0], 32)),
  snapshot: z.optional(SnapshotInputSchema).nullable(),
  metadata: ClaimConditionMetadataSchema.optional()
}))();
var ClaimConditionInputArray = z.array(ClaimConditionInputSchema);
var PartialClaimConditionInputSchema = ClaimConditionInputSchema.partial();
var ClaimConditionOutputSchema = (() => ClaimConditionInputSchema.extend({
  availableSupply: QuantitySchema,
  currentMintSupply: QuantitySchema,
  currencyMetadata: CurrencyValueSchema.default({
    value: BigNumber.from("0"),
    displayValue: "0",
    symbol: "",
    decimals: 18,
    name: ""
  }),
  price: BigNumberSchema,
  waitInSeconds: BigNumberSchema,
  startTime: BigNumberSchema.transform((n) => new Date(n.toNumber() * 1e3)),
  snapshot: SnapshotInputSchema.optional().nullable()
}))();
function resolveOrGenerateId(requestUId) {
  if (requestUId === void 0) {
    const buffer = import_buffer.Buffer.alloc(16);
    v4_default({}, buffer);
    return utils_exports.hexlify(utils_exports.toUtf8Bytes(buffer.toString("hex")));
  } else {
    return utils_exports.hexlify(requestUId);
  }
}
var BaseSignaturePayloadInput = (() => z.object({
  to: AddressOrEnsSchema.refine((address) => address.toLowerCase() !== lib_exports.AddressZero, {
    message: "Cannot create payload to mint to zero address"
  }),
  price: AmountSchema.default(0),
  currencyAddress: AddressSchema.default(NATIVE_TOKEN_ADDRESS),
  mintStartTime: StartDateSchema,
  mintEndTime: EndDateSchema,
  uid: z.string().optional().transform((arg) => resolveOrGenerateId(arg)),
  primarySaleRecipient: AddressOrEnsSchema.default(lib_exports.AddressZero)
}))();
var Signature20PayloadInput = BaseSignaturePayloadInput.extend({
  quantity: AmountSchema
});
var Signature20PayloadOutput = Signature20PayloadInput.extend({
  mintStartTime: BigNumberSchema,
  mintEndTime: BigNumberSchema
});
var Signature721PayloadInput = (() => BaseSignaturePayloadInput.extend({
  metadata: NFTInputOrUriSchema,
  royaltyRecipient: z.string().default(lib_exports.AddressZero),
  royaltyBps: BasisPointsSchema.default(0)
}))();
var Signature721PayloadOutput = (() => Signature721PayloadInput.extend({
  metadata: NFTInputOrUriSchema.default(""),
  uri: z.string(),
  royaltyBps: BigNumberSchema,
  mintStartTime: BigNumberSchema,
  mintEndTime: BigNumberSchema
}))();
var Signature1155PayloadInput = (() => Signature721PayloadInput.extend({
  metadata: NFTInputOrUriSchema.default(""),
  quantity: BigNumberishSchema
}))();
var Signature1155PayloadInputWithTokenId = Signature1155PayloadInput.extend({
  tokenId: BigNumberishSchema
});
var Signature1155PayloadOutput = Signature721PayloadOutput.extend({
  tokenId: BigNumberSchema,
  quantity: BigNumberSchema
});
var Signature721WithQuantityInput = (() => Signature721PayloadInput.extend({
  metadata: NFTInputOrUriSchema.default(""),
  quantity: BigNumberSchema.default(1)
}))();
var Signature721WithQuantityOutput = (() => Signature721PayloadOutput.extend({
  quantity: BigNumberSchema.default(1)
}))();
var MintRequest20 = [{
  name: "to",
  type: "address"
}, {
  name: "primarySaleRecipient",
  type: "address"
}, {
  name: "quantity",
  type: "uint256"
}, {
  name: "price",
  type: "uint256"
}, {
  name: "currency",
  type: "address"
}, {
  name: "validityStartTimestamp",
  type: "uint128"
}, {
  name: "validityEndTimestamp",
  type: "uint128"
}, {
  name: "uid",
  type: "bytes32"
}];
var MintRequest721 = [{
  name: "to",
  type: "address"
}, {
  name: "royaltyRecipient",
  type: "address"
}, {
  name: "royaltyBps",
  type: "uint256"
}, {
  name: "primarySaleRecipient",
  type: "address"
}, {
  name: "uri",
  type: "string"
}, {
  name: "price",
  type: "uint256"
}, {
  name: "currency",
  type: "address"
}, {
  name: "validityStartTimestamp",
  type: "uint128"
}, {
  name: "validityEndTimestamp",
  type: "uint128"
}, {
  name: "uid",
  type: "bytes32"
}];
var MintRequest1155 = [{
  name: "to",
  type: "address"
}, {
  name: "royaltyRecipient",
  type: "address"
}, {
  name: "royaltyBps",
  type: "uint256"
}, {
  name: "primarySaleRecipient",
  type: "address"
}, {
  name: "tokenId",
  type: "uint256"
}, {
  name: "uri",
  type: "string"
}, {
  name: "quantity",
  type: "uint256"
}, {
  name: "pricePerToken",
  type: "uint256"
}, {
  name: "currency",
  type: "address"
}, {
  name: "validityStartTimestamp",
  type: "uint128"
}, {
  name: "validityEndTimestamp",
  type: "uint128"
}, {
  name: "uid",
  type: "bytes32"
}];
var MintRequest721withQuantity = [{
  name: "to",
  type: "address"
}, {
  name: "royaltyRecipient",
  type: "address"
}, {
  name: "royaltyBps",
  type: "uint256"
}, {
  name: "primarySaleRecipient",
  type: "address"
}, {
  name: "uri",
  type: "string"
}, {
  name: "quantity",
  type: "uint256"
}, {
  name: "pricePerToken",
  type: "uint256"
}, {
  name: "currency",
  type: "address"
}, {
  name: "validityStartTimestamp",
  type: "uint128"
}, {
  name: "validityEndTimestamp",
  type: "uint128"
}, {
  name: "uid",
  type: "bytes32"
}];
var GenericRequest = [{
  name: "validityStartTimestamp",
  type: "uint128"
}, {
  name: "validityEndTimestamp",
  type: "uint128"
}, {
  name: "uid",
  type: "bytes32"
}, {
  name: "data",
  type: "bytes"
}];
var CommonContractSchema = (() => z.object({
  name: z.string(),
  description: z.string().optional(),
  image: FileOrBufferOrStringSchema.optional(),
  external_link: z.string().optional(),
  app_uri: z.string().optional(),
  social_urls: z.record(z.string()).optional()
}).catchall(z.unknown()))();
var CommonContractOutputSchema = (() => CommonContractSchema.extend({
  image: z.string().optional()
}).catchall(z.unknown()))();
var CommonRoyaltySchema = (() => z.object({
  /**
   * The amount of royalty collected on all royalties represented as basis points.
   * The default is 0 (no royalties).
   *
   * 1 basis point = 0.01%
   *
   * For example: if this value is 100, then the royalty is 1% of the total sales.
   *
   *  @internalremarks used by OpenSea "seller_fee_basis_points"
   */
  seller_fee_basis_points: BasisPointsSchema.default(0),
  /**
   * The address of the royalty recipient. All royalties will be sent
   * to this address.
   * @internalremarks used by OpenSea "fee_recipient"
   */
  fee_recipient: AddressOrEnsSchema.default(lib_exports.AddressZero)
}))();
var CommonPrimarySaleSchema = z.object({
  /**
   * primary sale recipient address
   */
  primary_sale_recipient: AddressOrEnsSchema
});
var CommonPlatformFeeSchema = (() => z.object({
  /**
   * platform fee basis points
   */
  platform_fee_basis_points: BasisPointsSchema.default(0),
  /**
   * platform fee recipient address
   */
  platform_fee_recipient: AddressOrEnsSchema.default(lib_exports.AddressZero)
}))();
var CommonTrustedForwarderSchema = (() => z.object({
  trusted_forwarders: z.array(AddressOrEnsSchema).default([])
}))();
var CommonSymbolSchema = (() => z.object({
  symbol: z.string().default("")
}))();
var BYOCContractMetadataSchema = (() => CommonContractSchema.catchall(z.union([BigNumberTransformSchema2, z.unknown()])))();
var CustomContractInput = (() => BYOCContractMetadataSchema.merge(CommonRoyaltySchema.merge(MerkleSchema).merge(CommonSymbolSchema).partial()).catchall(z.any()))();
var CustomContractOutput = (() => CommonContractOutputSchema.merge(CommonRoyaltySchema.merge(MerkleSchema).merge(CommonSymbolSchema).partial()).catchall(z.any()))();
var CustomContractDeploy = (() => CustomContractInput.merge(CommonPlatformFeeSchema.merge(CommonPrimarySaleSchema).merge(CommonTrustedForwarderSchema).partial()))();
var CustomContractSchema = {
  deploy: CustomContractDeploy,
  output: CustomContractOutput,
  input: CustomContractInput
};
var AbiTypeBaseSchema = (() => z.object({
  type: z.string(),
  name: z.string().default("")
}).catchall(z.any()))();
var AbiTypeSchema = (() => AbiTypeBaseSchema.extend({
  stateMutability: z.string().optional(),
  components: z.array(AbiTypeBaseSchema).optional()
}).catchall(z.any()))();
var AbiObjectSchema = (() => z.object({
  type: z.string(),
  name: z.string().default(""),
  inputs: z.array(AbiTypeSchema).default([]),
  outputs: z.array(AbiTypeSchema).default([])
}).catchall(z.any()))();
var AbiSchema = z.array(AbiObjectSchema);
var PreDeployMetadata = (() => z.object({
  name: z.string(),
  metadataUri: z.string(),
  bytecodeUri: z.string(),
  analytics: z.any().optional()
}).catchall(z.any()))();
var ChainIdToAddressSchema = (() => z.record(z.string(), z.string()))();
var CustomFactoryInput = (() => z.object({
  factoryFunction: z.string(),
  params: z.array(z.object({
    name: z.string(),
    type: z.string()
  })).default([]),
  customFactoryAddresses: ChainIdToAddressSchema
}))();
var FactoryDeploymentSchema = (() => z.object({
  implementationAddresses: ChainIdToAddressSchema,
  implementationInitializerFunction: z.string().default("initialize"),
  customFactoryInput: CustomFactoryInput.optional(),
  factoryAddresses: ChainIdToAddressSchema.optional()
}))();
var DeployTypeInput = (() => z.union([z.literal("standard"), z.literal("autoFactory"), z.literal("customFactory")]))();
var RouterTypeInput = (() => z.union([z.literal("none"), z.literal("plugin"), z.literal("dynamic")]))();
var DeploymentNetworkInput = (() => z.object({
  allNetworks: z.boolean().optional(),
  networksEnabled: z.array(z.number()).default([])
}))();
var ExtraPublishMetadataSchemaInput = (() => z.object({
  version: z.string().refine((v) => {
    try {
      toSemver(v);
      return true;
    } catch (e) {
      return false;
    }
  }, (out) => {
    return {
      message: `'${out}' is not a valid semantic version. Should be in the format of major.minor.patch. Ex: 0.4.1`
    };
  }),
  displayName: z.string().optional(),
  description: z.string().optional(),
  readme: z.string().optional(),
  license: z.string().optional(),
  changelog: z.string().optional(),
  tags: z.array(z.string()).optional(),
  audit: FileOrBufferOrStringSchema.nullable().optional(),
  logo: FileOrBufferOrStringSchema.nullable().optional(),
  isDeployableViaFactory: z.boolean().optional(),
  isDeployableViaProxy: z.boolean().optional(),
  factoryDeploymentData: FactoryDeploymentSchema.optional(),
  deployType: DeployTypeInput.optional(),
  routerType: RouterTypeInput.optional(),
  defaultExtensions: z.array(z.object({
    extensionName: z.string(),
    extensionVersion: z.string().default("latest"),
    publisherAddress: AddressOrEnsSchema
  })).optional(),
  networksForDeployment: DeploymentNetworkInput.optional(),
  constructorParams: z.record(z.string(), z.object({
    displayName: z.string().optional(),
    description: z.string().optional(),
    defaultValue: z.string().optional(),
    hidden: z.boolean().optional()
  }).catchall(z.any())).optional(),
  compositeAbi: AbiSchema.optional()
}).catchall(z.any()))();
var ExtraPublishMetadataSchemaOutput = (() => ExtraPublishMetadataSchemaInput.extend({
  audit: z.string().nullable().optional(),
  logo: z.string().nullable().optional()
}))();
var FullPublishMetadataSchemaInput = (() => PreDeployMetadata.merge(ExtraPublishMetadataSchemaInput).extend({
  publisher: AddressOrEnsSchema.optional()
}))();
var FullPublishMetadataSchemaOutput = (() => PreDeployMetadata.merge(ExtraPublishMetadataSchemaOutput).extend({
  publisher: AddressOrEnsSchema.optional()
}))();
var ProfileSchemaInput = (() => z.object({
  name: z.string().optional(),
  bio: z.string().optional(),
  avatar: FileOrBufferOrStringSchema.nullable().optional(),
  website: z.string().optional(),
  twitter: z.string().optional(),
  telegram: z.string().optional(),
  facebook: z.string().optional(),
  github: z.string().optional(),
  medium: z.string().optional(),
  linkedin: z.string().optional(),
  reddit: z.string().optional(),
  discord: z.string().optional()
}))();
var ProfileSchemaOutput = (() => ProfileSchemaInput.extend({
  avatar: z.string().nullable().optional()
}))();
var PublishedContractSchema = (() => z.object({
  id: z.string(),
  timestamp: BigNumberishSchema,
  metadataUri: z.string()
}))();
var ContractInfoSchema = (() => z.object({
  title: z.string().optional(),
  author: z.string().optional(),
  details: z.string().optional(),
  notice: z.string().optional()
}))();
var CompilerMetadataFetchedSchema = (() => z.object({
  name: z.string(),
  abi: AbiSchema,
  metadata: z.record(z.string(), z.any()),
  info: ContractInfoSchema,
  licenses: z.array(z.string().optional()).default([]).transform((v) => {
    return v.filter((license) => license !== void 0);
  }),
  isPartialAbi: z.boolean().optional()
}))();
var PreDeployMetadataFetchedSchema = (() => PreDeployMetadata.merge(CompilerMetadataFetchedSchema).extend({
  bytecode: z.string()
}))();
var CallOverrideSchema = (() => z.object({
  gasLimit: BigNumberishSchema.optional(),
  gasPrice: BigNumberishSchema.optional(),
  maxFeePerGas: BigNumberishSchema.optional(),
  maxPriorityFeePerGas: BigNumberishSchema.optional(),
  nonce: BigNumberishSchema.optional(),
  value: BigNumberishSchema.optional(),
  blockTag: z.union([z.string(), z.number()]).optional(),
  from: AddressOrEnsSchema.optional(),
  type: z.number().optional()
}).strict())();
var ContractEncoder = class {
  constructor(contractWrapper) {
    this.contractWrapper = contractWrapper;
  }
  /**
   * Encodes the given contract function with argument
   * @returns the encoded data
   */
  encode(fn, args) {
    return this.contractWrapper.readContract.interface.encodeFunctionData(fn, args);
  }
  /**
   * Decode encoded call data for a given function
   * @param fn - the function to decode
   * @param encodedArgs - the encoded arguments
   */
  decode(fn, encodedArgs) {
    return this.contractWrapper.readContract.interface.decodeFunctionData(fn, encodedArgs);
  }
};
var NotFoundError = class extends Error {
  /** @internal */
  constructor(identifier) {
    super(identifier ? `Object with id ${identifier} NOT FOUND` : "NOT_FOUND");
  }
};
var InvalidAddressError = class extends Error {
  /** @internal */
  constructor(address) {
    super(address ? `'${address}' is an invalid address` : "Invalid address passed");
  }
};
var MissingRoleError = class extends Error {
  /** @internal */
  /** @internal */
  constructor(address, role) {
    super(`MISSING ROLE: ${address} does not have the '${role}' role`);
  }
};
var AssetNotFoundError = class extends Error {
  /** @internal */
  /** @internal */
  constructor() {
    let message = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : "The asset you're trying to use could not be found.";
    super(`message: ${message}`);
  }
};
var UploadError = class extends Error {
  /** @internal */
  constructor(message) {
    super(`UPLOAD_FAILED: ${message}`);
  }
};
var FileNameMissingError = class extends Error {
  /** @internal */
  constructor() {
    super("File name is required when object is not a `File` type object.");
  }
};
var DuplicateFileNameError = class extends Error {
  /** @internal */
  constructor(fileName) {
    super(`DUPLICATE_FILE_NAME_ERROR: File name ${fileName} was passed for more than one file.`);
  }
};
var NotEnoughTokensError = class extends Error {
  /** @internal */
  constructor(contractAddress, quantity, available) {
    super(`BALANCE ERROR: you do not have enough balance on contract ${contractAddress} to use ${quantity} tokens. You have ${available} tokens available.`);
  }
};
var MissingOwnerRoleError = class extends Error {
  /** @internal */
  constructor() {
    super(`LIST ERROR: you should be the owner of the token to list it.`);
  }
};
var QuantityAboveLimitError = class extends Error {
  /** @internal */
  constructor(quantity) {
    super(`BUY ERROR: You cannot buy more than ${quantity} tokens`);
  }
};
var FetchError = class extends Error {
  /** @internal */
  constructor(message, innerError) {
    super(`FETCH_FAILED: ${message}`);
    this.innerError = innerError;
  }
};
var DuplicateLeafsError = class extends Error {
  constructor(message) {
    super(`DUPLICATE_LEAFS${message ? ` : ${message}` : ""}`);
  }
};
var AuctionAlreadyStartedError = class extends Error {
  constructor(id) {
    super(`Auction already started with existing bid${id ? `, id: ${id}` : ""}`);
  }
};
var FunctionDeprecatedError = class extends Error {
  /** @internal */
  constructor(message) {
    super(`FUNCTION DEPRECATED. ${message ? `Use ${message} instead` : ""}`);
  }
};
var ListingNotFoundError = class extends Error {
  constructor(marketplaceContractAddress, listingId) {
    super(`Could not find listing.${marketplaceContractAddress ? ` marketplace address: ${marketplaceContractAddress}` : ""}${listingId ? ` listing id: ${listingId}` : ""}`);
  }
};
var WrongListingTypeError = class extends Error {
  constructor(marketplaceContractAddress, listingId, actualType, expectedType) {
    super(`Incorrect listing type. Are you sure you're using the right method?.${marketplaceContractAddress ? ` marketplace address: ${marketplaceContractAddress}` : ""}${listingId ? ` listing id: ${listingId}` : ""}${expectedType ? ` expected type: ${expectedType}` : ""}${actualType ? ` actual type: ${actualType}` : ""}`);
  }
};
var RestrictedTransferError = class extends Error {
  constructor(assetAddress) {
    super(`Failed to transfer asset, transfer is restricted.${assetAddress ? ` Address : ${assetAddress}` : ""}`);
  }
};
var AdminRoleMissingError = class extends Error {
  constructor(address, contractAddress) {
    let message = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : "Failed to execute transaction";
    super(`${message}, admin role is missing${address ? ` on address: ${address}` : ""}${contractAddress ? ` on contract: ${contractAddress}` : ""}`);
  }
};
var AuctionHasNotEndedError = class extends Error {
  constructor(id, endTime) {
    super(`Auction has not ended yet${id ? `, id: ${id}` : ""}${endTime ? `, end time: ${endTime.toString()}` : ""}`);
  }
};
var ExtensionNotImplementedError = class extends Error {
  constructor(feature) {
    super(`This functionality is not available because the contract does not implement the '${feature.name}' Extension. Learn how to unlock this functionality at https://portal.thirdweb.com/extensions `);
  }
};
var _reason, _info, _raw;
var TransactionError = class extends Error {
  constructor(info, raw) {
    var _a;
    let errorMessage = `


╔═══════════════════╗
║ TRANSACTION ERROR ║
╚═══════════════════╝

`;
    errorMessage += `Reason: ${info.reason}`;
    errorMessage += `


╔═════════════════════════╗
║ TRANSACTION INFORMATION ║
╚═════════════════════════╝
`;
    errorMessage += withSpaces("from", info.from);
    if (info.to) {
      errorMessage += withSpaces("to", info.contractName ? `${info.to} (${info.contractName})` : info.to);
    }
    errorMessage += withSpaces(`chain`, `${info.network.name} (${info.network.chainId})`);
    if (info.rpcUrl) {
      try {
        const url = new URL(info.rpcUrl);
        errorMessage += withSpaces(`rpc`, url.hostname);
      } catch (e2) {
      }
    }
    if (info.hash) {
      errorMessage += withSpaces(`tx hash`, info.hash);
    }
    if (info.value && info.value.gt(0)) {
      errorMessage += withSpaces("value", `${utils_exports.formatEther(info.value)} ${((_a = NATIVE_TOKENS[info.network.chainId]) == null ? void 0 : _a.symbol) || ""}`);
    }
    errorMessage += withSpaces(`data`, `${info.data}`);
    if (info.method) {
      errorMessage += withSpaces("method", info.method);
    }
    if (info.sources) {
      const revertFile = info.sources.find((file) => file.source.includes(info.reason));
      if (revertFile) {
        const lines = revertFile.source.split("\n").map((line, index) => `${index + 1}  ${line}`);
        const revertLine = lines.findIndex((line) => line.includes(info.reason));
        lines[revertLine] += "   <-- REVERT";
        const errorLines = lines.slice(revertLine - 8, revertLine + 4);
        errorMessage += `


╔══════════════════════╗
║ SOLIDITY STACK TRACE ║
╚══════════════════════╝

`;
        errorMessage += `File: ${revertFile.filename.replace("node_modules/", "")}

`;
        errorMessage += errorLines.join("\n");
      }
    }
    errorMessage += `


╔═════════════════════╗
║ DEBUGGING RESOURCES ║
╚═════════════════════╝

`;
    errorMessage += `Need helping debugging? Join our Discord: https://discord.gg/thirdweb`;
    errorMessage += `

`;
    super(errorMessage);
    __privateAdd(this, _reason, void 0);
    __privateAdd(this, _info, void 0);
    __privateAdd(this, _raw, void 0);
    __privateSet(this, _reason, info.reason);
    __privateSet(this, _info, info);
    __privateSet(this, _raw, raw);
  }
  // Keep reason here for backwards compatibility
  get reason() {
    return __privateGet(this, _reason);
  }
  get raw() {
    return __privateGet(this, _raw);
  }
  get info() {
    return __privateGet(this, _info);
  }
};
_reason = new WeakMap();
_info = new WeakMap();
_raw = new WeakMap();
function parseRevertReason(error) {
  if (error.reason && !error.reason.includes("cannot estimate gas")) {
    return error.reason;
  }
  if (error.error) {
    return error.error;
  }
  let errorString = error;
  if (typeof error === "object") {
    errorString = JSON.stringify(error);
  } else if (typeof error !== "string") {
    errorString = error.toString();
  }
  return parseMessageParts(/.*?"message":"([^"\\]*).*?/, errorString) || parseMessageParts(/.*?"reason":"([^"\\]*).*?/, errorString) || error.message || "";
}
function withSpaces(label, content) {
  if (content === "") {
    return content;
  }
  const spaces = Array(10 - label.length).fill(" ").join("");
  if (content.includes("\n")) {
    content = "\n\n  " + content.split("\n").join(`
  `);
  } else {
    content = `${spaces}${content}`;
  }
  return `
${label}:${content}`;
}
function parseMessageParts(regex, raw) {
  const msgMatches = raw.match(regex) || [];
  let extracted = "";
  if ((msgMatches == null ? void 0 : msgMatches.length) > 0) {
    extracted += msgMatches[1];
  }
  return extracted;
}
function includesErrorMessage(err, message) {
  if (!err) {
    return false;
  }
  return err && err.toString().includes(message) || err && err.message && err.message.toString().includes(message) || err && err.error && err.error.toString().includes(message);
}
var FEATURE_TOKEN_CLAIM_CONDITIONS_V1 = {
  name: "ERC20ClaimConditionsV1",
  namespace: "token.drop.claim",
  docLinks: {
    sdk: "sdk.erc20dclaimable",
    contracts: "erc20claimconditions"
  },
  abis: [IERC20_default, IDropSinglePhase_V1_default],
  features: {}
};
var FEATURE_TOKEN_CLAIM_CONDITIONS_V2 = {
  name: "ERC20ClaimConditionsV2",
  namespace: "token.drop.claim",
  docLinks: {
    sdk: "sdk.erc20dclaimable",
    contracts: "erc20claimconditions"
  },
  abis: [IERC20_default, IDropSinglePhase_default],
  features: {}
};
var FEATURE_TOKEN_CLAIM_PHASES_V2 = {
  name: "ERC20ClaimPhasesV2",
  namespace: "token.drop.claim",
  docLinks: {
    sdk: "sdk.erc20dclaimable",
    contracts: "erc20claimphases"
  },
  abis: [IERC20_default, IDrop_default],
  features: {}
};
var FEATURE_TOKEN_CLAIM_PHASES_V1 = {
  name: "ERC20ClaimPhasesV1",
  namespace: "token.drop.claim",
  docLinks: {
    sdk: "sdk.erc20dclaimable",
    contracts: "erc20claimphases"
  },
  abis: [IDropERC20_V2_default],
  features: {}
};
var FEATURE_TOKEN_BURNABLE = {
  name: "ERC20Burnable",
  namespace: "token.burn",
  docLinks: {
    sdk: "sdk.erc20burnable",
    contracts: "erc20burnable"
  },
  abis: [IERC20_default, IBurnableERC20_default],
  features: {}
};
var FEATURE_TOKEN_SIGNATURE_MINTABLE = {
  name: "ERC20SignatureMintable",
  namespace: "token.signature",
  docLinks: {
    sdk: "sdk.erc20signaturemintable",
    contracts: "erc20signaturemint"
  },
  abis: [IERC20_default, ISignatureMintERC20_default],
  features: {}
};
var FEATURE_TOKEN_BATCH_MINTABLE = {
  name: "ERC20BatchMintable",
  namespace: "token.mint.batch",
  docLinks: {
    sdk: "sdk.erc20batchmintable",
    contracts: "erc20batchmintable"
  },
  abis: [IERC20_default, IMintableERC20_default, IMulticall_default],
  features: {}
};
var FEATURE_TOKEN_MINTABLE = {
  name: "ERC20Mintable",
  namespace: "token.mint",
  docLinks: {
    sdk: "sdk.erc20mintable",
    contracts: "erc20mintable"
  },
  abis: [IERC20_default, IMintableERC20_default],
  features: {
    [FEATURE_TOKEN_BATCH_MINTABLE.name]: FEATURE_TOKEN_BATCH_MINTABLE
  }
};
var FEATURE_TOKEN_PERMIT = {
  name: "ERC20Permit",
  namespace: "token.permit",
  docLinks: {
    sdk: "sdk.erc20permit",
    contracts: "erc20permit"
  },
  abis: [IERC20_default, IERC20Permit_default],
  features: {}
};
var FEATURE_TOKEN = {
  name: "ERC20",
  namespace: "token",
  docLinks: {
    sdk: "sdk.erc20",
    contracts: "erc20"
  },
  abis: [IERC20_default, IERC20Metadata_default],
  features: {
    [FEATURE_TOKEN_BURNABLE.name]: FEATURE_TOKEN_BURNABLE,
    [FEATURE_TOKEN_MINTABLE.name]: FEATURE_TOKEN_MINTABLE,
    [FEATURE_TOKEN_CLAIM_CONDITIONS_V1.name]: FEATURE_TOKEN_CLAIM_CONDITIONS_V1,
    [FEATURE_TOKEN_CLAIM_CONDITIONS_V2.name]: FEATURE_TOKEN_CLAIM_CONDITIONS_V2,
    [FEATURE_TOKEN_CLAIM_PHASES_V1.name]: FEATURE_TOKEN_CLAIM_PHASES_V1,
    [FEATURE_TOKEN_CLAIM_PHASES_V2.name]: FEATURE_TOKEN_CLAIM_PHASES_V2,
    [FEATURE_TOKEN_SIGNATURE_MINTABLE.name]: FEATURE_TOKEN_SIGNATURE_MINTABLE,
    [FEATURE_TOKEN_PERMIT.name]: FEATURE_TOKEN_PERMIT
  }
};
var FEATURE_NFT_BURNABLE = {
  name: "ERC721Burnable",
  namespace: "nft.burn",
  docLinks: {
    sdk: "sdk.erc721burnable",
    contracts: "erc721burnable"
  },
  abis: [IERC721_default, IBurnableERC721_default],
  features: {}
};
var FEATURE_NFT_REVEALABLE = {
  name: "ERC721Revealable",
  namespace: "nft.drop.revealer",
  docLinks: {
    sdk: "sdk.delayedreveal",
    contracts: "erc721revealable"
  },
  abis: [IERC721_default, ILazyMint_default, IDelayedReveal_default],
  features: {}
};
var FEATURE_NFT_TIERED_DROP = {
  name: "ERC721TieredDrop",
  namespace: "nft.tieredDrop",
  docLinks: {
    sdk: "sdk.erc721tiereddrop",
    //TODO
    contracts: ""
  },
  abis: [IERC721_default, LazyMintWithTier_default],
  features: {}
};
var FEATURE_NFT_CLAIM_CONDITIONS_V1 = {
  name: "ERC721ClaimConditionsV1",
  namespace: "nft.drop.claim",
  docLinks: {
    sdk: "sdk.erc721claimable",
    contracts: "erc721claimconditions"
  },
  abis: [IERC721_default, IDropSinglePhase_V1_default],
  features: {}
};
var FEATURE_NFT_CLAIM_CONDITIONS_V2 = {
  name: "ERC721ClaimConditionsV2",
  namespace: "nft.drop.claim",
  docLinks: {
    sdk: "sdk.erc721claimable",
    contracts: "erc721claimconditions"
  },
  abis: [IERC721_default, IDropSinglePhase_default],
  features: {}
};
var FEATURE_NFT_CLAIM_PHASES_V1 = {
  name: "ERC721ClaimPhasesV1",
  namespace: "nft.drop.claim",
  docLinks: {
    sdk: "sdk.erc721claimable",
    contracts: "erc721claimphases"
  },
  abis: [IDropERC721_V3_default],
  features: {}
};
var FEATURE_NFT_CLAIM_PHASES_V2 = {
  name: "ERC721ClaimPhasesV2",
  namespace: "nft.drop.claim",
  docLinks: {
    sdk: "sdk.erc721claimable",
    contracts: "erc721claimphases"
  },
  abis: [IERC721_default, IDrop_default],
  features: {}
};
var FEATURE_NFT_CLAIM_CUSTOM = {
  name: "ERC721ClaimCustom",
  namespace: "nft.drop.claim",
  docLinks: {
    sdk: "sdk.erc721claimable",
    contracts: "erc721claimcustom"
  },
  abis: [IERC721_default, IClaimableERC721_default],
  features: {}
};
var FEATURE_NFT_CLAIM_ZORA = {
  name: "ERC721ClaimZora",
  namespace: "nft.drop.claim",
  docLinks: {
    sdk: "sdk.erc721claimable",
    contracts: "erc721claimzora"
  },
  abis: [IERC721_default, zora_IERC721Drop_default],
  features: {}
};
var FEATURE_NFT_LAZY_MINTABLE = {
  name: "ERC721LazyMintable",
  namespace: "nft.drop",
  docLinks: {
    sdk: "sdk.erc721lazymintable",
    contracts: "lazymint"
  },
  abis: [IERC721_default, ILazyMint_default],
  features: {
    [FEATURE_NFT_REVEALABLE.name]: FEATURE_NFT_REVEALABLE
  }
};
var FEATURE_NFT_BATCH_MINTABLE = {
  name: "ERC721BatchMintable",
  namespace: "nft.mint.batch",
  docLinks: {
    sdk: "sdk.erc721batchmintable",
    contracts: "erc721batchmintable"
  },
  abis: [IERC721_default, IMintableERC721_default, IMulticall_default],
  features: {}
};
var FEATURE_NFT_MINTABLE = {
  name: "ERC721Mintable",
  namespace: "nft.mint",
  docLinks: {
    sdk: "sdk.erc721mintable",
    contracts: "erc721mintable"
  },
  abis: [IERC721_default, IMintableERC721_default],
  features: {
    [FEATURE_NFT_BATCH_MINTABLE.name]: FEATURE_NFT_BATCH_MINTABLE
  }
};
var FEATURE_NFT_SIGNATURE_MINTABLE_V2 = {
  name: "ERC721SignatureMintV2",
  namespace: "nft.signature",
  docLinks: {
    sdk: "sdk.erc721signaturemint",
    contracts: "erc721signaturemint"
  },
  abis: [IERC721_default, ISignatureMintERC721_default],
  features: {}
};
var FEATURE_NFT_SIGNATURE_MINTABLE_V1 = {
  name: "ERC721SignatureMintV1",
  namespace: "nft.signature",
  docLinks: {
    sdk: "sdk.erc721signaturemint",
    contracts: "erc721signaturemint"
  },
  abis: [ISignatureMintERC721_V1_default],
  features: {}
};
var FEATURE_NFT_ENUMERABLE = {
  name: "ERC721Enumerable",
  namespace: "nft.query.owned",
  docLinks: {
    sdk: "sdk.erc721enumerable",
    contracts: "erc721enumerable"
  },
  abis: [IERC721_default, IERC721Enumerable_default],
  features: {}
};
var FEATURE_NFT_QUERYABLE = {
  name: "ERC721AQueryable",
  namespace: "nft.query.owned",
  docLinks: {
    sdk: "",
    contracts: ""
  },
  abis: [IERC721AQueryableUpgradeable_default],
  features: {}
};
var FEATURE_NFT_SUPPLY = {
  name: "ERC721Supply",
  namespace: "nft.query",
  docLinks: {
    sdk: "sdk.erc721supply",
    contracts: "erc721supply"
  },
  abis: [IERC721_default, IERC721Supply_default],
  features: {
    [FEATURE_NFT_ENUMERABLE.name]: FEATURE_NFT_ENUMERABLE,
    [FEATURE_NFT_QUERYABLE.name]: FEATURE_NFT_QUERYABLE
  }
};
var FEATURE_NFT_SHARED_METADATA = {
  name: "ERC721SharedMetadata",
  namespace: "nft.sharedmetadata",
  docLinks: {
    sdk: "sdk.sharedmetadata",
    contracts: "SharedMetadata"
  },
  abis: [IERC721_default, SharedMetadata_default],
  features: {}
};
var FEATURE_NFT_LOYALTY_CARD = {
  name: "ERC721LoyaltyCard",
  namespace: "nft.loyaltyCard",
  docLinks: {
    // TODO
    sdk: "",
    contracts: ""
  },
  abis: [ILoyaltyCard_default],
  features: {}
};
var FEATURE_NFT_UPDATABLE_METADATA = {
  name: "ERC721UpdatableMetadata",
  namespace: "nft.metadata",
  docLinks: {
    // TODO
    sdk: "",
    contracts: ""
  },
  abis: [IERC721_default, INFTMetadata_default],
  features: {}
};
var FEATURE_NFT = {
  name: "ERC721",
  namespace: "nft",
  docLinks: {
    sdk: "sdk.erc721",
    contracts: "erc721"
  },
  abis: [IERC721_default, IERC721Metadata_default],
  features: {
    [FEATURE_NFT_BURNABLE.name]: FEATURE_NFT_BURNABLE,
    [FEATURE_NFT_SUPPLY.name]: FEATURE_NFT_SUPPLY,
    [FEATURE_NFT_MINTABLE.name]: FEATURE_NFT_MINTABLE,
    [FEATURE_NFT_LAZY_MINTABLE.name]: FEATURE_NFT_LAZY_MINTABLE,
    [FEATURE_NFT_SIGNATURE_MINTABLE_V1.name]: FEATURE_NFT_SIGNATURE_MINTABLE_V1,
    [FEATURE_NFT_SIGNATURE_MINTABLE_V2.name]: FEATURE_NFT_SIGNATURE_MINTABLE_V2,
    [FEATURE_NFT_TIERED_DROP.name]: FEATURE_NFT_TIERED_DROP,
    [FEATURE_NFT_CLAIM_CUSTOM.name]: FEATURE_NFT_CLAIM_CUSTOM,
    [FEATURE_NFT_CLAIM_ZORA.name]: FEATURE_NFT_CLAIM_ZORA,
    [FEATURE_NFT_CLAIM_CONDITIONS_V1.name]: FEATURE_NFT_CLAIM_CONDITIONS_V1,
    [FEATURE_NFT_CLAIM_CONDITIONS_V2.name]: FEATURE_NFT_CLAIM_CONDITIONS_V2,
    [FEATURE_NFT_CLAIM_PHASES_V1.name]: FEATURE_NFT_CLAIM_PHASES_V1,
    [FEATURE_NFT_CLAIM_PHASES_V2.name]: FEATURE_NFT_CLAIM_PHASES_V2,
    [FEATURE_NFT_SHARED_METADATA.name]: FEATURE_NFT_SHARED_METADATA,
    [FEATURE_NFT_LOYALTY_CARD.name]: FEATURE_NFT_LOYALTY_CARD,
    [FEATURE_NFT_UPDATABLE_METADATA.name]: FEATURE_NFT_UPDATABLE_METADATA
  }
};
var NAME_SYMBOL_ABI = [{
  inputs: [],
  name: "name",
  outputs: [{
    internalType: "string",
    name: "",
    type: "string"
  }],
  stateMutability: "view",
  type: "function"
}, {
  inputs: [],
  name: "symbol",
  outputs: [{
    internalType: "string",
    name: "",
    type: "string"
  }],
  stateMutability: "view",
  type: "function"
}];
var FEATURE_EDITION_BURNABLE = {
  name: "ERC1155Burnable",
  namespace: "edition.burn",
  docLinks: {
    sdk: "sdk.erc1155burnable",
    contracts: "erc1155burnable"
  },
  abis: [IERC1155_default, IBurnableERC1155_default],
  features: {}
};
var FEATURE_EDITION_CLAIM_CONDITIONS_V1 = {
  name: "ERC1155ClaimConditionsV1",
  namespace: "edition.drop.claim",
  docLinks: {
    sdk: "sdk.erc1155claimable",
    contracts: "erc1155dropsinglephase"
  },
  abis: [IERC1155_default, IDropSinglePhase1155_V1_default],
  features: {}
};
var FEATURE_EDITION_CLAIM_CONDITIONS_V2 = {
  name: "ERC1155ClaimConditionsV2",
  namespace: "edition.drop.claim",
  docLinks: {
    sdk: "sdk.erc1155claimable",
    contracts: "erc1155claimconditions"
  },
  abis: [IERC1155_default, IDropSinglePhase1155_default],
  features: {}
};
var FEATURE_EDITION_CLAIM_PHASES_V2 = {
  name: "ERC1155ClaimPhasesV2",
  namespace: "edition.drop.claim",
  docLinks: {
    sdk: "sdk.erc1155claimable",
    contracts: "erc1155claimphases"
  },
  abis: [IERC1155_default, IDrop1155_default],
  features: {}
};
var FEATURE_EDITION_CLAIM_PHASES_V1 = {
  name: "ERC1155ClaimPhasesV1",
  namespace: "edition.drop.claim",
  docLinks: {
    sdk: "sdk.erc1155claimable",
    contracts: "erc1155claimphases"
  },
  abis: [IDropERC1155_V2_default],
  features: {}
};
var FEATURE_EDITION_CLAIM_CUSTOM = {
  name: "ERC1155ClaimCustom",
  namespace: "edition.drop.claim",
  docLinks: {
    sdk: "sdk.erc1155claimable",
    contracts: "erc1155claimcustom"
  },
  abis: [IERC1155_default, IClaimableERC1155_default],
  features: {}
};
var FEATURE_EDITION_REVEALABLE = {
  name: "ERC1155Revealable",
  namespace: "edition.drop.revealer",
  docLinks: {
    sdk: "sdk.drop.delayedreveal",
    contracts: "erc1155revealable"
  },
  abis: [IERC1155_default, ILazyMint_default, IDelayedReveal_default],
  features: {}
};
var FEATURE_EDITION_LAZY_MINTABLE_V2 = {
  name: "ERC1155LazyMintableV2",
  namespace: "edition.drop",
  docLinks: {
    sdk: "sdk.erc1155droppable",
    contracts: "lazymint"
  },
  abis: [IERC1155_default, ILazyMint_default],
  features: {
    [FEATURE_EDITION_REVEALABLE.name]: FEATURE_EDITION_REVEALABLE
  }
};
var FEATURE_EDITION_LAZY_MINTABLE_V1 = {
  name: "ERC1155LazyMintableV1",
  namespace: "edition.drop",
  docLinks: {
    sdk: "sdk.erc1155droppable",
    contracts: "lazymint"
  },
  abis: [IDropERC1155_V2_default],
  features: {
    [FEATURE_EDITION_CLAIM_PHASES_V1.name]: FEATURE_EDITION_CLAIM_PHASES_V1
  }
};
var FEATURE_EDITION_SIGNATURE_MINTABLE = {
  name: "ERC1155SignatureMintable",
  namespace: "edition.signature",
  docLinks: {
    sdk: "sdk.erc1155signaturemintable",
    contracts: "erc1155signaturemint"
  },
  abis: [IERC1155_default, ISignatureMintERC1155_default],
  features: {}
};
var FEATURE_EDITION_BATCH_MINTABLE = {
  name: "ERC1155BatchMintable",
  namespace: "edition.mint.batch",
  docLinks: {
    sdk: "sdk.erc1155batchmintable",
    contracts: "erc1155batchmintable"
  },
  abis: [IERC1155_default, IMintableERC1155_default, IMulticall_default],
  features: {}
};
var FEATURE_EDITION_MINTABLE = {
  name: "ERC1155Mintable",
  namespace: "edition.mint",
  docLinks: {
    sdk: "sdk.erc1155mintable",
    contracts: "erc1155mintable"
  },
  abis: [IERC1155_default, IMintableERC1155_default],
  features: {
    [FEATURE_EDITION_BATCH_MINTABLE.name]: FEATURE_EDITION_BATCH_MINTABLE
  }
};
var FEATURE_EDITION_ENUMERABLE = {
  name: "ERC1155Enumerable",
  namespace: "edition.query",
  docLinks: {
    sdk: "sdk.erc1155",
    contracts: "erc1155enumerable"
  },
  abis: [IERC1155_default, IERC1155Enumerable_default],
  features: {}
};
var FEATURE_EDITION_UPDATABLE_METADATA = {
  name: "ERC1155UpdatableMetadata",
  namespace: "edition.metadata",
  docLinks: {
    // TODO
    sdk: "",
    contracts: ""
  },
  abis: [IERC1155_default, INFTMetadata_default],
  features: {}
};
var FEATURE_EDITION_SUPPLY = {
  name: "ERC1155Supply",
  namespace: "edition.supply",
  docLinks: {
    sdk: "",
    contracts: ""
  },
  abis: [IERC1155_default, IERC1155Supply_default],
  features: {}
};
var FEATURE_EDITION = {
  name: "ERC1155",
  namespace: "edition",
  docLinks: {
    sdk: "sdk.erc1155enumerable",
    contracts: "erc1155"
  },
  abis: [IERC1155_default, IERC1155Metadata_default, NAME_SYMBOL_ABI],
  features: {
    [FEATURE_EDITION_SUPPLY.name]: FEATURE_EDITION_SUPPLY,
    [FEATURE_EDITION_BURNABLE.name]: FEATURE_EDITION_BURNABLE,
    [FEATURE_EDITION_ENUMERABLE.name]: FEATURE_EDITION_ENUMERABLE,
    [FEATURE_EDITION_MINTABLE.name]: FEATURE_EDITION_MINTABLE,
    [FEATURE_EDITION_LAZY_MINTABLE_V1.name]: FEATURE_EDITION_LAZY_MINTABLE_V1,
    [FEATURE_EDITION_LAZY_MINTABLE_V2.name]: FEATURE_EDITION_LAZY_MINTABLE_V2,
    [FEATURE_EDITION_REVEALABLE.name]: FEATURE_EDITION_REVEALABLE,
    [FEATURE_EDITION_SIGNATURE_MINTABLE.name]: FEATURE_EDITION_SIGNATURE_MINTABLE,
    [FEATURE_EDITION_CLAIM_CUSTOM.name]: FEATURE_EDITION_CLAIM_CUSTOM,
    [FEATURE_EDITION_CLAIM_CONDITIONS_V1.name]: FEATURE_EDITION_CLAIM_CONDITIONS_V1,
    [FEATURE_EDITION_CLAIM_CONDITIONS_V2.name]: FEATURE_EDITION_CLAIM_CONDITIONS_V2,
    [FEATURE_EDITION_CLAIM_PHASES_V2.name]: FEATURE_EDITION_CLAIM_PHASES_V2,
    [FEATURE_EDITION_UPDATABLE_METADATA.name]: FEATURE_EDITION_UPDATABLE_METADATA
  }
};
var getAllPluginsAbi = [{
  inputs: [],
  name: "getAllPlugins",
  outputs: [{
    components: [{
      internalType: "bytes4",
      name: "functionSelector",
      type: "bytes4"
    }, {
      internalType: "string",
      name: "functionSignature",
      type: "string"
    }, {
      internalType: "address",
      name: "pluginAddress",
      type: "address"
    }],
    internalType: "struct IPluginMap.Plugin[]",
    name: "registered",
    type: "tuple[]"
  }],
  stateMutability: "view",
  type: "function"
}];
var getAllExtensionsAbi = [{
  inputs: [],
  name: "getAllExtensions",
  outputs: [{
    components: [{
      components: [{
        internalType: "string",
        name: "name",
        type: "string"
      }, {
        internalType: "string",
        name: "metadataURI",
        type: "string"
      }, {
        internalType: "address",
        name: "implementation",
        type: "address"
      }],
      internalType: "struct IExtension.ExtensionMetadata",
      name: "metadata",
      type: "tuple"
    }, {
      components: [{
        internalType: "bytes4",
        name: "functionSelector",
        type: "bytes4"
      }, {
        internalType: "string",
        name: "functionSignature",
        type: "string"
      }],
      internalType: "struct IExtension.ExtensionFunction[]",
      name: "functions",
      type: "tuple[]"
    }],
    internalType: "struct IExtension.Extension[]",
    name: "allExtensions",
    type: "tuple[]"
  }],
  stateMutability: "view",
  type: "function"
}];
var FEATURE_ROYALTY = {
  name: "Royalty",
  namespace: "royalty",
  docLinks: {
    sdk: "sdk.contractroyalty",
    contracts: "royalty"
  },
  abis: [IRoyalty_default],
  features: {}
};
var FEATURE_PRIMARY_SALE = {
  name: "PrimarySale",
  namespace: "sales",
  docLinks: {
    sdk: "sdk.contractprimarysale",
    contracts: "primarysale"
  },
  abis: [IPrimarySale_default],
  features: {}
};
var FEATURE_PLATFORM_FEE = {
  name: "PlatformFee",
  namespace: "platformFees",
  docLinks: {
    sdk: "sdk.platformfee",
    contracts: "platformfee"
  },
  abis: [IPlatformFee_default],
  features: {}
};
var FEATURE_PERMISSIONS_ENUMERABLE = {
  name: "PermissionsEnumerable",
  namespace: "roles",
  docLinks: {
    sdk: "sdk.contractroles",
    contracts: "permissionsenumerable"
  },
  abis: [IPermissionsEnumerable_default],
  features: {}
};
var FEATURE_PERMISSIONS = {
  name: "Permissions",
  namespace: "roles",
  docLinks: {
    sdk: "sdk.contractroles",
    contracts: "permissions"
  },
  abis: [IPermissions_default],
  features: {
    [FEATURE_PERMISSIONS_ENUMERABLE.name]: FEATURE_PERMISSIONS_ENUMERABLE
  }
};
var FEATURE_METADATA = {
  name: "ContractMetadata",
  namespace: "metadata",
  docLinks: {
    sdk: "sdk.contractmetadata",
    contracts: "contractmetadata"
  },
  abis: [IContractMetadata_default],
  features: {}
};
var FEATURE_APPURI = {
  name: "AppURI",
  namespace: "appURI",
  docLinks: {
    sdk: "sdk.appURI",
    //TODO
    contracts: ""
  },
  abis: [IAppURI_default],
  features: {}
};
var FEATURE_OWNER = {
  name: "Ownable",
  namespace: "owner",
  docLinks: {
    sdk: "sdk.owner",
    contracts: "ownable"
  },
  abis: [Ownable_default],
  features: {}
};
var FEATURE_GASLESS = {
  name: "Gasless",
  namespace: "gasless",
  docLinks: {
    sdk: "sdk.gaslesstransaction",
    // TODO add the correct name for this once it's added to portal
    contracts: "IERC2771Context"
  },
  abis: [IERC2771Context_default],
  features: {}
};
var FEATURE_PACK_VRF = {
  name: "PackVRF",
  namespace: "pack.vrf",
  docLinks: {
    sdk: "sdk.packvrf",
    //TODO
    contracts: "IPackVRF"
  },
  abis: [IPackVRFDirect_default],
  features: {}
};
var FEATURE_PLUGIN_ROUTER = {
  name: "PluginRouter",
  namespace: "plugin.router",
  docLinks: {
    sdk: "sdk.pluginrouter",
    //TODO
    contracts: "PluginRouter"
  },
  abis: [getAllPluginsAbi],
  features: {}
};
var FEATURE_DYNAMIC_CONTRACT = {
  name: "DynamicContract",
  namespace: "dynamic.contract",
  docLinks: {
    sdk: "",
    //TODO
    contracts: "IExtensionsManager"
  },
  abis: [getAllExtensionsAbi],
  features: {}
};
var FEATURE_DIRECT_LISTINGS = {
  name: "DirectListings",
  namespace: "direct.listings",
  docLinks: {
    // TODO
    sdk: "",
    contracts: "IDirectListings"
  },
  abis: [IDirectListings_default],
  features: {}
};
var FEATURE_ENGLISH_AUCTIONS = {
  name: "EnglishAuctions",
  namespace: "english.auctions",
  docLinks: {
    // TODO
    sdk: "",
    contracts: "IEnglishAuctions"
  },
  abis: [IEnglishAuctions_default],
  features: {}
};
var FEATURE_OFFERS = {
  name: "Offers",
  namespace: "offers",
  docLinks: {
    // TODO
    sdk: "",
    contracts: "IOffers"
  },
  abis: [IOffers_default],
  features: {}
};
var FEATURE_ACCOUNT_FACTORY = {
  name: "AccountFactory",
  namespace: "accountFactory",
  docLinks: {
    // TODO
    sdk: "sdk.accountFactory",
    contracts: "IAccountFactory"
  },
  abis: [IAccountFactoryCore_default],
  features: {}
};
var FEATURE_ACCOUNT_PERMISSIONS = {
  name: "AccountPermissions",
  namespace: "accountPermissions",
  docLinks: {
    // TODO
    sdk: "sdk.account",
    contracts: "IAccountPermissions"
  },
  abis: [IAccountPermissions_default],
  features: {}
};
var FEATURE_ACCOUNT = {
  name: "Account",
  namespace: "account",
  docLinks: {
    // TODO
    sdk: "sdk.account",
    contracts: "IAccount"
  },
  abis: [IAccount_default],
  features: {
    [FEATURE_ACCOUNT_PERMISSIONS.name]: FEATURE_ACCOUNT_PERMISSIONS
  }
};
var FEATURE_AIRDROP_ERC20 = {
  name: "AirdropERC20",
  namespace: "airdrop20",
  docLinks: {
    // TODO
    sdk: "",
    contracts: "IAirdropERC20"
  },
  abis: [IAirdropERC20_default],
  features: {}
};
var FEATURE_AIRDROP_ERC721 = {
  name: "AirdropERC721",
  namespace: "airdrop721",
  docLinks: {
    // TODO
    sdk: "",
    contracts: "IAirdropERC721"
  },
  abis: [IAirdropERC721_default],
  features: {}
};
var FEATURE_AIRDROP_ERC1155 = {
  name: "AirdropERC1155",
  namespace: "airdrop1155",
  docLinks: {
    // TODO
    sdk: "",
    contracts: "IAirdropERC1155"
  },
  abis: [IAirdropERC1155_default],
  features: {}
};
var SUPPORTED_FEATURES = {
  [FEATURE_TOKEN.name]: FEATURE_TOKEN,
  [FEATURE_NFT.name]: FEATURE_NFT,
  [FEATURE_EDITION.name]: FEATURE_EDITION,
  [FEATURE_ROYALTY.name]: FEATURE_ROYALTY,
  [FEATURE_PLATFORM_FEE.name]: FEATURE_PLATFORM_FEE,
  [FEATURE_PRIMARY_SALE.name]: FEATURE_PRIMARY_SALE,
  [FEATURE_PERMISSIONS.name]: FEATURE_PERMISSIONS,
  [FEATURE_METADATA.name]: FEATURE_METADATA,
  [FEATURE_APPURI.name]: FEATURE_APPURI,
  [FEATURE_OWNER.name]: FEATURE_OWNER,
  [FEATURE_GASLESS.name]: FEATURE_GASLESS,
  [FEATURE_PACK_VRF.name]: FEATURE_PACK_VRF,
  [FEATURE_PLUGIN_ROUTER.name]: FEATURE_PLUGIN_ROUTER,
  [FEATURE_DYNAMIC_CONTRACT.name]: FEATURE_DYNAMIC_CONTRACT,
  [FEATURE_DIRECT_LISTINGS.name]: FEATURE_DIRECT_LISTINGS,
  [FEATURE_ENGLISH_AUCTIONS.name]: FEATURE_ENGLISH_AUCTIONS,
  [FEATURE_OFFERS.name]: FEATURE_OFFERS,
  [FEATURE_AIRDROP_ERC20.name]: FEATURE_AIRDROP_ERC20,
  [FEATURE_AIRDROP_ERC721.name]: FEATURE_AIRDROP_ERC721,
  [FEATURE_AIRDROP_ERC1155.name]: FEATURE_AIRDROP_ERC1155,
  [FEATURE_ACCOUNT_FACTORY.name]: FEATURE_ACCOUNT_FACTORY,
  [FEATURE_ACCOUNT.name]: FEATURE_ACCOUNT,
  [FEATURE_NFT_LOYALTY_CARD.name]: FEATURE_NFT_LOYALTY_CARD,
  [FEATURE_NFT_UPDATABLE_METADATA.name]: FEATURE_NFT_UPDATABLE_METADATA
};
function toJSType(contractType) {
  let isReturnType = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : false;
  let withName = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : false;
  let jsType = contractType.type;
  let isArray = false;
  if (jsType.endsWith("[]")) {
    isArray = true;
    jsType = jsType.slice(0, -2);
  }
  if (jsType.startsWith("bytes")) {
    jsType = "BytesLike";
  }
  if (jsType.startsWith("uint") || jsType.startsWith("int")) {
    jsType = isReturnType ? "BigNumber" : "BigNumberish";
  }
  if (jsType.startsWith("bool")) {
    jsType = "boolean";
  }
  if (jsType === "address") {
    jsType = "string";
  }
  if (jsType === "tuple") {
    if (contractType.components) {
      jsType = `{ ${contractType.components.map((a) => toJSType(a, false, true)).join(", ")} }`;
    }
  }
  if (isArray) {
    jsType += "[]";
  }
  if (withName) {
    jsType = `${contractType.name}: ${jsType}`;
  }
  return jsType;
}
function extractCommentFromMetadata(name, metadata, type) {
  var _a, _b, _c, _d, _e, _f, _g, _h, _i, _j;
  return ((_e = (_d = (_b = (_a = metadata == null ? void 0 : metadata.output) == null ? void 0 : _a.userdoc) == null ? void 0 : _b[type]) == null ? void 0 : _d[Object.keys(((_c = metadata == null ? void 0 : metadata.output) == null ? void 0 : _c.userdoc[type]) || {}).find((fn) => fn.includes(name || "unknown")) || ""]) == null ? void 0 : _e.notice) || ((_j = (_i = (_g = (_f = metadata == null ? void 0 : metadata.output) == null ? void 0 : _f.devdoc) == null ? void 0 : _g[type]) == null ? void 0 : _i[Object.keys(((_h = metadata == null ? void 0 : metadata.output) == null ? void 0 : _h.devdoc[type]) || {}).find((fn) => fn.includes(name || "unknown")) || ""]) == null ? void 0 : _j.details);
}
function extractFunctionsFromAbi(abi, metadata) {
  var _a, _b, _c, _d;
  const functions = (abi || []).filter((el) => el.type === "function");
  const parsed = [];
  for (const f2 of functions) {
    const doc = extractCommentFromMetadata(f2.name, metadata, "methods");
    const args = ((_b = (_a = f2.inputs) == null ? void 0 : _a.map((i) => `${i.name || "key"}: ${toJSType(i)}`)) == null ? void 0 : _b.join(", ")) || "";
    const fargs = args ? `, [${args}]` : "";
    const out = (_d = (_c = f2.outputs) == null ? void 0 : _c.map((o) => toJSType(o, true))) == null ? void 0 : _d.join(", ");
    const promise = out ? `: Promise<${out}>` : `: Promise<TransactionResult>`;
    const signature = `contract.call("${f2.name}"${fargs})${promise}`;
    parsed.push({
      // eslint-disable-next-line @typescript-eslint/ban-ts-comment
      // @ts-ignore we know AbiTypeBaseSchema.name is not going to be undefined since we're doing `.default("")`
      inputs: f2.inputs || [],
      // eslint-disable-next-line @typescript-eslint/ban-ts-comment
      // @ts-ignore we know the AbiTypeBaseSchema.name is not going to be undefined since we're doing `.default("")`
      outputs: f2.outputs || [],
      name: f2.name || "unknown",
      signature,
      stateMutability: f2.stateMutability || "",
      comment: doc
    });
  }
  return parsed;
}
function hasMatchingAbi(contractAbi, featureAbis) {
  const contractFn = extractFunctionsFromAbi(contractAbi);
  const interfaceFn = featureAbis.flatMap((i) => extractFunctionsFromAbi(i));
  const intersection = contractFn.filter((fn) => {
    const match = interfaceFn.find((iFn) => iFn.name === fn.name && iFn.inputs.length === fn.inputs.length && iFn.inputs.every((i, index) => {
      var _a;
      if (i.type === "tuple" || i.type === "tuple[]") {
        return i.type === fn.inputs[index].type && ((_a = i.components) == null ? void 0 : _a.every((c, cIndex) => {
          var _a2, _b;
          return c.type === ((_b = (_a2 = fn.inputs[index].components) == null ? void 0 : _a2[cIndex]) == null ? void 0 : _b.type);
        }));
      }
      return i.type === fn.inputs[index].type;
    }));
    return match !== void 0;
  });
  return intersection.length === interfaceFn.length;
}
function matchesAbiFromBytecode(contractBytecode, featureAbis) {
  const interfaces = featureAbis.map((abi) => new import_utils.Interface(abi));
  const selectors = interfaces.flatMap((i) => {
    return Object.values(i.functions).map((fn) => Number(i.getSighash(fn)).toString(16));
  });
  const uniqueSelectors = [...new Set(selectors)];
  return uniqueSelectors.every((selector) => contractBytecode.includes(selector));
}
function detectFeatures(abi) {
  let features = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : SUPPORTED_FEATURES;
  const results = {};
  for (const featureKey in features) {
    const feature = features[featureKey];
    const enabled = matchesAbiInterface(abi, feature);
    const childResults = detectFeatures(abi, feature.features);
    results[featureKey] = {
      ...feature,
      features: childResults,
      enabled
    };
  }
  return results;
}
function detectFeaturesFromBytecode(bytecode2) {
  let features = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : SUPPORTED_FEATURES;
  const results = {};
  for (const featureKey in features) {
    const feature = features[featureKey];
    const enabled = matchesAbiFromBytecode(bytecode2, feature.abis);
    const childResults = detectFeaturesFromBytecode(bytecode2, feature.features);
    results[featureKey] = {
      ...feature,
      features: childResults,
      enabled
    };
  }
  return results;
}
function matchesAbiInterface(abi, feature) {
  return hasMatchingAbi(abi, feature.abis);
}
function isFeatureEnabled(abi, featureName) {
  const features = detectFeatures(abi);
  return _featureEnabled(features, featureName);
}
function isExtensionEnabled(abi, featureName) {
  return isFeatureEnabled(abi, featureName);
}
function _featureEnabled(features, featureName) {
  const keys = Object.keys(features);
  if (!keys.includes(featureName)) {
    let found = false;
    for (const key of keys) {
      const f2 = features[key];
      found = _featureEnabled(f2.features, featureName);
      if (found) {
        break;
      }
    }
    return found;
  }
  const feature = features[featureName];
  return feature.enabled;
}
function detectContractFeature(contractWrapper, featureName) {
  return isExtensionEnabled(AbiSchema.parse(contractWrapper.abi), featureName);
}
function hasFunction(functionName, contractWrapper) {
  return functionName in contractWrapper.readContract.functions;
}
var decoder;
try {
  decoder = new TextDecoder();
} catch (error) {
}
var src;
var srcEnd;
var position = 0;
var LEGACY_RECORD_INLINE_ID = 105;
var RECORD_DEFINITIONS_ID = 57342;
var RECORD_INLINE_ID = 57343;
var BUNDLED_STRINGS_ID = 57337;
var PACKED_REFERENCE_TAG_ID = 6;
var STOP_CODE = {};
var currentDecoder = {};
var currentStructures;
var srcString;
var srcStringStart = 0;
var srcStringEnd = 0;
var bundledStrings;
var referenceMap;
var currentExtensions = [];
var currentExtensionRanges = [];
var packedValues;
var dataView;
var restoreMapsAsObject;
var defaultOptions = {
  useRecords: false,
  mapsAsObjects: true
};
var sequentialMode = false;
var Decoder = class _Decoder {
  constructor(options) {
    if (options) {
      if ((options.keyMap || options._keyMap) && !options.useRecords) {
        options.useRecords = false;
        options.mapsAsObjects = true;
      }
      if (options.useRecords === false && options.mapsAsObjects === void 0) {
        options.mapsAsObjects = true;
      }
      if (options.getStructures) {
        options.getShared = options.getStructures;
      }
      if (options.getShared && !options.structures) {
        (options.structures = []).uninitialized = true;
      }
      if (options.keyMap) {
        this.mapKey = /* @__PURE__ */ new Map();
        for (let [k, v] of Object.entries(options.keyMap)) {
          this.mapKey.set(v, k);
        }
      }
    }
    Object.assign(this, options);
  }
  decodeKey(key) {
    return this.keyMap ? this.mapKey.get(key) || key : key;
  }
  decode(source, end) {
    if (src) {
      return saveState(() => {
        clearSource();
        return this ? this.decode(source, end) : _Decoder.prototype.decode.call(defaultOptions, source, end);
      });
    }
    srcEnd = end > -1 ? end : source.length;
    position = 0;
    srcStringEnd = 0;
    srcString = null;
    bundledStrings = null;
    src = source;
    try {
      dataView = source.dataView || (source.dataView = new DataView(source.buffer, source.byteOffset, source.byteLength));
    } catch (error) {
      src = null;
      if (source instanceof Uint8Array) {
        throw error;
      }
      throw new Error("Source must be a Uint8Array or Buffer but was a " + (source && typeof source === "object" ? source.constructor.name : typeof source));
    }
    if (this instanceof _Decoder) {
      currentDecoder = this;
      packedValues = this.sharedValues && (this.pack ? new Array(this.maxPrivatePackedValues || 16).concat(this.sharedValues) : this.sharedValues);
      if (this.structures) {
        currentStructures = this.structures;
        return checkedRead();
      } else if (!currentStructures || currentStructures.length > 0) {
        currentStructures = [];
      }
    } else {
      currentDecoder = defaultOptions;
      if (!currentStructures || currentStructures.length > 0) {
        currentStructures = [];
      }
      packedValues = null;
    }
    return checkedRead();
  }
};
function checkedRead() {
  try {
    let result = read();
    if (bundledStrings) {
      if (position >= bundledStrings.postBundlePosition) {
        let error = new Error("Unexpected bundle position");
        error.incomplete = true;
        throw error;
      }
      position = bundledStrings.postBundlePosition;
      bundledStrings = null;
    }
    if (position == srcEnd) {
      currentStructures = null;
      src = null;
      if (referenceMap) {
        referenceMap = null;
      }
    } else if (position > srcEnd) {
      let error = new Error("Unexpected end of CBOR data");
      error.incomplete = true;
      throw error;
    } else if (!sequentialMode) {
      throw new Error("Data read, but end of buffer not reached");
    }
    return result;
  } catch (error) {
    clearSource();
    if (error instanceof RangeError || error.message.startsWith("Unexpected end of buffer")) {
      error.incomplete = true;
    }
    throw error;
  }
}
function read() {
  let token = src[position++];
  let majorType = token >> 5;
  token = token & 31;
  if (token > 23) {
    switch (token) {
      case 24:
        token = src[position++];
        break;
      case 25:
        if (majorType == 7) {
          return getFloat16();
        }
        token = dataView.getUint16(position);
        position += 2;
        break;
      case 26:
        if (majorType == 7) {
          let value = dataView.getFloat32(position);
          if (currentDecoder.useFloat32 > 2) {
            let multiplier = mult10[(src[position] & 127) << 1 | src[position + 1] >> 7];
            position += 4;
            return (multiplier * value + (value > 0 ? 0.5 : -0.5) >> 0) / multiplier;
          }
          position += 4;
          return value;
        }
        token = dataView.getUint32(position);
        position += 4;
        break;
      case 27:
        if (majorType == 7) {
          let value = dataView.getFloat64(position);
          position += 8;
          return value;
        }
        if (majorType > 1) {
          if (dataView.getUint32(position) > 0) {
            throw new Error("JavaScript does not support arrays, maps, or strings with length over 4294967295");
          }
          token = dataView.getUint32(position + 4);
        } else if (currentDecoder.int64AsNumber) {
          token = dataView.getUint32(position) * 4294967296;
          token += dataView.getUint32(position + 4);
        } else {
          token = dataView.getBigUint64(position);
        }
        position += 8;
        break;
      case 31:
        switch (majorType) {
          case 2:
          case 3:
            throw new Error("Indefinite length not supported for byte or text strings");
          case 4:
            let array = [];
            let value, i = 0;
            while ((value = read()) != STOP_CODE) {
              array[i++] = value;
            }
            return majorType == 4 ? array : majorType == 3 ? array.join("") : import_buffer.Buffer.concat(array);
          case 5:
            let key;
            if (currentDecoder.mapsAsObjects) {
              let object = {};
              if (currentDecoder.keyMap) {
                while ((key = read()) != STOP_CODE) {
                  object[safeKey(currentDecoder.decodeKey(key))] = read();
                }
              } else {
                while ((key = read()) != STOP_CODE) {
                  object[safeKey(key)] = read();
                }
              }
              return object;
            } else {
              if (restoreMapsAsObject) {
                currentDecoder.mapsAsObjects = true;
                restoreMapsAsObject = false;
              }
              let map = /* @__PURE__ */ new Map();
              if (currentDecoder.keyMap) {
                while ((key = read()) != STOP_CODE) {
                  map.set(currentDecoder.decodeKey(key), read());
                }
              } else {
                while ((key = read()) != STOP_CODE) {
                  map.set(key, read());
                }
              }
              return map;
            }
          case 7:
            return STOP_CODE;
          default:
            throw new Error("Invalid major type for indefinite length " + majorType);
        }
      default:
        throw new Error("Unknown token " + token);
    }
  }
  switch (majorType) {
    case 0:
      return token;
    case 1:
      return ~token;
    case 2:
      return readBin(token);
    case 3:
      if (srcStringEnd >= position) {
        return srcString.slice(position - srcStringStart, (position += token) - srcStringStart);
      }
      if (srcStringEnd == 0 && srcEnd < 140 && token < 32) {
        let string = token < 16 ? shortStringInJS(token) : longStringInJS(token);
        if (string != null) {
          return string;
        }
      }
      return readFixedString(token);
    case 4:
      let array = new Array(token);
      for (let i = 0; i < token; i++) {
        array[i] = read();
      }
      return array;
    case 5:
      if (currentDecoder.mapsAsObjects) {
        let object = {};
        if (currentDecoder.keyMap) {
          for (let i = 0; i < token; i++) {
            object[safeKey(currentDecoder.decodeKey(read()))] = read();
          }
        } else {
          for (let i = 0; i < token; i++) {
            object[safeKey(read())] = read();
          }
        }
        return object;
      } else {
        if (restoreMapsAsObject) {
          currentDecoder.mapsAsObjects = true;
          restoreMapsAsObject = false;
        }
        let map = /* @__PURE__ */ new Map();
        if (currentDecoder.keyMap) {
          for (let i = 0; i < token; i++) {
            map.set(currentDecoder.decodeKey(read()), read());
          }
        } else {
          for (let i = 0; i < token; i++) {
            map.set(read(), read());
          }
        }
        return map;
      }
    case 6:
      if (token >= BUNDLED_STRINGS_ID) {
        let structure = currentStructures[token & 8191];
        if (structure) {
          if (!structure.read) {
            structure.read = createStructureReader(structure);
          }
          return structure.read();
        }
        if (token < 65536) {
          if (token == RECORD_INLINE_ID) {
            return recordDefinition(read());
          } else if (token == RECORD_DEFINITIONS_ID) {
            let length = readJustLength();
            let id = read();
            for (let i = 2; i < length; i++) {
              recordDefinition([id++, read()]);
            }
            return read();
          } else if (token == BUNDLED_STRINGS_ID) {
            return readBundleExt();
          }
          if (currentDecoder.getShared) {
            loadShared();
            structure = currentStructures[token & 8191];
            if (structure) {
              if (!structure.read) {
                structure.read = createStructureReader(structure);
              }
              return structure.read();
            }
          }
        }
      }
      let extension = currentExtensions[token];
      if (extension) {
        if (extension.handlesRead) {
          return extension(read);
        } else {
          return extension(read());
        }
      } else {
        let input = read();
        for (let i = 0; i < currentExtensionRanges.length; i++) {
          let value = currentExtensionRanges[i](token, input);
          if (value !== void 0) {
            return value;
          }
        }
        return new Tag(input, token);
      }
    case 7:
      switch (token) {
        case 20:
          return false;
        case 21:
          return true;
        case 22:
          return null;
        case 23:
          return;
        case 31:
        default:
          let packedValue = (packedValues || getPackedValues())[token];
          if (packedValue !== void 0) {
            return packedValue;
          }
          throw new Error("Unknown token " + token);
      }
    default:
      if (isNaN(token)) {
        let error = new Error("Unexpected end of CBOR data");
        error.incomplete = true;
        throw error;
      }
      throw new Error("Unknown CBOR token " + token);
  }
}
var validName = /^[a-zA-Z_$][a-zA-Z\d_$]*$/;
function createStructureReader(structure) {
  function readObject() {
    let length = src[position++];
    length = length & 31;
    if (length > 23) {
      switch (length) {
        case 24:
          length = src[position++];
          break;
        case 25:
          length = dataView.getUint16(position);
          position += 2;
          break;
        case 26:
          length = dataView.getUint32(position);
          position += 4;
          break;
        default:
          throw new Error("Expected array header, but got " + src[position - 1]);
      }
    }
    let compiledReader = this.compiledReader;
    while (compiledReader) {
      if (compiledReader.propertyCount === length) {
        return compiledReader(read);
      }
      compiledReader = compiledReader.next;
    }
    if (this.slowReads++ >= 3) {
      let array = this.length == length ? this : this.slice(0, length);
      compiledReader = currentDecoder.keyMap ? new Function("r", "return {" + array.map((k) => currentDecoder.decodeKey(k)).map((k) => validName.test(k) ? safeKey(k) + ":r()" : "[" + JSON.stringify(k) + "]:r()").join(",") + "}") : new Function("r", "return {" + array.map((key) => validName.test(key) ? safeKey(key) + ":r()" : "[" + JSON.stringify(key) + "]:r()").join(",") + "}");
      if (this.compiledReader) {
        compiledReader.next = this.compiledReader;
      }
      compiledReader.propertyCount = length;
      this.compiledReader = compiledReader;
      return compiledReader(read);
    }
    let object = {};
    if (currentDecoder.keyMap) {
      for (let i = 0; i < length; i++) {
        object[safeKey(currentDecoder.decodeKey(this[i]))] = read();
      }
    } else {
      for (let i = 0; i < length; i++) {
        object[safeKey(this[i])] = read();
      }
    }
    return object;
  }
  structure.slowReads = 0;
  return readObject;
}
function safeKey(key) {
  return key === "__proto__" ? "__proto_" : key;
}
var readFixedString = readStringJS;
function readStringJS(length) {
  let result;
  if (length < 16) {
    if (result = shortStringInJS(length)) {
      return result;
    }
  }
  if (length > 64 && decoder) {
    return decoder.decode(src.subarray(position, position += length));
  }
  const end = position + length;
  const units = [];
  result = "";
  while (position < end) {
    const byte1 = src[position++];
    if ((byte1 & 128) === 0) {
      units.push(byte1);
    } else if ((byte1 & 224) === 192) {
      const byte2 = src[position++] & 63;
      units.push((byte1 & 31) << 6 | byte2);
    } else if ((byte1 & 240) === 224) {
      const byte2 = src[position++] & 63;
      const byte3 = src[position++] & 63;
      units.push((byte1 & 31) << 12 | byte2 << 6 | byte3);
    } else if ((byte1 & 248) === 240) {
      const byte2 = src[position++] & 63;
      const byte3 = src[position++] & 63;
      const byte4 = src[position++] & 63;
      let unit = (byte1 & 7) << 18 | byte2 << 12 | byte3 << 6 | byte4;
      if (unit > 65535) {
        unit -= 65536;
        units.push(unit >>> 10 & 1023 | 55296);
        unit = 56320 | unit & 1023;
      }
      units.push(unit);
    } else {
      units.push(byte1);
    }
    if (units.length >= 4096) {
      result += fromCharCode.apply(String, units);
      units.length = 0;
    }
  }
  if (units.length > 0) {
    result += fromCharCode.apply(String, units);
  }
  return result;
}
var fromCharCode = String.fromCharCode;
function longStringInJS(length) {
  let start = position;
  let bytes = new Array(length);
  for (let i = 0; i < length; i++) {
    const byte = src[position++];
    if ((byte & 128) > 0) {
      position = start;
      return;
    }
    bytes[i] = byte;
  }
  return fromCharCode.apply(String, bytes);
}
function shortStringInJS(length) {
  if (length < 4) {
    if (length < 2) {
      if (length === 0) {
        return "";
      } else {
        let a = src[position++];
        if ((a & 128) > 1) {
          position -= 1;
          return;
        }
        return fromCharCode(a);
      }
    } else {
      let a = src[position++];
      let b = src[position++];
      if ((a & 128) > 0 || (b & 128) > 0) {
        position -= 2;
        return;
      }
      if (length < 3) {
        return fromCharCode(a, b);
      }
      let c = src[position++];
      if ((c & 128) > 0) {
        position -= 3;
        return;
      }
      return fromCharCode(a, b, c);
    }
  } else {
    let a = src[position++];
    let b = src[position++];
    let c = src[position++];
    let d = src[position++];
    if ((a & 128) > 0 || (b & 128) > 0 || (c & 128) > 0 || (d & 128) > 0) {
      position -= 4;
      return;
    }
    if (length < 6) {
      if (length === 4) {
        return fromCharCode(a, b, c, d);
      } else {
        let e = src[position++];
        if ((e & 128) > 0) {
          position -= 5;
          return;
        }
        return fromCharCode(a, b, c, d, e);
      }
    } else if (length < 8) {
      let e = src[position++];
      let f2 = src[position++];
      if ((e & 128) > 0 || (f2 & 128) > 0) {
        position -= 6;
        return;
      }
      if (length < 7) {
        return fromCharCode(a, b, c, d, e, f2);
      }
      let g = src[position++];
      if ((g & 128) > 0) {
        position -= 7;
        return;
      }
      return fromCharCode(a, b, c, d, e, f2, g);
    } else {
      let e = src[position++];
      let f2 = src[position++];
      let g = src[position++];
      let h = src[position++];
      if ((e & 128) > 0 || (f2 & 128) > 0 || (g & 128) > 0 || (h & 128) > 0) {
        position -= 8;
        return;
      }
      if (length < 10) {
        if (length === 8) {
          return fromCharCode(a, b, c, d, e, f2, g, h);
        } else {
          let i = src[position++];
          if ((i & 128) > 0) {
            position -= 9;
            return;
          }
          return fromCharCode(a, b, c, d, e, f2, g, h, i);
        }
      } else if (length < 12) {
        let i = src[position++];
        let j = src[position++];
        if ((i & 128) > 0 || (j & 128) > 0) {
          position -= 10;
          return;
        }
        if (length < 11) {
          return fromCharCode(a, b, c, d, e, f2, g, h, i, j);
        }
        let k = src[position++];
        if ((k & 128) > 0) {
          position -= 11;
          return;
        }
        return fromCharCode(a, b, c, d, e, f2, g, h, i, j, k);
      } else {
        let i = src[position++];
        let j = src[position++];
        let k = src[position++];
        let l = src[position++];
        if ((i & 128) > 0 || (j & 128) > 0 || (k & 128) > 0 || (l & 128) > 0) {
          position -= 12;
          return;
        }
        if (length < 14) {
          if (length === 12) {
            return fromCharCode(a, b, c, d, e, f2, g, h, i, j, k, l);
          } else {
            let m = src[position++];
            if ((m & 128) > 0) {
              position -= 13;
              return;
            }
            return fromCharCode(a, b, c, d, e, f2, g, h, i, j, k, l, m);
          }
        } else {
          let m = src[position++];
          let n = src[position++];
          if ((m & 128) > 0 || (n & 128) > 0) {
            position -= 14;
            return;
          }
          if (length < 15) {
            return fromCharCode(a, b, c, d, e, f2, g, h, i, j, k, l, m, n);
          }
          let o = src[position++];
          if ((o & 128) > 0) {
            position -= 15;
            return;
          }
          return fromCharCode(a, b, c, d, e, f2, g, h, i, j, k, l, m, n, o);
        }
      }
    }
  }
}
function readBin(length) {
  return currentDecoder.copyBuffers ? (
    // specifically use the copying slice (not the node one)
    Uint8Array.prototype.slice.call(src, position, position += length)
  ) : src.subarray(position, position += length);
}
var f32Array = new Float32Array(1);
var u8Array = new Uint8Array(f32Array.buffer, 0, 4);
function getFloat16() {
  let byte0 = src[position++];
  let byte1 = src[position++];
  let exponent = (byte0 & 127) >> 2;
  if (exponent === 31) {
    if (byte1 || byte0 & 3) {
      return NaN;
    }
    return byte0 & 128 ? -Infinity : Infinity;
  }
  if (exponent === 0) {
    let abs = ((byte0 & 3) << 8 | byte1) / (1 << 24);
    return byte0 & 128 ? -abs : abs;
  }
  u8Array[3] = byte0 & 128 | // sign bit
  (exponent >> 1) + 56;
  u8Array[2] = (byte0 & 7) << 5 | // last exponent bit and first two mantissa bits
  byte1 >> 3;
  u8Array[1] = byte1 << 5;
  u8Array[0] = 0;
  return f32Array[0];
}
var Tag = class {
  constructor(value, tag) {
    this.value = value;
    this.tag = tag;
  }
};
currentExtensions[0] = (dateString) => {
  return new Date(dateString);
};
currentExtensions[1] = (epochSec) => {
  return new Date(Math.round(epochSec * 1e3));
};
currentExtensions[2] = (buffer) => {
  let value = BigInt(0);
  for (let i = 0, l = buffer.byteLength; i < l; i++) {
    value = BigInt(buffer[i]) + value << BigInt(8);
  }
  return value;
};
currentExtensions[3] = (buffer) => {
  return BigInt(-1) - currentExtensions[2](buffer);
};
currentExtensions[4] = (fraction) => {
  return Number(fraction[1] + "e" + fraction[0]);
};
currentExtensions[5] = (fraction) => {
  return fraction[1] * Math.exp(fraction[0] * Math.log(2));
};
var recordDefinition = (definition) => {
  let id = definition[0] - 57344;
  let structure = definition[1];
  let existingStructure = currentStructures[id];
  if (existingStructure && existingStructure.isShared) {
    (currentStructures.restoreStructures || (currentStructures.restoreStructures = []))[id] = existingStructure;
  }
  currentStructures[id] = structure;
  structure.read = createStructureReader(structure);
  let object = {};
  if (currentDecoder.keyMap) {
    for (let i = 2, l = definition.length; i < l; i++) {
      let key = currentDecoder.decodeKey(structure[i - 2]);
      object[safeKey(key)] = definition[i];
    }
  } else {
    for (let i = 2, l = definition.length; i < l; i++) {
      let key = structure[i - 2];
      object[safeKey(key)] = definition[i];
    }
  }
  return object;
};
currentExtensions[LEGACY_RECORD_INLINE_ID] = recordDefinition;
currentExtensions[14] = (value) => {
  if (bundledStrings) {
    return bundledStrings[0].slice(bundledStrings.position0, bundledStrings.position0 += value);
  }
  return new Tag(value, 14);
};
currentExtensions[15] = (value) => {
  if (bundledStrings) {
    return bundledStrings[1].slice(bundledStrings.position1, bundledStrings.position1 += value);
  }
  return new Tag(value, 15);
};
var glbl = {
  Error,
  RegExp
};
currentExtensions[27] = (data) => {
  return (glbl[data[0]] || Error)(data[1], data[2]);
};
var packedTable = (_read) => {
  if (src[position++] != 132) {
    throw new Error("Packed values structure must be followed by a 4 element array");
  }
  let newPackedValues = _read();
  packedValues = packedValues ? newPackedValues.concat(packedValues.slice(newPackedValues.length)) : newPackedValues;
  packedValues.prefixes = _read();
  packedValues.suffixes = _read();
  return _read();
};
packedTable.handlesRead = true;
currentExtensions[51] = packedTable;
currentExtensions[PACKED_REFERENCE_TAG_ID] = (data) => {
  if (!packedValues) {
    if (currentDecoder.getShared) {
      loadShared();
    } else {
      return new Tag(data, PACKED_REFERENCE_TAG_ID);
    }
  }
  if (typeof data === "number") {
    return packedValues[16 + (data >= 0 ? 2 * data : -2 * data - 1)];
  }
  throw new Error("No support for non-integer packed references yet");
};
currentExtensions[25] = (id) => {
  return stringRefs[id];
};
currentExtensions[256] = (_read) => {
  stringRefs = [];
  try {
    return _read();
  } finally {
    stringRefs = null;
  }
};
currentExtensions[256].handlesRead = true;
currentExtensions[28] = (_read) => {
  if (!referenceMap) {
    referenceMap = /* @__PURE__ */ new Map();
    referenceMap.id = 0;
  }
  let id = referenceMap.id++;
  let token = src[position];
  let target;
  if (token >> 5 == 4) {
    target = [];
  } else {
    target = {};
  }
  let refEntry = {
    target
  };
  referenceMap.set(id, refEntry);
  let targetProperties = _read();
  if (refEntry.used) {
    return Object.assign(target, targetProperties);
  }
  refEntry.target = targetProperties;
  return targetProperties;
};
currentExtensions[28].handlesRead = true;
currentExtensions[29] = (id) => {
  let refEntry = referenceMap.get(id);
  refEntry.used = true;
  return refEntry.target;
};
currentExtensions[258] = (array) => new Set(array);
(currentExtensions[259] = (_read) => {
  if (currentDecoder.mapsAsObjects) {
    currentDecoder.mapsAsObjects = false;
    restoreMapsAsObject = true;
  }
  return _read();
}).handlesRead = true;
function combine(a, b) {
  if (typeof a === "string") {
    return a + b;
  }
  if (a instanceof Array) {
    return a.concat(b);
  }
  return Object.assign({}, a, b);
}
function getPackedValues() {
  if (!packedValues) {
    if (currentDecoder.getShared) {
      loadShared();
    } else {
      throw new Error("No packed values available");
    }
  }
  return packedValues;
}
var SHARED_DATA_TAG_ID = 1399353956;
currentExtensionRanges.push((tag, input) => {
  if (tag >= 225 && tag <= 255) {
    return combine(getPackedValues().prefixes[tag - 224], input);
  }
  if (tag >= 28704 && tag <= 32767) {
    return combine(getPackedValues().prefixes[tag - 28672], input);
  }
  if (tag >= 1879052288 && tag <= 2147483647) {
    return combine(getPackedValues().prefixes[tag - 1879048192], input);
  }
  if (tag >= 216 && tag <= 223) {
    return combine(input, getPackedValues().suffixes[tag - 216]);
  }
  if (tag >= 27647 && tag <= 28671) {
    return combine(input, getPackedValues().suffixes[tag - 27639]);
  }
  if (tag >= 1811940352 && tag <= 1879048191) {
    return combine(input, getPackedValues().suffixes[tag - 1811939328]);
  }
  if (tag == SHARED_DATA_TAG_ID) {
    return {
      packedValues,
      structures: currentStructures.slice(0),
      version: input
    };
  }
  if (tag == 55799) {
    return input;
  }
});
var isLittleEndianMachine = new Uint8Array(new Uint16Array([1]).buffer)[0] == 1;
var typedArrays = [Uint8Array];
var typedArrayTags = [64];
for (let i = 0; i < typedArrays.length; i++) {
  registerTypedArray(typedArrays[i], typedArrayTags[i]);
}
function registerTypedArray(TypedArray, tag) {
  let dvMethod = "get" + TypedArray.name.slice(0, -5);
  if (typeof TypedArray !== "function") {
    TypedArray = null;
  }
  let bytesPerElement = TypedArray.BYTES_PER_ELEMENT;
  for (let littleEndian = 0; littleEndian < 2; littleEndian++) {
    if (!littleEndian && bytesPerElement == 1) {
      continue;
    }
    let sizeShift = bytesPerElement == 2 ? 1 : bytesPerElement == 4 ? 2 : 3;
    currentExtensions[littleEndian ? tag : tag - 4] = bytesPerElement == 1 || littleEndian == isLittleEndianMachine ? (buffer) => {
      if (!TypedArray) {
        throw new Error("Could not find typed array for code " + tag);
      }
      return new TypedArray(Uint8Array.prototype.slice.call(buffer, 0).buffer);
    } : (buffer) => {
      if (!TypedArray) {
        throw new Error("Could not find typed array for code " + tag);
      }
      let dv = new DataView(buffer.buffer, buffer.byteOffset, buffer.byteLength);
      let elements = buffer.length >> sizeShift;
      let ta = new TypedArray(elements);
      let method = dv[dvMethod];
      for (let i = 0; i < elements; i++) {
        ta[i] = method.call(dv, i << sizeShift, littleEndian);
      }
      return ta;
    };
  }
}
function readBundleExt() {
  let length = readJustLength();
  let bundlePosition = position + read();
  for (let i = 2; i < length; i++) {
    let bundleLength = readJustLength();
    position += bundleLength;
  }
  let dataPosition = position;
  position = bundlePosition;
  bundledStrings = [readStringJS(readJustLength()), readStringJS(readJustLength())];
  bundledStrings.position0 = 0;
  bundledStrings.position1 = 0;
  bundledStrings.postBundlePosition = position;
  position = dataPosition;
  return read();
}
function readJustLength() {
  let token = src[position++] & 31;
  if (token > 23) {
    switch (token) {
      case 24:
        token = src[position++];
        break;
      case 25:
        token = dataView.getUint16(position);
        position += 2;
        break;
      case 26:
        token = dataView.getUint32(position);
        position += 4;
        break;
    }
  }
  return token;
}
function loadShared() {
  if (currentDecoder.getShared) {
    let sharedData = saveState(() => {
      src = null;
      return currentDecoder.getShared();
    }) || {};
    let updatedStructures = sharedData.structures || [];
    currentDecoder.sharedVersion = sharedData.version;
    packedValues = currentDecoder.sharedValues = sharedData.packedValues;
    if (currentStructures === true) {
      currentDecoder.structures = currentStructures = updatedStructures;
    } else {
      currentStructures.splice.apply(currentStructures, [0, updatedStructures.length].concat(updatedStructures));
    }
  }
}
function saveState(callback) {
  let savedSrcEnd = srcEnd;
  let savedPosition = position;
  let savedSrcStringStart = srcStringStart;
  let savedSrcStringEnd = srcStringEnd;
  let savedSrcString = srcString;
  let savedReferenceMap = referenceMap;
  let savedBundledStrings = bundledStrings;
  let savedSrc = new Uint8Array(src.slice(0, srcEnd));
  let savedStructures = currentStructures;
  let savedDecoder = currentDecoder;
  let savedSequentialMode = sequentialMode;
  let value = callback();
  srcEnd = savedSrcEnd;
  position = savedPosition;
  srcStringStart = savedSrcStringStart;
  srcStringEnd = savedSrcStringEnd;
  srcString = savedSrcString;
  referenceMap = savedReferenceMap;
  bundledStrings = savedBundledStrings;
  src = savedSrc;
  sequentialMode = savedSequentialMode;
  currentStructures = savedStructures;
  currentDecoder = savedDecoder;
  dataView = new DataView(src.buffer, src.byteOffset, src.byteLength);
  return value;
}
function clearSource() {
  src = null;
  referenceMap = null;
  currentStructures = null;
}
var mult10 = new Array(147);
for (let i = 0; i < 256; i++) {
  mult10[i] = Number("1e" + Math.floor(45.15 - i * 0.30103));
}
var defaultDecoder = new Decoder({
  useRecords: false
});
var decode = defaultDecoder.decode;
function hexToBytes(hex) {
  hex = hex.toString(16);
  if (!hex.startsWith("0x")) {
    hex = `0x${hex}`;
  }
  if (!isHexStrict(hex)) {
    throw new Error(`Given value "${hex}" is not a valid hex string.`);
  }
  hex = hex.replace(/^0x/i, "");
  const bytes = [];
  for (let c = 0; c < hex.length; c += 2) {
    bytes.push(parseInt(hex.slice(c, c + 2), 16));
  }
  return bytes;
}
function isHexStrict(hex) {
  return (typeof hex === "string" || typeof hex === "number") && /^(-)?0x[0-9a-f]*$/i.test(hex.toString());
}
function extractIPFSHashFromBytecode(bytecode2) {
  const numericBytecode = hexToBytes(bytecode2);
  const cborLength = numericBytecode[numericBytecode.length - 2] * 256 + numericBytecode[numericBytecode.length - 1];
  const bytecodeBuffer = Uint8Array.from(numericBytecode.slice(numericBytecode.length - 2 - cborLength, -2));
  const cborData = decode(bytecodeBuffer);
  if ("ipfs" in cborData && cborData["ipfs"]) {
    try {
      return `ipfs://${import_bs58.default.encode(cborData["ipfs"])}`;
    } catch (e) {
      console.warn("feature-detection ipfs cbor failed", e);
    }
  }
  return void 0;
}
function extractMinimalProxyImplementationAddress(bytecode2) {
  if (bytecode2.startsWith("0x363d3d373d3d3d363d73")) {
    const implementationAddress = bytecode2.slice(22, 62);
    return `0x${implementationAddress}`;
  }
  if (bytecode2.startsWith("0x36603057343d5230")) {
    const implementationAddress = bytecode2.slice(122, 122 + 40);
    return `0x${implementationAddress}`;
  }
  if (bytecode2.startsWith("0x3d3d3d3d363d3d37363d73")) {
    const implementationAddress = bytecode2.slice(24, 24 + 40);
    return `0x${implementationAddress}`;
  }
  if (bytecode2.startsWith("0x366000600037611000600036600073")) {
    const implementationAddress = bytecode2.slice(32, 32 + 40);
    return `0x${implementationAddress}`;
  }
  return void 0;
}
async function resolveContractUriFromAddress(address, provider2) {
  const {
    bytecode: bytecode2
  } = await resolveImplementation(address, provider2);
  return extractIPFSHashFromBytecode(bytecode2);
}
async function resolveContractUriAndBytecode(address, provider2) {
  const {
    bytecode: bytecode2
  } = await resolveImplementation(address, provider2);
  return {
    uri: extractIPFSHashFromBytecode(bytecode2),
    bytecode: bytecode2
  };
}
async function resolveImplementation(address, provider2) {
  let bytecode2;
  try {
    bytecode2 = await provider2.getCode(address);
  } catch (e) {
    throw new Error(`Failed to get bytecode for address ${address}: ${e}`);
  }
  if (bytecode2 === "0x") {
    const chain = await provider2.getNetwork();
    throw new Error(`Contract at ${address} does not exist on chain '${chain.name}' (chainId: ${chain.chainId})`);
  }
  try {
    const implementationAddress = extractMinimalProxyImplementationAddress(bytecode2);
    if (implementationAddress) {
      return await resolveImplementation(implementationAddress, provider2);
    }
  } catch (e) {
  }
  try {
    const proxyStorage = await provider2.getStorageAt(address, BigNumber.from("0x360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc"));
    const implementationAddress = `0x${proxyStorage.slice(-40)}`;
    if (utils_exports.isAddress(implementationAddress) && implementationAddress !== lib_exports.AddressZero) {
      return await resolveImplementation(implementationAddress, provider2);
    }
  } catch (e) {
  }
  if (!bytecode2) {
    throw new Error(`Error fetching bytecode for ${address}`);
  }
  return {
    address,
    bytecode: bytecode2
  };
}
var CONTRACT_METADATA_TIMEOUT_SEC = 2;
async function fetchContractMetadata(compilerMetadataUri, storage) {
  const metadata = await storage.downloadJSON(compilerMetadataUri, {
    timeoutInSeconds: CONTRACT_METADATA_TIMEOUT_SEC
  });
  if (!metadata || !metadata.output) {
    throw new Error(`Could not resolve metadata for contract at ${compilerMetadataUri}`);
  }
  const abi = AbiSchema.parse(metadata.output.abi);
  const compilationTarget = metadata.settings.compilationTarget;
  const targets = Object.keys(compilationTarget);
  const name = compilationTarget[targets[0]];
  const info = ContractInfoSchema.parse({
    title: metadata.output.devdoc.title,
    author: metadata.output.devdoc.author,
    details: metadata.output.devdoc.detail,
    notice: metadata.output.userdoc.notice
  });
  const licenses = [...new Set(Object.entries(metadata.sources).map((_ref) => {
    let [, src2] = _ref;
    return src2.license;
  }))];
  return {
    name,
    abi,
    metadata,
    info,
    licenses
  };
}
function getProcessEnv2(key) {
  let defaultValue = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : "";
  if (typeof import_process.default !== "undefined") {
    if (import_process.default.env[key]) {
      return import_process.default.env[key];
    }
  }
  return defaultValue;
}
var MultichainRegistry_address = "0xcdAD8FA86e18538aC207872E8ff3536501431B73";
function getMultichainRegistryAddress() {
  return getProcessEnv2("multiChainRegistryAddress", MultichainRegistry_address);
}
var isBrowser2 = () => true;
var isNode = () => !isBrowser2();
function unique(a, fn) {
  if (a.length === 0 || a.length === 1) {
    return a;
  }
  if (!fn) {
    return a;
  }
  for (let i = 0; i < a.length; i++) {
    for (let j = i + 1; j < a.length; j++) {
      if (fn(a[i], a[j])) {
        a.splice(j, 1);
      }
    }
  }
  return a;
}
function joinABIs(abis) {
  const parsedABIs = abis.map((abi) => AbiSchema.parse(abi)).flat();
  const filteredABIs = unique(parsedABIs, (a, b) => {
    return a.name === b.name && a.type === b.type && a.inputs.length === b.inputs.length;
  });
  const finalABIs = filteredABIs.filter((item) => item.type !== "constructor");
  return AbiSchema.parse(finalABIs);
}
function extractFeatures(input, enabledExtensions) {
  if (!input) {
    return;
  }
  for (const extensionKey in input) {
    const extension = input[extensionKey];
    if (extension.enabled) {
      enabledExtensions.push(extension);
    }
    extractFeatures(extension.features, enabledExtensions);
  }
}
function getAllDetectedFeatures(abi) {
  const features = [];
  extractFeatures(detectFeatures(abi), features);
  return features;
}
function getAllDetectedExtensionsFromBytecode(bytecode2) {
  const features = [];
  extractFeatures(detectFeaturesFromBytecode(bytecode2), features);
  return features;
}
function constructAbiFromBytecode(bytecode2) {
  let extensions = getAllDetectedExtensionsFromBytecode(bytecode2);
  if (extensions.find((f2) => f2.name === "ERC721")) {
    extensions = extensions.filter((f2) => f2.name !== "ERC20");
  }
  const abi = joinABIs(extensions.map((f2) => joinABIs(f2.abis)));
  return abi;
}
function getAllDetectedExtensions(abi) {
  return getAllDetectedFeatures(abi).map((f2) => ({
    ...f2,
    extensions: f2.features
  }));
}
var metadataCache = {};
var multichainRegistry = void 0;
function getCacheKey(address, chainId) {
  return `${address}-${chainId}`;
}
function putInCache(address, chainId, metadata) {
  metadataCache[getCacheKey(address, chainId)] = metadata;
}
function getFromCache(address, chainId) {
  return metadataCache[getCacheKey(address, chainId)];
}
async function fetchContractMetadataFromAddress(address, provider2, storage) {
  let sdkOptions = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : {};
  const chainId = (await provider2.getNetwork()).chainId;
  const cached = getFromCache(address, chainId);
  if (cached) {
    return cached;
  }
  let metadata;
  const [ipfsData, registryData] = await Promise.all([resolveContractUriAndBytecode(address, provider2).catch(() => void 0), getMetadataUriFromMultichainRegistry(address, chainId, sdkOptions).then((uri) => {
    if (!uri) {
      return void 0;
    }
    return {
      uri,
      bytecode: ""
    };
  }).catch(() => void 0)]);
  const bytecode2 = ipfsData == null ? void 0 : ipfsData.bytecode;
  const metadataUri = (registryData == null ? void 0 : registryData.uri) || (ipfsData == null ? void 0 : ipfsData.uri);
  if (!metadataUri && !bytecode2) {
    throw new Error(`Could not fetch bytecode for contract at ${address} on chain ${chainId}, double check that the address and chainId are correct.`);
  }
  try {
    metadata = await fetchContractMetadata(metadataUri, storage);
  } catch (e) {
  }
  if (!metadata && bytecode2) {
    const abi = constructAbiFromBytecode(bytecode2);
    if (abi && abi.length > 0) {
      console.warn(`Contract metadata could only be partially resolved, some contract functions might be unavailable. Try importing the contract by visiting: https://thirdweb.com/${chainId}/${address}`);
      metadata = {
        name: "Unimported Contract",
        abi,
        metadata: {},
        info: {},
        licenses: [],
        isPartialAbi: true
      };
      return metadata;
    }
  }
  if (!metadata) {
    throw new Error(`Could not resolve contract. Try importing it by visiting: https://thirdweb.com/${chainId}/${address}`);
  }
  putInCache(address, chainId, metadata);
  return metadata;
}
async function getMetadataUriFromMultichainRegistry(address, chainId, sdkOptions) {
  var _a;
  if (!multichainRegistry) {
    const polygonChain = (_a = sdkOptions == null ? void 0 : sdkOptions.supportedChains) == null ? void 0 : _a.find((c) => c.chainId === 137);
    const chain = polygonChain || c137;
    multichainRegistry = new Contract(getMultichainRegistryAddress(), TWMultichainRegistryLogic_default, getChainProvider(chain, sdkOptions));
  }
  const importedUri = await multichainRegistry.getMetadataUri(chainId, address);
  return importedUri;
}
async function fetchAbiFromAddress(address, provider2, storage) {
  try {
    const metadata = await fetchContractMetadataFromAddress(address, provider2, storage);
    if (metadata && metadata.abi) {
      return metadata.abi;
    }
  } catch (e) {
  }
  return void 0;
}
function buildDeployTransactionFunction(fn) {
  async function executeFn() {
    const tx = await fn(...arguments);
    return tx.execute();
  }
  executeFn.prepare = fn;
  return executeFn;
}
function buildTransactionFunction(fn) {
  async function executeFn() {
    const tx = await fn(...arguments);
    return tx.execute();
  }
  executeFn.prepare = fn;
  return executeFn;
}
async function getDefaultGasOverrides(provider2) {
  if (isBrowser2()) {
    return {};
  }
  if (provider2.originalProvider) {
    provider2 = provider2.originalProvider;
  }
  const feeData = await getDynamicFeeData(provider2);
  if (feeData.maxFeePerGas && feeData.maxPriorityFeePerGas) {
    return {
      maxFeePerGas: feeData.maxFeePerGas,
      maxPriorityFeePerGas: feeData.maxPriorityFeePerGas
    };
  } else {
    return {
      gasPrice: await getGasPrice(provider2)
    };
  }
}
async function getDynamicFeeData(provider2) {
  let maxFeePerGas = null;
  let maxPriorityFeePerGas = null;
  const [{
    chainId
  }, block, eth_maxPriorityFeePerGas] = await Promise.all([provider2.getNetwork(), provider2.getBlock("latest"), provider2.send("eth_maxPriorityFeePerGas", []).catch(() => null)]);
  const baseBlockFee = block && block.baseFeePerGas ? block.baseFeePerGas : utils_exports.parseUnits("100", "wei");
  if (chainId === c80001.chainId || chainId === c137.chainId) {
    maxPriorityFeePerGas = await getPolygonGasPriorityFee(chainId);
  } else if (eth_maxPriorityFeePerGas) {
    maxPriorityFeePerGas = BigNumber.from(eth_maxPriorityFeePerGas);
  } else {
    const feeData = await provider2.getFeeData();
    maxPriorityFeePerGas = feeData.maxPriorityFeePerGas;
    if (!maxPriorityFeePerGas) {
      return {
        maxFeePerGas: null,
        maxPriorityFeePerGas: null
      };
    }
  }
  maxFeePerGas = baseBlockFee.mul(2).add(getPreferredPriorityFee(maxPriorityFeePerGas));
  return {
    maxFeePerGas,
    maxPriorityFeePerGas
  };
}
function getPreferredPriorityFee(defaultPriorityFeePerGas) {
  let percentMultiplier = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 10;
  const extraTip = defaultPriorityFeePerGas.div(100).mul(percentMultiplier);
  const txGasPrice = defaultPriorityFeePerGas.add(extraTip);
  return txGasPrice;
}
async function getGasPrice(provider2) {
  const gasPrice = await provider2.getGasPrice();
  const maxGasPrice = utils_exports.parseUnits("300", "gwei");
  const extraTip = gasPrice.div(100).mul(10);
  const txGasPrice = gasPrice.add(extraTip);
  if (txGasPrice.gt(maxGasPrice)) {
    return maxGasPrice;
  }
  return txGasPrice;
}
function getGasStationUrl(chainId) {
  switch (chainId) {
    case ChainId.Polygon:
      return "https://gasstation.polygon.technology/v2";
    case ChainId.Mumbai:
      return "https://gasstation-testnet.polygon.technology/v2";
  }
}
var MIN_POLYGON_GAS_PRICE = utils_exports.parseUnits("31", "gwei");
var MIN_MUMBAI_GAS_PRICE = utils_exports.parseUnits("1", "gwei");
function getDefaultGasFee(chainId) {
  switch (chainId) {
    case ChainId.Polygon:
      return MIN_POLYGON_GAS_PRICE;
    case ChainId.Mumbai:
      return MIN_MUMBAI_GAS_PRICE;
  }
}
async function getPolygonGasPriorityFee(chainId) {
  const gasStationUrl = getGasStationUrl(chainId);
  try {
    const data = await (await (0, import_cross_fetch2.default)(gasStationUrl)).json();
    const priorityFee = data["fast"]["maxPriorityFee"];
    if (priorityFee > 0) {
      const fixedFee = parseFloat(priorityFee).toFixed(9);
      return utils_exports.parseUnits(fixedFee, "gwei");
    }
  } catch (e) {
    console.error("failed to fetch gas", e);
  }
  return getDefaultGasFee(chainId);
}
async function fetchSourceFilesFromMetadata(publishedMetadata, storage) {
  return await Promise.all(Object.entries(publishedMetadata.metadata.sources).map(async (_ref) => {
    let [path, info] = _ref;
    const urls = info.urls;
    const ipfsLink = urls ? urls.find((url) => url.includes("ipfs")) : void 0;
    if (ipfsLink) {
      const ipfsHash = ipfsLink.split("ipfs/")[1];
      const timeout = new Promise((_r, rej) => setTimeout(() => rej("timeout"), 3e3));
      const source = await Promise.race([(await storage.download(`ipfs://${ipfsHash}`)).text(), timeout]);
      return {
        filename: path,
        source
      };
    } else {
      return {
        filename: path,
        source: info.content || "Could not find source for this contract"
      };
    }
  }));
}
function isRouterContract(abi) {
  const isPluginRouter = isFeatureEnabled(AbiSchema.parse(abi), "PluginRouter");
  const isBaseRouter = isFeatureEnabled(AbiSchema.parse(abi), "DynamicContract");
  return isBaseRouter || isPluginRouter;
}
var ERROR_SUBSTRINGS = ["eip-155", "eip155", "protected", "invalid chain id for signer", "chain id none", "chain_id mismatch", "recovered sender mismatch", "transaction hash mismatch", "chainid no support", "chainid (0)", "chainid(0)"];
var ERROR_SUBSTRINGS_COMPOSITE = [["account", "not found"], ["wrong", "chainid"]];
var CUSTOM_GAS_FOR_CHAIN = {
  [5001]: {
    name: "Mantle Testnet",
    gasPrice: 1
  },
  [71402]: {
    name: "Godwoken Mainnet",
    gasPrice: 4e4 * 10 ** 9
  },
  [1351057110]: {
    name: "Chaos (SKALE Testnet)",
    gasPrice: 1e5
  },
  [361]: {
    name: "Theta Mainnet",
    gasPrice: 4e3 * 10 ** 9
  },
  [365]: {
    name: "Theta Testnet",
    gasPrice: 4e3 * 10 ** 9
  },
  [7700]: {
    name: "Canto",
    gasPrice: 1e3 * 10 ** 9
  },
  [7701]: {
    name: "Canto Testnet",
    gasPrice: 1e3 * 10 ** 9
  },
  [338]: {
    name: "Cronos Testnet",
    gasPrice: 2e3 * 10 ** 9
  },
  [199]: {
    name: "BitTorrent Chain",
    gasPrice: 3e5 * 10 ** 9
  }
};
function matchError(error) {
  const errorIndex = ERROR_SUBSTRINGS.findIndex((substring) => error.includes(substring));
  const compositeErrorIndex = ERROR_SUBSTRINGS_COMPOSITE.findIndex((arr) => {
    let foundError = true;
    arr.forEach((substring) => {
      foundError && (foundError = error.includes(substring));
    });
    return foundError;
  });
  return errorIndex !== -1 || compositeErrorIndex !== -1;
}
var CREATE2_FACTORY_BYTECODE = "0x604580600e600039806000f350fe7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe03601600081602082378035828234f58015156039578182fd5b8082525050506014600cf3";
var SIGNATURE = {
  v: 27,
  r: "0x2222222222222222222222222222222222222222222222222222222222222222",
  s: "0x2222222222222222222222222222222222222222222222222222222222222222"
};
var COMMON_FACTORY = "0x4e59b44847b379578588920cA78FbF26c0B4956C";
var GAS_LIMIT_FOR_DEPLOYER = 5e6;
var DEPLOYER_BYTECODE = "0x60806040526040516107f33803806107f383398101604081905261002291610359565b805160005b818110156100c157828181518110610041576100416104c9565b6020026020010151600001516001600160a01b03163b600014156100af576100ad838281518110610074576100746104c9565b602002602001015160200151848381518110610092576100926104c9565b6020026020010151604001516100c960201b6100091760201c565b505b806100b9816104df565b915050610027565b505050610557565b606061011183836040518060400160405280601e81526020017f416464726573733a206c6f772d6c6576656c2063616c6c206661696c6564000081525061011860201b60201c565b9392505050565b6060610127848460008561012f565b949350505050565b6060824710156101955760405162461bcd60e51b815260206004820152602660248201527f416464726573733a20696e73756666696369656e742062616c616e636520666f6044820152651c8818d85b1b60d21b60648201526084015b60405180910390fd5b6001600160a01b0385163b6101ec5760405162461bcd60e51b815260206004820152601d60248201527f416464726573733a2063616c6c20746f206e6f6e2d636f6e7472616374000000604482015260640161018c565b600080866001600160a01b031685876040516102089190610508565b60006040518083038185875af1925050503d8060008114610245576040519150601f19603f3d011682016040523d82523d6000602084013e61024a565b606091505b50909250905061025b828286610266565b979650505050505050565b60608315610275575081610111565b8251156102855782518084602001fd5b8160405162461bcd60e51b815260040161018c9190610524565b634e487b7160e01b600052604160045260246000fd5b604051606081016001600160401b03811182821017156102d7576102d761029f565b60405290565b604051601f8201601f191681016001600160401b03811182821017156103055761030561029f565b604052919050565b80516001600160a01b038116811461032457600080fd5b919050565b60005b8381101561034457818101518382015260200161032c565b83811115610353576000848401525b50505050565b6000602080838503121561036c57600080fd5b82516001600160401b038082111561038357600080fd5b818501915085601f83011261039757600080fd5b8151818111156103a9576103a961029f565b8060051b6103b88582016102dd565b91825283810185019185810190898411156103d257600080fd5b86860192505b838310156104bc578251858111156103f05760008081fd5b86016060601f19828d0381018213156104095760008081fd5b6104116102b5565b61041c8b850161030d565b8152604061042b81860161030d565b828d01529284015192898411156104425760008081fd5b83850194508e603f86011261045957600093508384fd5b8b85015193508984111561046f5761046f61029f565b61047f8c84601f870116016102dd565b92508383528e818587010111156104965760008081fd5b6104a5848d8501838801610329565b8101919091528452505091860191908601906103d8565b9998505050505050505050565b634e487b7160e01b600052603260045260246000fd5b600060001982141561050157634e487b7160e01b600052601160045260246000fd5b5060010190565b6000825161051a818460208701610329565b9190910192915050565b6020815260008251806020840152610543816040850160208701610329565b601f01601f19169190910160400192915050565b61028d806105666000396000f3fe6080604052600080fd5b606061004b83836040518060400160405280601e81526020017f416464726573733a206c6f772d6c6576656c2063616c6c206661696c65640000815250610052565b9392505050565b60606100618484600085610069565b949350505050565b6060824710156100cf5760405162461bcd60e51b815260206004820152602660248201527f416464726573733a20696e73756666696369656e742062616c616e636520666f6044820152651c8818d85b1b60d21b60648201526084015b60405180910390fd5b6001600160a01b0385163b6101265760405162461bcd60e51b815260206004820152601d60248201527f416464726573733a2063616c6c20746f206e6f6e2d636f6e747261637400000060448201526064016100c6565b600080866001600160a01b031685876040516101429190610208565b60006040518083038185875af1925050503d806000811461017f576040519150601f19603f3d011682016040523d82523d6000602084013e610184565b606091505b509150915061019482828661019f565b979650505050505050565b606083156101ae57508161004b565b8251156101be5782518084602001fd5b8160405162461bcd60e51b81526004016100c69190610224565b60005b838110156101f35781810151838201526020016101db565b83811115610202576000848401525b50505050565b6000825161021a8184602087016101d8565b9190910192915050565b60208152600082518060208401526102438160408501602087016101d8565b601f01601f1916919091016040019291505056fea26469706673582212200b524eb8ceaafe6c603273ee859fddbc2d6f1b7860c3d853dcf6f129f9d9371364736f6c634300080c0033";
var DEPLOYER_ABI = [{
  inputs: [{
    components: [{
      internalType: "address",
      name: "predictedAddress",
      type: "address"
    }, {
      internalType: "address",
      name: "to",
      type: "address"
    }, {
      internalType: "bytes",
      name: "data",
      type: "bytes"
    }],
    internalType: "struct IDeployer.Transaction[]",
    name: "transactions",
    type: "tuple[]"
  }],
  stateMutability: "payable",
  type: "constructor"
}];
async function isContractDeployed(address, provider2) {
  const code = await provider2.getCode(address);
  return code !== "0x" && code !== "0x0";
}
async function isEIP155Enforced(provider2) {
  try {
    await provider2.sendTransaction("0xf8a58085174876e800830186a08080b853604580600e600039806000f350fe7fffffffffffffffafffffffffffffffffffffffffffffffffffffffffffffffe03601600081602082378035828234f58015156039578182fd5b8082525050506014600cf31ba02222222222222222222222222222222222222222222222222222222222222222a02222222222222222222222222222222222222222222222222222222222222222");
  } catch (e) {
    const errorMsg = e.toString().toLowerCase();
    const errorJson = JSON.stringify(e).toLowerCase();
    if (matchError(errorMsg) || matchError(errorJson)) {
      return true;
    }
    return false;
  }
  return false;
}
function getKeylessTxn(transaction, signature) {
  const digest = utils_exports.arrayify(utils_exports.keccak256(utils_exports.serializeTransaction(transaction)));
  const signer = utils_exports.recoverAddress(digest, signature);
  const signedSerializedTx = utils_exports.serializeTransaction(transaction, signature);
  return {
    signer,
    transaction: signedSerializedTx
  };
}
function getCreate2FactoryDeploymentInfo(chainId, gasPrice) {
  const signature = utils_exports.joinSignature(SIGNATURE);
  const deploymentTransaction = getKeylessTxn({
    gasPrice: gasPrice ? gasPrice : 100 * 10 ** 9,
    gasLimit: 1e5,
    nonce: 0,
    data: CREATE2_FACTORY_BYTECODE,
    chainId
  }, signature);
  const create2FactoryAddress = utils_exports.getContractAddress({
    from: deploymentTransaction.signer,
    nonce: 0
  });
  return {
    ...deploymentTransaction,
    deployment: create2FactoryAddress
  };
}
async function getCreate2FactoryAddress(provider2) {
  const commonFactoryExists = await isContractDeployed(COMMON_FACTORY, provider2);
  if (commonFactoryExists) {
    return COMMON_FACTORY;
  }
  const enforceEip155 = await isEIP155Enforced(provider2);
  const networkId = (await provider2.getNetwork()).chainId;
  const chainId = enforceEip155 ? networkId : 0;
  const deploymentInfo = CUSTOM_GAS_FOR_CHAIN[networkId] ? getCreate2FactoryDeploymentInfo(chainId, CUSTOM_GAS_FOR_CHAIN[networkId].gasPrice) : getCreate2FactoryDeploymentInfo(chainId);
  return deploymentInfo.deployment;
}
var bytecode = "0x60606040526040805190810160405280600d81526020017f57726170706564204574686572000000000000000000000000000000000000008152506000908051906020019061004f9291906100c8565b506040805190810160405280600481526020017f57455448000000000000000000000000000000000000000000000000000000008152506001908051906020019061009b9291906100c8565b506012600260006101000a81548160ff021916908360ff16021790555034156100c357600080fd5b61016d565b828054600181600116156101000203166002900490600052602060002090601f016020900481019282601f1061010957805160ff1916838001178555610137565b82800160010185558215610137579182015b8281111561013657825182559160200191906001019061011b565b5b5090506101449190610148565b5090565b61016a91905b8082111561016657600081600090555060010161014e565b5090565b90565b610c348061017c6000396000f3006060604052600436106100af576000357c0100000000000000000000000000000000000000000000000000000000900463ffffffff16806306fdde03146100b9578063095ea7b31461014757806318160ddd146101a157806323b872dd146101ca5780632e1a7d4d14610243578063313ce5671461026657806370a082311461029557806395d89b41146102e2578063a9059cbb14610370578063d0e30db0146103ca578063dd62ed3e146103d4575b6100b7610440565b005b34156100c457600080fd5b6100cc6104dd565b6040518080602001828103825283818151815260200191508051906020019080838360005b8381101561010c5780820151818401526020810190506100f1565b50505050905090810190601f1680156101395780820380516001836020036101000a031916815260200191505b509250505060405180910390f35b341561015257600080fd5b610187600480803573ffffffffffffffffffffffffffffffffffffffff1690602001909190803590602001909190505061057b565b604051808215151515815260200191505060405180910390f35b34156101ac57600080fd5b6101b461066d565b6040518082815260200191505060405180910390f35b34156101d557600080fd5b610229600480803573ffffffffffffffffffffffffffffffffffffffff1690602001909190803573ffffffffffffffffffffffffffffffffffffffff1690602001909190803590602001909190505061068c565b604051808215151515815260200191505060405180910390f35b341561024e57600080fd5b61026460048080359060200190919050506109d9565b005b341561027157600080fd5b610279610b05565b604051808260ff1660ff16815260200191505060405180910390f35b34156102a057600080fd5b6102cc600480803573ffffffffffffffffffffffffffffffffffffffff16906020019091905050610b18565b6040518082815260200191505060405180910390f35b34156102ed57600080fd5b6102f5610b30565b6040518080602001828103825283818151815260200191508051906020019080838360005b8381101561033557808201518184015260208101905061031a565b50505050905090810190601f1680156103625780820380516001836020036101000a031916815260200191505b509250505060405180910390f35b341561037b57600080fd5b6103b0600480803573ffffffffffffffffffffffffffffffffffffffff16906020019091908035906020019091905050610bce565b604051808215151515815260200191505060405180910390f35b6103d2610440565b005b34156103df57600080fd5b61042a600480803573ffffffffffffffffffffffffffffffffffffffff1690602001909190803573ffffffffffffffffffffffffffffffffffffffff16906020019091905050610be3565b6040518082815260200191505060405180910390f35b34600360003373ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff168152602001908152602001600020600082825401925050819055503373ffffffffffffffffffffffffffffffffffffffff167fe1fffcc4923d04b559f4d29a8bfc6cda04eb5b0d3c460751c2402c5c5cc9109c346040518082815260200191505060405180910390a2565b60008054600181600116156101000203166002900480601f0160208091040260200160405190810160405280929190818152602001828054600181600116156101000203166002900480156105735780601f1061054857610100808354040283529160200191610573565b820191906000526020600020905b81548152906001019060200180831161055657829003601f168201915b505050505081565b600081600460003373ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16815260200190815260200160002060008573ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff168152602001908152602001600020819055508273ffffffffffffffffffffffffffffffffffffffff163373ffffffffffffffffffffffffffffffffffffffff167f8c5be1e5ebec7d5bd14f71427d1e84f3dd0314c0f7b2291e5b200ac8c7c3b925846040518082815260200191505060405180910390a36001905092915050565b60003073ffffffffffffffffffffffffffffffffffffffff1631905090565b600081600360008673ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16815260200190815260200160002054101515156106dc57600080fd5b3373ffffffffffffffffffffffffffffffffffffffff168473ffffffffffffffffffffffffffffffffffffffff16141580156107b457507fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff600460008673ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16815260200190815260200160002060003373ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff1681526020019081526020016000205414155b156108cf5781600460008673ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16815260200190815260200160002060003373ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff168152602001908152602001600020541015151561084457600080fd5b81600460008673ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16815260200190815260200160002060003373ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff168152602001908152602001600020600082825403925050819055505b81600360008673ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff1681526020019081526020016000206000828254039250508190555081600360008573ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff168152602001908152602001600020600082825401925050819055508273ffffffffffffffffffffffffffffffffffffffff168473ffffffffffffffffffffffffffffffffffffffff167fddf252ad1be2c89b69c2b068fc378daa952ba7f163c4a11628f55a4df523b3ef846040518082815260200191505060405180910390a3600190509392505050565b80600360003373ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff1681526020019081526020016000205410151515610a2757600080fd5b80600360003373ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff168152602001908152602001600020600082825403925050819055503373ffffffffffffffffffffffffffffffffffffffff166108fc829081150290604051600060405180830381858888f193505050501515610ab457600080fd5b3373ffffffffffffffffffffffffffffffffffffffff167f7fcf532c15f0a6db0bd6d0e038bea71d30d808c7d98cb3bf7268a95bf5081b65826040518082815260200191505060405180910390a250565b600260009054906101000a900460ff1681565b60036020528060005260406000206000915090505481565b60018054600181600116156101000203166002900480601f016020809104026020016040519081016040528092919081815260200182805460018160011615610100020316600290048015610bc65780601f10610b9b57610100808354040283529160200191610bc6565b820191906000526020600020905b815481529060010190602001808311610ba957829003601f168201915b505050505081565b6000610bdb33848461068c565b905092915050565b60046020528160005260406000206020528060005260406000206000915091505054815600a165627a7a72305820deb4c2ccab3c2fdca32ab3f46728389c2fe2c165d5fafa07661e4e004f6c344a0029";
var ContractPublisher_address = "0x664244560eBa21Bf82d7150C791bE1AbcD5B4cd7";
function getContractPublisherAddress() {
  return getProcessEnv2("contractPublisherAddress", ContractPublisher_address);
}
var DropErc721ContractInput = CommonContractSchema.merge(CommonRoyaltySchema).merge(MerkleSchema).merge(CommonSymbolSchema);
var DropErc721ContractOutput = CommonContractOutputSchema.merge(CommonRoyaltySchema).merge(MerkleSchema).merge(CommonSymbolSchema);
var DropErc721ContractDeploy = DropErc721ContractInput.merge(CommonPlatformFeeSchema).merge(CommonPrimarySaleSchema).merge(CommonTrustedForwarderSchema);
var DropErc721ContractSchema = {
  deploy: DropErc721ContractDeploy,
  output: DropErc721ContractOutput,
  input: DropErc721ContractInput
};
var DropErc1155ContractInput = CommonContractSchema.merge(CommonRoyaltySchema).merge(MerkleSchema).merge(CommonSymbolSchema);
var DropErc1155ContractOutput = CommonContractOutputSchema.merge(CommonRoyaltySchema).merge(MerkleSchema).merge(CommonSymbolSchema);
var DropErc1155ContractDeploy = DropErc1155ContractInput.merge(CommonPlatformFeeSchema).merge(CommonPrimarySaleSchema).merge(CommonTrustedForwarderSchema);
var DropErc1155ContractSchema = {
  deploy: DropErc1155ContractDeploy,
  output: DropErc1155ContractOutput,
  input: DropErc1155ContractInput
};
var MarketplaceContractInput = CommonContractSchema;
var MarketplaceContractOutput = CommonContractOutputSchema;
var MarketplaceContractDeploy = MarketplaceContractInput.merge(CommonPlatformFeeSchema).merge(CommonTrustedForwarderSchema);
var MarketplaceContractSchema = {
  deploy: MarketplaceContractDeploy,
  output: MarketplaceContractOutput,
  input: MarketplaceContractInput
};
var PackContractInput = CommonContractSchema.merge(CommonRoyaltySchema).merge(CommonSymbolSchema);
var PackContractOutput = CommonContractOutputSchema.merge(CommonRoyaltySchema).merge(CommonSymbolSchema);
var PackContractDeploy = PackContractInput.merge(CommonPlatformFeeSchema).merge(CommonTrustedForwarderSchema);
var PackContractSchema = {
  deploy: PackContractDeploy,
  output: PackContractOutput,
  input: PackContractInput
};
var SplitRecipientInputSchema = (() => z.object({
  address: AddressOrEnsSchema,
  sharesBps: BasisPointsSchema.gt(0, "Shares must be greater than 0")
}))();
var SplitRecipientOuputSchema = SplitRecipientInputSchema.extend({
  address: AddressOrEnsSchema,
  sharesBps: BasisPointsSchema
});
var SplitsContractInput = (() => CommonContractSchema.extend({
  recipients: z.array(SplitRecipientInputSchema).default([]).superRefine((val, context) => {
    const addressMap = {};
    let totalShares = 0;
    for (let index = 0; index < val.length; index++) {
      const entry = val[index];
      if (addressMap[entry.address]) {
        context.addIssue({
          code: z.ZodIssueCode.custom,
          message: `Duplicate address.`,
          path: [index, `address`]
        });
      }
      addressMap[entry.address] = true;
      totalShares += entry.sharesBps;
      if (totalShares > 1e4) {
        context.addIssue({
          code: z.ZodIssueCode.custom,
          message: `Total shares cannot go over 100%.`,
          path: [index, `sharesBps`]
        });
      }
    }
    if (totalShares !== 1e4) {
      context.addIssue({
        code: z.ZodIssueCode.custom,
        message: `Total shares need to add up to 100%. Total shares are currently ${totalShares / 100}%`,
        path: []
      });
    }
  })
}))();
var SplitsContractOutput = (() => CommonContractOutputSchema.extend({
  recipients: z.array(SplitRecipientOuputSchema)
}))();
var SplitsContractDeploy = SplitsContractInput.merge(SplitsContractInput).merge(CommonTrustedForwarderSchema);
var SplitsContractSchema = {
  deploy: SplitsContractDeploy,
  output: SplitsContractOutput,
  input: SplitsContractInput
};
var TokenErc20ContractInput = CommonContractSchema.merge(CommonSymbolSchema);
var TokenErc20ContractOutput = CommonContractOutputSchema.merge(CommonSymbolSchema);
var TokenErc20ContractDeploy = TokenErc20ContractInput.merge(CommonPlatformFeeSchema).merge(CommonPrimarySaleSchema).merge(CommonTrustedForwarderSchema);
var TokenErc20ContractSchema = {
  deploy: TokenErc20ContractDeploy,
  output: TokenErc20ContractOutput,
  input: TokenErc20ContractInput
};
var TokenErc721ContractInput = CommonContractSchema.merge(CommonRoyaltySchema).merge(CommonSymbolSchema);
var TokenErc721ContractOutput = CommonContractOutputSchema.merge(CommonRoyaltySchema).merge(CommonSymbolSchema);
var TokenErc721ContractDeploy = TokenErc721ContractInput.merge(CommonPlatformFeeSchema).merge(CommonPrimarySaleSchema).merge(CommonTrustedForwarderSchema);
var TokenErc721ContractSchema = {
  deploy: TokenErc721ContractDeploy,
  output: TokenErc721ContractOutput,
  input: TokenErc721ContractInput
};
var TokenErc1155ContractInput = CommonContractSchema.merge(CommonRoyaltySchema).merge(CommonSymbolSchema);
var TokenErc1155ContractOutput = CommonContractOutputSchema.merge(CommonRoyaltySchema).merge(CommonSymbolSchema);
var TokenErc1155ContractDeploy = TokenErc1155ContractInput.merge(CommonPlatformFeeSchema).merge(CommonPrimarySaleSchema).merge(CommonTrustedForwarderSchema);
var TokenErc1155ContractSchema = {
  deploy: TokenErc1155ContractDeploy,
  output: TokenErc1155ContractOutput,
  input: TokenErc1155ContractInput
};
var VoteSettingsInputSchema = (() => z.object({
  voting_delay_in_blocks: z.number().min(0).default(0),
  voting_period_in_blocks: z.number().min(1).default(1),
  voting_token_address: AddressOrEnsSchema,
  voting_quorum_fraction: PercentSchema.default(0),
  proposal_token_threshold: BigNumberishSchema.default(1)
}))();
var VoteSettingsOuputSchema = VoteSettingsInputSchema.extend({
  proposal_token_threshold: BigNumberSchema
});
var VoteContractInput = CommonContractSchema.merge(VoteSettingsInputSchema);
var VoteContractOutput = CommonContractOutputSchema.merge(VoteSettingsOuputSchema);
var VoteContractDeploy = VoteContractInput.merge(CommonTrustedForwarderSchema);
var VoteContractSchema = {
  deploy: VoteContractDeploy,
  output: VoteContractOutput,
  input: VoteContractInput
};
async function resolveAddress(addressOrEns) {
  return AddressOrEnsSchema.parseAsync(addressOrEns);
}
async function fetchExtendedReleaseMetadata(publishMetadataUri, storage) {
  const meta = await (await storage.download(publishMetadataUri)).text();
  return FullPublishMetadataSchemaOutput.parse(JSON.parse(meta));
}
async function fetchRawPredeployMetadata(publishMetadataUri, storage) {
  return PreDeployMetadata.parse(JSON.parse(await (await storage.download(publishMetadataUri)).text()));
}
async function fetchPreDeployMetadata(publishMetadataUri, storage) {
  const rawMeta = await fetchRawPredeployMetadata(publishMetadataUri, storage);
  const deployBytecode = await (await storage.download(rawMeta.bytecodeUri)).text();
  const parsedMeta = await fetchContractMetadata(rawMeta.metadataUri, storage);
  return PreDeployMetadataFetchedSchema.parse({
    ...rawMeta,
    ...parsedMeta,
    bytecode: deployBytecode
  });
}
var deployMetadataCache = {};
async function fetchAndCacheDeployMetadata(publishMetadataUri, storage) {
  if (deployMetadataCache[publishMetadataUri]) {
    return deployMetadataCache[publishMetadataUri];
  }
  const compilerMetadata = await fetchPreDeployMetadata(publishMetadataUri, storage);
  let extendedMetadata;
  try {
    extendedMetadata = await fetchExtendedReleaseMetadata(publishMetadataUri, storage);
  } catch (e) {
  }
  const data = {
    compilerMetadata,
    extendedMetadata
  };
  deployMetadataCache[publishMetadataUri] = data;
  return data;
}
var AddressZero = "0x0000000000000000000000000000000000000000";
var TWRegistry_address = "0x7c487845f98938Bb955B1D5AD069d9a30e4131fd";
var TWFactory_address = "0x5DBC7B840baa9daBcBe9D2492E45D7244B54A2A0";
var OZ_DEFENDER_FORWARDER_ADDRESS = "0xc82BbE41f2cF04e3a8efA18F7032BDD7f6d98a81";
var CONTRACT_ADDRESSES = {
  [ChainId.Mainnet]: {
    openzeppelinForwarder: OZ_DEFENDER_FORWARDER_ADDRESS,
    openzeppelinForwarderEOA: "0x76ce2CB1Ae48Fa067f4fb8c5f803111AE0B24BEA",
    biconomyForwarder: "0x84a0856b038eaAd1cC7E297cF34A7e72685A8693",
    twFactory: TWFactory_address,
    twRegistry: TWRegistry_address,
    twBYOCRegistry: AddressZero
  },
  [ChainId.Goerli]: {
    openzeppelinForwarder: "0x5001A14CA6163143316a7C614e30e6041033Ac20",
    openzeppelinForwarderEOA: "0xe73c50cB9c5B378627ff625BB6e6725A4A5D65d2",
    biconomyForwarder: "0xE041608922d06a4F26C0d4c27d8bCD01daf1f792",
    twFactory: TWFactory_address,
    twRegistry: TWRegistry_address,
    twBYOCRegistry: "0xB1Bd9d7942A250BA2Dce27DD601F2ED4211A60C4"
  },
  [ChainId.Polygon]: {
    openzeppelinForwarder: OZ_DEFENDER_FORWARDER_ADDRESS,
    openzeppelinForwarderEOA: "0x4f247c69184ad61036EC2Bb3213b69F10FbEDe1F",
    biconomyForwarder: "0x86C80a8aa58e0A4fa09A69624c31Ab2a6CAD56b8",
    twFactory: TWFactory_address,
    twRegistry: TWRegistry_address,
    twBYOCRegistry: "0x308473Be900F4185A56587dE54bDFF5E8f7a6AE7"
  },
  [ChainId.Mumbai]: {
    openzeppelinForwarder: OZ_DEFENDER_FORWARDER_ADDRESS,
    openzeppelinForwarderEOA: "0xb1A2883fc4d287d9cB8Dbb96cFF60C76BEf2D250",
    biconomyForwarder: "0x9399BB24DBB5C4b782C70c2969F58716Ebbd6a3b",
    twFactory: TWFactory_address,
    twRegistry: TWRegistry_address,
    twBYOCRegistry: "0x3F17972CB27506eb4a6a3D59659e0B57a43fd16C"
  },
  [ChainId.Avalanche]: {
    openzeppelinForwarder: OZ_DEFENDER_FORWARDER_ADDRESS,
    openzeppelinForwarderEOA: "0xb1A2883fc4d287d9cB8Dbb96cFF60C76BEf2D250",
    biconomyForwarder: "0x64CD353384109423a966dCd3Aa30D884C9b2E057",
    twFactory: TWFactory_address,
    twRegistry: TWRegistry_address,
    twBYOCRegistry: AddressZero
  },
  [ChainId.AvalancheFujiTestnet]: {
    openzeppelinForwarder: OZ_DEFENDER_FORWARDER_ADDRESS,
    openzeppelinForwarderEOA: "0xe73c50cB9c5B378627ff625BB6e6725A4A5D65d2",
    biconomyForwarder: "0x6271Ca63D30507f2Dcbf99B52787032506D75BBF",
    twFactory: TWFactory_address,
    twRegistry: TWRegistry_address,
    twBYOCRegistry: "0x3E6eE864f850F5e5A98bc950B68E181Cf4010F23"
  },
  [ChainId.Fantom]: {
    openzeppelinForwarder: OZ_DEFENDER_FORWARDER_ADDRESS,
    openzeppelinForwarderEOA: "0xb1A2883fc4d287d9cB8Dbb96cFF60C76BEf2D250",
    biconomyForwarder: "0x64CD353384109423a966dCd3Aa30D884C9b2E057",
    twFactory: "0x97EA0Fcc552D5A8Fb5e9101316AAd0D62Ea0876B",
    twRegistry: TWRegistry_address,
    twBYOCRegistry: AddressZero
  },
  [ChainId.FantomTestnet]: {
    openzeppelinForwarder: OZ_DEFENDER_FORWARDER_ADDRESS,
    openzeppelinForwarderEOA: "0x42D3048b595B6e1c28a588d70366CcC2AA4dB47b",
    biconomyForwarder: "0x69FB8Dca8067A5D38703b9e8b39cf2D51473E4b4",
    twFactory: TWFactory_address,
    twRegistry: TWRegistry_address,
    twBYOCRegistry: "0x3E6eE864f850F5e5A98bc950B68E181Cf4010F23"
  },
  [ChainId.Arbitrum]: {
    openzeppelinForwarder: "0x4a8AC7f22DeD2CF923A51e4A1c67490bd8868add",
    openzeppelinForwarderEOA: "0x4f247c69184ad61036EC2Bb3213b69F10FbEDe1F",
    biconomyForwarder: "0xfe0fa3C06d03bDC7fb49c892BbB39113B534fB57",
    twFactory: "0xd24b3de085CFd8c54b94feAD08a7962D343E6DE0",
    twRegistry: TWRegistry_address,
    twBYOCRegistry: AddressZero
  },
  [ChainId.ArbitrumGoerli]: {
    openzeppelinForwarder: "0x8cbc8B5d71702032904750A66AEfE8B603eBC538",
    openzeppelinForwarderEOA: "0x119704314Ef304EaAAE4b3c7C9ABd59272A28310",
    biconomyForwarder: AddressZero,
    twFactory: "0xd24b3de085CFd8c54b94feAD08a7962D343E6DE0",
    twRegistry: TWRegistry_address,
    twBYOCRegistry: AddressZero
  },
  [ChainId.Optimism]: {
    openzeppelinForwarder: "0xd85da690EF288A6976DE0E85Fb2Aad512eBAfbf7",
    openzeppelinForwarderEOA: "0x7e80648EB2071E26937F9D42A513ccf4815fc702",
    biconomyForwarder: "0xefba8a2a82ec1fb1273806174f5e28fbb917cf95",
    twFactory: "0xd24b3de085CFd8c54b94feAD08a7962D343E6DE0",
    twRegistry: TWRegistry_address,
    twBYOCRegistry: AddressZero
  },
  [ChainId.OptimismGoerli]: {
    openzeppelinForwarder: "0x8cbc8B5d71702032904750A66AEfE8B603eBC538",
    openzeppelinForwarderEOA: "0x119704314Ef304EaAAE4b3c7C9ABd59272A28310",
    biconomyForwarder: AddressZero,
    twFactory: "0xd24b3de085CFd8c54b94feAD08a7962D343E6DE0",
    twRegistry: TWRegistry_address,
    twBYOCRegistry: AddressZero
  },
  [ChainId.BinanceSmartChainMainnet]: {
    openzeppelinForwarder: "0x7C4717039B89d5859c4Fbb85EDB19A6E2ce61171",
    openzeppelinForwarderEOA: "0xE8dd2Ff0212F86d3197b4AfDC6dAC6ac47eb10aC",
    biconomyForwarder: "0x86C80a8aa58e0A4fa09A69624c31Ab2a6CAD56b8",
    twBYOCRegistry: AddressZero,
    twFactory: "0xd24b3de085CFd8c54b94feAD08a7962D343E6DE0",
    twRegistry: TWRegistry_address
  },
  [ChainId.BinanceSmartChainTestnet]: {
    openzeppelinForwarder: "0x44bE9D54B9C8b5e57a3325E8Ec9154640e7c6955",
    openzeppelinForwarderEOA: "0x7e80648EB2071E26937F9D42A513ccf4815fc702",
    biconomyForwarder: "0x61456BF1715C1415730076BB79ae118E806E74d2",
    twBYOCRegistry: AddressZero,
    twFactory: "0xd24b3de085CFd8c54b94feAD08a7962D343E6DE0",
    twRegistry: TWRegistry_address
  },
  [ChainId.Hardhat]: {
    openzeppelinForwarder: AddressZero,
    openzeppelinForwarderEOA: AddressZero,
    biconomyForwarder: AddressZero,
    twFactory: AddressZero,
    twRegistry: AddressZero,
    twBYOCRegistry: AddressZero
  },
  [ChainId.Localhost]: {
    openzeppelinForwarder: AddressZero,
    openzeppelinForwarderEOA: AddressZero,
    biconomyForwarder: AddressZero,
    twFactory: AddressZero,
    twRegistry: AddressZero,
    twBYOCRegistry: AddressZero
  }
};
function getContractAddressByChainId(chainId, contractName) {
  var _a;
  if (chainId === ChainId.Hardhat || chainId === ChainId.Localhost) {
    if (contractName === "twFactory") {
      return getProcessEnv2("factoryAddress");
    } else if (contractName === "twRegistry") {
      return getProcessEnv2("registryAddress");
    } else {
      return AddressZero;
    }
  }
  return (_a = CONTRACT_ADDRESSES[chainId]) == null ? void 0 : _a[contractName];
}
var InterfaceId_IERC721 = utils_exports.arrayify("0x80ac58cd");
var InterfaceId_IERC1155 = utils_exports.arrayify("0xd9b67a26");
var EventType = function(EventType2) {
  EventType2["Transaction"] = "transaction";
  EventType2["Signature"] = "signature";
  return EventType2;
}({});
var THIRDWEB_DEPLOYER = "0xdd99b75f095d0c4d5112aCe938e4e6ed962fb024";
async function fetchPublishedContractFromPolygon(publisherAddress, contractName) {
  let version = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : "latest";
  let storage = arguments.length > 3 ? arguments[3] : void 0;
  let clientId = arguments.length > 4 ? arguments[4] : void 0;
  let secretKey = arguments.length > 5 ? arguments[5] : void 0;
  const polygonChain = getSupportedChains().find((c) => c.chainId === 137);
  const chain = polygonChain || c137;
  const publisher = await resolveAddress(publisherAddress);
  const contract = new Contract(getContractPublisherAddress(), ContractPublisher_default, getChainProvider(chain, {
    clientId,
    secretKey
  }));
  let publishedContract;
  if (!version || version === "latest") {
    const model = await contract.getPublishedContract(publisher, contractName);
    publishedContract = PublishedContractSchema.parse({
      id: model.contractId,
      timestamp: model.publishTimestamp,
      metadataUri: model.publishMetadataUri
    });
  } else {
    const allVersions = (await contract.getPublishedContractVersions(publisher, contractName)).map((c) => {
      return PublishedContractSchema.parse({
        id: c.contractId,
        timestamp: c.publishTimestamp,
        metadataUri: c.publishMetadataUri
      });
    });
    const versionMetadata = await Promise.all(allVersions.map(async (c) => {
      return {
        name: c.id,
        publishedTimestamp: c.timestamp,
        publishedMetadata: await fetchAndCacheDeployMetadata(c.metadataUri, storage)
      };
    }));
    const versionMatch = versionMetadata.find((metadata) => {
      var _a;
      return ((_a = metadata.publishedMetadata.extendedMetadata) == null ? void 0 : _a.version) === version;
    });
    invariant(versionMatch, "Contract version not found");
    publishedContract = allVersions.find((c) => c.timestamp === versionMatch.publishedTimestamp);
  }
  if (!publishedContract) {
    throw new Error(`No published contract found for ${contractName} at version by '${THIRDWEB_DEPLOYER}'`);
  }
  return publishedContract;
}
function getSaltHash(bytecode2) {
  const bytecodePrefixed = bytecode2.startsWith("0x") ? bytecode2 : `0x${bytecode2}`;
  const bytecodeHash = utils_exports.id(bytecodePrefixed);
  const salt = `tw.${bytecodeHash}`;
  const saltHash = utils_exports.id(salt);
  return saltHash;
}
function getInitBytecodeWithSalt(bytecode2, encodedArgs, salt) {
  const bytecodePrefixed = bytecode2.startsWith("0x") ? bytecode2 : `0x${bytecode2}`;
  const saltHash = salt ? utils_exports.id(salt) : getSaltHash(bytecodePrefixed);
  const initBytecodeWithSalt = utils_exports.solidityPack(["bytes32", "bytes", "bytes"], [saltHash, bytecodePrefixed, encodedArgs]);
  return initBytecodeWithSalt;
}
function computeDeploymentAddress(bytecode2, encodedArgs, create2FactoryAddress, salt) {
  const bytecodePrefixed = bytecode2.startsWith("0x") ? bytecode2 : `0x${bytecode2}`;
  const saltHash = salt ? utils_exports.id(salt) : getSaltHash(bytecodePrefixed);
  const initBytecode = utils_exports.solidityPack(["bytes", "bytes"], [bytecodePrefixed, encodedArgs]);
  const deployInfoPacked = utils_exports.solidityPack(["bytes1", "address", "bytes32", "bytes32"], ["0xff", create2FactoryAddress, saltHash, utils_exports.solidityKeccak256(["bytes"], [initBytecode])]);
  const hashedDeployInfo = utils_exports.solidityKeccak256(["bytes"], [deployInfoPacked]);
  return `0x${hashedDeployInfo.slice(26)}`;
}
function extractConstructorParamsFromAbi(abi) {
  const parsedAbi = AbiSchema.parse(abi || []);
  for (const input of parsedAbi) {
    if (input.type === "constructor") {
      return input.inputs || [];
    }
  }
  return [];
}
var caches = {
  deploymentPresets: {}
};
function getRoyaltyEngineV1ByChainId(chainId) {
  return ROYALTY_ENGINE_V1_ADDRESS[chainId] || lib_exports.AddressZero;
}
var ROYALTY_ENGINE_V1_ADDRESS = {
  [ChainId.Mainnet]: "0x0385603ab55642cb4dd5de3ae9e306809991804f",
  [ChainId.Goerli]: "0xEF770dFb6D5620977213f55f99bfd781D04BBE15",
  [ChainId.BinanceSmartChainMainnet]: "0xEF770dFb6D5620977213f55f99bfd781D04BBE15",
  [ChainId.Polygon]: "0x28EdFcF0Be7E86b07493466e7631a213bDe8eEF2",
  [ChainId.Mumbai]: "0x0a01E11887f727D1b1Cd81251eeEE9BEE4262D07",
  [ChainId.Avalanche]: "0xEF770dFb6D5620977213f55f99bfd781D04BBE15",
  [ChainId.Optimism]: "0xEF770dFb6D5620977213f55f99bfd781D04BBE15",
  [ChainId.Arbitrum]: "0xEF770dFb6D5620977213f55f99bfd781D04BBE15"
};
async function computeDeploymentInfo(contractType, provider2, storage, create2Factory, contractOptions, clientId, secretKey) {
  const contractName = contractOptions && contractOptions.contractName;
  const version = contractOptions && contractOptions.version;
  let publisherAddress = contractOptions && contractOptions.publisherAddress;
  let metadata = contractOptions && contractOptions.metadata;
  invariant(contractName || metadata, "Require contract name or metadata");
  if (contractName && caches.deploymentPresets[contractName]) {
    return caches.deploymentPresets[contractName];
  }
  if (contractName === "WETH9") {
    const address2 = computeDeploymentAddress(bytecode, [], create2Factory);
    const contractDeployed2 = await isContractDeployed(address2, provider2);
    let initBytecodeWithSalt2 = "";
    if (!contractDeployed2) {
      initBytecodeWithSalt2 = getInitBytecodeWithSalt(bytecode, []);
    }
    return {
      name: contractName,
      type: contractType,
      transaction: {
        predictedAddress: address2,
        to: create2Factory,
        data: initBytecodeWithSalt2
      }
    };
  }
  if (!metadata) {
    invariant(contractName, "Require contract name");
    if (!publisherAddress) {
      publisherAddress = THIRDWEB_DEPLOYER;
    }
    const publishedContract = await fetchPublishedContractFromPolygon(publisherAddress, contractName, version, storage, clientId, secretKey);
    metadata = (await fetchAndCacheDeployMetadata(publishedContract.metadataUri, storage)).compilerMetadata;
  }
  const encodedArgs = await encodeConstructorParamsForImplementation(metadata, provider2, storage, create2Factory, contractOptions == null ? void 0 : contractOptions.constructorParams, clientId, secretKey);
  const address = computeDeploymentAddress(metadata.bytecode, encodedArgs, create2Factory);
  const contractDeployed = await isContractDeployed(address, provider2);
  let initBytecodeWithSalt = "";
  if (!contractDeployed) {
    initBytecodeWithSalt = getInitBytecodeWithSalt(metadata.bytecode, encodedArgs);
  }
  return {
    name: contractName,
    type: contractType,
    transaction: {
      predictedAddress: address,
      to: create2Factory,
      data: initBytecodeWithSalt
    },
    encodedArgs
  };
}
async function encodeConstructorParamsForImplementation(compilerMetadata, provider2, storage, create2Factory, constructorParamMap, clientId, secretKey) {
  const constructorParams = extractConstructorParamsFromAbi(compilerMetadata.abi);
  const constructorParamTypes = constructorParams.map((p) => {
    if (p.type === "tuple[]") {
      return utils_exports.ParamType.from(p);
    } else {
      return p.type;
    }
  });
  const constructorParamValues = await Promise.all(constructorParams.map(async (p) => {
    if (constructorParamMap && constructorParamMap[p.name]) {
      if (constructorParamMap[p.name].type) {
        invariant(constructorParamMap[p.name].type === p.type, `Provided type ${constructorParamMap[p.name].type} doesn't match the actual type ${p.type} from Abi`);
      }
      return constructorParamMap[p.name].value;
    }
    if (p.name && p.name.includes("nativeTokenWrapper")) {
      const chainId = (await provider2.getNetwork()).chainId;
      let nativeTokenWrapperAddress = getNativeTokenByChainId(chainId).wrapped.address;
      if (nativeTokenWrapperAddress === lib_exports.AddressZero) {
        const deploymentInfo = await computeDeploymentInfo("infra", provider2, storage, create2Factory, {
          contractName: "WETH9"
        }, clientId, secretKey);
        if (!caches.deploymentPresets["WETH9"]) {
          caches.deploymentPresets["WETH9"] = deploymentInfo;
        }
        nativeTokenWrapperAddress = deploymentInfo.transaction.predictedAddress;
      }
      return nativeTokenWrapperAddress;
    } else if (p.name && p.name.includes("trustedForwarder")) {
      if (compilerMetadata.name === "Pack") {
        const deploymentInfo2 = await computeDeploymentInfo("infra", provider2, storage, create2Factory, {
          contractName: "ForwarderEOAOnly"
        }, clientId, secretKey);
        if (!caches.deploymentPresets["ForwarderEOAOnly"]) {
          caches.deploymentPresets["ForwarderEOAOnly"] = deploymentInfo2;
        }
        return deploymentInfo2.transaction.predictedAddress;
      }
      const deploymentInfo = await computeDeploymentInfo("infra", provider2, storage, create2Factory, {
        contractName: "Forwarder"
      }, clientId, secretKey);
      if (!caches.deploymentPresets["Forwarder"]) {
        caches.deploymentPresets["Forwarder"] = deploymentInfo;
      }
      return deploymentInfo.transaction.predictedAddress;
    } else if (p.name && p.name.includes("royaltyEngineAddress")) {
      const chainId = (await provider2.getNetwork()).chainId;
      return getRoyaltyEngineV1ByChainId(chainId);
    } else {
      throw new Error("Can't resolve constructor arguments");
    }
  }));
  const encodedArgs = utils_exports.defaultAbiCoder.encode(constructorParamTypes, constructorParamValues);
  return encodedArgs;
}
async function computeEOAForwarderAddress(provider2, storage, create2Factory, clientId, secretKey) {
  if (!create2Factory || create2Factory === "") {
    create2Factory = await getCreate2FactoryAddress(provider2);
  }
  return (await computeDeploymentInfo("infra", provider2, storage, create2Factory, {
    contractName: "ForwarderEOAOnly"
  }, clientId, secretKey)).transaction.predictedAddress;
}
async function computeForwarderAddress(provider2, storage, create2Factory, clientId, secretKey) {
  if (!create2Factory || create2Factory === "") {
    create2Factory = await getCreate2FactoryAddress(provider2);
  }
  return (await computeDeploymentInfo("infra", provider2, storage, create2Factory, {
    contractName: "Forwarder"
  }, clientId, secretKey)).transaction.predictedAddress;
}
var ForwardRequest = [{
  name: "from",
  type: "address"
}, {
  name: "to",
  type: "address"
}, {
  name: "value",
  type: "uint256"
}, {
  name: "gas",
  type: "uint256"
}, {
  name: "nonce",
  type: "uint256"
}, {
  name: "data",
  type: "bytes"
}];
var ChainAwareForwardRequest = [{
  name: "from",
  type: "address"
}, {
  name: "to",
  type: "address"
}, {
  name: "value",
  type: "uint256"
}, {
  name: "gas",
  type: "uint256"
}, {
  name: "nonce",
  type: "uint256"
}, {
  name: "data",
  type: "bytes"
}, {
  name: "chainid",
  type: "uint256"
}];
var BiconomyForwarderAbi = [{
  inputs: [{
    internalType: "address",
    name: "from",
    type: "address"
  }, {
    internalType: "uint256",
    name: "batchId",
    type: "uint256"
  }],
  name: "getNonce",
  outputs: [{
    internalType: "uint256",
    name: "",
    type: "uint256"
  }],
  stateMutability: "view",
  type: "function"
}];
var _nonces = {};
var _noncesSyncTimestamp = {};
async function getAndIncrementNonce(forwarder, forwarderFunction, forwarderArgs) {
  const address = forwarderArgs.join("|");
  const timestamp = _noncesSyncTimestamp[address];
  const shouldSync = Date.now() - timestamp >= 2e3;
  if (!(address in _nonces) || shouldSync) {
    const nonceResult = await forwarder.functions[forwarderFunction](...forwarderArgs);
    if (Array.isArray(nonceResult) && nonceResult.length > 0) {
      _nonces[address] = BigNumber.from(nonceResult[0]);
    } else {
      _nonces[address] = BigNumber.from(nonceResult);
    }
    _noncesSyncTimestamp[address] = Date.now();
  }
  const nonce = _nonces[address];
  _nonces[address] = BigNumber.from(_nonces[address]).add(1);
  return nonce;
}
async function signTypedDataInternal(signerInput, domain, types, message) {
  var _a, _b;
  let signer = signerInput;
  if (signerInput.originalSigner) {
    signer = signerInput.originalSigner;
  }
  const provider2 = signer == null ? void 0 : signer.provider;
  if (!provider2) {
    throw new Error("missing provider");
  }
  const payload = utils_exports._TypedDataEncoder.getPayload(domain, types, message);
  let signature = "";
  const signerAddress = (await signer.getAddress()).toLowerCase();
  if ((_a = provider2 == null ? void 0 : provider2.provider) == null ? void 0 : _a.isWalletConnect) {
    signature = await provider2.send("eth_signTypedData", [(await signer.getAddress()).toLowerCase(), JSON.stringify(payload)]);
  } else {
    try {
      signature = await signer._signTypedData(domain, types, message);
    } catch (err) {
      if ((_b = err == null ? void 0 : err.message) == null ? void 0 : _b.includes("eth_signTypedData_v4")) {
        signature = await provider2.send("eth_signTypedData", [signerAddress, JSON.stringify(payload)]);
      } else {
        try {
          await provider2.send("eth_signTypedData_v4", [signerAddress, JSON.stringify(payload)]);
        } catch (finalErr) {
          throw finalErr;
        }
      }
    }
  }
  return {
    payload,
    signature: utils_exports.joinSignature(utils_exports.splitSignature(signature))
  };
}
var NAME_ABI = [{
  inputs: [],
  name: "name",
  outputs: [{
    internalType: "string",
    name: "",
    type: "string"
  }],
  stateMutability: "view",
  type: "function"
}];
var DOMAIN_SEPARATOR_ABI = [{
  constant: true,
  inputs: [],
  name: "DOMAIN_SEPARATOR",
  outputs: [{
    internalType: "bytes32",
    name: "",
    type: "bytes32"
  }],
  payable: false,
  stateMutability: "view",
  type: "function"
}, {
  inputs: [],
  name: "getDomainSeperator",
  outputs: [{
    internalType: "bytes32",
    name: "",
    type: "bytes32"
  }],
  stateMutability: "view",
  type: "function"
}];
var NONCES_ABI = [{
  inputs: [{
    internalType: "address",
    name: "owner",
    type: "address"
  }],
  name: "nonces",
  outputs: [{
    internalType: "uint256",
    name: "",
    type: "uint256"
  }],
  stateMutability: "view",
  type: "function"
}, {
  inputs: [{
    internalType: "address",
    name: "user",
    type: "address"
  }],
  name: "getNonce",
  outputs: [{
    internalType: "uint256",
    name: "nonce",
    type: "uint256"
  }],
  stateMutability: "view",
  type: "function"
}];
async function getSignerNonce(signer, contractAddress) {
  const contract = new Contract(contractAddress, NONCES_ABI, signer);
  try {
    return await contract.nonces(await signer.getAddress());
  } catch (err) {
    return await contract.getNonce(await signer.getAddress());
  }
}
async function getDomainSeperator(signer, contractAddress) {
  const contract = new Contract(contractAddress, DOMAIN_SEPARATOR_ABI, signer);
  try {
    return await contract.DOMAIN_SEPARATOR();
  } catch (err) {
    try {
      return await contract.getDomainSeperator();
    } catch (err2) {
      console.error("Error getting domain separator", err2);
    }
  }
}
async function getTokenName(signer, contractAddress) {
  return new Contract(contractAddress, NAME_ABI, signer).name();
}
async function getChainDomainSeperator(signer, domain) {
  const contractDomainSeparator = await getDomainSeperator(signer, domain.verifyingContract);
  const polygonDomain = {
    name: domain.name,
    version: domain.version,
    verifyingContract: domain.verifyingContract,
    salt: utils_exports.hexZeroPad(BigNumber.from(domain.chainId).toHexString(), 32)
  };
  if (utils_exports._TypedDataEncoder.hashDomain(polygonDomain) === contractDomainSeparator) {
    return polygonDomain;
  }
  return domain;
}
async function signEIP2612Permit(signer, currencyAddress, owner, spender, value, deadline, nonce) {
  const domain = await getChainDomainSeperator(signer, {
    name: await getTokenName(signer, currencyAddress),
    version: "1",
    chainId: await signer.getChainId(),
    verifyingContract: currencyAddress
  });
  nonce = nonce || (await getSignerNonce(signer, currencyAddress)).toString();
  deadline = deadline || lib_exports.MaxUint256;
  const message = {
    owner,
    spender,
    value,
    nonce,
    deadline
  };
  const types = {
    Permit: [{
      name: "owner",
      type: "address"
    }, {
      name: "spender",
      type: "address"
    }, {
      name: "value",
      type: "uint256"
    }, {
      name: "nonce",
      type: "uint256"
    }, {
      name: "deadline",
      type: "uint256"
    }]
  };
  const {
    signature
  } = await signTypedDataInternal(signer, domain, types, message);
  return {
    message,
    signature
  };
}
var TransactionContext = class {
  constructor(options) {
    this.args = options.args;
    this.overrides = options.overrides || {};
    this.provider = options.provider;
    this.signer = options.signer;
    this.storage = options.storage;
    if (!this.signer.provider) {
      this.signer = this.signer.connect(this.provider);
    }
  }
  get getSigner() {
    return this.signer;
  }
  get getProvider() {
    return this.provider;
  }
  get getStorage() {
    return this.storage;
  }
  getArgs() {
    return this.args;
  }
  getOverrides() {
    return this.overrides;
  }
  getValue() {
    return this.overrides.value || 0;
  }
  setArgs(args) {
    this.args = args;
    return this;
  }
  setOverrides(overrides) {
    this.overrides = overrides;
    return this;
  }
  updateOverrides(overrides) {
    this.overrides = {
      ...this.overrides,
      ...overrides
    };
    return this;
  }
  setValue(value) {
    this.updateOverrides({
      value
    });
    return this;
  }
  setGasLimit(gasLimit) {
    this.updateOverrides({
      gasLimit
    });
    return this;
  }
  setGasPrice(gasPrice) {
    this.updateOverrides({
      gasPrice
    });
    return this;
  }
  setNonce(nonce) {
    this.updateOverrides({
      nonce
    });
    return this;
  }
  setMaxFeePerGas(maxFeePerGas) {
    this.updateOverrides({
      maxFeePerGas
    });
    return this;
  }
  setMaxPriorityFeePerGas(maxPriorityFeePerGas) {
    this.updateOverrides({
      maxPriorityFeePerGas
    });
    return this;
  }
  setType(type) {
    this.updateOverrides({
      type
    });
    return this;
  }
  setAccessList(accessList) {
    this.updateOverrides({
      accessList
    });
    return this;
  }
  setCustomData(customData) {
    this.updateOverrides({
      customData
    });
    return this;
  }
  setCcipReadEnabled(ccipReadEnabled) {
    this.updateOverrides({
      ccipReadEnabled
    });
    return this;
  }
  /**
   * Set a multiple to multiply the gas limit by
   *
   * @example
   * ```js
   * // Set the gas limit multiple to 1.2 (increase by 20%)
   * tx.setGasLimitMultiple(1.2)
   * ```
   */
  setGasLimitMultiple(factor) {
    if (BigNumber.isBigNumber(this.overrides.gasLimit)) {
      this.overrides.gasLimit = BigNumber.from(Math.floor(BigNumber.from(this.overrides.gasLimit).toNumber() * factor));
    } else {
      this.gasMultiple = factor;
    }
  }
  /**
   * Estimate the total gas cost of this transaction (in both ether and wei)
   */
  async estimateGasCost() {
    const [gasLimit, gasPrice] = await Promise.all([this.estimateGasLimit(), this.getGasPrice()]);
    const gasCost = gasLimit.mul(gasPrice);
    return {
      ether: utils_exports.formatEther(gasCost),
      wei: gasCost
    };
  }
  /**
   * Calculates the gas price for transactions (adding a 10% tip buffer)
   */
  async getGasPrice() {
    return getGasPrice(this.provider);
  }
  /**
   * Get the address of the transaction signer
   */
  async getSignerAddress() {
    return this.signer.getAddress();
  }
  /**
   * Get gas overrides for the transaction
   */
  async getGasOverrides() {
    return getDefaultGasOverrides(this.provider);
  }
  /**
   * Calculates the priority fee per gas according (adding a 10% buffer)
   */
  getPreferredPriorityFee(defaultPriorityFeePerGas) {
    const extraTip = defaultPriorityFeePerGas.div(100).mul(10);
    const txGasPrice = defaultPriorityFeePerGas.add(extraTip);
    return txGasPrice;
  }
};
var Transaction = class _Transaction extends TransactionContext {
  static fromContractWrapper(options) {
    const signer = options.contractWrapper.getSigner();
    if (!signer) {
      throw new Error("Cannot create a transaction without a signer. Please ensure that you have a connected signer.");
    }
    const optionsWithContract = {
      ...options,
      contract: options.contractWrapper.writeContract,
      provider: options.contractWrapper.getProvider(),
      signer,
      gasless: options.contractWrapper.options.gasless,
      storage: options.contractWrapper.storage
    };
    return new _Transaction(optionsWithContract);
  }
  static async fromContractInfo(options) {
    const storage = options.storage;
    let contractAbi = options.contractAbi;
    if (!contractAbi) {
      try {
        const metadata = await fetchContractMetadataFromAddress(options.contractAddress, options.provider, storage);
        contractAbi = metadata.abi;
      } catch {
        throw new Error(`Could resolve contract metadata for address ${options.contractAddress}. Please pass the contract ABI manually with the 'contractAbi' option.`);
      }
    }
    const contract = new Contract(options.contractAddress, contractAbi, options.provider);
    const optionsWithContract = {
      ...options,
      storage,
      contract
    };
    return new _Transaction(optionsWithContract);
  }
  constructor(options) {
    super({
      args: options.args,
      overrides: options.overrides,
      provider: options.provider,
      signer: options.signer,
      storage: options.storage
    });
    this.method = options.method;
    this.gaslessOptions = options.gasless;
    this.parse = options.parse;
    this.contract = options.contract.connect(this.signer);
    this.storage = options.storage;
  }
  getTarget() {
    return this.contract.address;
  }
  getMethod() {
    return this.method;
  }
  getGaslessOptions() {
    return this.gaslessOptions;
  }
  setGaslessOptions(options) {
    this.gaslessOptions = options;
    return this;
  }
  setParse(parse2) {
    this.parse = parse2;
    return this;
  }
  /**
   * Encode the function data for this transaction
   */
  encode() {
    return this.contract.interface.encodeFunctionData(this.method, this.args);
  }
  /**
   * Get the signed transaction
   */
  async sign() {
    const populatedTx = await this.populateTransaction();
    const signedTx = await this.contract.signer.signTransaction(populatedTx);
    return signedTx;
  }
  async populateTransaction() {
    const gasOverrides = await this.getGasOverrides();
    const overrides = {
      ...gasOverrides,
      ...this.overrides
    };
    if (!overrides.gasLimit) {
      overrides.gasLimit = await this.estimateGasLimit();
    }
    const tx = await this.contract.populateTransaction[this.method](...this.args, overrides);
    const populatedTx = await this.contract.signer.populateTransaction(tx);
    return populatedTx;
  }
  /**
   * Simulate the transaction on-chain without executing
   */
  async simulate() {
    if (!this.contract.callStatic[this.method]) {
      throw this.functionError();
    }
    try {
      return await this.contract.callStatic[this.method](...this.args, ...this.overrides.value ? [{
        value: this.overrides.value
      }] : []);
    } catch (err) {
      throw await this.transactionError(err);
    }
  }
  /**
   * Estimate the gas limit of this transaction
   */
  async estimateGasLimit() {
    if (!this.contract.estimateGas[this.method]) {
      throw this.functionError();
    }
    try {
      const gasEstimate = await this.contract.estimateGas[this.method](...this.args, this.overrides);
      if (this.gasMultiple) {
        return BigNumber.from(Math.floor(BigNumber.from(gasEstimate).toNumber() * this.gasMultiple));
      }
      return gasEstimate;
    } catch (err) {
      await this.simulate();
      throw await this.transactionError(err);
    }
  }
  /**
   * Send the transaction without waiting for it to be mined.
   */
  async send() {
    if (!this.contract.functions[this.method]) {
      throw this.functionError();
    }
    if (this.gaslessOptions && ("openzeppelin" in this.gaslessOptions || "biconomy" in this.gaslessOptions)) {
      return this.sendGasless();
    }
    const gasOverrides = await this.getGasOverrides();
    const overrides = {
      ...gasOverrides,
      ...this.overrides
    };
    if (!overrides.gasLimit) {
      overrides.gasLimit = await this.estimateGasLimit();
      try {
        const abi = JSON.parse(this.contract.interface.format("json"));
        if (isRouterContract(abi)) {
          overrides.gasLimit = overrides.gasLimit.mul(110).div(100);
        }
      } catch (err) {
        console.warn("Error raising gas limit", err);
      }
    }
    try {
      return await this.contract.functions[this.method](...this.args, overrides);
    } catch (err) {
      throw await this.transactionError(err);
    }
  }
  /**
   * Send the transaction and wait for it to be mined
   */
  async execute() {
    const tx = await this.send();
    let receipt;
    try {
      receipt = await tx.wait();
    } catch (err) {
      await this.simulate();
      throw await this.transactionError(err);
    }
    if (this.parse) {
      return this.parse(receipt);
    }
    return {
      receipt
    };
  }
  /**
   * Execute the transaction with gasless
   */
  async sendGasless() {
    const tx = await this.prepareGasless();
    const txHash = await defaultGaslessSendFunction(tx, this.signer, this.provider, this.storage, this.gaslessOptions);
    let sentTx;
    let iteration = 1;
    while (!sentTx) {
      try {
        sentTx = await this.provider.getTransaction(txHash);
      } catch (err) {
      }
      if (!sentTx) {
        await new Promise((resolve) => setTimeout(resolve, Math.min(iteration * 1e3, 1e4)));
        iteration++;
      }
      if (iteration > 20) {
        throw new Error(`Unable to retrieve transaction with hash ${txHash}`);
      }
    }
    return sentTx;
  }
  /**
   * @internal
   * @returns
   */
  async prepareGasless() {
    var _a;
    invariant(this.gaslessOptions && ("openzeppelin" in this.gaslessOptions || "biconomy" in this.gaslessOptions), "No gasless options set on this transaction!");
    const signerAddress = await this.getSignerAddress();
    const args = [...this.args];
    if (this.method === "multicall" && Array.isArray(this.args[0]) && args[0].length > 0) {
      args[0] = args[0].map((tx) => utils_exports.solidityPack(["bytes", "address"], [tx, signerAddress]));
    }
    invariant(this.signer, "Cannot execute gasless transaction without valid signer");
    const [{
      chainId
    }, from] = await Promise.all([this.provider.getNetwork(), this.overrides.from || signerAddress]);
    const to = this.contract.address;
    const value = ((_a = this.overrides) == null ? void 0 : _a.value) || 0;
    if (BigNumber.from(value).gt(0)) {
      throw new Error("Cannot send native token value with gasless transaction");
    }
    const data = this.contract.interface.encodeFunctionData(this.method, args);
    let gas = BigNumber.from(0);
    try {
      const gasEstimate = await this.contract.estimateGas[this.method](...args);
      gas = gasEstimate.mul(2);
    } catch (e) {
    }
    if (gas.lt(1e5)) {
      gas = BigNumber.from(5e5);
    }
    if (this.overrides.gasLimit && BigNumber.from(this.overrides.gasLimit).gt(gas)) {
      gas = BigNumber.from(this.overrides.gasLimit);
    }
    return {
      from,
      to,
      data,
      chainId,
      gasLimit: gas,
      functionName: this.method,
      functionArgs: args,
      callOverrides: this.overrides
    };
  }
  functionError() {
    return new Error(`Contract "${this.contract.address}" does not have function "${this.method}"`);
  }
  /**
   * Create a nicely formatted error message with tx metadata and solidity stack trace
   */
  async transactionError(error) {
    var _a, _b, _c;
    const provider2 = this.provider;
    const [network, from] = await Promise.all([provider2.getNetwork(), this.overrides.from || this.getSignerAddress()]);
    const to = this.contract.address;
    const data = this.encode();
    const value = BigNumber.from(this.overrides.value || 0);
    const rpcUrl = (_a = provider2.connection) == null ? void 0 : _a.url;
    const functionSignature = this.contract.interface.getFunction(this.method);
    const methodArgs = this.args.map((arg) => {
      if (JSON.stringify(arg).length <= 80) {
        return JSON.stringify(arg);
      }
      return JSON.stringify(arg, void 0, 2);
    });
    const joinedArgs = methodArgs.join(", ").length <= 80 ? methodArgs.join(", ") : "\n" + methodArgs.map((arg) => "  " + arg.split("\n").join("\n  ")).join(",\n") + "\n";
    const method = `${functionSignature.name}(${joinedArgs})`;
    const hash = error.transactionHash || ((_b = error.transaction) == null ? void 0 : _b.hash) || ((_c = error.receipt) == null ? void 0 : _c.transactionHash);
    const reason = parseRevertReason(error);
    let sources = void 0;
    let contractName = void 0;
    try {
      const metadata = await fetchContractMetadataFromAddress(this.contract.address, this.provider, this.storage);
      if (metadata.name) {
        contractName = metadata.name;
      }
      if (metadata.metadata.sources) {
        sources = await fetchSourceFilesFromMetadata(metadata, this.storage);
      }
    } catch (err) {
    }
    return new TransactionError({
      reason,
      from,
      to,
      method,
      data,
      network,
      rpcUrl,
      value,
      hash,
      contractName,
      sources
    }, error);
  }
};
var DeployTransaction = class extends TransactionContext {
  constructor(options) {
    super(options);
    this.factory = options.factory;
    this.events = options.events;
  }
  encode() {
    return utils_exports.hexlify(utils_exports.concat([this.factory.bytecode, this.factory.interface.encodeDeploy(this.args)]));
  }
  getTarget() {
    return lib_exports.AddressZero;
  }
  getMethod() {
    return "deploy";
  }
  async sign() {
    const populatedTx = await this.populateTransaction();
    return this.signer.signTransaction(populatedTx);
  }
  async simulate() {
    const populatedTx = await this.populateTransaction();
    return this.signer.call(populatedTx);
  }
  async estimateGasLimit() {
    try {
      const gasOverrides = await this.getGasOverrides();
      const overrides = {
        ...gasOverrides,
        ...this.overrides
      };
      const populatedTx = this.factory.getDeployTransaction(...this.args, overrides);
      return this.signer.estimateGas(populatedTx);
    } catch (err) {
      throw await this.deployError(err);
    }
  }
  async send() {
    try {
      const populatedTx = await this.populateTransaction();
      return await this.signer.sendTransaction(populatedTx);
    } catch (err) {
      throw await this.deployError(err);
    }
  }
  async execute() {
    const tx = await this.send();
    try {
      await tx.wait();
    } catch (err) {
      await this.simulate();
      throw await this.deployError(err);
    }
    const contractAddress = utils_exports.getContractAddress({
      from: tx.from,
      nonce: tx.nonce
    });
    if (this.events) {
      this.events.emit("contractDeployed", {
        status: "completed",
        contractAddress,
        transactionHash: tx.hash
      });
    }
    return contractAddress;
  }
  async populateTransaction() {
    const gasOverrides = await this.getGasOverrides();
    const overrides = {
      ...gasOverrides,
      ...this.overrides
    };
    if (!overrides.gasLimit) {
      overrides.gasLimit = await this.estimateGasLimit();
    }
    return this.factory.getDeployTransaction(...this.args, overrides);
  }
  /**
   * Create a nicely formatted error message with tx metadata and solidity stack trace
   */
  async deployError(error) {
    var _a, _b, _c;
    const provider2 = this.provider;
    const [network, from] = await Promise.all([provider2.getNetwork(), this.overrides.from || this.getSignerAddress()]);
    const data = this.encode();
    const value = BigNumber.from(this.overrides.value || 0);
    const rpcUrl = (_a = provider2.connection) == null ? void 0 : _a.url;
    const methodArgs = this.args.map((arg) => {
      if (JSON.stringify(arg).length <= 80) {
        return JSON.stringify(arg);
      }
      return JSON.stringify(arg, void 0, 2);
    });
    const joinedArgs = methodArgs.join(", ").length <= 80 ? methodArgs.join(", ") : "\n" + methodArgs.map((arg) => "  " + arg.split("\n").join("\n  ")).join(",\n") + "\n";
    const method = `deployContract(${joinedArgs})`;
    const hash = error.transactionHash || ((_b = error.transaction) == null ? void 0 : _b.hash) || ((_c = error.receipt) == null ? void 0 : _c.transactionHash);
    const reason = parseRevertReason(error);
    return new TransactionError({
      reason,
      from,
      method,
      data,
      network,
      rpcUrl,
      value,
      hash
    }, error);
  }
};
async function defaultGaslessSendFunction(transaction, signer, provider2, storage, gaslessOptions) {
  if (gaslessOptions && "biconomy" in gaslessOptions) {
    return biconomySendFunction(transaction, signer, provider2, gaslessOptions);
  }
  return defenderSendFunction(transaction, signer, provider2, storage, gaslessOptions);
}
async function biconomySendFunction(transaction, signer, provider2, gaslessOptions) {
  const request = await biconomyPrepareRequest(transaction, signer, provider2, gaslessOptions);
  const response = await (0, import_cross_fetch2.default)("https://api.biconomy.io/api/v2/meta-tx/native", request);
  if (response.ok) {
    const resp = await response.json();
    if (!resp.txHash) {
      throw new Error(`relay transaction failed: ${resp.log}`);
    }
    return resp.txHash;
  }
  throw new Error(`relay transaction failed with status: ${response.status} (${response.statusText})`);
}
async function defenderSendFunction(transaction, signer, provider2, storage, gaslessOptions) {
  invariant(gaslessOptions && "openzeppelin" in gaslessOptions, "calling openzeppelin gasless transaction without openzeppelin config in the SDK options");
  const request = await defenderPrepareRequest(transaction, signer, provider2, storage, gaslessOptions);
  const response = await (0, import_cross_fetch2.default)(gaslessOptions.openzeppelin.relayerUrl, request);
  if (response.ok) {
    const resp = await response.json();
    if (!resp.result) {
      throw new Error(`Relay transaction failed: ${resp.message}`);
    }
    const result = JSON.parse(resp.result);
    return result.txHash;
  }
  throw new Error(`relay transaction failed with status: ${response.status} (${response.statusText})`);
}
async function defenderPrepareRequest(transaction, signer, provider2, storage, gaslessOptions) {
  invariant(gaslessOptions && "openzeppelin" in gaslessOptions, "calling openzeppelin gasless transaction without openzeppelin config in the SDK options");
  invariant(signer, "provider is not set");
  invariant(provider2, "provider is not set");
  const forwarderAddress = gaslessOptions.openzeppelin.relayerForwarderAddress || (gaslessOptions.openzeppelin.useEOAForwarder ? CONTRACT_ADDRESSES[transaction.chainId].openzeppelinForwarderEOA || await computeEOAForwarderAddress(provider2, storage) : CONTRACT_ADDRESSES[transaction.chainId].openzeppelinForwarder || await computeForwarderAddress(provider2, storage));
  const forwarder = new Contract(forwarderAddress, Forwarder_default, provider2);
  const nonce = await getAndIncrementNonce(forwarder, "getNonce", [transaction.from]);
  let domain;
  let types;
  let message;
  if (gaslessOptions.experimentalChainlessSupport) {
    domain = {
      name: "GSNv2 Forwarder",
      version: "0.0.1",
      verifyingContract: forwarderAddress
    };
    types = {
      ForwardRequest: ChainAwareForwardRequest
    };
    message = {
      from: transaction.from,
      to: transaction.to,
      value: BigNumber.from(0).toString(),
      gas: BigNumber.from(transaction.gasLimit).toString(),
      nonce: BigNumber.from(nonce).toString(),
      data: transaction.data,
      chainid: BigNumber.from(transaction.chainId).toString()
    };
  } else {
    domain = {
      name: gaslessOptions.openzeppelin.domainName,
      version: gaslessOptions.openzeppelin.domainVersion,
      chainId: transaction.chainId,
      verifyingContract: forwarderAddress
    };
    types = {
      ForwardRequest
    };
    message = {
      from: transaction.from,
      to: transaction.to,
      value: BigNumber.from(0).toString(),
      gas: BigNumber.from(transaction.gasLimit).toString(),
      nonce: BigNumber.from(nonce).toString(),
      data: transaction.data
    };
  }
  let signature;
  if (transaction.functionName === "approve" && transaction.functionArgs.length === 2) {
    const spender = transaction.functionArgs[0];
    const amount = transaction.functionArgs[1];
    const {
      message: permit,
      signature: sig
    } = await signEIP2612Permit(signer, transaction.to, transaction.from, spender, amount);
    const {
      r,
      s,
      v
    } = utils_exports.splitSignature(sig);
    message = {
      to: transaction.to,
      owner: permit.owner,
      spender: permit.spender,
      value: BigNumber.from(permit.value).toString(),
      nonce: BigNumber.from(permit.nonce).toString(),
      deadline: BigNumber.from(permit.deadline).toString(),
      r,
      s,
      v
    };
    signature = sig;
  } else {
    const {
      signature: sig
    } = await signTypedDataInternal(signer, domain, types, message);
    signature = sig;
  }
  let messageType = "forward";
  if (message == null ? void 0 : message.owner) {
    messageType = "permit";
  }
  return {
    method: "POST",
    body: JSON.stringify({
      request: message,
      signature,
      forwarderAddress,
      type: messageType
    })
  };
}
async function prepareGaslessRequest(tx) {
  const gaslessTx = await tx.prepareGasless();
  const gaslessOptions = tx.getGaslessOptions();
  if (gaslessOptions && "biconomy" in gaslessOptions) {
    const request = await biconomyPrepareRequest(gaslessTx, tx.getSigner, tx.getProvider, gaslessOptions);
    return {
      url: "https://api.biconomy.io/api/v2/meta-tx/native",
      ...request
    };
  } else {
    invariant(gaslessOptions && "openzeppelin" in gaslessOptions, "calling openzeppelin gasless transaction without openzeppelin config in the SDK options");
    const request = await defenderPrepareRequest(gaslessTx, tx.getSigner, tx.getProvider, tx.getStorage, gaslessOptions);
    return {
      url: gaslessOptions.openzeppelin.relayerUrl,
      ...request
    };
  }
}
async function biconomyPrepareRequest(transaction, signer, provider2, gaslessOptions) {
  var _a;
  invariant(gaslessOptions && "biconomy" in gaslessOptions, "calling biconomySendFunction without biconomy");
  invariant(signer && provider2, "signer and provider must be set");
  const forwarder = new Contract(getContractAddressByChainId(transaction.chainId, "biconomyForwarder"), BiconomyForwarderAbi, provider2);
  const batchId = 0;
  const batchNonce = await getAndIncrementNonce(forwarder, "getNonce", [transaction.from, batchId]);
  const request = {
    from: transaction.from,
    to: transaction.to,
    token: lib_exports.AddressZero,
    txGas: transaction.gasLimit.toNumber(),
    tokenGasPrice: "0",
    batchId,
    batchNonce: batchNonce.toNumber(),
    deadline: Math.floor(Date.now() / 1e3 + (gaslessOptions && "biconomy" in gaslessOptions && ((_a = gaslessOptions.biconomy) == null ? void 0 : _a.deadlineSeconds) || 3600)),
    data: transaction.data
  };
  const hashToSign = utils_exports.arrayify(utils_exports.solidityKeccak256(["address", "address", "address", "uint256", "uint256", "uint256", "uint256", "uint256", "bytes32"], [request.from, request.to, request.token, request.txGas, request.tokenGasPrice, request.batchId, request.batchNonce, request.deadline, utils_exports.keccak256(request.data)]));
  const signature = await signer.signMessage(hashToSign);
  return {
    method: "POST",
    body: JSON.stringify({
      from: transaction.from,
      apiId: gaslessOptions.biconomy.apiId,
      params: [request, signature],
      to: transaction.to,
      gasLimit: transaction.gasLimit.toHexString()
    }),
    headers: {
      "x-api-key": gaslessOptions.biconomy.apiKey,
      "Content-Type": "application/json;charset=utf-8"
    }
  };
}
var ContractMetadata = class {
  constructor(contractWrapper, schema, storage) {
    __publicField(this, "featureName", FEATURE_METADATA.name);
    /**
     * Set the metadata of this contract
     * @remarks OVERWRITE the metadata of a contract
     * @example
     * ```javascript
     * await contract.metadata.set({
     *   name: "My Contract",
     *   description: "My contract description"
     * })
     * ```
     * @public
     * @param metadata - the metadata to set
     * @twfeature ContractMetadata
     */
    __publicField(this, "set", buildTransactionFunction(async (metadata) => {
      const uri = await this._parseAndUploadMetadata(metadata);
      const wrapper = this.contractWrapper;
      if (this.supportsContractMetadata(wrapper)) {
        return Transaction.fromContractWrapper({
          contractWrapper: this.contractWrapper,
          method: "setContractURI",
          args: [uri],
          parse: (receipt) => {
            return {
              receipt,
              data: this.get
            };
          }
        });
      } else {
        throw new ExtensionNotImplementedError(FEATURE_METADATA);
      }
    }));
    /**
     * Update the metadata of a contract
     * @remarks Update the metadata of a contract
     * @example
     * ```javascript
     * await contract.metadata.update({
     *   description: "My new contract description"
     * })
     * ```
     * @public
     * @param metadata - the metadata to update
     * @twfeature ContractMetadata
     * */
    __publicField(this, "update", buildTransactionFunction(async (metadata) => {
      return await this.set.prepare({
        ...await this.get(),
        ...metadata
      });
    }));
    this.contractWrapper = contractWrapper;
    this.schema = schema;
    this.storage = storage;
  }
  /**
   * @internal
   */
  parseOutputMetadata(metadata) {
    return this.schema.output.parseAsync(metadata);
  }
  /**
   * @internal
   */
  parseInputMetadata(metadata) {
    return this.schema.input.parseAsync(metadata);
  }
  /**
   * Get the metadata of this contract
   * @remarks Get the metadata of a contract
   * @example
   * ```javascript
   * const metadata = await contract.metadata.get();
   * console.log(metadata);
   * ```
   * @public
   * @returns the metadata of the given contract
   * @twfeature ContractMetadata
   */
  async get() {
    let data;
    if (this.supportsContractMetadata(this.contractWrapper)) {
      const uri = await this.contractWrapper.read("contractURI", []);
      if (uri && uri.includes("://")) {
        data = await this.storage.downloadJSON(uri);
      }
    }
    if (!data) {
      try {
        let contractName;
        try {
          if (hasFunction("name", this.contractWrapper)) {
            contractName = await this.contractWrapper.read("name", []);
          }
        } catch (err) {
        }
        let contractSymbol;
        try {
          if (hasFunction("symbol", this.contractWrapper)) {
            contractSymbol = await this.contractWrapper.read("symbol", []);
          }
        } catch (err) {
        }
        let publishedMetadata;
        try {
          publishedMetadata = await fetchContractMetadataFromAddress(this.contractWrapper.address, this.contractWrapper.getProvider(), this.storage, this.contractWrapper.options);
        } catch (err) {
        }
        data = {
          name: contractName || (publishedMetadata == null ? void 0 : publishedMetadata.name),
          symbol: contractSymbol,
          description: publishedMetadata == null ? void 0 : publishedMetadata.info.title
        };
      } catch (e) {
        throw new Error("Could not fetch contract metadata");
      }
    }
    return this.parseOutputMetadata(data);
  }
  /**
   *
   * @internal
   * @param metadata - the metadata to set
   * @returns
   */
  async _parseAndUploadMetadata(metadata) {
    const parsedMetadata = await this.parseInputMetadata(metadata);
    return this.storage.upload(parsedMetadata);
  }
  supportsContractMetadata(contractWrapper) {
    return detectContractFeature(contractWrapper, "ContractMetadata");
  }
};
var roleMap = {
  admin: "",
  transfer: "TRANSFER_ROLE",
  minter: "MINTER_ROLE",
  pauser: "PAUSER_ROLE",
  lister: "LISTER_ROLE",
  asset: "ASSET_ROLE",
  unwrap: "UNWRAP_ROLE",
  factory: "FACTORY_ROLE",
  signer: "SIGNER_ROLE"
};
var ALL_ROLES = Object.keys(roleMap);
function getRoleHash(role) {
  if (role === "admin") {
    return utils_exports.hexZeroPad([0], 32);
  }
  return utils_exports.id(roleMap[role]);
}
var ContractRoles = class {
  /**
   * @internal
   * @remarks This is used for typing inside react hooks which is why it has to be public.
   */
  constructor(contractWrapper, roles) {
    __publicField(this, "featureName", FEATURE_PERMISSIONS.name);
    /**
     * Overwrite the list of members for specific roles
     *
     * @remarks Every role in the list will be overwritten with the new list of addresses provided with them.
     * If you want to add or remove addresses for a single address use {@link ContractRoles.grant} and {@link ContractRoles.revoke} respectively instead.
     * @param rolesWithAddresses - A record of {@link Role}s to lists of addresses that should be members of the given role.
     * @throws If you are requesting a role that does not exist on the contract this will throw an error.
     * @example Say you want to overwrite the list of addresses that are members of the minter role.
     * ```javascript
     * const minterAddresses = await contract.roles.get("minter");
     * await contract.roles.setAll({
     *  minter: []
     * });
     * console.log(await contract.roles.get("minter")); // No matter what members had the role before, the new list will be set to []
     * ```
     * @public
     * @twfeature Permissions
     *
     * */
    __publicField(this, "setAll", buildTransactionFunction(async (rolesWithAddresses) => {
      var _a, _b;
      const contractEncoder = new ContractEncoder(this.contractWrapper);
      const roles = Object.keys(rolesWithAddresses);
      invariant(roles.length, "you must provide at least one role to set");
      invariant(roles.every((role) => this.roles.includes(role)), "this contract does not support the given role");
      const currentRoles = await this.getAll();
      const encoded = [];
      const sortedRoles = roles.sort((role) => role === "admin" ? 1 : -1);
      for (let i = 0; i < sortedRoles.length; i++) {
        const role = sortedRoles[i];
        const addresses = await Promise.all(((_a = rolesWithAddresses[role]) == null ? void 0 : _a.map(async (addressOrEns) => await resolveAddress(addressOrEns))) || []);
        const currentAddresses = await Promise.all(((_b = currentRoles[role]) == null ? void 0 : _b.map(async (addressOrEns) => await resolveAddress(addressOrEns))) || []);
        const toAdd = addresses.filter((address) => !currentAddresses.includes(address));
        const toRemove = currentAddresses.filter((address) => !addresses.includes(address));
        if (toAdd.length) {
          toAdd.forEach((address) => {
            encoded.push(contractEncoder.encode("grantRole", [getRoleHash(role), address]));
          });
        }
        if (toRemove.length) {
          for (let j = 0; j < toRemove.length; j++) {
            const address = toRemove[j];
            const revokeFunctionName = await this.getRevokeRoleFunctionName(address);
            encoded.push(contractEncoder.encode(revokeFunctionName, [getRoleHash(role), address]));
          }
        }
      }
      return Transaction.fromContractWrapper({
        contractWrapper: this.contractWrapper,
        method: "multicall",
        args: [encoded]
      });
    }));
    /** **************************
     * WRITE FUNCTIONS
     ****************************/
    /**
     * Grant a role to a specific address
     *
     * @remarks Make sure you are sure you want to grant the role to the address.
     *
     * @example
     * ```javascript
     * await contract.roles.grant("minter", "{{wallet_address}}");
     * ```
     *
     * @param role - The {@link Role} to grant to the address
     * @param address - The address to grant the role to
     * @returns The transaction receipt
     * @throws If you are trying to grant does not exist on the contract this will throw an error.
     *
     * @public
     * @twfeature Permissions
     */
    __publicField(this, "grant", buildTransactionFunction(async (role, address) => {
      invariant(this.roles.includes(role), `this contract does not support the "${role}" role`);
      const resolvedAddress = await resolveAddress(address);
      return Transaction.fromContractWrapper({
        contractWrapper: this.contractWrapper,
        method: "grantRole",
        args: [getRoleHash(role), resolvedAddress]
      });
    }));
    /**
     * Revoke a role from a specific address
     *
     * @remarks
     *
     * -- Caution --
     *
     * This will let you remove yourself from the role, too.
     * If you remove yourself from the admin role, you will no longer be able to administer the contract.
     * There is no way to recover from this.
     *
     * @example
     * ```javascript
     * await contract.roles.revoke("minter", "{{wallet_address}}");
     * ```
     *
     * @param role - The {@link Role} to revoke
     * @param address - The address to revoke the role from
     * @returns The transaction receipt
     * @throws If you are trying to revoke does not exist on the module this will throw an error.
     *
     * @public
     * @twfeature Permissions
     */
    __publicField(this, "revoke", buildTransactionFunction(async (role, address) => {
      invariant(this.roles.includes(role), `this contract does not support the "${role}" role`);
      const resolvedAddress = await resolveAddress(address);
      const revokeFunctionName = await this.getRevokeRoleFunctionName(resolvedAddress);
      return Transaction.fromContractWrapper({
        contractWrapper: this.contractWrapper,
        method: revokeFunctionName,
        args: [getRoleHash(role), resolvedAddress]
      });
    }));
    this.contractWrapper = contractWrapper;
    this.roles = roles;
  }
  /** **************************
   * READ FUNCTIONS
   ****************************/
  /**
   * Get all members of all roles
   * @remarks See {@link ContractRoles.get} to get a list of addresses that are members of a specific role.
   * @example
   * ```javascript
   * const rolesAndMembers = await contract.roles.getAll();
   * ```
   * @returns A record of {@link Role}s to lists of addresses that are members of the given role.
   * @throws If the contract does not support roles this will throw an error.
   *
   * @public
   * @twfeature PermissionsEnumerable
   */
  async getAll() {
    invariant(this.roles.length, "this contract has no support for roles");
    const roles = {};
    for (const role of this.roles) {
      roles[role] = await this.get(role);
    }
    return roles;
  }
  /**
   * Get all members of a specific role
   * @remarks See {@link ContractRoles.getAll} to get get a list of addresses for all supported roles on the contract.
   * @param role - The Role to to get a memberlist for.
   * @returns The list of addresses that are members of the specific role.
   * @throws If you are requesting a role that does not exist on the contract this will throw an error.
   *
   * @example Say you want to get the list of addresses that are members of the minter role.
   * ```javascript
   * const minterAddresses = await contract.roles.get("minter");
   * ```
   *
   * @public
   * @twfeature Permissions
   */
  async get(role) {
    invariant(this.roles.includes(role), `this contract does not support the "${role}" role`);
    const wrapper = this.contractWrapper;
    if (hasFunction("getRoleMemberCount", wrapper) && hasFunction("getRoleMember", wrapper)) {
      const roleHash = getRoleHash(role);
      const count = (await wrapper.read("getRoleMemberCount", [roleHash])).toNumber();
      return await Promise.all(Array.from(Array(count).keys()).map((i) => wrapper.read("getRoleMember", [roleHash, i])));
    }
    throw new Error("Contract does not support enumerating roles. Please implement IPermissionsEnumerable to unlock this functionality.");
  }
  /**
   * Throws an error if an address is missing the roles specified.
   *
   * @param roles - The roles to check
   * @param address - The address to check
   *
   * @internal
   */
  async verify(roles, address) {
    await Promise.all(roles.map(async (role) => {
      const members = await this.get(role);
      const resolvedAddress = await resolveAddress(address);
      if (!members.map((a) => a.toLowerCase()).includes(resolvedAddress.toLowerCase())) {
        throw new MissingRoleError(resolvedAddress, role);
      }
    }));
  }
  /** **************************
   * PRIVATE FUNCTIONS
   ****************************/
  async getRevokeRoleFunctionName(address) {
    const resolvedAddress = await resolveAddress(address);
    const signerAddress = await this.contractWrapper.getSignerAddress();
    if (signerAddress.toLowerCase() === resolvedAddress.toLowerCase()) {
      return "renounceRole";
    }
    return "revokeRole";
  }
};
var ContractRoyalty = class {
  constructor(contractWrapper, metadata) {
    __publicField(this, "featureName", FEATURE_ROYALTY.name);
    /**
     * Set the royalty recipient and fee
     * @param royaltyData - the royalty recipient and fee
     *  @example
     * ```javascript
     * await contract.roles.setDefaultRoyaltyInfo({
     *   seller_fee_basis_points: 100, // 1% royalty fee
     *   fee_recipient: "0x...", // the fee recipient
     * });
     * ```
     * @public
     * @twfeature Royalty
     */
    __publicField(this, "setDefaultRoyaltyInfo", buildTransactionFunction(async (royaltyData) => {
      const oldMetadata = await this.metadata.get();
      const mergedMetadata = await this.metadata.parseInputMetadata({
        ...oldMetadata,
        ...royaltyData
      });
      const contractURI = await this.metadata._parseAndUploadMetadata(mergedMetadata);
      if (hasFunction("setContractURI", this.contractWrapper)) {
        const contractEncoder = new ContractEncoder(this.contractWrapper);
        const encoded = [contractEncoder.encode("setDefaultRoyaltyInfo", [mergedMetadata.fee_recipient, mergedMetadata.seller_fee_basis_points]), contractEncoder.encode("setContractURI", [contractURI])];
        return Transaction.fromContractWrapper({
          contractWrapper: this.contractWrapper,
          method: "multicall",
          args: [encoded],
          parse: (receipt) => ({
            receipt,
            data: () => this.getDefaultRoyaltyInfo()
          })
        });
      } else {
        throw new Error("Updating royalties requires implementing ContractMetadata in your contract to support marketplaces like OpenSea.");
      }
    }));
    /**
     * Set the royalty recipient and fee for a particular token
     * @param tokenId - the token id
     * @param royaltyData - the royalty recipient and fee
     * @example
     * ```javascript
     * const tokenId = 0;
     * await contract.roles.setTokenRoyaltyInfo(tokenId, {
     *   seller_fee_basis_points: 100, // 1% royalty fee
     *   fee_recipient: "0x...", // the fee recipient
     * });
     * ```
     * @public
     * @twfeature Royalty
     */
    __publicField(this, "setTokenRoyaltyInfo", buildTransactionFunction(async (tokenId, royaltyData) => {
      const parsedRoyaltyData = CommonRoyaltySchema.parse(royaltyData);
      return Transaction.fromContractWrapper({
        contractWrapper: this.contractWrapper,
        method: "setRoyaltyInfoForToken",
        args: [tokenId, parsedRoyaltyData.fee_recipient, parsedRoyaltyData.seller_fee_basis_points],
        parse: (receipt) => ({
          receipt,
          data: () => this.getDefaultRoyaltyInfo()
        })
      });
    }));
    this.contractWrapper = contractWrapper;
    this.metadata = metadata;
  }
  /**
   * Get the royalty recipient and fee
   * @returns - The royalty recipient and BPS
   * @example
   * ```javascript
   * const royaltyInfo = await contract.royalties.getDefaultRoyaltyInfo();
   * console.log(royaltyInfo.fee_recipient);
   * console.log(royaltyInfo.seller_fee_basis_points);
   * ```
   * @public
   * @twfeature Royalty
   */
  async getDefaultRoyaltyInfo() {
    const [royaltyRecipient, royaltyBps] = await this.contractWrapper.read("getDefaultRoyaltyInfo", []);
    return CommonRoyaltySchema.parseAsync({
      fee_recipient: royaltyRecipient,
      seller_fee_basis_points: royaltyBps
    });
  }
  /**
   * Get the royalty recipient and fee of a particular token
   * @returns - The royalty recipient and BPS
   * @example
   * ```javascript
   * const royaltyInfo = await contract.royalties.getDefaultRoyaltyInfo();
   * console.log(royaltyInfo.fee_recipient);
   * console.log(royaltyInfo.seller_fee_basis_points);
   * ```
   * @public
   * @twfeature Royalty
   */
  async getTokenRoyaltyInfo(tokenId) {
    const [royaltyRecipient, royaltyBps] = await this.contractWrapper.read("getRoyaltyInfoForToken", [tokenId]);
    return CommonRoyaltySchema.parseAsync({
      fee_recipient: royaltyRecipient,
      seller_fee_basis_points: royaltyBps
    });
  }
};
var ContractPrimarySale = class {
  constructor(contractWrapper) {
    __publicField(this, "featureName", FEATURE_PRIMARY_SALE.name);
    /**
     * Set the primary sale recipient
     * @param recipient - the wallet address
     * @example
     * ```javascript
     * await contract.sales.setRecipient(recipientWalletAddress);
     * ```
     * @public
     * @twfeature PrimarySale
     */
    __publicField(this, "setRecipient", buildTransactionFunction(async (recipient) => {
      return Transaction.fromContractWrapper({
        contractWrapper: this.contractWrapper,
        method: "setPrimarySaleRecipient",
        args: [recipient]
      });
    }));
    this.contractWrapper = contractWrapper;
  }
  /**
   * Get the primary sale recipient
   * @returns the wallet address.
   * @example
   * ```javascript
   * const salesRecipient = await contract.sales.getRecipient();
   * ```
   * @public
   * @twfeature PrimarySale
   */
  async getRecipient() {
    const result = await this.contractWrapper.read("primarySaleRecipient", []);
    return result;
  }
};
var FALLBACK_METADATA = {
  name: "Failed to load NFT metadata"
};
async function fetchTokenMetadata(tokenId, tokenUri, storage) {
  if (tokenUri.startsWith("data:application/json;base64") && typeof import_buffer.Buffer !== "undefined") {
    const base64 = tokenUri.split(",")[1];
    const jsonMetadata2 = JSON.parse(import_buffer.Buffer.from(base64, "base64").toString("utf-8"));
    return CommonNFTOutput.parse({
      ...jsonMetadata2,
      id: BigNumber.from(tokenId).toString(),
      uri: tokenUri
    });
  }
  const parsedUri = tokenUri.replace("{id}", utils_exports.hexZeroPad(BigNumber.from(tokenId).toHexString(), 32).slice(2));
  let jsonMetadata;
  try {
    jsonMetadata = await storage.downloadJSON(parsedUri);
  } catch (err) {
    const unparsedTokenIdUri = tokenUri.replace("{id}", BigNumber.from(tokenId).toString());
    try {
      jsonMetadata = await storage.downloadJSON(unparsedTokenIdUri);
    } catch (e) {
      console.warn(`failed to get token metadata: ${JSON.stringify({
        tokenId: tokenId.toString(),
        tokenUri
      })} -- falling back to default metadata`);
      jsonMetadata = FALLBACK_METADATA;
    }
  }
  return CommonNFTOutput.parse({
    ...jsonMetadata,
    id: BigNumber.from(tokenId).toString(),
    uri: tokenUri
  });
}
async function fetchTokenMetadataForContract(contractAddress, provider2, tokenId, storage) {
  let uri;
  const erc165 = new Contract(contractAddress, IERC165_default, provider2);
  const [isERC721, isERC1155] = await Promise.all([erc165.supportsInterface(InterfaceId_IERC721), erc165.supportsInterface(InterfaceId_IERC1155)]);
  if (isERC721) {
    const erc721 = new Contract(contractAddress, IERC721Metadata_default, provider2);
    uri = await erc721.tokenURI(tokenId);
  } else if (isERC1155) {
    const erc1155 = new Contract(contractAddress, IERC1155Metadata_default, provider2);
    uri = await erc1155.uri(tokenId);
  } else {
    throw Error("Contract must implement ERC 1155 or ERC 721.");
  }
  if (!uri) {
    return CommonNFTOutput.parse({
      ...FALLBACK_METADATA,
      id: BigNumber.from(tokenId).toString(),
      uri: ""
    });
  }
  return fetchTokenMetadata(tokenId, uri, storage);
}
async function uploadOrExtractURI(metadata, storage) {
  if (typeof metadata === "string") {
    return metadata;
  } else {
    return await storage.upload(CommonNFTInput.parse(metadata));
  }
}
async function uploadOrExtractURIs(metadatas, storage, startNumber, options) {
  if (isUriList(metadatas)) {
    return metadatas;
  } else if (isMetadataList(metadatas)) {
    const uris = await storage.uploadBatch(metadatas.map((m) => CommonNFTInput.parse(m)), {
      rewriteFileNames: {
        fileStartNumber: startNumber || 0
      },
      onProgress: options == null ? void 0 : options.onProgress
    });
    return uris;
  } else {
    throw new Error("NFT metadatas must all be of the same type (all URI or all NFTMetadataInput)");
  }
}
function getBaseUriFromBatch(uris) {
  const baseUri = uris[0].substring(0, uris[0].lastIndexOf("/"));
  for (let i = 0; i < uris.length; i++) {
    const uri = uris[i].substring(0, uris[i].lastIndexOf("/"));
    if (baseUri !== uri) {
      throw new Error(`Can only create batches with the same base URI for every entry in the batch. Expected '${baseUri}' but got '${uri}'`);
    }
  }
  return baseUri.replace(/\/$/, "") + "/";
}
function isUriList(metadatas) {
  return metadatas.find((m) => typeof m !== "string") === void 0;
}
function isMetadataList(metadatas) {
  return metadatas.find((m) => typeof m !== "object") === void 0;
}
var DelayedReveal = class {
  constructor(contractWrapper, storage, featureName, nextTokenIdToMintFn) {
    /**
     * Create a batch of encrypted NFTs that can be revealed at a later time.
     * @remarks Create a batch of encrypted NFTs that can be revealed at a later time.
     * @example
     * ```javascript
     * // the real NFTs, these will be encrypted until your reveal them!
     * const realNFTs = [{
     *   name: "Common NFT #1",
     *   description: "Common NFT, one of many.",
     *   image: fs.readFileSync("path/to/image.png"),
     * }, {
     *   name: "Super Rare NFT #2",
     *   description: "You got a Super Rare NFT!",
     *   image: fs.readFileSync("path/to/image.png"),
     * }];
     * // A placeholder NFT that people will get immediately in their wallet, until the reveal happens!
     * const placeholderNFT = {
     *   name: "Hidden NFT",
     *   description: "Will be revealed next week!"
     * };
     * // Create and encrypt the NFTs
     * await contract.revealer.createDelayedRevealBatch(
     *   placeholderNFT,
     *   realNFTs,
     *   "my secret password",
     * );
     * ```
     * @public
     * @param placeholder - the placeholder NFT to show before the reveal
     * @param metadatas - the final NFTs that will be hidden
     * @param password - the password that will be used to reveal these NFTs
     * @param options - additional options like upload progress
     */
    __publicField(this, "createDelayedRevealBatch", buildTransactionFunction(async (placeholder, metadatas, password, options) => {
      if (!password) {
        throw new Error("Password is required");
      }
      const placeholderUris = await this.storage.uploadBatch([CommonNFTInput.parse(placeholder)], {
        rewriteFileNames: {
          fileStartNumber: 0
        }
      });
      const placeholderUri = getBaseUriFromBatch(placeholderUris);
      const startFileNumber = await this.nextTokenIdToMintFn();
      const uris = await this.storage.uploadBatch(metadatas.map((m) => CommonNFTInput.parse(m)), {
        onProgress: options == null ? void 0 : options.onProgress,
        rewriteFileNames: {
          fileStartNumber: startFileNumber.toNumber()
        }
      });
      const baseUri = getBaseUriFromBatch(uris);
      const baseUriId = await this.contractWrapper.read("getBaseURICount", []);
      const hashedPassword = await this.hashDelayRevealPassword(baseUriId, password);
      const encryptedBaseUri = await this.contractWrapper.read("encryptDecrypt", [utils_exports.toUtf8Bytes(baseUri), hashedPassword]);
      let data;
      const legacyContract = await this.isLegacyContract();
      if (legacyContract) {
        data = encryptedBaseUri;
      } else {
        const chainId = await this.contractWrapper.getChainID();
        const provenanceHash = utils_exports.solidityKeccak256(["bytes", "bytes", "uint256"], [utils_exports.toUtf8Bytes(baseUri), hashedPassword, chainId]);
        data = utils_exports.defaultAbiCoder.encode(["bytes", "bytes32"], [encryptedBaseUri, provenanceHash]);
      }
      return Transaction.fromContractWrapper({
        contractWrapper: this.contractWrapper,
        method: "lazyMint",
        args: [uris.length, placeholderUri.endsWith("/") ? placeholderUri : `${placeholderUri}/`, data],
        parse: (receipt) => {
          const events = this.contractWrapper.parseLogs("TokensLazyMinted", receipt == null ? void 0 : receipt.logs);
          const startingIndex = events[0].args.startTokenId;
          const endingIndex = events[0].args.endTokenId;
          const results = [];
          for (let id = startingIndex; id.lte(endingIndex); id = id.add(1)) {
            results.push({
              id,
              receipt
            });
          }
          return results;
        }
      });
    }));
    /**
     * Reveal a batch of hidden NFTs
     * @remarks Reveal the NFTs of a batch using the password.
     * @example
     * ```javascript
     * // the batch to reveal
     * const batchId = 0;
     * // reveal the batch
     * await contract.revealer.reveal(batchId, "my secret password");
     * ```
     * @public
     * @param batchId - the id of the batch to reveal
     * @param password - the password
     */
    __publicField(this, "reveal", buildTransactionFunction(async (batchId, password) => {
      if (!password) {
        throw new Error("Password is required");
      }
      const key = await this.hashDelayRevealPassword(batchId, password);
      try {
        const decryptedUri = await this.contractWrapper.callStatic().reveal(batchId, key);
        if (!decryptedUri.includes("://") || !decryptedUri.endsWith("/")) {
          throw new Error("invalid password");
        }
      } catch (e) {
        throw new Error("invalid password");
      }
      return Transaction.fromContractWrapper({
        contractWrapper: this.contractWrapper,
        method: "reveal",
        args: [batchId, key]
      });
    }));
    this.featureName = featureName;
    this.nextTokenIdToMintFn = nextTokenIdToMintFn;
    this.contractWrapper = contractWrapper;
    this.storage = storage;
  }
  /**
   * Gets the list of unrevealed NFT batches.
   * @remarks Gets the list of unrevealed NFT batches.
   * @example
   * ```javascript
   * const batches = await contract.revealer.getBatchesToReveal();
   * ```
   * @public
   */
  async getBatchesToReveal() {
    const count = await this.contractWrapper.read("getBaseURICount", []);
    if (count.isZero()) {
      return [];
    }
    const countRangeArray = Array.from(Array(count.toNumber()).keys());
    const uriIndices = await Promise.all(countRangeArray.map((i) => {
      if (hasFunction("getBatchIdAtIndex", this.contractWrapper)) {
        return this.contractWrapper.read("getBatchIdAtIndex", [i]);
      }
      if (hasFunction("baseURIIndices", this.contractWrapper)) {
        return this.contractWrapper.read("baseURIIndices", [i]);
      }
      throw new Error("Contract does not have getBatchIdAtIndex or baseURIIndices.");
    }));
    const uriIndicesWithZeroStart = uriIndices.slice(0, uriIndices.length - 1);
    const tokenMetadatas = await Promise.all(Array.from([0, ...uriIndicesWithZeroStart]).map((i) => this.getNftMetadata(i.toString())));
    const legacyContract = await this.isLegacyContract();
    const encryptedUriData = await Promise.all(Array.from([...uriIndices]).map((i) => legacyContract ? this.getLegacyEncryptedData(i) : this.contractWrapper.read("encryptedData", [i])));
    const encryptedBaseUris = encryptedUriData.map((data) => {
      if (utils_exports.hexDataLength(data) > 0) {
        if (legacyContract) {
          return data;
        }
        const result = utils_exports.defaultAbiCoder.decode(["bytes", "bytes32"], data);
        return result[0];
      } else {
        return data;
      }
    });
    return tokenMetadatas.map((meta, index) => ({
      batchId: BigNumber.from(index),
      batchUri: meta.uri,
      placeholderMetadata: meta
    })).filter((_, index) => utils_exports.hexDataLength(encryptedBaseUris[index]) > 0);
  }
  /**
   * Algorithm to hash delay reveal password, so we don't broadcast the input password on-chain.
   *
   * @internal
   */
  async hashDelayRevealPassword(batchTokenIndex, password) {
    const chainId = await this.contractWrapper.getChainID();
    const contractAddress = this.contractWrapper.address;
    return utils_exports.solidityKeccak256(["string", "uint256", "uint256", "address"], [password, chainId, batchTokenIndex, contractAddress]);
  }
  async getNftMetadata(tokenId) {
    return fetchTokenMetadataForContract(this.contractWrapper.address, this.contractWrapper.getProvider(), tokenId, this.storage);
  }
  async isLegacyContract() {
    if (hasFunction("contractVersion", this.contractWrapper)) {
      try {
        const version = await this.contractWrapper.read("contractVersion", []);
        return version <= 2;
      } catch (e) {
        return false;
      }
    }
    return false;
  }
  async getLegacyEncryptedData(index) {
    const legacy = new Contract(this.contractWrapper.address, IDelayedRevealDeprecated_default, this.contractWrapper.getProvider());
    const result = await legacy.functions["encryptedBaseURI"](index);
    if (result.length > 0) {
      return result[0];
    } else {
      return "0x";
    }
  }
};
function abstractContractModelToLegacy(model) {
  return {
    startTimestamp: model.startTimestamp,
    maxClaimableSupply: model.maxClaimableSupply,
    supplyClaimed: model.supplyClaimed,
    merkleRoot: model.merkleRoot,
    pricePerToken: model.pricePerToken,
    currency: model.currency,
    quantityLimitPerTransaction: model.maxClaimablePerWallet,
    waitTimeInSecondsBetweenClaims: model.waitTimeInSecondsBetweenClaims || 0
  };
}
function abstractContractModelToNew(model) {
  return {
    startTimestamp: model.startTimestamp,
    maxClaimableSupply: model.maxClaimableSupply,
    supplyClaimed: model.supplyClaimed,
    merkleRoot: model.merkleRoot,
    pricePerToken: model.pricePerToken,
    currency: model.currency,
    quantityLimitPerWallet: model.maxClaimablePerWallet,
    metadata: model.metadata || ""
  };
}
function convertQuantityToBigNumber(quantity, tokenDecimals) {
  if (quantity === "unlimited") {
    return lib_exports.MaxUint256;
  } else {
    return utils_exports.parseUnits(quantity, tokenDecimals);
  }
}
function isNativeToken(tokenAddress) {
  return tokenAddress.toLowerCase() === NATIVE_TOKEN_ADDRESS || tokenAddress.toLowerCase() === lib_exports.AddressZero;
}
async function fetchCurrencyMetadata(provider2, asset) {
  if (isNativeToken(asset)) {
    const network = await provider2.getNetwork();
    const nativeToken = getNativeTokenByChainId(network.chainId);
    return {
      name: nativeToken.name,
      symbol: nativeToken.symbol,
      decimals: nativeToken.decimals
    };
  } else {
    const erc20 = new Contract(asset, IERC20Metadata_default, provider2);
    const [name, symbol, decimals] = await Promise.all([erc20.name(), erc20.symbol(), erc20.decimals()]);
    return {
      name,
      symbol,
      decimals
    };
  }
}
async function parseSnapshotInputs(inputs) {
  const chunkSize = 25e3;
  const chunks = Array.from({
    length: Math.ceil(inputs.length / chunkSize)
  }, (_, i) => inputs.slice(i * chunkSize, i * chunkSize + chunkSize));
  const results = [];
  for (const chunk of chunks) {
    results.push(...await SnapshotInputSchema.parseAsync(chunk));
  }
  return results;
}
var SHARD_NYBBLES = 2;
var SnapshotFormatVersion = function(SnapshotFormatVersion2) {
  SnapshotFormatVersion2[SnapshotFormatVersion2["V1"] = 1] = "V1";
  SnapshotFormatVersion2[SnapshotFormatVersion2["V2"] = 2] = "V2";
  return SnapshotFormatVersion2;
}({});
var ShardedMerkleTree = class _ShardedMerkleTree {
  constructor(storage, baseUri, originalEntriesUri, shardNybbles, tokenDecimals) {
    this.storage = storage;
    this.shardNybbles = shardNybbles;
    this.baseUri = baseUri;
    this.originalEntriesUri = originalEntriesUri;
    this.tokenDecimals = tokenDecimals;
    this.shards = {};
    this.trees = {};
  }
  static async fromUri(uri, storage) {
    try {
      const shardedMerkleTreeInfo = await storage.downloadJSON(uri);
      if (shardedMerkleTreeInfo.isShardedMerkleTree) {
        return _ShardedMerkleTree.fromShardedMerkleTreeInfo(shardedMerkleTreeInfo, storage);
      }
    } catch (e) {
      return void 0;
    }
  }
  static async fromShardedMerkleTreeInfo(info, storage) {
    return new _ShardedMerkleTree(storage, info.baseUri, info.originalEntriesUri, info.shardNybbles, info.tokenDecimals);
  }
  static hashEntry(entry, tokenDecimals, currencyDecimals, snapshotFormatVersion) {
    switch (snapshotFormatVersion) {
      case SnapshotFormatVersion.V1:
        return utils_exports.solidityKeccak256(["address", "uint256"], [entry.address, convertQuantityToBigNumber(entry.maxClaimable, tokenDecimals)]);
      case SnapshotFormatVersion.V2:
        return utils_exports.solidityKeccak256(["address", "uint256", "uint256", "address"], [entry.address, convertQuantityToBigNumber(entry.maxClaimable, tokenDecimals), convertQuantityToBigNumber(entry.price || "unlimited", currencyDecimals), entry.currencyAddress || lib_exports.AddressZero]);
    }
  }
  static async fetchAndCacheDecimals(cache, provider2, currencyAddress) {
    if (!currencyAddress) {
      return 18;
    }
    let currencyDecimals = cache[currencyAddress];
    if (currencyDecimals === void 0) {
      const currencyMetadata = await fetchCurrencyMetadata(provider2, currencyAddress);
      currencyDecimals = currencyMetadata.decimals;
      cache[currencyAddress] = currencyDecimals;
    }
    return currencyDecimals;
  }
  static async buildAndUpload(snapshotInput, tokenDecimals, provider2, storage, snapshotFormatVersion) {
    let shardNybbles = arguments.length > 5 && arguments[5] !== void 0 ? arguments[5] : SHARD_NYBBLES;
    const inputs = await parseSnapshotInputs(snapshotInput);
    const shards = {};
    for (const snapshotEntry of inputs) {
      const shard = snapshotEntry.address.slice(2, 2 + shardNybbles).toLowerCase();
      if (shards[shard] === void 0) {
        shards[shard] = [];
      }
      shards[shard].push(snapshotEntry);
    }
    const currencyDecimalMap = {};
    const subTrees = await Promise.all(Object.entries(shards).map(async (_ref) => {
      let [shard, entries] = _ref;
      return [shard, new import_merkletreejs.MerkleTree(await Promise.all(entries.map(async (entry) => {
        const currencyDecimals = await _ShardedMerkleTree.fetchAndCacheDecimals(currencyDecimalMap, provider2, entry.currencyAddress);
        return _ShardedMerkleTree.hashEntry(entry, tokenDecimals, currencyDecimals, snapshotFormatVersion);
      })), utils_exports.keccak256, {
        sort: true
      }).getHexRoot()];
    }));
    const roots = Object.fromEntries(subTrees);
    const tree = new import_merkletreejs.MerkleTree(Object.values(roots), utils_exports.keccak256, {
      sort: true
    });
    const shardsToUpload = [];
    for (const [shardId, entries] of Object.entries(shards)) {
      const data = {
        proofs: tree.getProof(roots[shardId]).map((value) => "0x" + value.data.toString("hex")),
        entries
      };
      shardsToUpload.push({
        data: JSON.stringify(data),
        name: `${shardId}.json`
      });
    }
    const uris = await storage.uploadBatch(shardsToUpload);
    const baseUri = uris[0].slice(0, uris[0].lastIndexOf("/"));
    const originalEntriesUri = await storage.upload(inputs);
    const shardedMerkleInfo = {
      merkleRoot: tree.getHexRoot(),
      baseUri,
      originalEntriesUri,
      shardNybbles,
      tokenDecimals,
      isShardedMerkleTree: true
    };
    const masterUri = await storage.upload(shardedMerkleInfo);
    return {
      shardedMerkleInfo,
      uri: masterUri
    };
  }
  async getProof(address, provider2, snapshotFormatVersion) {
    const shardId = address.slice(2, 2 + this.shardNybbles).toLowerCase();
    let shard = this.shards[shardId];
    const currencyDecimalMap = {};
    if (shard === void 0) {
      try {
        shard = this.shards[shardId] = await this.storage.downloadJSON(`${this.baseUri}/${shardId}.json`);
        const hashedEntries = await Promise.all(shard.entries.map(async (entry2) => {
          const currencyDecimals2 = await _ShardedMerkleTree.fetchAndCacheDecimals(currencyDecimalMap, provider2, entry2.currencyAddress);
          return _ShardedMerkleTree.hashEntry(entry2, this.tokenDecimals, currencyDecimals2, snapshotFormatVersion);
        }));
        this.trees[shardId] = new import_merkletreejs.MerkleTree(hashedEntries, utils_exports.keccak256, {
          sort: true
        });
      } catch (e) {
        return null;
      }
    }
    const entry = shard.entries.find((i) => i.address.toLowerCase() === address.toLowerCase());
    if (!entry) {
      return null;
    }
    const currencyDecimals = await _ShardedMerkleTree.fetchAndCacheDecimals(currencyDecimalMap, provider2, entry.currencyAddress);
    const leaf = _ShardedMerkleTree.hashEntry(entry, this.tokenDecimals, currencyDecimals, snapshotFormatVersion);
    const proof = this.trees[shardId].getProof(leaf).map((i) => "0x" + i.data.toString("hex"));
    return SnapshotEntryWithProofSchema.parseAsync({
      ...entry,
      proof: proof.concat(shard.proofs)
    });
  }
  async getAllEntries() {
    try {
      return await this.storage.downloadJSON(this.originalEntriesUri);
    } catch (e) {
      console.warn("Could not fetch original snapshot entries", e);
      return [];
    }
  }
};
async function fetchSnapshotEntryForAddress(address, merkleRoot, merkleMetadata, provider2, storage, snapshotFormatVersion) {
  if (!merkleMetadata) {
    return null;
  }
  const snapshotUri = merkleMetadata[merkleRoot];
  if (snapshotUri) {
    const raw = await storage.downloadJSON(snapshotUri);
    if (raw.isShardedMerkleTree && raw.merkleRoot === merkleRoot) {
      const merkleTree = await ShardedMerkleTree.fromShardedMerkleTreeInfo(raw, storage);
      return await merkleTree.getProof(address, provider2, snapshotFormatVersion);
    }
    const snapshotData = await SnapshotSchema.parseAsync(raw);
    if (merkleRoot === snapshotData.merkleRoot) {
      return snapshotData.claims.find((c) => c.address.toLowerCase() === address.toLowerCase()) || null;
    }
  }
  return null;
}
function legacyContractModelToAbstract(model) {
  return {
    startTimestamp: model.startTimestamp,
    maxClaimableSupply: model.maxClaimableSupply,
    supplyClaimed: model.supplyClaimed,
    merkleRoot: model.merkleRoot.toString(),
    pricePerToken: model.pricePerToken,
    currency: model.currency,
    maxClaimablePerWallet: model.quantityLimitPerTransaction,
    waitTimeInSecondsBetweenClaims: model.waitTimeInSecondsBetweenClaims
  };
}
function newContractModelToAbstract(model) {
  return {
    startTimestamp: model.startTimestamp,
    maxClaimableSupply: model.maxClaimableSupply,
    supplyClaimed: model.supplyClaimed,
    merkleRoot: model.merkleRoot.toString(),
    pricePerToken: model.pricePerToken,
    currency: model.currency,
    maxClaimablePerWallet: model.quantityLimitPerWallet,
    waitTimeInSecondsBetweenClaims: 0,
    metadata: model.metadata
  };
}
var RPCConnectionHandler = class extends eventemitter3_default {
  constructor(network, options) {
    super();
    try {
      this.options = SDKOptionsSchema.parse(options);
    } catch (optionParseError) {
      console.error("invalid sdk options object passed, falling back to default options", optionParseError);
      this.options = SDKOptionsSchema.parse({});
    }
    const [signer, provider2] = getSignerAndProvider(network, this.options);
    this.network = network;
    this.signer = signer;
    this.provider = provider2;
  }
  /**
   * The function to call whenever the network changes, such as when the users connects their wallet, disconnects their wallet, the connected chain changes, etc.
   *
   * @param network - a network, signer or provider that ethers js can interpret
   */
  updateSignerOrProvider(network) {
    const [signer, provider2] = getSignerAndProvider(network, this.options);
    this.network = network;
    this.signer = signer;
    this.provider = provider2;
  }
  /**
   *
   * @returns whether or not a signer is set, `true` if there is no signer so the class is in "read only" mode
   */
  isReadOnly() {
    return !isSigner(this.signer);
  }
  /**
   * Explicitly get the active signer.
   * @returns the active signer, if there is one
   */
  getSigner() {
    return this.signer;
  }
  /**
   * Explicitly get the active provider.
   * @returns the active provider
   */
  getProvider() {
    return this.provider;
  }
  /**
   *
   * @returns the current signer if there is one, otherwise the active provider
   */
  getSignerOrProvider() {
    return this.getSigner() || this.getProvider();
  }
};
var ContractWrapper = class extends RPCConnectionHandler {
  /**
   * @internal
   */
  constructor(network, contractAddress, contractAbi, options, storage) {
    super(network, options);
    __publicField(this, "isValidContract", false);
    __publicField(this, "customOverrides", () => ({}));
    this.abi = contractAbi;
    this.address = contractAddress;
    this.writeContract = new Contract(contractAddress, contractAbi, this.getSignerOrProvider());
    this.readContract = this.writeContract.connect(this.getProvider());
    this.storage = storage;
  }
  updateSignerOrProvider(network) {
    super.updateSignerOrProvider(network);
    this.writeContract = this.writeContract.connect(this.getSignerOrProvider());
    this.readContract = this.writeContract.connect(this.getProvider());
  }
  updateAbi(updatedAbi) {
    this.writeContract = new Contract(this.address, updatedAbi, this.getSignerOrProvider());
    this.readContract = this.writeContract.connect(this.getProvider());
    this.abi = AbiSchema.parse(updatedAbi);
  }
  /**
   * @internal
   */
  async getChainID() {
    const provider2 = this.getProvider();
    const {
      chainId
    } = await provider2.getNetwork();
    return chainId;
  }
  /**
   * @internal
   */
  async getSignerAddress() {
    const signer = this.getSigner();
    if (!signer) {
      throw new Error("This action requires a connected wallet to sign the transaction. Please pass a valid signer to the SDK.");
    }
    return await signer.getAddress();
  }
  /**
   * @internal
   */
  callStatic() {
    return this.writeContract.callStatic;
  }
  /**
   * @internal
   */
  async getCallOverrides() {
    return getDefaultGasOverrides(this.getProvider());
  }
  /**
   * @internal
   */
  emitTransactionEvent(status, transactionHash) {
    this.emit(EventType.Transaction, {
      status,
      transactionHash
    });
  }
  /**
   * @internal
   */
  async multiCall(encoded) {
    return this.sendTransaction("multicall", [encoded]);
  }
  /**
   * @internal
   */
  async estimateGas(fn, args) {
    return this.writeContract.estimateGas[fn](...args);
  }
  /**
   * @internal
   */
  withTransactionOverride(hook) {
    this.customOverrides = hook;
  }
  /**
   *
   * @param functionName The function name on the contract to call
   * @param args The arguments to be passed to the functionName
   * @returns The return value of the function call
   */
  async read(functionName, args) {
    const functions = extractFunctionsFromAbi(AbiSchema.parse(this.abi)).filter((f2) => f2.name === functionName);
    if (!functions.length) {
      throw new Error(`Function "${functionName.toString()}" not found in contract. Check your dashboard for the list of functions available`);
    }
    const fn = functions.find((f2) => f2.name === functionName && f2.inputs.length === args.length);
    if (!fn) {
      throw new Error(`Function "${functionName.toString()}" requires ${functions[0].inputs.length} arguments, but ${args.length} were provided.
Expected function signature: ${functions[0].signature}`);
    }
    const ethersFnName = `${functionName.toString()}(${fn.inputs.map((i) => i.type).join()})`;
    const fnName = ethersFnName in this.readContract.functions ? ethersFnName : functionName;
    if (fn.stateMutability === "view" || fn.stateMutability === "pure") {
      const result = await this.readContract[fnName.toString()](...args);
      return result;
    }
    throw new Error("Cannot call a write function with read()");
  }
  /**
   * @internal
   */
  async call(functionName) {
    let args = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : [];
    let overrides = arguments.length > 2 ? arguments[2] : void 0;
    const txOptions = overrides ? await CallOverrideSchema.parseAsync(overrides) : void 0;
    const functions = extractFunctionsFromAbi(AbiSchema.parse(this.abi)).filter((f2) => f2.name === functionName);
    if (!functions.length) {
      throw new Error(`Function "${functionName}" not found in contract. Check your dashboard for the list of functions available`);
    }
    const fn = functions.find((f2) => f2.name === functionName && f2.inputs.length === args.length);
    if (!fn) {
      throw new Error(`Function "${functionName}" requires ${functions[0].inputs.length} arguments, but ${args.length} were provided.
Expected function signature: ${functions[0].signature}`);
    }
    const ethersFnName = `${functionName}(${fn.inputs.map((i) => i.type).join()})`;
    const fnName = ethersFnName in this.readContract.functions ? ethersFnName : functionName;
    if (fn.stateMutability === "view" || fn.stateMutability === "pure") {
      return txOptions ? this.readContract[fnName](...args, txOptions) : this.readContract[fnName](...args);
    } else {
      const receipt = await this.sendTransaction(fnName, args, txOptions);
      return {
        receipt
      };
    }
  }
  /**
   * @internal
   */
  async sendTransaction(fn, args, callOverrides) {
    var _a;
    if (!callOverrides) {
      callOverrides = await this.getCallOverrides();
    }
    callOverrides = {
      ...callOverrides,
      ...this.customOverrides()
    };
    this.customOverrides = () => ({});
    if (((_a = this.options) == null ? void 0 : _a.gasless) && ("openzeppelin" in this.options.gasless || "biconomy" in this.options.gasless)) {
      if (fn === "multicall" && Array.isArray(args[0]) && args[0].length > 0) {
        const from = await this.getSignerAddress();
        args[0] = args[0].map((tx) => utils_exports.solidityPack(["bytes", "address"], [tx, from]));
      }
      const provider2 = this.getProvider();
      const txHash = await this.sendGaslessTransaction(fn, args, callOverrides);
      this.emitTransactionEvent("submitted", txHash);
      const receipt = await provider2.waitForTransaction(txHash);
      this.emitTransactionEvent("completed", txHash);
      return receipt;
    } else {
      if (!this.isValidContract) {
        const code = await this.getProvider().getCode(this.address);
        this.isValidContract = code !== "0x";
        if (!this.isValidContract) {
          throw new Error("The address you're trying to send a transaction to is not a smart contract. Make sure you are on the correct network and the contract address is correct");
        }
      }
      const tx = await this.sendTransactionByFunction(fn, args, callOverrides);
      this.emitTransactionEvent("submitted", tx.hash);
      let receipt;
      try {
        receipt = await tx.wait();
      } catch (err) {
        try {
          await this.writeContract.callStatic[fn](...args, ...callOverrides.value ? [{
            value: callOverrides.value
          }] : []);
        } catch (staticErr) {
          throw await this.formatError(staticErr, fn, args, callOverrides);
        }
        throw await this.formatError(err, fn, args, callOverrides);
      }
      this.emitTransactionEvent("completed", tx.hash);
      return receipt;
    }
  }
  /**
   * @internal
   */
  async sendTransactionByFunction(fn, args, callOverrides) {
    const func = this.writeContract.functions[fn];
    if (!func) {
      throw new Error(`invalid function: "${fn.toString()}"`);
    }
    if (!callOverrides.gasLimit) {
      try {
        callOverrides.gasLimit = await this.writeContract.estimateGas[fn](...args, callOverrides);
      } catch (e) {
        try {
          await this.writeContract.callStatic[fn](...args, ...callOverrides.value ? [{
            value: callOverrides.value
          }] : []);
        } catch (err) {
          throw await this.formatError(err, fn, args, callOverrides);
        }
      }
    }
    try {
      return await func(...args, callOverrides);
    } catch (err) {
      throw await this.formatError(err, fn, args, callOverrides);
    }
  }
  async formatError(error, fn, args, callOverrides) {
    var _a, _b, _c;
    const provider2 = this.getProvider();
    const network = await provider2.getNetwork();
    const from = await (callOverrides.from || this.getSignerAddress());
    const to = this.address;
    const data = this.readContract.interface.encodeFunctionData(fn, args);
    const value = BigNumber.from(callOverrides.value || 0);
    const rpcUrl = (_a = provider2.connection) == null ? void 0 : _a.url;
    const functionSignature = this.readContract.interface.getFunction(fn);
    const methodArgs = args.map((arg) => {
      if (JSON.stringify(arg).length <= 80) {
        return JSON.stringify(arg);
      }
      return JSON.stringify(arg, void 0, 2);
    });
    const joinedArgs = methodArgs.join(", ").length <= 80 ? methodArgs.join(", ") : "\n" + methodArgs.map((arg) => "  " + arg.split("\n").join("\n  ")).join(",\n") + "\n";
    const method = `${functionSignature.name}(${joinedArgs})`;
    const hash = error.transactionHash || ((_b = error.transaction) == null ? void 0 : _b.hash) || ((_c = error.receipt) == null ? void 0 : _c.transactionHash);
    const reason = parseRevertReason(error);
    let sources = void 0;
    let contractName = void 0;
    try {
      const metadata = await fetchContractMetadataFromAddress(this.address, this.getProvider(), this.storage, this.options);
      if (metadata.name) {
        contractName = metadata.name;
      }
      if (metadata.metadata.sources) {
        sources = await fetchSourceFilesFromMetadata(metadata, this.storage);
      }
    } catch (err) {
    }
    return new TransactionError({
      reason,
      from,
      to,
      method,
      data,
      network,
      rpcUrl,
      value,
      hash,
      contractName,
      sources
    }, error);
  }
  /**
   * @internal
   */
  async sendGaslessTransaction(fn) {
    let args = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : [];
    let callOverrides = arguments.length > 2 ? arguments[2] : void 0;
    const signer = this.getSigner();
    invariant(signer, "Cannot execute gasless transaction without valid signer");
    const chainId = await this.getChainID();
    const from = await this.getSignerAddress();
    const to = this.writeContract.address;
    const value = (callOverrides == null ? void 0 : callOverrides.value) || 0;
    if (BigNumber.from(value).gt(0)) {
      throw new Error("Cannot send native token value with gasless transaction");
    }
    const data = this.writeContract.interface.encodeFunctionData(fn, args);
    let gas = BigNumber.from(0);
    try {
      const gasEstimate = await this.readContract.estimateGas[fn](...args);
      gas = gasEstimate.mul(2);
    } catch (e) {
    }
    if (gas.lt(1e5)) {
      gas = BigNumber.from(5e5);
    }
    if (callOverrides.gasLimit && BigNumber.from(callOverrides.gasLimit).gt(gas)) {
      gas = BigNumber.from(callOverrides.gasLimit);
    }
    const tx = {
      from,
      to,
      data,
      chainId,
      gasLimit: gas,
      functionName: fn.toString(),
      functionArgs: args,
      callOverrides
    };
    return await this.defaultGaslessSendFunction(tx);
  }
  async signTypedData(signer, domain, types, message) {
    this.emit(EventType.Signature, {
      status: "submitted",
      message,
      signature: ""
    });
    const {
      signature: sig
    } = await signTypedDataInternal(signer, domain, types, message);
    this.emit(EventType.Signature, {
      status: "completed",
      message,
      signature: sig
    });
    return sig;
  }
  parseLogs(eventName, logs) {
    if (!logs || logs.length === 0) {
      return [];
    }
    const topic = this.writeContract.interface.getEventTopic(eventName);
    const parsedLogs = logs.filter((x) => x.topics.indexOf(topic) >= 0);
    return parsedLogs.map((l) => this.writeContract.interface.parseLog(l));
  }
  async defaultGaslessSendFunction(transaction) {
    if (this.options.gasless && "biconomy" in this.options.gasless) {
      return this.biconomySendFunction(transaction);
    }
    return this.defenderSendFunction(transaction);
  }
  async biconomySendFunction(transaction) {
    var _a, _b;
    invariant(this.options.gasless && "biconomy" in this.options.gasless, "calling biconomySendFunction without biconomy");
    const signer = this.getSigner();
    const provider2 = this.getProvider();
    invariant(signer && provider2, "signer and provider must be set");
    const forwarder = new Contract(getContractAddressByChainId(transaction.chainId, "biconomyForwarder"), BiconomyForwarderAbi, provider2);
    const batchId = 0;
    const batchNonce = await getAndIncrementNonce(forwarder, "getNonce", [transaction.from, batchId]);
    const request = {
      from: transaction.from,
      to: transaction.to,
      token: lib_exports.AddressZero,
      txGas: transaction.gasLimit.toNumber(),
      tokenGasPrice: "0",
      batchId,
      batchNonce: batchNonce.toNumber(),
      deadline: Math.floor(Date.now() / 1e3 + (((_a = this.options) == null ? void 0 : _a.gasless) && "biconomy" in this.options.gasless && ((_b = this.options.gasless.biconomy) == null ? void 0 : _b.deadlineSeconds) || 3600)),
      data: transaction.data
    };
    const hashToSign = utils_exports.arrayify(utils_exports.solidityKeccak256(["address", "address", "address", "uint256", "uint256", "uint256", "uint256", "uint256", "bytes32"], [request.from, request.to, request.token, request.txGas, request.tokenGasPrice, request.batchId, request.batchNonce, request.deadline, utils_exports.keccak256(request.data)]));
    this.emit(EventType.Signature, {
      status: "submitted",
      message: hashToSign,
      signature: ""
    });
    const signature = await signer.signMessage(hashToSign);
    this.emit(EventType.Signature, {
      status: "completed",
      message: hashToSign,
      signature
    });
    const response = await (0, import_cross_fetch2.default)("https://api.biconomy.io/api/v2/meta-tx/native", {
      method: "POST",
      body: JSON.stringify({
        from: transaction.from,
        apiId: this.options.gasless.biconomy.apiId,
        params: [request, signature],
        to: transaction.to,
        gasLimit: transaction.gasLimit.toHexString()
      }),
      headers: {
        "x-api-key": this.options.gasless.biconomy.apiKey,
        "Content-Type": "application/json;charset=utf-8"
      }
    });
    if (response.ok) {
      const resp = await response.json();
      if (!resp.txHash) {
        throw new Error(`relay transaction failed: ${resp.log}`);
      }
      return resp.txHash;
    }
    throw new Error(`relay transaction failed with status: ${response.status} (${response.statusText})`);
  }
  async defenderSendFunction(transaction) {
    invariant(this.options.gasless && "openzeppelin" in this.options.gasless, "calling openzeppelin gasless transaction without openzeppelin config in the SDK options");
    const signer = this.getSigner();
    const provider2 = this.getProvider();
    invariant(signer, "provider is not set");
    invariant(provider2, "provider is not set");
    const forwarderAddress = this.options.gasless.openzeppelin.relayerForwarderAddress || (this.options.gasless.openzeppelin.useEOAForwarder ? CONTRACT_ADDRESSES[transaction.chainId].openzeppelinForwarderEOA || await computeEOAForwarderAddress(this.getProvider(), this.storage, "", this.options.clientId, this.options.secretKey) : CONTRACT_ADDRESSES[transaction.chainId].openzeppelinForwarder || await computeForwarderAddress(this.getProvider(), this.storage, "", this.options.clientId, this.options.secretKey));
    const forwarder = new Contract(forwarderAddress, Forwarder_default, provider2);
    const nonce = await getAndIncrementNonce(forwarder, "getNonce", [transaction.from]);
    let domain;
    let types;
    let message;
    if (this.options.gasless.experimentalChainlessSupport) {
      domain = {
        name: "GSNv2 Forwarder",
        version: "0.0.1",
        verifyingContract: forwarderAddress
      };
      types = {
        ForwardRequest: ChainAwareForwardRequest
      };
      message = {
        from: transaction.from,
        to: transaction.to,
        value: BigNumber.from(0).toString(),
        gas: BigNumber.from(transaction.gasLimit).toString(),
        nonce: BigNumber.from(nonce).toString(),
        data: transaction.data,
        chainid: BigNumber.from(transaction.chainId).toString()
      };
    } else {
      domain = {
        name: this.options.gasless.openzeppelin.domainName,
        version: this.options.gasless.openzeppelin.domainVersion,
        chainId: transaction.chainId,
        verifyingContract: forwarderAddress
      };
      types = {
        ForwardRequest
      };
      message = {
        from: transaction.from,
        to: transaction.to,
        value: BigNumber.from(0).toString(),
        gas: BigNumber.from(transaction.gasLimit).toString(),
        nonce: BigNumber.from(nonce).toString(),
        data: transaction.data
      };
    }
    let signature;
    this.emit(EventType.Signature, {
      status: "submitted",
      message,
      signature: ""
    });
    if (transaction.functionName === "approve" && transaction.functionArgs.length === 2) {
      const spender = transaction.functionArgs[0];
      const amount = transaction.functionArgs[1];
      const {
        message: permit,
        signature: sig
      } = await signEIP2612Permit(signer, this.writeContract.address, transaction.from, spender, amount);
      const {
        r,
        s,
        v
      } = utils_exports.splitSignature(sig);
      message = {
        to: this.address,
        owner: permit.owner,
        spender: permit.spender,
        value: BigNumber.from(permit.value).toString(),
        nonce: BigNumber.from(permit.nonce).toString(),
        deadline: BigNumber.from(permit.deadline).toString(),
        r,
        s,
        v
      };
      signature = sig;
    } else {
      const {
        signature: sig
      } = await signTypedDataInternal(signer, domain, types, message);
      signature = sig;
    }
    let messageType = "forward";
    if (message == null ? void 0 : message.owner) {
      messageType = "permit";
    }
    const body = JSON.stringify({
      request: message,
      signature,
      forwarderAddress,
      type: messageType
    });
    this.emit(EventType.Signature, {
      status: "completed",
      message,
      signature
    });
    const response = await (0, import_cross_fetch2.default)(this.options.gasless.openzeppelin.relayerUrl, {
      method: "POST",
      body
    });
    if (response.ok) {
      const resp = await response.json();
      if (!resp.result) {
        throw new Error(`Relay transaction failed: ${resp.message}`);
      }
      const result = JSON.parse(resp.result);
      return result.txHash;
    }
    throw new Error(`relay transaction failed with status: ${response.status} (${response.statusText})`);
  }
};
async function approveErc20Allowance(contractToApprove, currencyAddress, price, quantity, tokenDecimals) {
  const signer = contractToApprove.getSigner();
  const provider2 = contractToApprove.getProvider();
  const erc20 = new ContractWrapper(signer || provider2, currencyAddress, IERC20_default, contractToApprove.options, contractToApprove.storage);
  const owner = await contractToApprove.getSignerAddress();
  const spender = contractToApprove.address;
  const allowance = await erc20.read("allowance", [owner, spender]);
  const totalPrice = BigNumber.from(price).mul(BigNumber.from(quantity)).div(utils_exports.parseUnits("1", tokenDecimals));
  if (allowance.lt(totalPrice)) {
    await erc20.sendTransaction("approve", [spender, allowance.add(totalPrice)]);
  }
}
async function normalizePriceValue(provider2, inputPrice, currencyAddress) {
  const metadata = await fetchCurrencyMetadata(provider2, currencyAddress);
  return utils_exports.parseUnits(AmountSchema.parse(inputPrice), metadata.decimals);
}
async function prepareClaim(addressToClaim, quantity, activeClaimCondition, merkleMetadataFetcher, tokenDecimals, contractWrapper, storage, checkERC20Allowance, snapshotFormatVersion) {
  let maxClaimable = convertQuantityToBigNumber(activeClaimCondition.maxClaimablePerWallet, tokenDecimals);
  let proofs = [utils_exports.hexZeroPad([0], 32)];
  let priceInProof = activeClaimCondition.price;
  let currencyAddressInProof = activeClaimCondition.currencyAddress;
  try {
    if (!activeClaimCondition.merkleRootHash.toString().startsWith(lib_exports.AddressZero)) {
      const snapshotEntry = await fetchSnapshotEntryForAddress(addressToClaim, activeClaimCondition.merkleRootHash.toString(), await merkleMetadataFetcher(), contractWrapper.getProvider(), storage, snapshotFormatVersion);
      if (snapshotEntry) {
        proofs = snapshotEntry.proof;
        maxClaimable = snapshotEntry.maxClaimable === "unlimited" ? lib_exports.MaxUint256 : utils_exports.parseUnits(snapshotEntry.maxClaimable, tokenDecimals);
        priceInProof = snapshotEntry.price === void 0 || snapshotEntry.price === "unlimited" ? lib_exports.MaxUint256 : await normalizePriceValue(contractWrapper.getProvider(), snapshotEntry.price, snapshotEntry.currencyAddress || lib_exports.AddressZero);
        currencyAddressInProof = snapshotEntry.currencyAddress || lib_exports.AddressZero;
      } else {
        if (snapshotFormatVersion === SnapshotFormatVersion.V1) {
          throw new Error("No claim found for this address");
        }
      }
    }
  } catch (e) {
    if ((e == null ? void 0 : e.message) === "No claim found for this address") {
      throw e;
    }
    console.warn("failed to check claim condition merkle root hash, continuing anyways", e);
  }
  const overrides = await contractWrapper.getCallOverrides() || {};
  const pricePerToken = priceInProof.toString() !== lib_exports.MaxUint256.toString() ? priceInProof : activeClaimCondition.price;
  const currencyAddress = currencyAddressInProof !== lib_exports.AddressZero ? currencyAddressInProof : activeClaimCondition.currencyAddress;
  if (pricePerToken.gt(0)) {
    if (isNativeToken(currencyAddress)) {
      overrides["value"] = BigNumber.from(pricePerToken).mul(quantity).div(utils_exports.parseUnits("1", tokenDecimals));
    } else if (checkERC20Allowance) {
      await approveErc20Allowance(contractWrapper, currencyAddress, pricePerToken, quantity, tokenDecimals);
    }
  }
  return {
    overrides,
    proofs,
    maxClaimable,
    price: pricePerToken,
    currencyAddress,
    priceInProof,
    currencyAddressInProof
  };
}
async function createSnapshot(snapshotInput, tokenDecimals, provider2, storage, snapshotFormatVersion) {
  const input = await parseSnapshotInputs(snapshotInput);
  const addresses = input.map((i) => i.address);
  const hasDuplicates = new Set(addresses).size < addresses.length;
  if (hasDuplicates) {
    throw new DuplicateLeafsError();
  }
  const tree = await ShardedMerkleTree.buildAndUpload(input, tokenDecimals, provider2, storage, snapshotFormatVersion);
  return {
    merkleRoot: tree.shardedMerkleInfo.merkleRoot,
    snapshotUri: tree.uri
  };
}
function compare(a, b) {
  const left = BigNumber.from(a);
  const right = BigNumber.from(b);
  if (left.eq(right)) {
    return 0;
  } else if (left.gt(right)) {
    return 1;
  } else {
    return -1;
  }
}
async function processSnapshotData(claimConditionInputs, tokenDecimals, provider2, storage, snapshotFormatVersion) {
  const snapshotInfos = [];
  const inputsWithSnapshots = await Promise.all(claimConditionInputs.map(async (conditionInput) => {
    if (conditionInput.snapshot && conditionInput.snapshot.length > 0) {
      const snapshotInfo = await createSnapshot(conditionInput.snapshot, tokenDecimals, provider2, storage, snapshotFormatVersion);
      snapshotInfos.push(snapshotInfo);
      conditionInput.merkleRootHash = snapshotInfo.merkleRoot;
    } else {
      conditionInput.merkleRootHash = utils_exports.hexZeroPad([0], 32);
    }
    return conditionInput;
  }));
  return {
    inputsWithSnapshots,
    snapshotInfos
  };
}
async function convertToContractModel(c, tokenDecimals, provider2, storage) {
  const currency = c.currencyAddress === lib_exports.AddressZero ? NATIVE_TOKEN_ADDRESS : c.currencyAddress;
  const maxClaimableSupply = convertQuantityToBigNumber(c.maxClaimableSupply, tokenDecimals);
  const maxClaimablePerWallet = convertQuantityToBigNumber(c.maxClaimablePerWallet, tokenDecimals);
  let metadataOrUri;
  if (c.metadata) {
    if (typeof c.metadata === "string") {
      metadataOrUri = c.metadata;
    } else {
      metadataOrUri = await storage.upload(c.metadata);
    }
  }
  return {
    startTimestamp: c.startTime,
    maxClaimableSupply,
    supplyClaimed: 0,
    maxClaimablePerWallet,
    pricePerToken: await normalizePriceValue(provider2, c.price, currency),
    currency,
    merkleRoot: c.merkleRootHash.toString(),
    waitTimeInSecondsBetweenClaims: c.waitInSeconds || 0,
    metadata: metadataOrUri
  };
}
async function processClaimConditionInputs(claimConditionInputs, tokenDecimals, provider2, storage, snapshotFormatVersion) {
  const {
    inputsWithSnapshots,
    snapshotInfos
  } = await processSnapshotData(claimConditionInputs, tokenDecimals, provider2, storage, snapshotFormatVersion);
  const parsedInputs = await ClaimConditionInputArray.parseAsync(inputsWithSnapshots);
  const sortedConditions = (await Promise.all(parsedInputs.map((c) => convertToContractModel(c, tokenDecimals, provider2, storage)))).sort((a, b) => {
    return compare(a.startTimestamp, b.startTimestamp);
  });
  return {
    snapshotInfos,
    sortedConditions
  };
}
async function fetchCurrencyValue(providerOrSigner, asset, price) {
  const metadata = await fetchCurrencyMetadata(providerOrSigner, asset);
  return {
    ...metadata,
    value: BigNumber.from(price),
    displayValue: utils_exports.formatUnits(price, metadata.decimals)
  };
}
async function fetchSnapshot(merkleRoot, merkleMetadata, storage) {
  if (!merkleMetadata) {
    return null;
  }
  const snapshotUri = merkleMetadata[merkleRoot];
  if (snapshotUri) {
    const raw = await storage.downloadJSON(snapshotUri);
    if (raw.isShardedMerkleTree && raw.merkleRoot === merkleRoot) {
      const smt = await ShardedMerkleTree.fromUri(snapshotUri, storage);
      return (smt == null ? void 0 : smt.getAllEntries()) || null;
    } else {
      const snapshotData = await SnapshotSchema.parseAsync(raw);
      if (merkleRoot === snapshotData.merkleRoot) {
        return snapshotData.claims.map((claim) => ({
          address: claim.address,
          maxClaimable: claim.maxClaimable,
          price: claim.price,
          currencyAddress: claim.currencyAddress
        }));
      }
    }
  }
  return null;
}
function convertToReadableQuantity(bn, tokenDecimals) {
  if (bn.toString() === lib_exports.MaxUint256.toString()) {
    return "unlimited";
  } else {
    return utils_exports.formatUnits(bn, tokenDecimals);
  }
}
async function transformResultToClaimCondition(pm, tokenDecimals, provider2, merkleMetadata, storage, shouldDownloadSnapshot) {
  var _a;
  const cv = await fetchCurrencyValue(provider2, pm.currency, pm.pricePerToken);
  const maxClaimableSupply = convertToReadableQuantity(pm.maxClaimableSupply, tokenDecimals);
  const maxClaimablePerWallet = convertToReadableQuantity(pm.maxClaimablePerWallet, tokenDecimals);
  const availableSupply = convertToReadableQuantity(BigNumber.from(pm.maxClaimableSupply).sub(pm.supplyClaimed), tokenDecimals);
  const currentMintSupply = convertToReadableQuantity(pm.supplyClaimed, tokenDecimals);
  let resolvedMetadata;
  if (pm.metadata) {
    resolvedMetadata = await storage.downloadJSON(pm.metadata);
  }
  return ClaimConditionOutputSchema.parseAsync({
    startTime: pm.startTimestamp,
    maxClaimableSupply,
    maxClaimablePerWallet,
    currentMintSupply,
    availableSupply,
    waitInSeconds: (_a = pm.waitTimeInSecondsBetweenClaims) == null ? void 0 : _a.toString(),
    price: BigNumber.from(pm.pricePerToken),
    currency: pm.currency,
    currencyAddress: pm.currency,
    currencyMetadata: cv,
    merkleRootHash: pm.merkleRoot,
    snapshot: shouldDownloadSnapshot ? await fetchSnapshot(pm.merkleRoot, merkleMetadata, storage) : void 0,
    metadata: resolvedMetadata
  });
}
async function updateExistingClaimConditions(index, claimConditionInput, existingConditions) {
  if (index >= existingConditions.length) {
    throw Error(`Index out of bounds - got index: ${index} with ${existingConditions.length} conditions`);
  }
  const priceDecimals = existingConditions[index].currencyMetadata.decimals;
  const priceInWei = existingConditions[index].price;
  const priceInTokens = utils_exports.formatUnits(priceInWei, priceDecimals);
  const newConditionParsed = await ClaimConditionInputSchema.parseAsync({
    ...existingConditions[index],
    price: priceInTokens,
    ...claimConditionInput
  });
  const mergedConditionOutput = await ClaimConditionOutputSchema.parseAsync({
    ...newConditionParsed,
    price: priceInWei
  });
  return existingConditions.map((existingOutput, i) => {
    let newConditionAtIndex;
    if (i === index) {
      newConditionAtIndex = mergedConditionOutput;
    } else {
      newConditionAtIndex = existingOutput;
    }
    const formattedPrice = utils_exports.formatUnits(newConditionAtIndex.price, priceDecimals);
    return {
      ...newConditionAtIndex,
      price: formattedPrice
      // manually transform back to input price type
    };
  });
}
var Status = function(Status2) {
  Status2[Status2["UNSET"] = 0] = "UNSET";
  Status2[Status2["Created"] = 1] = "Created";
  Status2[Status2["Completed"] = 2] = "Completed";
  Status2[Status2["Cancelled"] = 3] = "Cancelled";
  Status2[Status2["Active"] = 4] = "Active";
  Status2[Status2["Expired"] = 5] = "Expired";
  return Status2;
}({});
var ClaimEligibility = function(ClaimEligibility2) {
  ClaimEligibility2["NotEnoughSupply"] = "There is not enough supply to claim.";
  ClaimEligibility2["AddressNotAllowed"] = "This address is not on the allowlist.";
  ClaimEligibility2["WaitBeforeNextClaimTransaction"] = "Not enough time since last claim transaction. Please wait.";
  ClaimEligibility2["ClaimPhaseNotStarted"] = "Claim phase has not started yet.";
  ClaimEligibility2["AlreadyClaimed"] = "You have already claimed the token.";
  ClaimEligibility2["WrongPriceOrCurrency"] = "Incorrect price or currency.";
  ClaimEligibility2["OverMaxClaimablePerWallet"] = "Cannot claim more than maximum allowed quantity.";
  ClaimEligibility2["NotEnoughTokens"] = "There are not enough tokens in the wallet to pay for the claim.";
  ClaimEligibility2["NoActiveClaimPhase"] = "There is no active claim phase at the moment. Please check back in later.";
  ClaimEligibility2["NoClaimConditionSet"] = "There is no claim condition set.";
  ClaimEligibility2["NoWallet"] = "No wallet connected.";
  ClaimEligibility2["Unknown"] = "No claim conditions found.";
  return ClaimEligibility2;
}({});
var DropClaimConditions = class {
  constructor(contractWrapper, metadata, storage) {
    /** ***************************************
     * WRITE FUNCTIONS
     *****************************************/
    /**
     * Set public mint conditions
     *
     * @remarks Sets the public mint conditions that need to be fullfiled by users to claim NFTs.
     *
     * @example
     * ```javascript
     * const presaleStartTime = new Date();
     * const publicSaleStartTime = new Date(Date.now() + 60 * 60 * 24 * 1000);
     *
     * // Optionally specify addresses that can claim
     * const snapshots = ['0x...', '0x...']
     *
     * // Or alternatively, you can pass snapshots with the max number of NFTs each address can claim
     * // const snapshots = [{ address: '0x...', maxClaimable: 1 }, { address: '0x...', maxClaimable: 2 }]
     *
     * const claimConditions = [
     *   {
     *     startTime: presaleStartTime, // start the presale now
     *     maxClaimableSupply: 2, // limit how many mints for this presale
     *     price: 0.01, // presale price
     *     snapshot: snapshots, // limit minting to only certain addresses
     *   },
     *   {
     *     startTime: publicSaleStartTime, // 24h after presale, start public sale
     *     price: 0.08, // public sale price
     *   }
     * ]);
     *
     * await dropContract.claimConditions.set(claimConditions);
     * ```
     *
     * @param claimConditionInputs - The claim conditions
     * @param resetClaimEligibilityForAll - Whether to reset the state of who already claimed NFTs previously
     */
    __publicField(this, "set", buildTransactionFunction((() => {
      var _this = this;
      return async function(claimConditionInputs) {
        let resetClaimEligibilityForAll = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : false;
        let claimConditionsProcessed = claimConditionInputs;
        if (_this.isLegacySinglePhaseDrop(_this.contractWrapper) || _this.isNewSinglePhaseDrop(_this.contractWrapper)) {
          resetClaimEligibilityForAll = true;
          if (claimConditionInputs.length === 0) {
            claimConditionsProcessed = [{
              startTime: /* @__PURE__ */ new Date(0),
              currencyAddress: lib_exports.AddressZero,
              price: 0,
              maxClaimableSupply: 0,
              maxClaimablePerWallet: 0,
              waitInSeconds: 0,
              merkleRootHash: utils_exports.hexZeroPad([0], 32),
              snapshot: []
            }];
          } else if (claimConditionInputs.length > 1) {
            throw new Error("Single phase drop contract cannot have multiple claim conditions, only one is allowed");
          }
        }
        if (_this.isNewSinglePhaseDrop(_this.contractWrapper) || _this.isNewMultiphaseDrop(_this.contractWrapper)) {
          claimConditionsProcessed.forEach((cc) => {
            var _a;
            if (cc.snapshot && cc.snapshot.length > 0 && (cc.maxClaimablePerWallet === void 0 || cc.maxClaimablePerWallet === "unlimited")) {
              throw new Error("maxClaimablePerWallet must be set to a specific value when an allowlist is set.\nExample: Set it to 0 to only allow addresses in the allowlist to claim the amount specified in the allowlist.\ncontract.claimConditions.set([{ snapshot: [{ address: '0x...', maxClaimable: 1 }], maxClaimablePerWallet: 0 }])");
            }
            if (cc.snapshot && cc.snapshot.length > 0 && ((_a = cc.maxClaimablePerWallet) == null ? void 0 : _a.toString()) === "0" && cc.snapshot.map((s) => {
              var _a2;
              if (typeof s === "string") {
                return 0;
              } else {
                return Number(((_a2 = s.maxClaimable) == null ? void 0 : _a2.toString()) || 0);
              }
            }).reduce((acc, current) => {
              return acc + current;
            }, 0) === 0) {
              throw new Error("maxClaimablePerWallet is set to 0, and all addresses in the allowlist have max claimable 0. This means that no one can claim.");
            }
          });
        }
        const {
          snapshotInfos,
          sortedConditions
        } = await processClaimConditionInputs(claimConditionsProcessed, await _this.getTokenDecimals(), _this.contractWrapper.getProvider(), _this.storage, _this.getSnapshotFormatVersion());
        const merkleInfo = {};
        snapshotInfos.forEach((s) => {
          merkleInfo[s.merkleRoot] = s.snapshotUri;
        });
        const metadata = await _this.metadata.get();
        const encoded = [];
        if (!(0, import_fast_deep_equal.default)(metadata.merkle, merkleInfo)) {
          const mergedMetadata = await _this.metadata.parseInputMetadata({
            ...metadata,
            merkle: merkleInfo
          });
          const contractURI = await _this.metadata._parseAndUploadMetadata(mergedMetadata);
          if (hasFunction("setContractURI", _this.contractWrapper)) {
            const contractEncoder = new ContractEncoder(_this.contractWrapper);
            encoded.push(contractEncoder.encode("setContractURI", [contractURI]));
          } else {
            throw new Error("Setting a merkle root requires implementing ContractMetadata in your contract to support storing a merkle root.");
          }
        }
        const cw = _this.contractWrapper;
        const baseContractEncoder = new ContractEncoder(cw);
        if (_this.isLegacySinglePhaseDrop(cw)) {
          const contractEncoderLegacy = new ContractEncoder(cw);
          encoded.push(contractEncoderLegacy.encode("setClaimConditions", [abstractContractModelToLegacy(sortedConditions[0]), resetClaimEligibilityForAll]));
        } else if (_this.isLegacyMultiPhaseDrop(cw)) {
          encoded.push(baseContractEncoder.encode("setClaimConditions", [sortedConditions.map(abstractContractModelToLegacy), resetClaimEligibilityForAll]));
        } else if (_this.isNewSinglePhaseDrop(cw)) {
          encoded.push(baseContractEncoder.encode("setClaimConditions", [abstractContractModelToNew(sortedConditions[0]), resetClaimEligibilityForAll]));
        } else if (_this.isNewMultiphaseDrop(cw)) {
          encoded.push(baseContractEncoder.encode("setClaimConditions", [sortedConditions.map(abstractContractModelToNew), resetClaimEligibilityForAll]));
        } else {
          throw new Error("Contract does not support claim conditions");
        }
        if (hasFunction("multicall", _this.contractWrapper)) {
          return Transaction.fromContractWrapper({
            contractWrapper: _this.contractWrapper,
            method: "multicall",
            args: [encoded]
          });
        }
        throw new Error("Contract does not support multicall");
      };
    })()));
    /**
     * Update a single claim condition with new data.
     *
     * @param index - the index of the claim condition to update, as given by the index from the result of `getAll()`
     * @param claimConditionInput - the new data to update, previous data will be retained
     */
    __publicField(this, "update", buildTransactionFunction(async (index, claimConditionInput) => {
      const existingConditions = await this.getAll();
      const newConditionInputs = await updateExistingClaimConditions(index, claimConditionInput, existingConditions);
      return await this.set.prepare(newConditionInputs);
    }));
    this.storage = storage;
    this.contractWrapper = contractWrapper;
    this.metadata = metadata;
  }
  /** ***************************************
   * READ FUNCTIONS
   *****************************************/
  /**
   * Get the currently active claim condition
   *
   * @returns the claim condition metadata
   */
  async getActive(options) {
    const cc = await this.get();
    const metadata = await this.metadata.get();
    return await transformResultToClaimCondition(cc, await this.getTokenDecimals(), this.contractWrapper.getProvider(), metadata.merkle || {}, this.storage, (options == null ? void 0 : options.withAllowList) || false);
  }
  async get(conditionId) {
    if (this.isLegacySinglePhaseDrop(this.contractWrapper)) {
      const contractModel = await this.contractWrapper.read("claimCondition", []);
      return legacyContractModelToAbstract(contractModel);
    } else if (this.isLegacyMultiPhaseDrop(this.contractWrapper)) {
      const id = conditionId !== void 0 ? conditionId : await this.contractWrapper.read("getActiveClaimConditionId", []);
      const contractModel = await this.contractWrapper.read("getClaimConditionById", [id]);
      return legacyContractModelToAbstract(contractModel);
    } else if (this.isNewSinglePhaseDrop(this.contractWrapper)) {
      const contractModel = await this.contractWrapper.read("claimCondition", []);
      return newContractModelToAbstract(contractModel);
    } else if (this.isNewMultiphaseDrop(this.contractWrapper)) {
      const id = conditionId !== void 0 ? conditionId : await this.contractWrapper.read("getActiveClaimConditionId", []);
      const contractModel = await this.contractWrapper.read("getClaimConditionById", [id]);
      return newContractModelToAbstract(contractModel);
    } else {
      throw new Error("Contract does not support claim conditions");
    }
  }
  /**
   * Get all the claim conditions
   *
   * @returns the claim conditions metadata
   */
  async getAll(options) {
    if (this.isLegacyMultiPhaseDrop(this.contractWrapper) || this.isNewMultiphaseDrop(this.contractWrapper)) {
      const [currentStartId, countBn] = await this.contractWrapper.read("claimCondition", []);
      const startId = currentStartId.toNumber();
      const count = countBn.toNumber();
      const conditions = [];
      for (let i = startId; i < startId + count; i++) {
        conditions.push(this.get(i));
      }
      const [metadata, decimals, ...fetchedConditions] = await Promise.all([this.metadata.get(), this.getTokenDecimals(), ...conditions]);
      return Promise.all(fetchedConditions.map((c) => transformResultToClaimCondition(c, decimals, this.contractWrapper.getProvider(), metadata.merkle, this.storage, (options == null ? void 0 : options.withAllowList) || false)));
    } else {
      return [await this.getActive(options)];
    }
  }
  /**
   * Can Claim
   *
   * @remarks Check if the drop can currently be claimed.
   *
   * @example
   * ```javascript
   * // Quantity of tokens to check claimability of
   * const quantity = 1;
   * const canClaim = await contract.canClaim(quantity);
   * ```
   */
  async canClaim(quantity, addressToCheck) {
    if (addressToCheck) {
      addressToCheck = await resolveAddress(addressToCheck);
    }
    return (await this.getClaimIneligibilityReasons(quantity, addressToCheck)).length === 0;
  }
  /**
   * For any claim conditions that a particular wallet is violating,
   * this function returns human readable information about the
   * breaks in the condition that can be used to inform the user.
   *
   * @param quantity - The desired quantity that would be claimed.
   * @param addressToCheck - The wallet address, defaults to the connected wallet.
   *
   */
  async getClaimIneligibilityReasons(quantity, addressToCheck) {
    const reasons = [];
    let activeConditionIndex;
    let claimCondition;
    const decimals = await this.getTokenDecimals();
    const quantityWithDecimals = utils_exports.parseUnits(AmountSchema.parse(quantity), decimals);
    if (addressToCheck === void 0) {
      try {
        addressToCheck = await this.contractWrapper.getSignerAddress();
      } catch (err) {
        console.warn("failed to get signer address", err);
      }
    }
    if (!addressToCheck) {
      return [ClaimEligibility.NoWallet];
    }
    const resolvedAddress = await resolveAddress(addressToCheck);
    try {
      claimCondition = await this.getActive();
    } catch (err) {
      if (includesErrorMessage(err, "!CONDITION") || includesErrorMessage(err, "no active mint condition")) {
        reasons.push(ClaimEligibility.NoClaimConditionSet);
        return reasons;
      }
      console.warn("failed to get active claim condition", err);
      reasons.push(ClaimEligibility.Unknown);
      return reasons;
    }
    if (claimCondition.availableSupply !== "unlimited") {
      const supplyWithDecimals = utils_exports.parseUnits(claimCondition.availableSupply, decimals);
      if (supplyWithDecimals.lt(quantityWithDecimals)) {
        reasons.push(ClaimEligibility.NotEnoughSupply);
        return reasons;
      }
    }
    const merkleRootArray = utils_exports.stripZeros(claimCondition.merkleRootHash);
    const hasAllowList = merkleRootArray.length > 0;
    let allowListEntry = null;
    if (hasAllowList) {
      allowListEntry = await this.getClaimerProofs(resolvedAddress);
      if (!allowListEntry && (this.isLegacySinglePhaseDrop(this.contractWrapper) || this.isLegacyMultiPhaseDrop(this.contractWrapper))) {
        reasons.push(ClaimEligibility.AddressNotAllowed);
        return reasons;
      }
      if (allowListEntry) {
        try {
          const claimVerification = await this.prepareClaim(quantity, false, decimals, resolvedAddress);
          let validMerkleProof;
          if (this.isLegacyMultiPhaseDrop(this.contractWrapper)) {
            activeConditionIndex = await this.contractWrapper.read("getActiveClaimConditionId", []);
            [validMerkleProof] = await this.contractWrapper.read("verifyClaimMerkleProof", [activeConditionIndex, resolvedAddress, quantity, claimVerification.proofs, claimVerification.maxClaimable]);
            if (!validMerkleProof) {
              reasons.push(ClaimEligibility.AddressNotAllowed);
              return reasons;
            }
          } else if (this.isLegacySinglePhaseDrop(this.contractWrapper)) {
            [validMerkleProof] = await this.contractWrapper.read("verifyClaimMerkleProof", [resolvedAddress, quantity, {
              proof: claimVerification.proofs,
              maxQuantityInAllowlist: claimVerification.maxClaimable
            }]);
            if (!validMerkleProof) {
              reasons.push(ClaimEligibility.AddressNotAllowed);
              return reasons;
            }
          } else if (this.isNewSinglePhaseDrop(this.contractWrapper)) {
            await this.contractWrapper.read("verifyClaim", [resolvedAddress, quantity, claimVerification.currencyAddress, claimVerification.price, {
              proof: claimVerification.proofs,
              quantityLimitPerWallet: claimVerification.maxClaimable,
              currency: claimVerification.currencyAddressInProof,
              pricePerToken: claimVerification.priceInProof
            }]);
          } else if (this.isNewMultiphaseDrop(this.contractWrapper)) {
            activeConditionIndex = await this.contractWrapper.read("getActiveClaimConditionId", []);
            await this.contractWrapper.read("verifyClaim", [activeConditionIndex, resolvedAddress, quantity, claimVerification.currencyAddress, claimVerification.price, {
              proof: claimVerification.proofs,
              quantityLimitPerWallet: claimVerification.maxClaimable,
              currency: claimVerification.currencyAddressInProof,
              pricePerToken: claimVerification.priceInProof
            }]);
          }
        } catch (e) {
          console.warn("Merkle proof verification failed:", "reason" in e ? e.reason : e);
          const reason = e.reason;
          switch (reason) {
            case "!Qty":
              reasons.push(ClaimEligibility.OverMaxClaimablePerWallet);
              break;
            case "!PriceOrCurrency":
              reasons.push(ClaimEligibility.WrongPriceOrCurrency);
              break;
            case "!MaxSupply":
              reasons.push(ClaimEligibility.NotEnoughSupply);
              break;
            case "cant claim yet":
              reasons.push(ClaimEligibility.ClaimPhaseNotStarted);
              break;
            default: {
              reasons.push(ClaimEligibility.AddressNotAllowed);
              break;
            }
          }
          return reasons;
        }
      }
    }
    if (this.isNewSinglePhaseDrop(this.contractWrapper) || this.isNewMultiphaseDrop(this.contractWrapper)) {
      let claimedSupply = BigNumber.from(0);
      let maxClaimable = convertQuantityToBigNumber(claimCondition.maxClaimablePerWallet, decimals);
      try {
        claimedSupply = await this.getSupplyClaimedByWallet(resolvedAddress);
      } catch (e) {
      }
      if (allowListEntry) {
        maxClaimable = convertQuantityToBigNumber(allowListEntry.maxClaimable, decimals);
      }
      if (maxClaimable.gt(0) && maxClaimable.lt(claimedSupply.add(quantityWithDecimals))) {
        reasons.push(ClaimEligibility.OverMaxClaimablePerWallet);
        return reasons;
      }
      if (!hasAllowList || hasAllowList && !allowListEntry) {
        if (maxClaimable.lte(claimedSupply) || maxClaimable.eq(0)) {
          reasons.push(ClaimEligibility.AddressNotAllowed);
          return reasons;
        }
      }
    }
    if (this.isLegacySinglePhaseDrop(this.contractWrapper) || this.isLegacyMultiPhaseDrop(this.contractWrapper)) {
      let [lastClaimedTimestamp, timestampForNextClaim] = [BigNumber.from(0), BigNumber.from(0)];
      if (this.isLegacyMultiPhaseDrop(this.contractWrapper)) {
        activeConditionIndex = await this.contractWrapper.read("getActiveClaimConditionId", []);
        [lastClaimedTimestamp, timestampForNextClaim] = await this.contractWrapper.read("getClaimTimestamp", [activeConditionIndex, resolvedAddress]);
      } else if (this.isLegacySinglePhaseDrop(this.contractWrapper)) {
        [lastClaimedTimestamp, timestampForNextClaim] = await this.contractWrapper.read("getClaimTimestamp", [resolvedAddress]);
      }
      const now = BigNumber.from(Date.now()).div(1e3);
      if (lastClaimedTimestamp.gt(0) && now.lt(timestampForNextClaim)) {
        if (timestampForNextClaim.eq(lib_exports.MaxUint256)) {
          reasons.push(ClaimEligibility.AlreadyClaimed);
        } else {
          reasons.push(ClaimEligibility.WaitBeforeNextClaimTransaction);
        }
        return reasons;
      }
    }
    if (claimCondition.price.gt(0) && isNode()) {
      const totalPrice = claimCondition.price.mul(BigNumber.from(quantity));
      const provider2 = this.contractWrapper.getProvider();
      if (isNativeToken(claimCondition.currencyAddress)) {
        const balance = await provider2.getBalance(resolvedAddress);
        if (balance.lt(totalPrice)) {
          reasons.push(ClaimEligibility.NotEnoughTokens);
        }
      } else {
        const erc20 = new ContractWrapper(provider2, claimCondition.currencyAddress, IERC20_default, {}, this.storage);
        const balance = await erc20.read("balanceOf", [resolvedAddress]);
        if (balance.lt(totalPrice)) {
          reasons.push(ClaimEligibility.NotEnoughTokens);
        }
      }
    }
    return reasons;
  }
  /**
   * Returns allow list information and merkle proofs for the given address.
   * @param claimerAddress - the claimer address
   * @param claimConditionId - optional the claim condition id to get the proofs for
   */
  async getClaimerProofs(claimerAddress, claimConditionId) {
    const claimCondition = await this.get(claimConditionId);
    const merkleRoot = claimCondition.merkleRoot;
    const merkleRootArray = utils_exports.stripZeros(merkleRoot);
    if (merkleRootArray.length > 0) {
      const metadata = await this.metadata.get();
      const resolvedAddress = await resolveAddress(claimerAddress);
      return await fetchSnapshotEntryForAddress(resolvedAddress, merkleRoot.toString(), metadata.merkle, this.contractWrapper.getProvider(), this.storage, this.getSnapshotFormatVersion());
    } else {
      return null;
    }
  }
  /**
   * Get the total supply claimed by a specific wallet
   * @param walletAddress the wallet address to check
   * @returns the total supply claimed
   */
  async getSupplyClaimedByWallet(walletAddress) {
    const resolvedAddress = await resolveAddress(walletAddress);
    if (this.isNewSinglePhaseDrop(this.contractWrapper)) {
      return await this.contractWrapper.read("getSupplyClaimedByWallet", [resolvedAddress]);
    }
    if (this.isNewMultiphaseDrop(this.contractWrapper)) {
      const activeClaimConditionId = await this.contractWrapper.read("getActiveClaimConditionId", []);
      return await this.contractWrapper.read("getSupplyClaimedByWallet", [activeClaimConditionId, resolvedAddress]);
    }
    throw new Error("This contract does not support the getSupplyClaimedByWallet function");
  }
  /** ***************************************
   * PRIVATE FUNCTIONS
   *****************************************/
  async getTokenDecimals() {
    if (detectContractFeature(this.contractWrapper, "ERC20")) {
      return this.contractWrapper.read("decimals", []);
    } else {
      return Promise.resolve(0);
    }
  }
  /**
   * Returns proofs and the overrides required for the transaction.
   *
   * @returns - `overrides` and `proofs` as an object.
   * @internal
   */
  async prepareClaim(quantity, checkERC20Allowance) {
    let decimals = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : 0;
    let address = arguments.length > 3 ? arguments[3] : void 0;
    const addressToClaim = address ? address : await this.contractWrapper.getSignerAddress();
    return prepareClaim(addressToClaim, quantity, await this.getActive(), async () => (await this.metadata.get()).merkle, decimals, this.contractWrapper, this.storage, checkERC20Allowance, this.getSnapshotFormatVersion());
  }
  async getClaimArguments(destinationAddress, quantity, claimVerification) {
    const resolvedAddress = await resolveAddress(destinationAddress);
    if (this.isLegacyMultiPhaseDrop(this.contractWrapper)) {
      return [resolvedAddress, quantity, claimVerification.currencyAddress, claimVerification.price, claimVerification.proofs, claimVerification.maxClaimable];
    } else if (this.isLegacySinglePhaseDrop(this.contractWrapper)) {
      return [resolvedAddress, quantity, claimVerification.currencyAddress, claimVerification.price, {
        proof: claimVerification.proofs,
        maxQuantityInAllowlist: claimVerification.maxClaimable
      }, utils_exports.toUtf8Bytes("")];
    }
    return [resolvedAddress, quantity, claimVerification.currencyAddress, claimVerification.price, {
      proof: claimVerification.proofs,
      quantityLimitPerWallet: claimVerification.maxClaimable,
      pricePerToken: claimVerification.priceInProof,
      currency: claimVerification.currencyAddressInProof
    }, utils_exports.toUtf8Bytes("")];
  }
  /**
   * Construct a claim transaction without executing it.
   * This is useful for estimating the gas cost of a claim transaction, overriding transaction options and having fine grained control over the transaction execution.
   * @param destinationAddress
   * @param quantity
   * @param options
   *
   * @deprecated Use `contract.erc721.claim.prepare(...args)` instead
   */
  async getClaimTransaction(destinationAddress, quantity, options) {
    if (options == null ? void 0 : options.pricePerToken) {
      throw new Error("Price per token is be set via claim conditions by calling `contract.erc721.claimConditions.set()`");
    }
    const claimVerification = await this.prepareClaim(quantity, (options == null ? void 0 : options.checkERC20Allowance) === void 0 ? true : options.checkERC20Allowance, await this.getTokenDecimals());
    return Transaction.fromContractWrapper({
      contractWrapper: this.contractWrapper,
      method: "claim",
      args: await this.getClaimArguments(destinationAddress, quantity, claimVerification),
      overrides: claimVerification.overrides
    });
  }
  isNewSinglePhaseDrop(contractWrapper) {
    return detectContractFeature(contractWrapper, "ERC721ClaimConditionsV2") || detectContractFeature(contractWrapper, "ERC20ClaimConditionsV2");
  }
  isNewMultiphaseDrop(contractWrapper) {
    return detectContractFeature(contractWrapper, "ERC721ClaimPhasesV2") || detectContractFeature(contractWrapper, "ERC20ClaimPhasesV2");
  }
  isLegacySinglePhaseDrop(contractWrapper) {
    return detectContractFeature(contractWrapper, "ERC721ClaimConditionsV1") || detectContractFeature(contractWrapper, "ERC20ClaimConditionsV1");
  }
  isLegacyMultiPhaseDrop(contractWrapper) {
    return detectContractFeature(contractWrapper, "ERC721ClaimPhasesV1") || detectContractFeature(contractWrapper, "ERC20ClaimPhasesV1");
  }
  getSnapshotFormatVersion() {
    return this.isLegacyMultiPhaseDrop(this.contractWrapper) || this.isLegacySinglePhaseDrop(this.contractWrapper) ? SnapshotFormatVersion.V1 : SnapshotFormatVersion.V2;
  }
};
var DropErc1155ClaimConditions = class {
  constructor(contractWrapper, metadata, storage) {
    /** ***************************************
     * WRITE FUNCTIONS
     *****************************************/
    /**
     * Set claim conditions on a single NFT
     *
     * @remarks Sets the public mint conditions that need to be fulfilled by users to claim a particular NFT in this contract.
     *
     * @example
     * ```javascript
     * const presaleStartTime = new Date();
     * const publicSaleStartTime = new Date(Date.now() + 60 * 60 * 24 * 1000);
     *
     * // Optionally specify addresses that can claim
     * const snapshots = ['0x...', '0x...']
     *
     * // Or alternatively, you can pass snapshots with the max number of NFTs each address can claim
     * // const snapshots = [{ address: '0x...', maxClaimable: 1 }, { address: '0x...', maxClaimable: 2 }]
     *
     * const claimConditions = [
     *   {
     *     startTime: presaleStartTime, // start the presale now
     *     maxClaimableSupply: 2, // limit how many mints for this presale
     *     price: 0.01, // presale price
     *     snapshot: snapshots, // limit minting to only certain addresses
     *   },
     *   {
     *     startTime: publicSaleStartTime, // 24h after presale, start public sale
     *     price: 0.08, // public sale price
     *   }
     * ]);
     *
     * const tokenId = 0; // the id of the NFT to set claim conditions on
     * await dropContract.claimConditions.set(tokenId, claimConditions);
     * ```
     *
     * @param tokenId - The id of the NFT to set the claim conditions on
     * @param claimConditionInputs - The claim conditions
     * @param resetClaimEligibilityForAll - Whether to reset the state of who already claimed NFTs previously
     */
    __publicField(this, "set", buildTransactionFunction((() => {
      var _this = this;
      return async function(tokenId, claimConditionInputs) {
        let resetClaimEligibilityForAll = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : false;
        return _this.setBatch.prepare([{
          tokenId,
          claimConditions: claimConditionInputs
        }], resetClaimEligibilityForAll);
      };
    })()));
    /**
     * Set claim conditions on multiple NFTs at once
     *
     * @remarks Sets the claim conditions that need to be fulfilled by users to claim the given NFTs in this contract.
     *
     * @example
     * ```javascript
     * const claimConditionsForTokens = [
     *   {
     *     tokenId: 0,
     *     claimConditions: [{
     *       startTime: new Date(), // start the claim phase now
     *       maxClaimableSupply: 2, // limit how many mints for this tokenId
     *       price: 0.01, // price for this tokenId
     *       snapshot: ['0x...', '0x...'], // limit minting to only certain addresses
     *     }]
     *   },
     *   {
     *     tokenId: 1,
     *     claimConditions: [{
     *       startTime: new Date(),
     *       price: 0.08, // different price for this tokenId
     *     }]
     *   },
     * ];
     *
     * await dropContract.claimConditions.setBatch(claimConditionsForTokens);
     * ```
     *
     * @param claimConditionsForToken - The claim conditions for each NFT
     * @param resetClaimEligibilityForAll - Whether to reset the state of who already claimed NFTs previously
     */
    __publicField(this, "setBatch", buildTransactionFunction((() => {
      var _this2 = this;
      return async function(claimConditionsForToken) {
        let resetClaimEligibilityForAll = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : false;
        const merkleInfo = {};
        const processedClaimConditions = await Promise.all(claimConditionsForToken.map(async (_ref) => {
          let {
            tokenId,
            claimConditions
          } = _ref;
          let claimConditionsProcessed = claimConditions;
          if (_this2.isLegacySinglePhaseDrop(_this2.contractWrapper)) {
            resetClaimEligibilityForAll = true;
            if (claimConditions.length === 0) {
              claimConditionsProcessed = [{
                startTime: /* @__PURE__ */ new Date(0),
                currencyAddress: lib_exports.AddressZero,
                price: 0,
                maxClaimableSupply: 0,
                maxClaimablePerWallet: 0,
                waitInSeconds: 0,
                merkleRootHash: utils_exports.hexZeroPad([0], 32),
                snapshot: []
              }];
            } else if (claimConditions.length > 1) {
              throw new Error("Single phase drop contract cannot have multiple claim conditions, only one is allowed");
            }
          }
          if (_this2.isNewSinglePhaseDrop(_this2.contractWrapper) || _this2.isNewMultiphaseDrop(_this2.contractWrapper)) {
            claimConditionsProcessed.forEach((cc) => {
              var _a;
              if (cc.snapshot && cc.snapshot.length > 0 && (cc.maxClaimablePerWallet === void 0 || cc.maxClaimablePerWallet === "unlimited")) {
                throw new Error("maxClaimablePerWallet must be set to a specific value when an allowlist is set.\nSet it to 0 to only allow addresses in the allowlist to claim the amount specified in the allowlist.\n\nex:\ncontract.claimConditions.set(tokenId, [{ snapshot: [{ address: '0x...', maxClaimable: 1 }], maxClaimablePerWallet: 0 }])");
              }
              if (cc.snapshot && cc.snapshot.length > 0 && ((_a = cc.maxClaimablePerWallet) == null ? void 0 : _a.toString()) === "0" && cc.snapshot.map((s) => {
                var _a2;
                if (typeof s === "string") {
                  return 0;
                } else {
                  return Number(((_a2 = s.maxClaimable) == null ? void 0 : _a2.toString()) || 0);
                }
              }).reduce((acc, current) => {
                return acc + current;
              }, 0) === 0) {
                throw new Error("maxClaimablePerWallet is set to 0, and all addresses in the allowlist have max claimable 0. This means that no one can claim.");
              }
            });
          }
          const {
            snapshotInfos,
            sortedConditions
          } = await processClaimConditionInputs(claimConditionsProcessed, 0, _this2.contractWrapper.getProvider(), _this2.storage, _this2.getSnapshotFormatVersion());
          snapshotInfos.forEach((s) => {
            merkleInfo[s.merkleRoot] = s.snapshotUri;
          });
          return {
            tokenId,
            sortedConditions
          };
        }));
        const metadata = await _this2.metadata.get();
        const encoded = [];
        for (const key of Object.keys(metadata.merkle || {})) {
          merkleInfo[key] = metadata.merkle[key];
        }
        if (!(0, import_fast_deep_equal.default)(metadata.merkle, merkleInfo)) {
          const mergedMetadata = await _this2.metadata.parseInputMetadata({
            ...metadata,
            merkle: merkleInfo
          });
          const contractURI = await _this2.metadata._parseAndUploadMetadata(mergedMetadata);
          if (hasFunction("setContractURI", _this2.contractWrapper)) {
            const contractEncoder = new ContractEncoder(_this2.contractWrapper);
            encoded.push(contractEncoder.encode("setContractURI", [contractURI]));
          } else {
            throw new Error("Setting a merkle root requires implementing ContractMetadata in your contract to support storing a merkle root.");
          }
        }
        processedClaimConditions.forEach((_ref2) => {
          let {
            tokenId,
            sortedConditions
          } = _ref2;
          const baseContractEncoder = new ContractEncoder(_this2.contractWrapper);
          if (_this2.isLegacySinglePhaseDrop(_this2.contractWrapper)) {
            const legacyContractEncoder = new ContractEncoder(_this2.contractWrapper);
            encoded.push(legacyContractEncoder.encode("setClaimConditions", [tokenId, abstractContractModelToLegacy(sortedConditions[0]), resetClaimEligibilityForAll]));
          } else if (_this2.isLegacyMultiPhaseDrop(_this2.contractWrapper)) {
            encoded.push(baseContractEncoder.encode("setClaimConditions", [tokenId, sortedConditions.map(abstractContractModelToLegacy), resetClaimEligibilityForAll]));
          } else if (_this2.isNewSinglePhaseDrop(_this2.contractWrapper)) {
            encoded.push(baseContractEncoder.encode("setClaimConditions", [tokenId, abstractContractModelToNew(sortedConditions[0]), resetClaimEligibilityForAll]));
          } else if (_this2.isNewMultiphaseDrop(_this2.contractWrapper)) {
            encoded.push(baseContractEncoder.encode("setClaimConditions", [tokenId, sortedConditions.map(abstractContractModelToNew), resetClaimEligibilityForAll]));
          } else {
            throw new Error("Contract does not support claim conditions");
          }
        });
        if (hasFunction("multicall", _this2.contractWrapper)) {
          return Transaction.fromContractWrapper({
            contractWrapper: _this2.contractWrapper,
            method: "multicall",
            args: [encoded]
          });
        }
        throw new Error("Contract does not support multicall");
      };
    })()));
    /**
     * Update a single claim condition with new data.
     * @param tokenId - the token id to update
     * @param index - the index of the claim condition to update, as given by the index from the result of `getAll()`
     * @param claimConditionInput - the new data to update, previous data will be retained
     */
    __publicField(this, "update", buildTransactionFunction(async (tokenId, index, claimConditionInput) => {
      const existingConditions = await this.getAll(tokenId);
      const newConditionInputs = await updateExistingClaimConditions(index, claimConditionInput, existingConditions);
      return await this.set.prepare(tokenId, newConditionInputs);
    }));
    this.storage = storage;
    this.contractWrapper = contractWrapper;
    this.metadata = metadata;
  }
  /** ***************************************
   * READ FUNCTIONS
   *****************************************/
  /**
   * Get the currently active claim condition
   *
   * @returns the claim condition metadata
   */
  async getActive(tokenId, options) {
    const mc = await this.get(tokenId);
    const metadata = await this.metadata.get();
    return await transformResultToClaimCondition(mc, 0, this.contractWrapper.getProvider(), metadata.merkle, this.storage, (options == null ? void 0 : options.withAllowList) || false);
  }
  async get(tokenId, conditionId) {
    if (this.isLegacySinglePhaseDrop(this.contractWrapper)) {
      const contractModel = await this.contractWrapper.read("claimCondition", [tokenId]);
      return legacyContractModelToAbstract(contractModel);
    } else if (this.isLegacyMultiPhaseDrop(this.contractWrapper)) {
      const id = conditionId !== void 0 ? conditionId : await this.contractWrapper.read("getActiveClaimConditionId", [tokenId]);
      const contractModel = await this.contractWrapper.read("getClaimConditionById", [tokenId, id]);
      return legacyContractModelToAbstract(contractModel);
    } else if (this.isNewSinglePhaseDrop(this.contractWrapper)) {
      const contractModel = await this.contractWrapper.read("claimCondition", [tokenId]);
      return newContractModelToAbstract(contractModel);
    } else if (this.isNewMultiphaseDrop(this.contractWrapper)) {
      const id = conditionId !== void 0 ? conditionId : await this.contractWrapper.read("getActiveClaimConditionId", [tokenId]);
      const contractModel = await this.contractWrapper.read("getClaimConditionById", [tokenId, id]);
      return newContractModelToAbstract(contractModel);
    } else {
      throw new Error("Contract does not support claim conditions");
    }
  }
  /**
   * Get all the claim conditions
   *
   * @returns the claim conditions metadata
   */
  async getAll(tokenId, options) {
    if (this.isLegacyMultiPhaseDrop(this.contractWrapper) || this.isNewMultiphaseDrop(this.contractWrapper)) {
      const claimCondition = await this.contractWrapper.read("claimCondition", [tokenId]);
      const startId = claimCondition.currentStartId.toNumber();
      const count = claimCondition.count.toNumber();
      const conditions = [];
      for (let i = startId; i < startId + count; i++) {
        conditions.push(await this.get(tokenId, i));
      }
      const metadata = await this.metadata.get();
      return Promise.all(conditions.map((c) => transformResultToClaimCondition(c, 0, this.contractWrapper.getProvider(), metadata.merkle, this.storage, (options == null ? void 0 : options.withAllowList) || false)));
    } else {
      return [await this.getActive(tokenId, options)];
    }
  }
  /**
   * Can Claim
   *
   * @remarks Check if a particular NFT can currently be claimed by a given user.
   *
   * @example
   * ```javascript
   * // Quantity of tokens to check claimability of
   * const quantity = 1;
   * const canClaim = await contract.canClaim(quantity);
   * ```
   */
  async canClaim(tokenId, quantity, addressToCheck) {
    if (addressToCheck) {
      addressToCheck = await resolveAddress(addressToCheck);
    }
    return (await this.getClaimIneligibilityReasons(tokenId, quantity, addressToCheck)).length === 0;
  }
  /**
   * For any claim conditions that a particular wallet is violating,
   * this function returns human-readable information about the
   * breaks in the condition that can be used to inform the user.
   *
   * @param tokenId - the token id to check
   * @param quantity - The desired quantity that would be claimed.
   * @param addressToCheck - The wallet address, defaults to the connected wallet.
   *
   */
  async getClaimIneligibilityReasons(tokenId, quantity, addressToCheck) {
    const reasons = [];
    let activeConditionIndex;
    let claimCondition;
    if (addressToCheck === void 0) {
      try {
        addressToCheck = await this.contractWrapper.getSignerAddress();
      } catch (err) {
        console.warn("failed to get signer address", err);
      }
    }
    if (!addressToCheck) {
      return [ClaimEligibility.NoWallet];
    }
    const resolvedAddress = await resolveAddress(addressToCheck);
    try {
      claimCondition = await this.getActive(tokenId);
    } catch (err) {
      if (includesErrorMessage(err, "!CONDITION") || includesErrorMessage(err, "no active mint condition")) {
        reasons.push(ClaimEligibility.NoClaimConditionSet);
        return reasons;
      }
      reasons.push(ClaimEligibility.Unknown);
      return reasons;
    }
    if (claimCondition.availableSupply !== "unlimited") {
      if (BigNumber.from(claimCondition.availableSupply).lt(quantity)) {
        reasons.push(ClaimEligibility.NotEnoughSupply);
        return reasons;
      }
    }
    const merkleRootArray = utils_exports.stripZeros(claimCondition.merkleRootHash);
    const hasAllowList = merkleRootArray.length > 0;
    let allowListEntry = null;
    if (hasAllowList) {
      allowListEntry = await this.getClaimerProofs(tokenId, resolvedAddress);
      if (!allowListEntry && (this.isLegacySinglePhaseDrop(this.contractWrapper) || this.isLegacyMultiPhaseDrop(this.contractWrapper))) {
        reasons.push(ClaimEligibility.AddressNotAllowed);
        return reasons;
      }
      if (allowListEntry) {
        try {
          const claimVerification = await this.prepareClaim(tokenId, quantity, false, resolvedAddress);
          let validMerkleProof;
          if (this.isLegacyMultiPhaseDrop(this.contractWrapper)) {
            activeConditionIndex = await this.contractWrapper.read("getActiveClaimConditionId", [tokenId]);
            [validMerkleProof] = await this.contractWrapper.read("verifyClaimMerkleProof", [activeConditionIndex, resolvedAddress, tokenId, quantity, claimVerification.proofs, claimVerification.maxClaimable]);
            if (!validMerkleProof) {
              reasons.push(ClaimEligibility.AddressNotAllowed);
              return reasons;
            }
          } else if (this.isLegacySinglePhaseDrop(this.contractWrapper)) {
            [validMerkleProof] = await this.contractWrapper.read("verifyClaimMerkleProof", [tokenId, resolvedAddress, quantity, {
              proof: claimVerification.proofs,
              maxQuantityInAllowlist: claimVerification.maxClaimable
            }]);
            if (!validMerkleProof) {
              reasons.push(ClaimEligibility.AddressNotAllowed);
              return reasons;
            }
          } else if (this.isNewSinglePhaseDrop(this.contractWrapper)) {
            await this.contractWrapper.read("verifyClaim", [tokenId, resolvedAddress, quantity, claimVerification.currencyAddress, claimVerification.price, {
              proof: claimVerification.proofs,
              quantityLimitPerWallet: claimVerification.maxClaimable,
              currency: claimVerification.currencyAddressInProof,
              pricePerToken: claimVerification.priceInProof
            }]);
          } else if (this.isNewMultiphaseDrop(this.contractWrapper)) {
            activeConditionIndex = await this.contractWrapper.read("getActiveClaimConditionId", [tokenId]);
            await this.contractWrapper.read("verifyClaim", [activeConditionIndex, resolvedAddress, tokenId, quantity, claimVerification.currencyAddress, claimVerification.price, {
              proof: claimVerification.proofs,
              quantityLimitPerWallet: claimVerification.maxClaimable,
              currency: claimVerification.currencyAddressInProof,
              pricePerToken: claimVerification.priceInProof
            }]);
          }
        } catch (e) {
          console.warn("Merkle proof verification failed:", "reason" in e ? e.reason : e);
          const reason = e.reason;
          switch (reason) {
            case "!Qty":
              reasons.push(ClaimEligibility.OverMaxClaimablePerWallet);
              break;
            case "!PriceOrCurrency":
              reasons.push(ClaimEligibility.WrongPriceOrCurrency);
              break;
            case "!MaxSupply":
              reasons.push(ClaimEligibility.NotEnoughSupply);
              break;
            case "cant claim yet":
              reasons.push(ClaimEligibility.ClaimPhaseNotStarted);
              break;
            default: {
              reasons.push(ClaimEligibility.AddressNotAllowed);
              break;
            }
          }
          return reasons;
        }
      }
    }
    if (this.isNewSinglePhaseDrop(this.contractWrapper) || this.isNewMultiphaseDrop(this.contractWrapper)) {
      let claimedSupply = BigNumber.from(0);
      let maxClaimable = convertQuantityToBigNumber(claimCondition.maxClaimablePerWallet, 0);
      try {
        claimedSupply = await this.getSupplyClaimedByWallet(tokenId, resolvedAddress);
      } catch (e) {
      }
      if (allowListEntry) {
        maxClaimable = convertQuantityToBigNumber(allowListEntry.maxClaimable, 0);
      }
      if (maxClaimable.gt(0) && maxClaimable.lt(claimedSupply.add(quantity))) {
        reasons.push(ClaimEligibility.OverMaxClaimablePerWallet);
        return reasons;
      }
      if (!hasAllowList || hasAllowList && !allowListEntry) {
        if (maxClaimable.lte(claimedSupply) || maxClaimable.eq(0)) {
          reasons.push(ClaimEligibility.AddressNotAllowed);
          return reasons;
        }
      }
    }
    let [lastClaimedTimestamp, timestampForNextClaim] = [BigNumber.from(0), BigNumber.from(0)];
    if (this.isLegacyMultiPhaseDrop(this.contractWrapper)) {
      activeConditionIndex = await this.contractWrapper.read("getActiveClaimConditionId", [tokenId]);
      [lastClaimedTimestamp, timestampForNextClaim] = await this.contractWrapper.read("getClaimTimestamp", [tokenId, activeConditionIndex, resolvedAddress]);
    } else if (this.isLegacySinglePhaseDrop(this.contractWrapper)) {
      [lastClaimedTimestamp, timestampForNextClaim] = await this.contractWrapper.read("getClaimTimestamp", [tokenId, resolvedAddress]);
    }
    const now = BigNumber.from(Date.now()).div(1e3);
    if (lastClaimedTimestamp.gt(0) && now.lt(timestampForNextClaim)) {
      if (timestampForNextClaim.eq(lib_exports.MaxUint256)) {
        reasons.push(ClaimEligibility.AlreadyClaimed);
      } else {
        reasons.push(ClaimEligibility.WaitBeforeNextClaimTransaction);
      }
      return reasons;
    }
    if (claimCondition.price.gt(0) && isNode()) {
      const totalPrice = claimCondition.price.mul(quantity);
      const provider2 = this.contractWrapper.getProvider();
      if (isNativeToken(claimCondition.currencyAddress)) {
        const balance = await provider2.getBalance(resolvedAddress);
        if (balance.lt(totalPrice)) {
          reasons.push(ClaimEligibility.NotEnoughTokens);
        }
      } else {
        const erc20 = new ContractWrapper(provider2, claimCondition.currencyAddress, IERC20_default, {}, this.storage);
        const balance = await erc20.read("balanceOf", [resolvedAddress]);
        if (balance.lt(totalPrice)) {
          reasons.push(ClaimEligibility.NotEnoughTokens);
        }
      }
    }
    return reasons;
  }
  /**
   * Returns allow list information and merkle proofs for the given address.
   * @param tokenId - the token ID to check
   * @param claimerAddress - the claimer address
   * @param claimConditionId - optional the claim condition id to get the proofs for
   */
  async getClaimerProofs(tokenId, claimerAddress, claimConditionId) {
    const claimCondition = await this.get(tokenId, claimConditionId);
    const merkleRoot = claimCondition.merkleRoot;
    const merkleRootArray = utils_exports.stripZeros(merkleRoot);
    if (merkleRootArray.length > 0) {
      const metadata = await this.metadata.get();
      const resolvedAddress = await resolveAddress(claimerAddress);
      return await fetchSnapshotEntryForAddress(resolvedAddress, merkleRoot.toString(), metadata.merkle, this.contractWrapper.getProvider(), this.storage, this.getSnapshotFormatVersion());
    } else {
      return null;
    }
  }
  /**
   * Get the total supply claimed by a specific wallet
   * @param walletAddress the wallet address to check
   * @returns the total supply claimed
   */
  async getSupplyClaimedByWallet(tokenId, walletAddress) {
    const resolvedAddress = await resolveAddress(walletAddress);
    if (this.isNewSinglePhaseDrop(this.contractWrapper)) {
      return await this.contractWrapper.read("getSupplyClaimedByWallet", [tokenId, resolvedAddress]);
    }
    if (this.isNewMultiphaseDrop(this.contractWrapper)) {
      const activeClaimConditionId = await this.contractWrapper.read("getActiveClaimConditionId", [tokenId]);
      return await this.contractWrapper.read("getSupplyClaimedByWallet", [tokenId, activeClaimConditionId, resolvedAddress]);
    }
    throw new Error("This contract does not support the getSupplyClaimedByWallet function");
  }
  /**
   * Returns proofs and the overrides required for the transaction.
   *
   * @returns - `overrides` and `proofs` as an object.
   */
  async prepareClaim(tokenId, quantity, checkERC20Allowance, address) {
    const addressToClaim = await resolveAddress(address ? address : await this.contractWrapper.getSignerAddress());
    return prepareClaim(addressToClaim, quantity, await this.getActive(tokenId), async () => (await this.metadata.get()).merkle, 0, this.contractWrapper, this.storage, checkERC20Allowance, this.getSnapshotFormatVersion());
  }
  async getClaimArguments(tokenId, destinationAddress, quantity, claimVerification) {
    const resolvedAddress = await resolveAddress(destinationAddress);
    if (this.isLegacyMultiPhaseDrop(this.contractWrapper)) {
      return [resolvedAddress, tokenId, quantity, claimVerification.currencyAddress, claimVerification.price, claimVerification.proofs, claimVerification.maxClaimable];
    } else if (this.isLegacySinglePhaseDrop(this.contractWrapper)) {
      return [resolvedAddress, tokenId, quantity, claimVerification.currencyAddress, claimVerification.price, {
        proof: claimVerification.proofs,
        maxQuantityInAllowlist: claimVerification.maxClaimable
      }, utils_exports.toUtf8Bytes("")];
    }
    return [resolvedAddress, tokenId, quantity, claimVerification.currencyAddress, claimVerification.price, {
      proof: claimVerification.proofs,
      quantityLimitPerWallet: claimVerification.maxClaimable,
      pricePerToken: claimVerification.priceInProof,
      currency: claimVerification.currencyAddressInProof
    }, utils_exports.toUtf8Bytes("")];
  }
  /**
   * Construct a claim transaction without executing it.
   * This is useful for estimating the gas cost of a claim transaction, overriding transaction options and having fine grained control over the transaction execution.
   * @param destinationAddress - Address you want to send the token to
   * @param tokenId - Id of the token you want to claim
   * @param quantity - Quantity of the tokens you want to claim
   *
   * @deprecated Use `contract.erc1155.claim.prepare(...args)` instead
   */
  async getClaimTransaction(destinationAddress, tokenId, quantity, options) {
    if (options == null ? void 0 : options.pricePerToken) {
      throw new Error("Price per token should be set via claim conditions by calling `contract.erc1155.claimConditions.set()`");
    }
    const claimVerification = await this.prepareClaim(tokenId, quantity, (options == null ? void 0 : options.checkERC20Allowance) || true);
    return Transaction.fromContractWrapper({
      contractWrapper: this.contractWrapper,
      method: "claim",
      args: await this.getClaimArguments(tokenId, destinationAddress, quantity, claimVerification),
      overrides: claimVerification.overrides
    });
  }
  isNewSinglePhaseDrop(contractWrapper) {
    return detectContractFeature(contractWrapper, "ERC1155ClaimConditionsV2");
  }
  isNewMultiphaseDrop(contractWrapper) {
    return detectContractFeature(contractWrapper, "ERC1155ClaimPhasesV2");
  }
  isLegacySinglePhaseDrop(contractWrapper) {
    return detectContractFeature(contractWrapper, "ERC1155ClaimConditionsV1");
  }
  isLegacyMultiPhaseDrop(contractWrapper) {
    return detectContractFeature(contractWrapper, "ERC1155ClaimPhasesV1");
  }
  getSnapshotFormatVersion() {
    return this.isLegacyMultiPhaseDrop(this.contractWrapper) || this.isLegacySinglePhaseDrop(this.contractWrapper) ? SnapshotFormatVersion.V1 : SnapshotFormatVersion.V2;
  }
};
var Erc20BatchMintable = class {
  constructor(erc20, contractWrapper) {
    __publicField(this, "featureName", FEATURE_TOKEN_BATCH_MINTABLE.name);
    /**
     * Mint Tokens To Many Wallets
     *
     * @remarks Mint tokens to many wallets in one transaction.
     *
     * @example
     * ```javascript
     * // Data of the tokens you want to mint
     * const data = [
     *   {
     *     toAddress: "{{wallet_address}}", // Address to mint tokens to
     *     amount: 0.2, // How many tokens to mint to specified address
     *   },
     *  {
     *    toAddress: "0x...",
     *    amount: 1.4,
     *  }
     * ]
     *
     * await contract.token.mint.batch(data);
     * ```
     */
    __publicField(this, "to", buildTransactionFunction(async (args) => {
      const encoded = [];
      const contractEncoder = new ContractEncoder(this.contractWrapper);
      for (const arg of args) {
        encoded.push(contractEncoder.encode("mintTo", [await resolveAddress(arg.toAddress), await this.erc20.normalizeAmount(arg.amount)]));
      }
      return Transaction.fromContractWrapper({
        contractWrapper: this.contractWrapper,
        method: "multicall",
        args: [encoded]
      });
    }));
    this.erc20 = erc20;
    this.contractWrapper = contractWrapper;
  }
};
var Erc20Burnable = class {
  constructor(erc20, contractWrapper) {
    __publicField(this, "featureName", FEATURE_TOKEN_BURNABLE.name);
    /**
     * Burn Tokens
     *
     * @remarks Burn tokens held by the connected wallet
     *
     * @example
     * ```javascript
     * // The amount of this token you want to burn
     * const amount = 1.2;
     *
     * await contract.token.burn.tokens(amount);
     * ```
     */
    __publicField(this, "tokens", buildTransactionFunction(async (amount) => {
      return Transaction.fromContractWrapper({
        contractWrapper: this.contractWrapper,
        method: "burn",
        args: [await this.erc20.normalizeAmount(amount)]
      });
    }));
    /**
     * Burn Tokens
     *
     * @remarks Burn tokens held by the specified wallet
     *
     * @example
     * ```javascript
     * // Address of the wallet sending the tokens
     * const holderAddress = "{{wallet_address}}";
     *
     * // The amount of this token you want to burn
     * const amount = 1.2;
     *
     * await contract.token.burn.from(holderAddress, amount);
     * ```
     */
    __publicField(this, "from", buildTransactionFunction(async (holder, amount) => {
      return Transaction.fromContractWrapper({
        contractWrapper: this.contractWrapper,
        method: "burnFrom",
        args: [await resolveAddress(holder), await this.erc20.normalizeAmount(amount)]
      });
    }));
    this.erc20 = erc20;
    this.contractWrapper = contractWrapper;
  }
};
var Erc20ClaimableWithConditions = class {
  /**
   * Configure claim conditions
   * @remarks Define who can claim NFTs in the collection, when and how many.
   * @example
   * ```javascript
   * const presaleStartTime = new Date();
   * const publicSaleStartTime = new Date(Date.now() + 60 * 60 * 24 * 1000);
   * const claimConditions = [
   *   {
   *     startTime: presaleStartTime, // start the presale now
   *     maxClaimableSupply: 2, // limit how many mints for this presale
   *     price: 0.01, // presale price
   *     snapshot: ['0x...', '0x...'], // limit minting to only certain addresses
   *   },
   *   {
   *     startTime: publicSaleStartTime, // 24h after presale, start public sale
   *     price: 0.08, // public sale price
   *   }
   * ]);
   * await contract.token.drop.claim.conditions.set(claimConditions);
   * ```
   */
  constructor(erc20, contractWrapper, storage) {
    __publicField(this, "featureName", FEATURE_TOKEN_CLAIM_CONDITIONS_V2.name);
    /**
     * Claim a certain amount of tokens to a specific Wallet
     *
     * @remarks Let the specified wallet claim Tokens.
     *
     * @example
     * ```javascript
     * const address = "{{wallet_address}}"; // address of the wallet you want to claim the NFTs
     * const quantity = 42.69; // how many tokens you want to claim
     *
     * const tx = await contract.token.drop.claim.to(address, quantity);
     * const receipt = tx.receipt; // the transaction receipt
     * ```
     *
     * @param destinationAddress - Address you want to send the token to
     * @param amount - Quantity of the tokens you want to claim
     * @param checkERC20Allowance - Optional, check if the wallet has enough ERC20 allowance to claim the tokens, and if not, approve the transfer
     * @param claimData
     * @returns - The transaction receipt
     */
    __publicField(this, "to", buildTransactionFunction(async (destinationAddress, amount, options) => {
      const quantity = await this.erc20.normalizeAmount(amount);
      return await this.conditions.getClaimTransaction(destinationAddress, quantity, options);
    }));
    this.erc20 = erc20;
    this.contractWrapper = contractWrapper;
    this.storage = storage;
    const metadata = new ContractMetadata(this.contractWrapper, CustomContractSchema, this.storage);
    this.conditions = new DropClaimConditions(this.contractWrapper, metadata, this.storage);
  }
};
var Erc20Droppable = class {
  /**
   * Configure claim conditions
   * @remarks Define who can claim NFTs in the collection, when and how many.
   * @example
   * ```javascript
   * const presaleStartTime = new Date();
   * const publicSaleStartTime = new Date(Date.now() + 60 * 60 * 24 * 1000);
   * const claimConditions = [
   *   {
   *     startTime: presaleStartTime, // start the presale now
   *     maxClaimableSupply: 2, // limit how many mints for this presale
   *     price: 0.01, // presale price
   *     snapshot: ['0x...', '0x...'], // limit minting to only certain addresses
   *   },
   *   {
   *     startTime: publicSaleStartTime, // 24h after presale, start public sale
   *     price: 0.08, // public sale price
   *   }
   * ]);
   * await contract.nft.drop.claim.conditions.set(claimConditions);
   * ```
   */
  constructor(erc20, contractWrapper, storage) {
    this.erc20 = erc20;
    this.contractWrapper = contractWrapper;
    this.storage = storage;
    this.claim = new Erc20ClaimableWithConditions(this.erc20, this.contractWrapper, this.storage);
  }
};
var Erc20Mintable = class {
  /**
   * Batch mint Tokens to many addresses
   */
  constructor(erc20, contractWrapper) {
    __publicField(this, "featureName", FEATURE_TOKEN_MINTABLE.name);
    /**
     * Mint Tokens
     *
     * @remarks Mint tokens to a specified address.
     *
     * @example
     * ```javascript
     * const toAddress = "{{wallet_address}}"; // Address of the wallet you want to mint the tokens to
     * const amount = "1.5"; // The amount of this token you want to mint
     * await contract.token.mint.to(toAddress, amount);
     * ```
     */
    __publicField(this, "to", buildTransactionFunction(async (to, amount) => {
      return await this.getMintTransaction(to, amount);
    }));
    this.erc20 = erc20;
    this.contractWrapper = contractWrapper;
    this.batch = this.detectErc20BatchMintable();
  }
  /**
   * @deprecated Use `contract.erc20.mint.prepare(...args)` instead
   */
  async getMintTransaction(to, amount) {
    return Transaction.fromContractWrapper({
      contractWrapper: this.contractWrapper,
      method: "mintTo",
      args: [await resolveAddress(to), await this.erc20.normalizeAmount(amount)]
    });
  }
  detectErc20BatchMintable() {
    if (detectContractFeature(this.contractWrapper, "ERC20BatchMintable")) {
      return new Erc20BatchMintable(this.erc20, this.contractWrapper);
    }
    return void 0;
  }
};
async function setErc20Allowance(contractToApprove, value, currencyAddress, overrides) {
  if (isNativeToken(currencyAddress)) {
    overrides["value"] = value;
  } else {
    const signer = contractToApprove.getSigner();
    const provider2 = contractToApprove.getProvider();
    const erc20 = new ContractWrapper(signer || provider2, currencyAddress, IERC20_default, contractToApprove.options, contractToApprove.storage);
    const owner = await contractToApprove.getSignerAddress();
    const spender = contractToApprove.address;
    const allowance = await erc20.read("allowance", [owner, spender]);
    if (allowance.lt(value)) {
      await erc20.sendTransaction("approve", [spender, value]);
    }
    return overrides;
  }
}
var Erc20SignatureMintable = class {
  constructor(contractWrapper, roles) {
    __publicField(this, "featureName", FEATURE_TOKEN_SIGNATURE_MINTABLE.name);
    /**
     * Mint tokens from a signature
     *
     * @remarks Mint a certain amount of tokens from a previously generated signature.
     *
     * @example
     * ```javascript
     * // see how to craft a payload to sign in the `generate()` documentation
     * const signedPayload = contract.erc20.signature.generate(payload);
     *
     * // Use the signed payload to mint the tokens
     * const tx = contract.erc20.signature.mint(signedPayload);
     * ```
     * @param signedPayload - the previously generated payload and signature with {@link Erc20SignatureMintable.generate}
     * @twfeature ERC20SignatureMintable
     */
    __publicField(this, "mint", buildTransactionFunction(async (signedPayload) => {
      const mintRequest = signedPayload.payload;
      const signature = signedPayload.signature;
      const message = await this.mapPayloadToContractStruct(mintRequest);
      const overrides = await this.contractWrapper.getCallOverrides();
      await setErc20Allowance(this.contractWrapper, BigNumber.from(message.price), mintRequest.currencyAddress, overrides);
      return Transaction.fromContractWrapper({
        contractWrapper: this.contractWrapper,
        method: "mintWithSignature",
        args: [message, signature],
        overrides
      });
    }));
    /**
     * Mint any number of generated tokens signatures at once
     * @remarks Mint multiple token signatures in one transaction. Note that this is only possible for free mints (cannot batch mints with a price attached to it for security reasons)
     * @param signedPayloads - the array of signed payloads to mint
     * @twfeature ERC20SignatureMintable
     */
    __publicField(this, "mintBatch", buildTransactionFunction(async (signedPayloads) => {
      const contractPayloads = await Promise.all(signedPayloads.map(async (s) => {
        const message = await this.mapPayloadToContractStruct(s.payload);
        const signature = s.signature;
        const price = s.payload.price;
        if (BigNumber.from(price).gt(0)) {
          throw new Error("Can only batch free mints. For mints with a price, use regular mint()");
        }
        return {
          message,
          signature
        };
      }));
      const contractEncoder = new ContractEncoder(this.contractWrapper);
      const encoded = contractPayloads.map((p) => {
        return contractEncoder.encode("mintWithSignature", [p.message, p.signature]);
      });
      return Transaction.fromContractWrapper({
        contractWrapper: this.contractWrapper,
        method: "multicall",
        args: [encoded]
      });
    }));
    this.contractWrapper = contractWrapper;
    this.roles = roles;
  }
  /**
   * Verify that a payload is correctly signed
   * @param signedPayload - the payload to verify
   * @twfeature ERC20SignatureMintable
   *
   * ```javascript
   * const startTime = new Date();
   * const endTime = new Date(Date.now() + 60 * 60 * 24 * 1000);
   * const payload = {
   *   quantity: 4.2, // The quantity of tokens to be minted
   *   to: {{wallet_address}}, // Who will receive the tokens
   *   price: 0.5, // the price to pay for minting those tokens
   *   currencyAddress: NATIVE_TOKEN_ADDRESS, // the currency to pay with
   *   mintStartTime: startTime, // can mint anytime from now
   *   mintEndTime: endTime, // to 24h from now,
   *   primarySaleRecipient: "0x...", // custom sale recipient for this token mint
   * };
   *
   * const signedPayload = await contract.erc20.signature.generate(payload);
   * // Now you can verify if the signed payload is valid
   * const isValid = await contract.erc20.signature.verify(signedPayload);
   * ```
   */
  async verify(signedPayload) {
    const mintRequest = signedPayload.payload;
    const signature = signedPayload.signature;
    const message = await this.mapPayloadToContractStruct(mintRequest);
    const verification = await this.contractWrapper.read("verify", [message, signature]);
    return verification[0];
  }
  /**
   * Generate a signature that can be used to mint a certain amount of tokens
   *
   * @remarks Takes in a quantity of tokens, some conditions for how it can be minted and signs it with your private key. The generated signature can then be used to mint those tokens using the exact payload and signature generated.
   *
   * @example
   * ```javascript
   * const startTime = new Date();
   * const endTime = new Date(Date.now() + 60 * 60 * 24 * 1000);
   * const payload = {
   *   quantity: 4.2, // The quantity of tokens to be minted
   *   to: {{wallet_address}}, // Who will receive the tokens
   *   price: 0.5, // the price to pay for minting those tokens
   *   currencyAddress: NATIVE_TOKEN_ADDRESS, // the currency to pay with
   *   mintStartTime: startTime, // can mint anytime from now
   *   mintEndTime: endTime, // to 24h from now,
   *   primarySaleRecipient: "0x...", // custom sale recipient for this token mint
   * };
   *
   * const signedPayload = await contract.erc20.signature.generate(payload);
   * // now anyone can use these to mint the NFT using `contract.erc20.signature.mint(signedPayload)`
   * ```
   * @param mintRequest - the payload to sign
   * @returns the signed payload and the corresponding signature
   * @twfeature ERC20SignatureMintable
   */
  async generate(mintRequest) {
    return (await this.generateBatch([mintRequest]))[0];
  }
  /**
   * Generate a batch of signatures that can be used to mint many token signatures.
   *
   * @remarks See {@link Erc20SignatureMintable.generate}
   *
   * @param payloadsToSign - the payloads to sign
   * @returns an array of payloads and signatures
   * @twfeature ERC20SignatureMintable
   */
  async generateBatch(payloadsToSign) {
    var _a;
    await ((_a = this.roles) == null ? void 0 : _a.verify(["minter"], await this.contractWrapper.getSignerAddress()));
    const parsedRequests = await Promise.all(payloadsToSign.map((m) => Signature20PayloadInput.parseAsync(m)));
    const chainId = await this.contractWrapper.getChainID();
    const signer = this.contractWrapper.getSigner();
    invariant(signer, "No signer available");
    const name = await this.contractWrapper.read("name", []);
    return await Promise.all(parsedRequests.map(async (m) => {
      const finalPayload = await Signature20PayloadOutput.parseAsync(m);
      const signature = await this.contractWrapper.signTypedData(signer, {
        name,
        version: "1",
        chainId,
        verifyingContract: this.contractWrapper.address
      }, {
        MintRequest: MintRequest20
      }, await this.mapPayloadToContractStruct(finalPayload));
      return {
        payload: finalPayload,
        signature: signature.toString()
      };
    }));
  }
  /** ******************************
   * PRIVATE FUNCTIONS
   *******************************/
  /**
   * Maps a payload to the format expected by the contract
   *
   * @internal
   *
   * @param mintRequest - The payload to map.
   * @returns - The mapped payload.
   */
  async mapPayloadToContractStruct(mintRequest) {
    const normalizedPrice = await normalizePriceValue(this.contractWrapper.getProvider(), mintRequest.price, mintRequest.currencyAddress);
    const amountWithDecimals = utils_exports.parseUnits(mintRequest.quantity, await this.contractWrapper.read("decimals", []));
    return {
      to: mintRequest.to,
      primarySaleRecipient: mintRequest.primarySaleRecipient,
      quantity: amountWithDecimals,
      price: normalizedPrice,
      currency: mintRequest.currencyAddress,
      validityEndTimestamp: mintRequest.mintEndTime,
      validityStartTimestamp: mintRequest.mintStartTime,
      uid: mintRequest.uid
    };
  }
};
function assertEnabled(namespace, feature) {
  if (!namespace) {
    throw new ExtensionNotImplementedError(feature);
  }
  return namespace;
}
async function normalizeAmount(contractWrapper, amount) {
  const decimals = await contractWrapper.read("decimals", []);
  return utils_exports.parseUnits(AmountSchema.parse(amount), decimals);
}
var Erc20 = class {
  constructor(contractWrapper, storage, chainId) {
    __publicField(this, "featureName", FEATURE_TOKEN.name);
    /**
     * Transfer tokens
     *
     * @remarks Transfer tokens from the connected wallet to another wallet.
     *
     * @example
     * ```javascript
     * // Address of the wallet you want to send the tokens to
     * const toAddress = "0x...";
     * // The amount of tokens you want to send
     * const amount = 0.1;
     * await contract.erc20.transfer(toAddress, amount);
     * ```
     * @twfeature ERC20
     */
    __publicField(this, "transfer", buildTransactionFunction(async (to, amount) => {
      return Transaction.fromContractWrapper({
        contractWrapper: this.contractWrapper,
        method: "transfer",
        args: await Promise.all([resolveAddress(to), this.normalizeAmount(amount)])
      });
    }));
    /**
     * Transfer tokens from a specific address
     *
     * @remarks Transfer tokens from one wallet to another
     *
     * @example
     * ```javascript
     * // Address of the wallet sending the tokens
     * const fromAddress = "{{wallet_address}}";
     * // Address of the wallet you want to send the tokens to
     * const toAddress = "0x...";
     * // The number of tokens you want to send
     * const amount = 1.2
     * // Note that the connected wallet must have approval to transfer the tokens of the fromAddress
     * await contract.erc20.transferFrom(fromAddress, toAddress, amount);
     * ```
     * @twfeature ERC20
     */
    __publicField(this, "transferFrom", buildTransactionFunction(async (from, to, amount) => {
      return Transaction.fromContractWrapper({
        contractWrapper: this.contractWrapper,
        method: "transferFrom",
        args: await Promise.all([resolveAddress(from), resolveAddress(to), this.normalizeAmount(amount)])
      });
    }));
    /**
     * Set token allowance
     * @remarks Allows the specified `spender` wallet to transfer the given `amount` of tokens to another wallet
     * @example
     * ```javascript
     * // Address of the wallet to allow transfers from
     * const spenderAddress = "0x...";
     * // The number of tokens to give as allowance
     * const amount = 100
     * await contract.erc20.setAllowance(spenderAddress, amount);
     * ```
     * @twfeature ERC20
     */
    __publicField(this, "setAllowance", buildTransactionFunction(async (spender, amount) => {
      return Transaction.fromContractWrapper({
        contractWrapper: this.contractWrapper,
        method: "approve",
        args: await Promise.all([resolveAddress(spender), this.normalizeAmount(amount)])
      });
    }));
    /**
     * Transfer tokens to many wallets
     *
     * @remarks Mint tokens from the connected wallet to many wallets
     *
     * @example
     * ```javascript
     * // Data of the tokens you want to mint
     * const data = [
     *   {
     *     toAddress: "{{wallet_address}}", // Address to mint tokens to
     *     amount: 100, // How many tokens to mint to specified address
     *   },
     *  {
     *    toAddress: "0x...",
     *    amount: 100,
     *  }
     * ]
     *
     * await contract.erc20.transferBatch(data);
     * ```
     */
    __publicField(this, "transferBatch", buildTransactionFunction(async (args) => {
      const contractEncoder = new ContractEncoder(this.contractWrapper);
      const encoded = (await Promise.all(args.map((arg) => Promise.all([this.normalizeAmount(arg.amount), resolveAddress(arg.toAddress)])))).map((_ref) => {
        let [amountWithDecimals, address] = _ref;
        return contractEncoder.encode("transfer", [address, amountWithDecimals]);
      });
      return Transaction.fromContractWrapper({
        contractWrapper: this.contractWrapper,
        method: "multicall",
        args: [encoded]
      });
    }));
    ////// ERC20 Mintable Extension //////
    /**
     * Mint tokens
     *
     * @remarks Mint tokens to the connected wallet.
     *
     * @example
     * ```javascript
     * const amount = "1.5"; // The amount of this token you want to mint
     * await contract.erc20.mint(amount);
     * ```
     * @twfeature ERC20Mintable
     */
    __publicField(this, "mint", buildTransactionFunction(async (amount) => {
      return this.mintTo.prepare(await this.contractWrapper.getSignerAddress(), amount);
    }));
    /**
     * Mint tokens to a specific wallet
     *
     * @remarks Mint tokens to a specified address.
     *
     * @example
     * ```javascript
     * const toAddress = "{{wallet_address}}"; // Address of the wallet you want to mint the tokens to
     * const amount = "1.5"; // The amount of this token you want to mint
     * await contract.erc20.mintTo(toAddress, amount);
     * ```
     * @twfeature ERC20Mintable
     */
    __publicField(this, "mintTo", buildTransactionFunction(async (receiver, amount) => {
      return assertEnabled(this.mintable, FEATURE_TOKEN_MINTABLE).to.prepare(receiver, amount);
    }));
    ////// ERC20 BatchMintable Extension //////
    /**
     * Mint tokens to many wallets
     *
     * @remarks Mint tokens to many wallets in one transaction.
     *
     * @example
     * ```javascript
     * // Data of the tokens you want to mint
     * const data = [
     *   {
     *     toAddress: "{{wallet_address}}", // Address to mint tokens to
     *     amount: 0.2, // How many tokens to mint to specified address
     *   },
     *  {
     *    toAddress: "0x...",
     *    amount: 1.4,
     *  }
     * ]
     *
     * await contract.mintBatchTo(data);
     * ```
     * @twfeature ERC20BatchMintable
     */
    __publicField(this, "mintBatchTo", buildTransactionFunction(async (args) => {
      var _a;
      return assertEnabled((_a = this.mintable) == null ? void 0 : _a.batch, FEATURE_TOKEN_BATCH_MINTABLE).to.prepare(args);
    }));
    ////// ERC20 Burnable Extension //////
    /**
     * Burn tokens
     *
     * @remarks Burn tokens held by the connected wallet
     *
     * @example
     * ```javascript
     * // The amount of this token you want to burn
     * const amount = 1.2;
     *
     * await contract.erc20.burn(amount);
     * ```
     * @twfeature ERC20Burnable
     */
    __publicField(this, "burn", buildTransactionFunction(async (amount) => {
      return assertEnabled(this.burnable, FEATURE_TOKEN_BURNABLE).tokens.prepare(amount);
    }));
    /**
     * Burn tokens from a specific wallet
     *
     * @remarks Burn tokens held by the specified wallet
     *
     * @example
     * ```javascript
     * // Address of the wallet sending the tokens
     * const holderAddress = "{{wallet_address}}";
     *
     * // The amount of this token you want to burn
     * const amount = 1.2;
     *
     * await contract.erc20.burnFrom(holderAddress, amount);
     * ```
     * @twfeature ERC20Burnable
     */
    __publicField(this, "burnFrom", buildTransactionFunction(async (holder, amount) => {
      return assertEnabled(this.burnable, FEATURE_TOKEN_BURNABLE).from.prepare(holder, amount);
    }));
    ////// ERC20 Claimable Extension //////
    /**
     * Claim tokens
     *
     * @remarks Let the specified wallet claim Tokens.
     *
     * @example
     * ```javascript
     * const address = "{{wallet_address}}"; // address of the wallet you want to claim the NFTs
     * const quantity = 42.69; // how many tokens you want to claim
     *
     * const tx = await contract.erc20.claim(address, quantity);
     * const receipt = tx.receipt; // the transaction receipt
     * ```
     *
     * @param destinationAddress - Address you want to send the token to
     * @param amount - Quantity of the tokens you want to claim
     * @param checkERC20Allowance - Optional, check if the wallet has enough ERC20 allowance to claim the tokens, and if not, approve the transfer
     * @param claimData
     * @returns - The transaction receipt
     * @twfeature ERC20ClaimPhasesV2 | ERC20ClaimPhasesV1 | ERC20ClaimConditionsV2 | ERC20ClaimConditionsV1
     */
    __publicField(this, "claim", buildTransactionFunction(async (amount, options) => {
      return this.claimTo.prepare(await this.contractWrapper.getSignerAddress(), amount, options);
    }));
    /**
     * Claim tokens to a specific wallet
     *
     * @remarks Let the specified wallet claim Tokens.
     *
     * @example
     * ```javascript
     * const address = "{{wallet_address}}"; // address of the wallet you want to claim the NFTs
     * const quantity = 42.69; // how many tokens you want to claim
     *
     * const tx = await contract.erc20.claim(address, quantity);
     * const receipt = tx.receipt; // the transaction receipt
     * ```
     *
     * @param destinationAddress - Address you want to send the token to
     * @param amount - Quantity of the tokens you want to claim
     * @param checkERC20Allowance - Optional, check if the wallet has enough ERC20 allowance to claim the tokens, and if not, approve the transfer
     * @param claimData
     * @returns - The transaction receipt
     * @twfeature ERC20ClaimPhasesV2 | ERC20ClaimPhasesV1 | ERC20ClaimConditionsV2 | ERC20ClaimConditionsV1
     */
    __publicField(this, "claimTo", buildTransactionFunction(async (destinationAddress, amount, options) => {
      var _a;
      return assertEnabled((_a = this.droppable) == null ? void 0 : _a.claim, FEATURE_TOKEN_CLAIM_CONDITIONS_V2).to.prepare(destinationAddress, amount, options);
    }));
    this.contractWrapper = contractWrapper;
    this.storage = storage;
    this.mintable = this.detectErc20Mintable();
    this.burnable = this.detectErc20Burnable();
    this.droppable = this.detectErc20Droppable();
    this.signatureMintable = this.detectErc20SignatureMintable();
    this._chainId = chainId;
  }
  /**
   * Mint tokens
   */
  get chainId() {
    return this._chainId;
  }
  /**
   * @internal
   */
  onNetworkUpdated(network) {
    this.contractWrapper.updateSignerOrProvider(network);
  }
  /**
   * @internal
   */
  getAddress() {
    return this.contractWrapper.address;
  }
  ////// Standard ERC20 Extension //////
  /**
   * Get the token metadata
   * @remarks name, symbol, etc...
   * @example
   * ```javascript
   * const token = await contract.erc20.get();
   * ```
   * @returns The token metadata
   * @twfeature ERC20
   */
  async get() {
    return await fetchCurrencyMetadata(this.contractWrapper.getProvider(), this.getAddress());
  }
  /**
   * Get token balance for the currently connected wallet
   *
   * @remarks Get a wallets token balance.
   *
   * @example
   * ```javascript
   * const balance = await contract.erc20.balance();
   * ```
   *
   * @returns The balance of a specific wallet.
   * @twfeature ERC20
   */
  async balance() {
    return await this.balanceOf(await this.contractWrapper.getSignerAddress());
  }
  /**
   * Get token balance for a specific wallet
   *
   * @remarks Get a wallets token balance.
   *
   * @example
   * ```javascript
   * const walletAddress = "{{wallet_address}}";
   * const balance = await contract.erc20.balanceOf(walletAddress);
   * ```
   *
   * @returns The balance of a specific wallet.
   * @twfeature ERC20
   */
  async balanceOf(address) {
    return this.getValue(await this.contractWrapper.read("balanceOf", [await resolveAddress(address)]));
  }
  /**
   * Get the total supply for this token
   * @remarks Get how much supply has been minted
   * @example
   * ```javascript
   * const balance = await contract.erc20.totalSupply();
   * ```
   * @twfeature ERC20
   */
  async totalSupply() {
    return await this.getValue(await this.contractWrapper.read("totalSupply", []));
  }
  /**
   * Get token allowance
   *
   * @remarks Get the allowance of a 'spender' wallet over the connected wallet's funds - the allowance of a different address for a token is the amount of tokens that the `spender` wallet is allowed to spend on behalf of the connected wallet.
   *
   * @example
   * ```javascript
   * // Address of the wallet to check token allowance
   * const spenderAddress = "0x...";
   * const allowance = await contract.erc20.allowance(spenderAddress);
   * ```
   *
   * @returns The allowance of one wallet over anothers funds.
   * @twfeature ERC20
   */
  async allowance(spender) {
    const [owner, spenderAddress] = await Promise.all([this.contractWrapper.getSignerAddress(), resolveAddress(spender)]);
    return await this.allowanceOf(owner, spenderAddress);
  }
  /**
   * Get token allowance of a specific wallet
   *
   * @remarks Get the allowance of one wallet over another wallet's funds - the allowance of a different address for a token is the amount of tokens that the wallet is allowed to spend on behalf of the specified wallet.
   *
   * @example
   * ```javascript
   * // Address of the wallet who owns the funds
   * const owner = "{{wallet_address}}";
   * // Address of the wallet to check token allowance
   * const spender = "0x...";
   * const allowance = await contract.erc20.allowanceOf(owner, spender);
   * ```
   *
   * @returns The allowance of one wallet over anothers funds.
   * @twfeature ERC20
   */
  async allowanceOf(owner, spender) {
    const args = await Promise.all([resolveAddress(owner), resolveAddress(spender)]);
    return await this.getValue(await this.contractWrapper.read("allowance", args));
  }
  /**
   * Construct a mint transaction without executing it
   * @remarks This is useful for estimating the gas cost of a mint transaction, overriding transaction options and having fine grained control over the transaction execution.
   * @param receiver - Address you want to send the token to
   * @param amount - The amount of tokens you want to mint
   *
   * @deprecated Use `contract.erc20.mint.prepare(...args)` instead
   * @twfeature ERC20Mintable
   */
  async getMintTransaction(receiver, amount) {
    return assertEnabled(this.mintable, FEATURE_TOKEN_MINTABLE).getMintTransaction(receiver, amount);
  }
  /**
   * Configure claim conditions
   * @remarks Define who can claim NFTs in the collection, when and how many.
   * @example
   * ```javascript
   * const presaleStartTime = new Date();
   * const publicSaleStartTime = new Date(Date.now() + 60 * 60 * 24 * 1000);
   * const claimConditions = [
   *   {
   *     startTime: presaleStartTime, // start the presale now
   *     maxClaimableSupply: 2, // limit how many mints for this presale
   *     price: 0.01, // presale price
   *     snapshot: ['0x...', '0x...'], // limit minting to only certain addresses
   *   },
   *   {
   *     startTime: publicSaleStartTime, // 24h after presale, start public sale
   *     price: 0.08, // public sale price
   *   }
   * ]);
   * await contract.erc20.claimConditions.set(claimConditions);
   * ```
   * @twfeature ERC20ClaimPhasesV2 | ERC20ClaimPhasesV1 | ERC20ClaimConditionsV2 | ERC20ClaimConditionsV1
   */
  get claimConditions() {
    var _a;
    return assertEnabled((_a = this.droppable) == null ? void 0 : _a.claim, FEATURE_TOKEN_CLAIM_CONDITIONS_V2).conditions;
  }
  ////// ERC20 SignatureMint Extension //////
  /**
   * Mint with signature
   * @remarks Generate dynamic tokens with your own signature, and let others mint them using that signature.
   * @example
   * ```javascript
   * // see how to craft a payload to sign in the `contract.erc20.signature.generate()` documentation
   * const signedPayload = contract.erc20.signature().generate(payload);
   *
   * // now the payload can be used to mint tokens
   * const tx = contract.erc20.signature.mint(signedPayload);
   * ```
   * @twfeature ERC20SignatureMintable
   */
  get signature() {
    return assertEnabled(this.signatureMintable, FEATURE_TOKEN_SIGNATURE_MINTABLE);
  }
  /** ******************************
   * PRIVATE FUNCTIONS
   *******************************/
  /**
   * returns the wei amount from a token amount
   * @internal
   * @param amount
   */
  async normalizeAmount(amount) {
    return normalizeAmount(this.contractWrapper, amount);
  }
  /**
   * @internal
   */
  async getValue(value) {
    return await fetchCurrencyValue(this.contractWrapper.getProvider(), this.getAddress(), BigNumber.from(value));
  }
  detectErc20Mintable() {
    if (detectContractFeature(this.contractWrapper, "ERC20")) {
      return new Erc20Mintable(this, this.contractWrapper);
    }
    return void 0;
  }
  detectErc20Burnable() {
    if (detectContractFeature(this.contractWrapper, "ERC20Burnable")) {
      return new Erc20Burnable(this, this.contractWrapper);
    }
    return void 0;
  }
  detectErc20Droppable() {
    if (detectContractFeature(this.contractWrapper, "ERC20ClaimConditionsV1") || detectContractFeature(this.contractWrapper, "ERC20ClaimConditionsV2") || detectContractFeature(this.contractWrapper, "ERC20ClaimPhasesV1") || detectContractFeature(this.contractWrapper, "ERC20ClaimPhasesV2")) {
      return new Erc20Droppable(this, this.contractWrapper, this.storage);
    }
    return void 0;
  }
  detectErc20SignatureMintable() {
    if (detectContractFeature(this.contractWrapper, "ERC20SignatureMintable")) {
      return new Erc20SignatureMintable(this.contractWrapper);
    }
    return void 0;
  }
};
var Erc721BatchMintable = class {
  constructor(erc721, contractWrapper, storage) {
    __publicField(this, "featureName", FEATURE_NFT_BATCH_MINTABLE.name);
    /**
     * Mint Many unique NFTs
     *
     * @remarks Mint many unique NFTs at once to a specified wallet.
     *
     * @example
     * ```javascript
     * // Address of the wallet you want to mint the NFT to
     * const walletAddress = "{{wallet_address}}";
     *
     * // Custom metadata of the NFTs you want to mint.
     * const metadatas = [{
     *   name: "Cool NFT #1",
     *   description: "This is a cool NFT",
     *   image: fs.readFileSync("path/to/image.png"), // This can be an image url or file
     * }, {
     *   name: "Cool NFT #2",
     *   description: "This is a cool NFT",
     *   image: fs.readFileSync("path/to/other/image.png"),
     * }];
     *
     * const tx = await contract.mint.batch.to(walletAddress, metadatas);
     * const receipt = tx[0].receipt; // same transaction receipt for all minted NFTs
     * const firstTokenId = tx[0].id; // token id of the first minted NFT
     * const firstNFT = await tx[0].data(); // (optional) fetch details of the first minted NFT
     * ```
     */
    __publicField(this, "to", buildTransactionFunction(async (to, metadatas) => {
      const [uris, resolvedAddress] = await Promise.all([uploadOrExtractURIs(metadatas, this.storage), resolveAddress(to)]);
      const contractEncoder = new ContractEncoder(this.contractWrapper);
      const encoded = uris.map((uri) => contractEncoder.encode("mintTo", [resolvedAddress, uri]));
      return Transaction.fromContractWrapper({
        contractWrapper: this.contractWrapper,
        method: "multicall",
        args: [encoded],
        parse: (receipt) => {
          const events = this.contractWrapper.parseLogs("TokensMinted", receipt.logs);
          if (events.length === 0 || events.length < metadatas.length) {
            throw new Error("TokenMinted event not found, minting failed");
          }
          return events.map((e) => {
            const id = e.args.tokenIdMinted;
            return {
              id,
              receipt,
              data: () => this.erc721.get(id)
            };
          });
        }
      });
    }));
    this.erc721 = erc721;
    this.contractWrapper = contractWrapper;
    this.storage = storage;
  }
};
var Erc721ClaimableWithConditions = class {
  /**
   * Configure claim conditions
   * @remarks Define who can claim NFTs in the collection, when and how many.
   * @example
   * ```javascript
   * const presaleStartTime = new Date();
   * const publicSaleStartTime = new Date(Date.now() + 60 * 60 * 24 * 1000);
   * const claimConditions = [
   *   {
   *     startTime: presaleStartTime, // start the presale now
   *     maxClaimableSupply: 2, // limit how many mints for this presale
   *     price: 0.01, // presale price
   *     snapshot: ['0x...', '0x...'], // limit minting to only certain addresses
   *   },
   *   {
   *     startTime: publicSaleStartTime, // 24h after presale, start public sale
   *     price: 0.08, // public sale price
   *   }
   * ]);
   * await contract.erc721.claimConditions.set(claimConditions);
   * ```
   */
  constructor(erc721, contractWrapper, storage) {
    __publicField(this, "featureName", FEATURE_NFT_CLAIM_CONDITIONS_V2.name);
    /**
     * Claim unique NFTs to a specific Wallet
     *
     * @remarks Let the specified wallet claim NFTs.
     *
     * @example
     * ```javascript
     * const address = "{{wallet_address}}"; // address of the wallet you want to claim the NFTs
     * const quantity = 1; // how many unique NFTs you want to claim
     *
     * const tx = await contract.erc721.claimTo(address, quantity);
     * const receipt = tx[0].receipt; // the transaction receipt
     * const claimedTokenId = tx[0].id; // the id of the first NFT claimed
     * const claimedNFT = await tx[0].data(); // (optional) get the first claimed NFT metadata
     * ```
     *
     * @param destinationAddress - Address you want to send the token to
     * @param quantity - Quantity of the tokens you want to claim
     * @param options
     * @returns - an array of results containing the id of the token claimed, the transaction receipt and a promise to optionally fetch the nft metadata
     */
    __publicField(this, "to", buildTransactionFunction(async (destinationAddress, quantity, options) => {
      const tx = await this.conditions.getClaimTransaction(destinationAddress, quantity, options);
      tx.setParse((receipt) => {
        const event = this.contractWrapper.parseLogs("TokensClaimed", receipt == null ? void 0 : receipt.logs);
        const startingIndex = event[0].args.startTokenId;
        const endingIndex = startingIndex.add(quantity);
        const results = [];
        for (let id = startingIndex; id.lt(endingIndex); id = id.add(1)) {
          results.push({
            id,
            receipt,
            data: () => this.erc721.get(id)
          });
        }
        return results;
      });
      return tx;
    }));
    this.erc721 = erc721;
    this.contractWrapper = contractWrapper;
    this.storage = storage;
    const metadata = new ContractMetadata(this.contractWrapper, CustomContractSchema, this.storage);
    this.conditions = new DropClaimConditions(this.contractWrapper, metadata, this.storage);
  }
};
async function calculateClaimCost(contractWrapper, pricePerToken, quantity, currencyAddress, checkERC20Allowance) {
  let overrides = {};
  const currency = currencyAddress || NATIVE_TOKEN_ADDRESS;
  const normalizedPrice = await normalizePriceValue(contractWrapper.getProvider(), pricePerToken, currency);
  const totalCost = normalizedPrice.mul(quantity);
  if (totalCost.gt(0)) {
    if (currency === NATIVE_TOKEN_ADDRESS) {
      overrides = {
        value: totalCost
      };
    } else if (currency !== NATIVE_TOKEN_ADDRESS && checkERC20Allowance) {
      await approveErc20Allowance(contractWrapper, currency, totalCost, quantity, 0);
    }
  }
  return overrides;
}
var Erc721Claimable = class {
  constructor(erc721, contractWrapper) {
    __publicField(this, "featureName", FEATURE_NFT_CLAIM_CUSTOM.name);
    /**
     * Claim NFTs to a specific Wallet
     *
     * @remarks Let the specified wallet claim NFTs.
     *
     * @example
     * ```javascript
     * const address = "{{wallet_address}}"; // address of the wallet you want to claim the NFTs
     * const quantity = 1; // how many NFTs you want to claim
     *
     * const tx = await contract.erc721.claimTo(address, quantity);
     * const receipt = tx[0].receipt; // the transaction receipt
     * ```
     *
     * @param destinationAddress - Address you want to send the token to
     * @param quantity - Quantity of the tokens you want to claim
     * @param options - Options for claiming the NFTs
     *
     * @returns - Receipt for the transaction
     */
    __publicField(this, "to", buildTransactionFunction(async (destinationAddress, quantity, options) => {
      const tx = await this.getClaimTransaction(destinationAddress, quantity, options);
      tx.setParse((receipt) => {
        const event = this.contractWrapper.parseLogs("TokensClaimed", receipt == null ? void 0 : receipt.logs);
        const startingIndex = event[0].args.startTokenId;
        const endingIndex = startingIndex.add(quantity);
        const results = [];
        for (let id = startingIndex; id.lt(endingIndex); id = id.add(1)) {
          results.push({
            id,
            receipt,
            data: () => this.erc721.get(id)
          });
        }
        return results;
      });
      return tx;
    }));
    this.erc721 = erc721;
    this.contractWrapper = contractWrapper;
  }
  /**
   * Construct a claim transaction without executing it.
   * This is useful for estimating the gas cost of a claim transaction, overriding transaction options and having fine grained control over the transaction execution.
   * @param destinationAddress - Address you want to send the token to
   * @param tokenId - Id of the token you want to claim
   * @param quantity - Quantity of the tokens you want to claim
   * @param options - Options for claiming the NFTs
   *
   * @deprecated Use `contract.erc721.claim.prepare(...args)` instead
   */
  async getClaimTransaction(destinationAddress, quantity, options) {
    let overrides = {};
    if (options && options.pricePerToken) {
      overrides = await calculateClaimCost(this.contractWrapper, options.pricePerToken, quantity, options.currencyAddress, options.checkERC20Allowance);
    }
    return Transaction.fromContractWrapper({
      contractWrapper: this.contractWrapper,
      method: "claim",
      args: [destinationAddress, quantity],
      overrides
    });
  }
};
var Erc721LazyMintable = class {
  /**
   * Delayed reveal
   * @remarks Create a batch of encrypted NFTs that can be revealed at a later time.
   * @example
   * ```javascript
   * // the real NFTs, these will be encrypted until you reveal them
   * const realNFTs = [{
   *   name: "Common NFT #1",
   *   description: "Common NFT, one of many.",
   *   image: fs.readFileSync("path/to/image.png"),
   * }, {
   *   name: "Super Rare NFT #2",
   *   description: "You got a Super Rare NFT!",
   *   image: fs.readFileSync("path/to/image.png"),
   * }];
   * // A placeholder NFT that people will get immediately in their wallet, and will be converted to the real NFT at reveal time
   * const placeholderNFT = {
   *   name: "Hidden NFT",
   *   description: "Will be revealed next week!"
   * };
   * // Create and encrypt the NFTs
   * await contract.nft.drop.revealer.createDelayedRevealBatch(
   *   placeholderNFT,
   *   realNFTs,
   *   "my secret password",
   * );
   * // Whenever you're ready, reveal your NFTs at any time
   * const batchId = 0; // the batch to reveal
   * await contract.erc721.revealer.reveal(batchId, "my secret password");
   * ```
   */
  constructor(erc721, contractWrapper, storage) {
    __publicField(this, "featureName", FEATURE_NFT_LAZY_MINTABLE.name);
    /**
     * Create a batch of unique NFTs to be claimed in the future
     *
     * @remarks Create batch allows you to create a batch of many unique NFTs in one transaction.
     *
     * @example
     * ```javascript
     * // Custom metadata of the NFTs to create
     * const metadatas = [{
     *   name: "Cool NFT",
     *   description: "This is a cool NFT",
     *   image: fs.readFileSync("path/to/image.png"), // This can be an image url or file
     * }, {
     *   name: "Cool NFT",
     *   description: "This is a cool NFT",
     *   image: fs.readFileSync("path/to/image.png"),
     * }];
     *
     * const results = await contract.erc721.lazyMint(metadatas); // uploads and creates the NFTs on chain
     * const firstTokenId = results[0].id; // token id of the first created NFT
     * const firstNFT = await results[0].data(); // (optional) fetch details of the first created NFT
     * ```
     *
     * @param metadatas - The metadata to include in the batch.
     * @param options - optional upload progress callback
     */
    __publicField(this, "lazyMint", buildTransactionFunction(async (metadatas, options) => {
      const startFileNumber = await this.erc721.nextTokenIdToMint();
      const batch = await uploadOrExtractURIs(metadatas, this.storage, startFileNumber.toNumber(), options);
      const baseUri = getBaseUriFromBatch(batch);
      return Transaction.fromContractWrapper({
        contractWrapper: this.contractWrapper,
        method: "lazyMint",
        args: [batch.length, baseUri.endsWith("/") ? baseUri : `${baseUri}/`, utils_exports.toUtf8Bytes("")],
        parse: (receipt) => {
          const event = this.contractWrapper.parseLogs("TokensLazyMinted", receipt == null ? void 0 : receipt.logs);
          const startingIndex = event[0].args.startTokenId;
          const endingIndex = event[0].args.endTokenId;
          const results = [];
          for (let id = startingIndex; id.lte(endingIndex); id = id.add(1)) {
            results.push({
              id,
              receipt,
              data: () => this.erc721.getTokenMetadata(id)
            });
          }
          return results;
        }
      });
    }));
    this.erc721 = erc721;
    this.contractWrapper = contractWrapper;
    this.storage = storage;
    this.revealer = this.detectErc721Revealable();
  }
  /** ******************************
   * PRIVATE FUNCTIONS
   *******************************/
  detectErc721Revealable() {
    if (detectContractFeature(this.contractWrapper, "ERC721Revealable")) {
      return new DelayedReveal(this.contractWrapper, this.storage, FEATURE_NFT_REVEALABLE.name, () => this.erc721.nextTokenIdToMint());
    }
    return void 0;
  }
};
var Erc721Mintable = class {
  constructor(erc721, contractWrapper, storage) {
    __publicField(this, "featureName", FEATURE_NFT_MINTABLE.name);
    /**
     * Mint a unique NFT
     *
     * @remarks Mint a unique NFT to a specified wallet.
     *
     * @example
     * ```javascript
     * // Address of the wallet you want to mint the NFT to
     * const walletAddress = "{{wallet_address}}";
     *
     * // Custom metadata of the NFT, note that you can fully customize this metadata with other properties.
     * const metadata = {
     *   name: "Cool NFT",
     *   description: "This is a cool NFT",
     *   image: fs.readFileSync("path/to/image.png"), // This can be an image url or file
     * };
     *
     * const tx = await contract.nft.mint.to(walletAddress, metadata);
     * const receipt = tx.receipt; // the transaction receipt
     * const tokenId = tx.id; // the id of the NFT minted
     * const nft = await tx.data(); // (optional) fetch details of minted NFT
     * ```
     */
    __publicField(this, "to", buildTransactionFunction(async (to, metadata) => {
      const [uri, toAddress] = await Promise.all([uploadOrExtractURI(metadata, this.storage), resolveAddress(to)]);
      return Transaction.fromContractWrapper({
        contractWrapper: this.contractWrapper,
        method: "mintTo",
        args: [toAddress, uri],
        parse: (receipt) => {
          const event = this.contractWrapper.parseLogs("Transfer", receipt == null ? void 0 : receipt.logs);
          if (event.length === 0) {
            throw new Error("TransferEvent event not found");
          }
          const id = event[0].args.tokenId;
          return {
            id,
            receipt,
            data: () => this.erc721.get(id)
          };
        }
      });
    }));
    this.erc721 = erc721;
    this.contractWrapper = contractWrapper;
    this.storage = storage;
    this.batch = this.detectErc721BatchMintable();
  }
  /**
   * @deprecated Use `contract.erc721.mint.prepare(...args)` instead
   */
  async getMintTransaction(to, metadata) {
    return this.to.prepare(await resolveAddress(to), metadata);
  }
  detectErc721BatchMintable() {
    if (detectContractFeature(this.contractWrapper, "ERC721BatchMintable")) {
      return new Erc721BatchMintable(this.erc721, this.contractWrapper, this.storage);
    }
    return void 0;
  }
};
var Erc721Enumerable = class {
  constructor(erc721, contractWrapper) {
    __publicField(this, "featureName", FEATURE_NFT_ENUMERABLE.name);
    this.erc721 = erc721;
    this.contractWrapper = contractWrapper;
  }
  /**
   * Get all NFTs owned by a specific wallet
   *
   * @remarks Get all the data associated with the NFTs owned by a specific wallet.
   *
   * @example
   * ```javascript
   * // Address of the wallet to get the NFTs of
   * const address = "{{wallet_address}}";
   * const nfts = await contract.nft.query.owned.all(address);
   * ```
   * @param walletAddress - the wallet address to query, defaults to the connected wallet
   * @returns The NFT metadata for all NFTs in the contract.
   */
  async all(walletAddress) {
    const tokenIds = await this.tokenIds(walletAddress);
    return await Promise.all(tokenIds.map((tokenId) => this.erc721.get(tokenId.toString())));
  }
  /**
   * Get all token ids of NFTs owned by a specific wallet.
   * @param walletAddress - the wallet address to query, defaults to the connected wallet
   */
  async tokenIds(walletAddress) {
    const address = await resolveAddress(walletAddress || await this.contractWrapper.getSignerAddress());
    const balance = await this.contractWrapper.read("balanceOf", [address]);
    const indices = Array.from(Array(balance.toNumber()).keys());
    return await Promise.all(indices.map((i) => this.contractWrapper.read("tokenOfOwnerByIndex", [address, i])));
  }
};
var Erc721AQueryable = class {
  constructor(erc721, contractWrapper) {
    __publicField(this, "featureName", FEATURE_NFT_QUERYABLE.name);
    this.erc721 = erc721;
    this.contractWrapper = contractWrapper;
  }
  /**
   * Get all NFTs owned by a specific wallet
   *
   * @remarks Get all the data associated with the NFTs owned by a specific wallet.
   *
   * @example
   * ```javascript
   * // Address of the wallet to get the NFTs of
   * const address = "{{wallet_address}}";
   * const nfts = await contract.nft.query.owned.all(address);
   * ```
   * @param walletAddress - the wallet address to query, defaults to the connected wallet
   * @returns The NFT metadata for all NFTs in the contract.
   */
  async all(walletAddress) {
    const tokenIds = await this.tokenIds(walletAddress);
    return await Promise.all(tokenIds.map((tokenId) => this.erc721.get(tokenId.toString())));
  }
  /**
   * Get all token ids of NFTs owned by a specific wallet.
   * @param walletAddress - the wallet address to query, defaults to the connected wallet
   */
  async tokenIds(walletAddress) {
    const address = await resolveAddress(walletAddress || await this.contractWrapper.getSignerAddress());
    return await this.contractWrapper.read("tokensOfOwner", [address]);
  }
};
var Erc721Supply = class {
  constructor(erc721, contractWrapper) {
    __publicField(this, "featureName", FEATURE_NFT_SUPPLY.name);
    this.erc721 = erc721;
    this.contractWrapper = contractWrapper;
    this.owned = this.detectErc721Owned();
  }
  /**
   * Get all NFTs
   *
   * @remarks Get all the data associated with every NFT in this contract.
   *
   * By default, returns the first 100 NFTs, use queryParams to fetch more.
   *
   * @example
   * ```javascript
   * const nfts = await contract.nft.query.all();
   * ```
   * @param queryParams - optional filtering to only fetch a subset of results.
   * @returns The NFT metadata for all NFTs queried.
   */
  async all(queryParams) {
    let startTokenId = BigNumber.from(0);
    if (hasFunction("startTokenId", this.contractWrapper)) {
      startTokenId = await this.contractWrapper.read("startTokenId", []);
    }
    const start = BigNumber.from((queryParams == null ? void 0 : queryParams.start) || 0).add(startTokenId).toNumber();
    const count = BigNumber.from((queryParams == null ? void 0 : queryParams.count) || DEFAULT_QUERY_ALL_COUNT).toNumber();
    const maxSupply = await this.erc721.nextTokenIdToMint();
    const maxId = Math.min(maxSupply.add(startTokenId).toNumber(), start + count);
    return await Promise.all([...Array(maxId - start).keys()].map((i) => this.erc721.get((start + i).toString())));
  }
  /**
   * Return all the owners of each token id in this contract
   * @returns
   */
  async allOwners() {
    let totalCount;
    let startTokenId = BigNumber.from(0);
    if (hasFunction("startTokenId", this.contractWrapper)) {
      startTokenId = await this.contractWrapper.read("startTokenId", []);
    }
    try {
      totalCount = await this.erc721.totalClaimedSupply();
    } catch (e) {
      totalCount = await this.totalCount();
    }
    totalCount = totalCount.add(startTokenId);
    const arr = [...new Array(totalCount.toNumber()).keys()];
    const owners = await Promise.all(arr.map((i) => this.erc721.ownerOf(i).catch(() => lib_exports.AddressZero)));
    return arr.map((i) => ({
      tokenId: i,
      owner: owners[i]
    })).filter((o) => o.owner !== lib_exports.AddressZero);
  }
  /**
   * Get the number of NFTs minted
   * @remarks This returns the total number of NFTs minted in this contract, **not** the total supply of a given token.
   *
   * @returns the total number of NFTs minted in this contract
   * @public
   */
  async totalCount() {
    return await this.erc721.nextTokenIdToMint();
  }
  /**
   * Get the number of NFTs of this contract currently owned by end users
   * @returns the total number of NFTs of this contract in circulation (minted & not burned)
   * @public
   */
  async totalCirculatingSupply() {
    return await this.contractWrapper.read("totalSupply", []);
  }
  detectErc721Owned() {
    if (detectContractFeature(this.contractWrapper, "ERC721Enumerable")) {
      return new Erc721Enumerable(this.erc721, this.contractWrapper);
    } else if (detectContractFeature(this.contractWrapper, "ERC721AQueryable")) {
      return new Erc721AQueryable(this.erc721, this.contractWrapper);
    }
    return void 0;
  }
};
var TieredDropPayloadSchema = (() => BaseSignaturePayloadInput.extend({
  tierPriority: z.array(z.string()),
  royaltyRecipient: AddressOrEnsSchema.default(lib_exports.AddressZero),
  royaltyBps: BasisPointsSchema.default(0),
  quantity: BigNumberSchema.default(1)
}))();
var Erc721TieredDrop = class {
  constructor(erc721, contractWrapper, storage) {
    __publicField(this, "featureName", FEATURE_NFT_TIERED_DROP.name);
    __publicField(this, "createBatchWithTier", buildTransactionFunction(async (metadatas, tier, options) => {
      const startFileNumber = await this.erc721.nextTokenIdToMint();
      const batch = await uploadOrExtractURIs(metadatas, this.storage, startFileNumber.toNumber(), options);
      const baseUri = getBaseUriFromBatch(batch);
      return Transaction.fromContractWrapper({
        contractWrapper: this.contractWrapper,
        method: "lazyMint",
        args: [batch.length, baseUri.endsWith("/") ? baseUri : `${baseUri}/`, tier, utils_exports.toUtf8Bytes("")],
        parse: (receipt) => {
          const event = this.contractWrapper.parseLogs("TokensLazyMinted", receipt == null ? void 0 : receipt.logs);
          const startingIndex = event[0].args[1];
          const endingIndex = event[0].args[2];
          const results = [];
          for (let id = startingIndex; id.lte(endingIndex); id = id.add(1)) {
            results.push({
              id,
              receipt,
              data: () => this.erc721.getTokenMetadata(id)
            });
          }
          return results;
        }
      });
    }));
    __publicField(this, "createDelayedRevealBatchWithTier", buildTransactionFunction(async (placeholder, metadatas, password, tier, options) => {
      if (!password) {
        throw new Error("Password is required");
      }
      const placeholderUris = await this.storage.uploadBatch([CommonNFTInput.parse(placeholder)], {
        rewriteFileNames: {
          fileStartNumber: 0
        }
      });
      const placeholderUri = getBaseUriFromBatch(placeholderUris);
      const startFileNumber = await this.erc721.nextTokenIdToMint();
      const uris = await this.storage.uploadBatch(metadatas.map((m) => CommonNFTInput.parse(m)), {
        onProgress: options == null ? void 0 : options.onProgress,
        rewriteFileNames: {
          fileStartNumber: startFileNumber.toNumber()
        }
      });
      const baseUri = getBaseUriFromBatch(uris);
      const baseUriId = await this.contractWrapper.read("getBaseURICount", []);
      const chainId = await this.contractWrapper.getChainID();
      const hashedPassword = utils_exports.solidityKeccak256(["string", "uint256", "uint256", "address"], [password, chainId, baseUriId, this.contractWrapper.address]);
      const encryptedBaseUri = await this.contractWrapper.read("encryptDecrypt", [utils_exports.toUtf8Bytes(baseUri), hashedPassword]);
      const provenanceHash = utils_exports.solidityKeccak256(["bytes", "bytes", "uint256"], [utils_exports.toUtf8Bytes(baseUri), hashedPassword, chainId]);
      const data = utils_exports.defaultAbiCoder.encode(["bytes", "bytes32"], [encryptedBaseUri, provenanceHash]);
      return Transaction.fromContractWrapper({
        contractWrapper: this.contractWrapper,
        method: "lazyMint",
        args: [uris.length, placeholderUri.endsWith("/") ? placeholderUri : `${placeholderUri}/`, tier, data],
        parse: (receipt) => {
          const event = this.contractWrapper.parseLogs("TokensLazyMinted", receipt == null ? void 0 : receipt.logs);
          const startingIndex = event[0].args[1];
          const endingIndex = event[0].args[2];
          const results = [];
          for (let id = startingIndex; id.lte(endingIndex); id = id.add(1)) {
            results.push({
              id,
              receipt,
              data: () => this.erc721.getTokenMetadata(id)
            });
          }
          return results;
        }
      });
    }));
    __publicField(this, "reveal", buildTransactionFunction(async (batchId, password) => {
      if (!password) {
        throw new Error("Password is required");
      }
      const chainId = await this.contractWrapper.getChainID();
      const key = utils_exports.solidityKeccak256(["string", "uint256", "uint256", "address"], [password, chainId, batchId, this.contractWrapper.address]);
      try {
        const decryptedUri = await this.contractWrapper.callStatic().reveal(batchId, key);
        if (!decryptedUri.includes("://") || !decryptedUri.endsWith("/")) {
          throw new Error("invalid password");
        }
      } catch (e) {
        throw new Error("invalid password");
      }
      return Transaction.fromContractWrapper({
        contractWrapper: this.contractWrapper,
        method: "reveal",
        args: [batchId, key]
      });
    }));
    this.erc721 = erc721;
    this.contractWrapper = contractWrapper;
    this.storage = storage;
  }
  async getMetadataInTier(tier) {
    const tiers = await this.contractWrapper.read("getMetadataForAllTiers", []);
    const batches = tiers.find((t) => t.tier === tier);
    if (!batches) {
      throw new Error("Tier not found in contract.");
    }
    const nfts = await Promise.all(batches.ranges.map((range, i) => {
      const nftsInRange = [];
      const baseUri = batches.baseURIs[i];
      for (let j = range.startIdInclusive.toNumber(); j < range.endIdNonInclusive.toNumber(); j++) {
        const uri = baseUri.endsWith("/") ? `${baseUri}${j}` : `${baseUri}/${j}`;
        const metadata = this.storage.downloadJSON(uri);
        nftsInRange.push(metadata);
      }
      return nftsInRange;
    }).flat());
    return nfts;
  }
  async getTokensInTier(tier) {
    const endIndex = await this.contractWrapper.read("getTokensInTierLen", []);
    if (endIndex.eq(0)) {
      return [];
    }
    const ranges = await this.contractWrapper.read("getTokensInTier", [tier, 0, endIndex]);
    const nfts = await Promise.all(ranges.map((range) => {
      const nftsInRange = [];
      for (let i = range.startIdInclusive.toNumber(); i < range.endIdNonInclusive.toNumber(); i++) {
        nftsInRange.push(this.erc721.get(i));
      }
      return nftsInRange;
    }).flat());
    return nfts;
  }
  async generate(payloadToSign) {
    const [payload] = await this.generateBatch([payloadToSign]);
    return payload;
  }
  async generateBatch(payloadsToSign) {
    const parsedPayloads = await Promise.all(payloadsToSign.map((payload) => TieredDropPayloadSchema.parseAsync(payload)));
    const chainId = await this.contractWrapper.getChainID();
    const signer = this.contractWrapper.getSigner();
    invariant(signer, "No signer available");
    return await Promise.all(parsedPayloads.map(async (payload) => {
      const signature = await this.contractWrapper.signTypedData(signer, {
        name: "SignatureAction",
        version: "1",
        chainId,
        verifyingContract: this.contractWrapper.address
      }, {
        GenericRequest
      }, await this.mapPayloadToContractStruct(payload));
      return {
        payload,
        signature: signature.toString()
      };
    }));
  }
  async verify(signedPayload) {
    const message = await this.mapPayloadToContractStruct(signedPayload.payload);
    const verification = await this.contractWrapper.read("verify", [message, signedPayload.signature]);
    return verification[0];
  }
  async claimWithSignature(signedPayload) {
    const message = await this.mapPayloadToContractStruct(signedPayload.payload);
    const normalizedTotalPrice = await normalizePriceValue(this.contractWrapper.getProvider(), signedPayload.payload.price, signedPayload.payload.currencyAddress);
    const overrides = await this.contractWrapper.getCallOverrides();
    await setErc20Allowance(this.contractWrapper, normalizedTotalPrice, signedPayload.payload.currencyAddress, overrides);
    const receipt = await this.contractWrapper.sendTransaction("claimWithSignature", [message, signedPayload.signature], overrides);
    const event = this.contractWrapper.parseLogs("TokensClaimed", receipt == null ? void 0 : receipt.logs);
    const startingIndex = event[0].args.startTokenId;
    const endingIndex = startingIndex.add(event[0].args.quantityClaimed);
    const results = [];
    for (let id = startingIndex; id.lt(endingIndex); id = id.add(1)) {
      results.push({
        id,
        receipt,
        data: () => this.erc721.get(id)
      });
    }
    return results;
  }
  async mapPayloadToContractStruct(payload) {
    const normalizedTotalPrice = await normalizePriceValue(this.contractWrapper.getProvider(), payload.price, payload.currencyAddress);
    const data = utils_exports.defaultAbiCoder.encode(["string[]", "address", "address", "uint256", "address", "uint256", "uint256", "address"], [payload.tierPriority, payload.to, payload.royaltyRecipient, payload.royaltyBps, payload.primarySaleRecipient, payload.quantity, normalizedTotalPrice, payload.currencyAddress]);
    return {
      uid: payload.uid,
      validityStartTimestamp: payload.mintStartTime,
      validityEndTimestamp: payload.mintEndTime,
      data
    };
  }
};
var Erc721Burnable = class {
  constructor(contractWrapper) {
    __publicField(this, "featureName", FEATURE_NFT_BURNABLE.name);
    /**
     * Burn NFTs
     *
     * @remarks Burn NFTs held by the connected wallet
     *
     * @example
     * ```javascript
     * // The token ID of the NFT you want to burn
     * const tokenId = 0;
     *
     * await contract.nft.burn.token(tokenId);
     * ```
     */
    __publicField(this, "token", buildTransactionFunction(async (tokenId) => {
      return Transaction.fromContractWrapper({
        contractWrapper: this.contractWrapper,
        method: "burn",
        args: [tokenId]
      });
    }));
    this.contractWrapper = contractWrapper;
  }
};
function toWei(amount) {
  return utils_exports.parseEther(AmountSchema.parse(amount));
}
var Erc721ClaimableZora = class {
  constructor(erc721, contractWrapper) {
    __publicField(this, "featureName", FEATURE_NFT_CLAIM_ZORA.name);
    /**
     * Claim NFT
     *
     * @remarks Let the specified wallet claim NFTs.
     *
     * @example
     * ```javascript
     * const address = "{{wallet_address}}"; // address of the wallet you want to claim the NFTs
     * const quantity = 1; // how many NFTs you want to claim
     *
     * const tx = await contract.erc721.claimTo(address, quantity);
     * const receipt = tx[0].receipt; // the transaction receipt
     * ```
     *
     * @param destinationAddress - Address you want to send the token to, needs to be the connected wallet address
     * @param quantity - Quantity of the tokens you want to claim
     * @param options - Not applicable
     *
     * @returns - Receipt for the transaction
     */
    __publicField(this, "to", buildTransactionFunction(async (destinationAddress, quantity, options) => {
      var _a;
      const signerAddress = await ((_a = this.contractWrapper.getSigner()) == null ? void 0 : _a.getAddress());
      if (destinationAddress !== signerAddress) {
        throw new Error("Zora Drop: Destination address must match connected wallet address");
      }
      if (options == null ? void 0 : options.pricePerToken) {
        throw new Error("Zora Drop: Custom pricePerToken is not supported. Price is automatically calculated");
      }
      const saleDetails = await this.getSaleDetails();
      const price = saleDetails.publicSalePrice;
      const zoraFee = toWei("0.000777");
      const totalPrice = BigNumber.from(price).add(zoraFee).mul(quantity);
      const tx = Transaction.fromContractWrapper({
        contractWrapper: this.contractWrapper,
        method: "purchase",
        args: [quantity],
        overrides: {
          value: totalPrice
        }
      });
      tx.setParse((receipt) => {
        const event = this.contractWrapper.parseLogs("Sale", receipt == null ? void 0 : receipt.logs);
        const startingIndex = event[0].args.firstPurchasedTokenId;
        const endingIndex = startingIndex.add(quantity);
        const results = [];
        for (let id = startingIndex; id.lt(endingIndex); id = id.add(1)) {
          results.push({
            id,
            receipt,
            data: () => this.erc721.get(id)
          });
        }
        return results;
      });
      return tx;
    }));
    this.erc721 = erc721;
    this.contractWrapper = contractWrapper;
  }
  async getSaleDetails() {
    return this.contractWrapper.read("saleDetails", []);
  }
};
var Erc721LoyaltyCard = class {
  constructor(contractWrapper) {
    __publicField(this, "featureName", FEATURE_NFT_LOYALTY_CARD.name);
    /**
     * Cancel loyalty card NFTs
     *
     * @remarks Cancel loyalty card NFTs held by the connected wallet
     *
     * @example
     * ```javascript
     * // The token ID of the loyalty card you want to cancel
     * const tokenId = 0;
     *
     * await contract.nft.loyaltyCard.cancel(tokenId);
     * ```
     */
    __publicField(this, "cancel", buildTransactionFunction(async (tokenId) => {
      return Transaction.fromContractWrapper({
        contractWrapper: this.contractWrapper,
        method: "cancel",
        args: [tokenId]
      });
    }));
    /**
     * Revoke loyalty card NFTs
     *
     * @remarks Revoke loyalty card NFTs held by some owner.
     *
     * @example
     * ```javascript
     * // The token ID of the loyalty card you want to revoke
     * const tokenId = 0;
     *
     * await contract.nft.loyaltyCard.revoke(tokenId);
     * ```
     */
    __publicField(this, "revoke", buildTransactionFunction(async (tokenId) => {
      return Transaction.fromContractWrapper({
        contractWrapper: this.contractWrapper,
        method: "revoke",
        args: [tokenId]
      });
    }));
    this.contractWrapper = contractWrapper;
  }
};
var Erc721UpdatableMetadata = class {
  constructor(contractWrapper, storage) {
    __publicField(this, "featureName", FEATURE_NFT_UPDATABLE_METADATA.name);
    /**
     * Update the metadata of an NFT
     *
     * @remarks Update the metadata of an NFT
     *
     * @example
     * ```javascript
     * // The token ID of the NFT whose metadata you want to update
     * const tokenId = 0;
     * // The new metadata
     * const metadata = { name: "My NFT", description: "My NFT description""}
     *
     * await contract.nft.metadata.update(tokenId, metadata);
     * ```
     */
    __publicField(this, "update", buildTransactionFunction(async (tokenId, metadata) => {
      const uri = await uploadOrExtractURI(metadata, this.storage);
      return Transaction.fromContractWrapper({
        contractWrapper: this.contractWrapper,
        method: "setTokenURI",
        args: [tokenId, uri]
      });
    }));
    this.contractWrapper = contractWrapper;
    this.storage = storage;
  }
};
var Erc721SharedMetadata = class {
  constructor(contractWrapper, storage) {
    __publicField(this, "featureName", FEATURE_NFT_SHARED_METADATA.name);
    /**
     * Set Shared Metadata
     *
     * @remarks Set the shared metadata for the Open Edition NFTs.
     *
     * @example
     * ```javascript
     * const metadata = {
     *  name: "My NFT",
     *  description: "This is my NFT",
     *  image: ...
     *  animation_url: ...
     * };
     *
     * const contract = await sdk.getContract("{{contract_address}}");
     *
     * const tx = await contract.erc721.sharedMetadata.set(metadata);
     * ```
     *
     * @param metadata - The metadata you want to set for the shared metadata.
     *
     * @returns - Receipt for the transaction
     */
    __publicField(this, "set", buildTransactionFunction(async (metadata) => {
      const parsedMetadata = BasicNFTInput.parse(metadata);
      parsedMetadata.description = this.sanitizeJSONString(parsedMetadata.description);
      const batch = [];
      if (isFileOrBuffer(parsedMetadata.image)) {
        batch.push(this.storage.upload(parsedMetadata.image));
      } else if (typeof parsedMetadata.image === "string") {
        batch.push(Promise.resolve(parsedMetadata.image));
      } else {
        batch.push(Promise.resolve(void 0));
      }
      if (isFileOrBuffer(parsedMetadata.animation_url)) {
        batch.push(this.storage.upload(parsedMetadata.animation_url));
      } else if (typeof parsedMetadata.animation_url === "string") {
        batch.push(Promise.resolve(parsedMetadata.animation_url));
      } else {
        batch.push(Promise.resolve(void 0));
      }
      const [imageUri, animationUri] = await Promise.all(batch);
      return Transaction.fromContractWrapper({
        contractWrapper: this.contractWrapper,
        method: "setSharedMetadata",
        args: [{
          name: `${parsedMetadata.name || ""}`,
          description: parsedMetadata.description || "",
          imageURI: imageUri || "",
          animationURI: animationUri || ""
        }]
      });
    }));
    this.contractWrapper = contractWrapper;
    this.storage = storage;
  }
  /**
   * Get Shared Metadata
   *
   * @remarks Get the shared metadata for the Open Edition NFTs.
   *
   * @example
   * ```javascript
   * const contract = await sdk.getContract("{{contract_address}}");
   *
   * const tx = await contract.erc721.sharedMetadata.get();
   * ```
   *
   * @returns - The shared metadata for the Open Edition NFTs.
   */
  async get() {
    const metadata = await this.contractWrapper.read("sharedMetadata", []);
    if (metadata.every((value) => value === "")) {
      return void 0;
    }
    return {
      name: metadata.name,
      description: metadata.description,
      image: metadata.imageURI,
      animation_url: metadata.animationURI
    };
  }
  sanitizeJSONString(val) {
    if (!val) {
      return val;
    }
    const sanitized = JSON.stringify(val);
    return sanitized.slice(1, sanitized.length - 1);
  }
};
var Erc721WithQuantitySignatureMintable = class {
  constructor(contractWrapper, storage) {
    __publicField(this, "featureName", FEATURE_NFT_SIGNATURE_MINTABLE_V2.name);
    /**
     * Mint a dynamically generated NFT
     *
     * @remarks Mint a dynamic NFT with a previously generated signature.
     *
     * @example
     * ```javascript
     * // see how to craft a payload to sign in the `generate()` documentation
     * const signedPayload = contract.erc721.signature.generate(payload);
     *
     * // now anyone can mint the NFT
     * const tx = contract.erc721.signature.mint(signedPayload);
     * const receipt = tx.receipt; // the mint transaction receipt
     * const mintedId = tx.id; // the id of the NFT minted
     * ```
     * @param signedPayload - the previously generated payload and signature with {@link Erc721WithQuantitySignatureMintable.generate}
     * @twfeature ERC721SignatureMint
     */
    __publicField(this, "mint", buildTransactionFunction(async (signedPayload) => {
      const mintRequest = signedPayload.payload;
      const signature = signedPayload.signature;
      const overrides = await this.contractWrapper.getCallOverrides();
      const parse2 = (receipt) => {
        const t = this.contractWrapper.parseLogs("TokensMintedWithSignature", receipt.logs);
        if (t.length === 0) {
          throw new Error("No MintWithSignature event found");
        }
        const id = t[0].args.tokenIdMinted;
        return {
          id,
          receipt
        };
      };
      if (await this.isLegacyNFTContract()) {
        const message = await this.mapLegacyPayloadToContractStruct(mintRequest);
        const price = message.price;
        await setErc20Allowance(this.contractWrapper, price, mintRequest.currencyAddress, overrides);
        return Transaction.fromContractWrapper({
          contractWrapper: this.contractWrapper,
          method: "mintWithSignature",
          args: [message, signature],
          overrides,
          parse: parse2
        });
      } else {
        const message = await this.mapPayloadToContractStruct(mintRequest);
        const price = message.pricePerToken.mul(message.quantity);
        await setErc20Allowance(this.contractWrapper, price, mintRequest.currencyAddress, overrides);
        return Transaction.fromContractWrapper({
          contractWrapper: this.contractWrapper,
          method: "mintWithSignature",
          args: [message, signature],
          overrides,
          parse: parse2
        });
      }
    }));
    /**
     * Mint any number of dynamically generated NFT at once
     * @remarks Mint multiple dynamic NFTs in one transaction. Note that this is only possible for free mints (cannot batch mints with a price attached to it for security reasons)
     * @param signedPayloads - the array of signed payloads to mint
     * @twfeature ERC721SignatureMint
     */
    __publicField(this, "mintBatch", buildTransactionFunction(async (signedPayloads) => {
      const isLegacyNFTContract = await this.isLegacyNFTContract();
      const contractPayloads = (await Promise.all(signedPayloads.map((s) => isLegacyNFTContract ? this.mapLegacyPayloadToContractStruct(s.payload) : this.mapPayloadToContractStruct(s.payload)))).map((message, index) => {
        const s = signedPayloads[index];
        const signature = s.signature;
        const price = s.payload.price;
        if (BigNumber.from(price).gt(0)) {
          throw new Error("Can only batch free mints. For mints with a price, use regular mint()");
        }
        return {
          message,
          signature
        };
      });
      const contractEncoder = new ContractEncoder(this.contractWrapper);
      const encoded = contractPayloads.map((p) => {
        if (isLegacyNFTContract) {
          return contractEncoder.encode("mintWithSignature", [p.message, p.signature]);
        } else {
          return contractEncoder.encode("mintWithSignature", [p.message, p.signature]);
        }
      });
      if (hasFunction("multicall", this.contractWrapper)) {
        return Transaction.fromContractWrapper({
          contractWrapper: this.contractWrapper,
          method: "multicall",
          args: [encoded],
          parse: (receipt) => {
            const events = this.contractWrapper.parseLogs("TokensMintedWithSignature", receipt.logs);
            if (events.length === 0) {
              throw new Error("No MintWithSignature event found");
            }
            return events.map((log) => ({
              id: log.args.tokenIdMinted,
              receipt
            }));
          }
        });
      } else {
        throw new Error("Multicall not available on this contract!");
      }
    }));
    this.contractWrapper = contractWrapper;
    this.storage = storage;
  }
  /**
   * Verify that a payload is correctly signed
   * @param signedPayload - the payload to verify
   * @twfeature ERC721SignatureMint
   *
   * @example
   * ```javascript
   * const nftMetadata = {
   *   name: "Cool NFT #1",
   *   description: "This is a cool NFT",
   *   image: fs.readFileSync("path/to/image.png"), // This can be an image url or file
   * };
   *
   * const startTime = new Date();
   * const endTime = new Date(Date.now() + 60 * 60 * 24 * 1000);
   * const payload = {
   *   metadata: nftMetadata, // The NFT to mint
   *   to: {{wallet_address}}, // Who will receive the NFT
   *   quantity: 2, // the quantity of NFTs to mint
   *   price: 0.5, // the price per NFT
   *   currencyAddress: NATIVE_TOKEN_ADDRESS, // the currency to pay with
   *   mintStartTime: startTime, // can mint anytime from now
   *   mintEndTime: endTime, // to 24h from now
   *   royaltyRecipient: "0x...", // custom royalty recipient for this NFT
   *   royaltyBps: 100, // custom royalty fees for this NFT (in bps)
   *   primarySaleRecipient: "0x...", // custom sale recipient for this NFT
   * };
   *
   * const signedPayload = await contract.erc721.signature.generate(payload);
   * // Now you can verify if the signed payload is valid
   * const isValid = await contract.erc721.signature.verify(signedPayload);
   * ```
   */
  async verify(signedPayload) {
    const isLegacyNFTContract = await this.isLegacyNFTContract();
    const mintRequest = signedPayload.payload;
    const signature = signedPayload.signature;
    let message;
    let verification;
    if (isLegacyNFTContract) {
      message = await this.mapLegacyPayloadToContractStruct(mintRequest);
      verification = await this.contractWrapper.read("verify", [message, signature]);
    } else {
      message = await this.mapPayloadToContractStruct(mintRequest);
      verification = await this.contractWrapper.read("verify", [message, signature]);
    }
    return verification[0];
  }
  /**
   * Generate a signature that can be used to mint a dynamic NFT
   *
   * @remarks Takes in an NFT and some information about how it can be minted, uploads the metadata and signs it with your private key. The generated signature can then be used to mint an NFT using the exact payload and signature generated.
   *
   * @example
   * ```javascript
   * const nftMetadata = {
   *   name: "Cool NFT #1",
   *   description: "This is a cool NFT",
   *   image: fs.readFileSync("path/to/image.png"), // This can be an image url or file
   * };
   *
   * const startTime = new Date();
   * const endTime = new Date(Date.now() + 60 * 60 * 24 * 1000);
   * const payload = {
   *   metadata: nftMetadata, // The NFT to mint
   *   to: {{wallet_address}}, // Who will receive the NFT
   *   quantity: 2, // the quantity of NFTs to mint
   *   price: 0.5, // the price per NFT
   *   currencyAddress: NATIVE_TOKEN_ADDRESS, // the currency to pay with
   *   mintStartTime: startTime, // can mint anytime from now
   *   mintEndTime: endTime, // to 24h from now
   *   royaltyRecipient: "0x...", // custom royalty recipient for this NFT
   *   royaltyBps: 100, // custom royalty fees for this NFT (in bps)
   *   primarySaleRecipient: "0x...", // custom sale recipient for this NFT
   * };
   *
   * const signedPayload = await contract.erc721.signature.generate(payload);
   * // now anyone can use these to mint the NFT using `contract.erc721.signature.mint(signedPayload)`
   * ```
   * @param mintRequest - the payload to sign
   * @returns the signed payload and the corresponding signature
   * @twfeature ERC721SignatureMint
   */
  async generate(mintRequest) {
    return (await this.generateBatch([mintRequest]))[0];
  }
  /**
   * Genrate a batch of signatures that can be used to mint many dynamic NFTs.
   *
   * @remarks See {@link Erc721WithQuantitySignatureMintable.generate}
   *
   * @param payloadsToSign - the payloads to sign
   * @returns an array of payloads and signatures
   * @twfeature ERC721SignatureMint
   */
  async generateBatch(payloadsToSign) {
    const isLegacyNFTContract = await this.isLegacyNFTContract();
    const parsedRequests = await Promise.all(payloadsToSign.map((m) => Signature721WithQuantityInput.parseAsync(m)));
    const metadatas = parsedRequests.map((r) => r.metadata);
    const uris = await uploadOrExtractURIs(metadatas, this.storage);
    const chainId = await this.contractWrapper.getChainID();
    const signer = this.contractWrapper.getSigner();
    invariant(signer, "No signer available");
    return await Promise.all(parsedRequests.map(async (m, i) => {
      const uri = uris[i];
      const finalPayload = await Signature721WithQuantityOutput.parseAsync({
        ...m,
        uri
      });
      let signature;
      if (isLegacyNFTContract) {
        signature = await this.contractWrapper.signTypedData(signer, {
          name: "TokenERC721",
          version: "1",
          chainId,
          verifyingContract: this.contractWrapper.address
        }, {
          MintRequest: MintRequest721
        }, await this.mapLegacyPayloadToContractStruct(finalPayload));
      } else {
        signature = await this.contractWrapper.signTypedData(
          signer,
          {
            name: "SignatureMintERC721",
            version: "1",
            chainId,
            verifyingContract: await this.contractWrapper.address
          },
          {
            MintRequest: MintRequest721withQuantity
          },
          // TYPEHASH
          await this.mapPayloadToContractStruct(finalPayload)
        );
      }
      return {
        payload: finalPayload,
        signature: signature.toString()
      };
    }));
  }
  /** ******************************
   * PRIVATE FUNCTIONS
   *******************************/
  /**
   * Maps a payload to the format expected by the contract
   *
   * @internal
   *
   * @param mintRequest - The payload to map.
   * @returns - The mapped payload.
   */
  async mapPayloadToContractStruct(mintRequest) {
    const normalizedPricePerToken = await normalizePriceValue(this.contractWrapper.getProvider(), mintRequest.price, mintRequest.currencyAddress);
    return {
      to: mintRequest.to,
      royaltyRecipient: mintRequest.royaltyRecipient,
      royaltyBps: mintRequest.royaltyBps,
      primarySaleRecipient: mintRequest.primarySaleRecipient,
      uri: mintRequest.uri,
      quantity: mintRequest.quantity,
      pricePerToken: normalizedPricePerToken,
      currency: mintRequest.currencyAddress,
      validityStartTimestamp: mintRequest.mintStartTime,
      validityEndTimestamp: mintRequest.mintEndTime,
      uid: mintRequest.uid
    };
  }
  async mapLegacyPayloadToContractStruct(mintRequest) {
    const normalizedPricePerToken = await normalizePriceValue(this.contractWrapper.getProvider(), mintRequest.price, mintRequest.currencyAddress);
    return {
      to: mintRequest.to,
      price: normalizedPricePerToken,
      uri: mintRequest.uri,
      currency: mintRequest.currencyAddress,
      validityEndTimestamp: mintRequest.mintEndTime,
      validityStartTimestamp: mintRequest.mintStartTime,
      uid: mintRequest.uid,
      royaltyRecipient: mintRequest.royaltyRecipient,
      royaltyBps: mintRequest.royaltyBps,
      primarySaleRecipient: mintRequest.primarySaleRecipient
    };
  }
  async isLegacyNFTContract() {
    return detectContractFeature(this.contractWrapper, "ERC721SignatureMintV1");
  }
};
var Erc721 = class {
  constructor(contractWrapper, storage, chainId) {
    __publicField(this, "featureName", FEATURE_NFT.name);
    /**
     * Transfer an NFT
     *
     * @remarks Transfer an NFT from the connected wallet to another wallet.
     *
     * @example
     * ```javascript
     * const walletAddress = "{{wallet_address}}";
     * const tokenId = 0;
     * await contract.erc721.transfer(walletAddress, tokenId);
     * ```
     * @twfeature ERC721
     */
    __publicField(this, "transfer", buildTransactionFunction(async (to, tokenId) => {
      const [from, _to] = await Promise.all([this.contractWrapper.getSignerAddress(), resolveAddress(to)]);
      return Transaction.fromContractWrapper({
        contractWrapper: this.contractWrapper,
        method: "transferFrom(address,address,uint256)",
        args: [from, _to, tokenId]
      });
    }));
    /**
     * Transfer an NFT from a specific wallet
     *
     * @remarks Transfer an NFT from the given wallet to another wallet.
     *
     * @example
     * ```javascript
     * const fromWalletAddress = "{{wallet_address}}";
     * const toWalletAddress = "{{wallet_address}}";
     * const tokenId = 0;
     * await contract.erc721.transferFrom(fromWalletAddress, toWalletAddress, tokenId);
     * ```
     * @twfeature ERC721
     */
    __publicField(this, "transferFrom", buildTransactionFunction(async (from, to, tokenId) => {
      const [fromAddress, toAddress] = await Promise.all([resolveAddress(from), resolveAddress(to)]);
      return Transaction.fromContractWrapper({
        contractWrapper: this.contractWrapper,
        method: "transferFrom(address,address,uint256)",
        args: [fromAddress, toAddress, tokenId]
      });
    }));
    /**
     * Set approval for all NFTs
     * @remarks Approve or remove operator as an operator for the caller. Operators can call transferFrom or safeTransferFrom for any token owned by the caller.
     * @example
     * ```javascript
     * const operator = "{{wallet_address}}";
     * await contract.erc721.setApprovalForAll(operator, true);
     * ```
     * @param operator - the operator's address
     * @param approved - whether to approve or remove
     * @twfeature ERC721
     */
    __publicField(this, "setApprovalForAll", buildTransactionFunction(async (operator, approved) => {
      return Transaction.fromContractWrapper({
        contractWrapper: this.contractWrapper,
        method: "setApprovalForAll",
        args: [await resolveAddress(operator), approved]
      });
    }));
    /**
     * Set approval for a single NFT
     * @remarks Approve an operator for the NFT owner. Operators can call transferFrom or safeTransferFrom for the specified token.
     * @example
     * ```javascript
     * const operator = "{{wallet_address}}";
     * const tokenId = 0;
     * await contract.erc721.setApprovalForToken(operator, tokenId);
     * ```
     * @param operator - the operator's address
     * @param tokenId - the tokenId to give approval for
     *
     * @internal
     */
    __publicField(this, "setApprovalForToken", buildTransactionFunction(async (operator, tokenId) => {
      return Transaction.fromContractWrapper({
        contractWrapper: this.contractWrapper,
        method: "approve",
        args: [await resolveAddress(operator), tokenId]
      });
    }));
    ////// ERC721 Mintable Extension //////
    /**
     * Mint an NFT
     *
     * @remarks Mint an NFT to the connected wallet.
     *
     * @example
     * ```javascript
     * // Custom metadata of the NFT, note that you can fully customize this metadata with other properties.
     * const metadata = {
     *   name: "Cool NFT",
     *   description: "This is a cool NFT",
     *   image: fs.readFileSync("path/to/image.png"), // This can be an image url or file
     * };
     *
     * const tx = await contract.erc721.mint(metadata);
     * const receipt = tx.receipt; // the transaction receipt
     * const tokenId = tx.id; // the id of the NFT minted
     * const nft = await tx.data(); // (optional) fetch details of minted NFT
     * ```
     * @twfeature ERC721Mintable
     */
    __publicField(this, "mint", buildTransactionFunction(async (metadata) => {
      return this.mintTo.prepare(await this.contractWrapper.getSignerAddress(), metadata);
    }));
    /**
     * Mint an NFT to a specific wallet
     *
     * @remarks Mint a unique NFT to a specified wallet.
     *
     * @example
     * ```javascript
     * // Address of the wallet you want to mint the NFT to
     * const walletAddress = "{{wallet_address}}";
     *
     * // Custom metadata of the NFT, note that you can fully customize this metadata with other properties.
     * const metadata = {
     *   name: "Cool NFT",
     *   description: "This is a cool NFT",
     *   image: fs.readFileSync("path/to/image.png"), // This can be an image url or file
     * };
     *
     * const tx = await contract.erc721.mintTo(walletAddress, metadata);
     * const receipt = tx.receipt; // the transaction receipt
     * const tokenId = tx.id; // the id of the NFT minted
     * const nft = await tx.data(); // (optional) fetch details of minted NFT
     * ```
     * @twfeature ERC721Mintable
     */
    __publicField(this, "mintTo", buildTransactionFunction(async (receiver, metadata) => {
      return assertEnabled(this.mintable, FEATURE_NFT_MINTABLE).to.prepare(receiver, metadata);
    }));
    ////// ERC721 Batch Mintable Extension //////
    /**
     * Mint many NFTs
     *
     * @remarks Mint many unique NFTs at once to the connected wallet
     *
     * @example
     * ```javascript*
     * // Custom metadata of the NFTs you want to mint.
     * const metadatas = [{
     *   name: "Cool NFT #1",
     *   description: "This is a cool NFT",
     *   image: fs.readFileSync("path/to/image.png"), // This can be an image url or file
     * }, {
     *   name: "Cool NFT #2",
     *   description: "This is a cool NFT",
     *   image: fs.readFileSync("path/to/other/image.png"),
     * }];
     *
     * const tx = await contract.erc721.mintBatch(metadatas);
     * const receipt = tx[0].receipt; // same transaction receipt for all minted NFTs
     * const firstTokenId = tx[0].id; // token id of the first minted NFT
     * const firstNFT = await tx[0].data(); // (optional) fetch details of the first minted NFT
     * ```
     * @twfeature ERC721BatchMintable
     */
    __publicField(this, "mintBatch", buildTransactionFunction(async (metadatas) => {
      return this.mintBatchTo.prepare(await this.contractWrapper.getSignerAddress(), metadatas);
    }));
    /**
     * Mint many NFTs to a specific wallet
     *
     * @remarks Mint many unique NFTs at once to a specified wallet.
     *
     * @example
     * ```javascript
     * // Address of the wallet you want to mint the NFT to
     * const walletAddress = "{{wallet_address}}";
     *
     * // Custom metadata of the NFTs you want to mint.
     * const metadatas = [{
     *   name: "Cool NFT #1",
     *   description: "This is a cool NFT",
     *   image: fs.readFileSync("path/to/image.png"), // This can be an image url or file
     * }, {
     *   name: "Cool NFT #2",
     *   description: "This is a cool NFT",
     *   image: fs.readFileSync("path/to/other/image.png"),
     * }];
     *
     * const tx = await contract.erc721.mintBatchTo(walletAddress, metadatas);
     * const receipt = tx[0].receipt; // same transaction receipt for all minted NFTs
     * const firstTokenId = tx[0].id; // token id of the first minted NFT
     * const firstNFT = await tx[0].data(); // (optional) fetch details of the first minted NFT
     * ```
     * @twfeature ERC721BatchMintable
     */
    __publicField(this, "mintBatchTo", buildTransactionFunction(async (receiver, metadatas) => {
      var _a;
      return assertEnabled((_a = this.mintable) == null ? void 0 : _a.batch, FEATURE_NFT_BATCH_MINTABLE).to.prepare(receiver, metadatas);
    }));
    ////// ERC721 Burnable Extension //////
    /**
     * Burn a single NFT
     * @param tokenId - the token Id to burn
     *
     * @example
     * ```javascript
     * const result = await contract.erc721.burn(tokenId);
     * ```
     * @twfeature ERC721Burnable
     */
    __publicField(this, "burn", buildTransactionFunction(async (tokenId) => {
      return assertEnabled(this.burnable, FEATURE_NFT_BURNABLE).token.prepare(tokenId);
    }));
    ////// ERC721 Loyalty Card Extension //////
    /**
     * Cancel loyalty card NFTs
     *
     * @remarks Cancel loyalty card NFTs held by the connected wallet
     *
     * @example
     * ```javascript
     * // The token ID of the loyalty card you want to cancel
     * const tokenId = 0;
     *
     * const result = await contract.erc721.cancel(tokenId);
     * ```
     * @twfeature ERC721LoyaltyCard
     */
    __publicField(this, "cancel", buildTransactionFunction(async (tokenId) => {
      return assertEnabled(this.loyaltyCard, FEATURE_NFT_LOYALTY_CARD).cancel.prepare(tokenId);
    }));
    /**
     * Revoke loyalty card NFTs
     *
     * @remarks Revoke loyalty card NFTs held by some owner.
     *
     * @example
     * ```javascript
     * // The token ID of the loyalty card you want to revoke
     * const tokenId = 0;
     *
     * const result = await contract.erc721.revoke(tokenId);
     * ```
     * @twfeature ERC721LoyaltyCard
     */
    __publicField(this, "revoke", buildTransactionFunction(async (tokenId) => {
      return assertEnabled(this.loyaltyCard, FEATURE_NFT_LOYALTY_CARD).revoke.prepare(tokenId);
    }));
    ////// ERC721 LazyMint Extension //////
    /**
     * Lazy mint NFTs
     *
     * @remarks Create batch allows you to create a batch of many unique NFTs in one transaction.
     *
     * @example
     * ```javascript
     * // Custom metadata of the NFTs to create
     * const metadatas = [{
     *   name: "Cool NFT",
     *   description: "This is a cool NFT",
     *   image: fs.readFileSync("path/to/image.png"), // This can be an image url or file
     * }, {
     *   name: "Cool NFT",
     *   description: "This is a cool NFT",
     *   image: fs.readFileSync("path/to/image.png"),
     * }];
     *
     * const results = await contract.erc721.lazyMint(metadatas); // uploads and creates the NFTs on chain
     * const firstTokenId = results[0].id; // token id of the first created NFT
     * const firstNFT = await results[0].data(); // (optional) fetch details of the first created NFT
     * ```
     *
     * @param metadatas - The metadata to include in the batch.
     * @param options - optional upload progress callback
     * @twfeature ERC721LazyMintable
     */
    __publicField(this, "lazyMint", buildTransactionFunction(async (metadatas, options) => {
      return assertEnabled(this.lazyMintable, FEATURE_NFT_LAZY_MINTABLE).lazyMint.prepare(metadatas, options);
    }));
    ////// ERC721 Metadata Extension //////
    /**
     * Update the metadata of an NFT
     *
     * @remarks Update the metadata of an NFT
     *
     * @example
     * ```javascript
     * // The token ID of the NFT whose metadata you want to update
     * const tokenId = 0;
     * // The new metadata
     * const metadata = { name: "My NFT", description: "My NFT description""}
     *
     * await contract.erc721.update(tokenId, metadata);
     * ```
     * @twfeature ERC721UpdatableMetadata
     */
    __publicField(this, "update", buildTransactionFunction(async (tokenId, metadata) => {
      return assertEnabled(this.updatableMetadata, FEATURE_NFT_UPDATABLE_METADATA).update.prepare(tokenId, metadata);
    }));
    ////// ERC721 Claimable Extension //////
    /**
     * Claim NFTs
     *
     * @remarks Let the specified wallet claim NFTs.
     *
     * @example
     * ```javascript
     * const quantity = 1; // how many unique NFTs you want to claim
     *
     * const tx = await contract.erc721.claim(quantity);
     * const receipt = tx.receipt; // the transaction receipt
     * const claimedTokenId = tx.id; // the id of the NFT claimed
     * const claimedNFT = await tx.data(); // (optional) get the claimed NFT metadata
     * ```
     *
     * @param quantity - Quantity of the tokens you want to claim
     *
     * @returns - an array of results containing the id of the token claimed, the transaction receipt and a promise to optionally fetch the nft metadata
     * @twfeature ERC721ClaimCustom | ERC721ClaimPhasesV2 | ERC721ClaimPhasesV1 | ERC721ClaimConditionsV2 | ERC721ClaimConditionsV1 | ERC721ClaimZora
     */
    __publicField(this, "claim", buildTransactionFunction(async (quantity, options) => {
      return this.claimTo.prepare(await this.contractWrapper.getSignerAddress(), quantity, options);
    }));
    /**
     * Claim NFTs to a specific wallet
     *
     * @remarks Let the specified wallet claim NFTs.
     *
     * @example
     * ```javascript
     * const address = "{{wallet_address}}"; // address of the wallet you want to claim the NFTs
     * const quantity = 1; // how many unique NFTs you want to claim
     *
     * const tx = await contract.erc721.claimTo(address, quantity);
     * const receipt = tx.receipt; // the transaction receipt
     * const claimedTokenId = tx.id; // the id of the NFT claimed
     * const claimedNFT = await tx.data(); // (optional) get the claimed NFT metadata
     * ```
     *
     * @param destinationAddress - Address you want to send the token to
     * @param quantity - Quantity of the tokens you want to claim
     * @param options
     * @returns - an array of results containing the id of the token claimed, the transaction receipt and a promise to optionally fetch the nft metadata
     * @twfeature ERC721ClaimCustom | ERC721ClaimPhasesV2 | ERC721ClaimPhasesV1 | ERC721ClaimConditionsV2 | ERC721ClaimConditionsV1 | ERC721ClaimZora
     */
    __publicField(this, "claimTo", buildTransactionFunction(async (destinationAddress, quantity, options) => {
      const claimWithConditions = this.claimWithConditions;
      const claim = this.claimCustom;
      const claimZora = this.claimZora;
      if (claimWithConditions) {
        return claimWithConditions.to.prepare(destinationAddress, quantity, options);
      }
      if (claim) {
        return claim.to.prepare(destinationAddress, quantity, options);
      }
      if (claimZora) {
        return claimZora.to.prepare(destinationAddress, quantity, options);
      }
      throw new ExtensionNotImplementedError(FEATURE_NFT_CLAIM_CUSTOM);
    }));
    this.contractWrapper = contractWrapper;
    this.storage = storage;
    this.query = this.detectErc721Enumerable();
    this.mintable = this.detectErc721Mintable();
    this.burnable = this.detectErc721Burnable();
    this.lazyMintable = this.detectErc721LazyMintable();
    this.tieredDropable = this.detectErc721TieredDrop();
    this.signatureMintable = this.detectErc721SignatureMintable();
    this.claimWithConditions = this.detectErc721ClaimableWithConditions();
    this.claimCustom = this.detectErc721Claimable();
    this.claimZora = this.detectErc721ClaimableZora();
    this.erc721SharedMetadata = this.detectErc721SharedMetadata();
    this.loyaltyCard = this.detectErc721LoyaltyCard();
    this.updatableMetadata = this.detectErc721UpdatableMetadata();
    this._chainId = chainId;
  }
  get chainId() {
    return this._chainId;
  }
  /**
   * @internal
   */
  onNetworkUpdated(network) {
    this.contractWrapper.updateSignerOrProvider(network);
  }
  getAddress() {
    return this.contractWrapper.address;
  }
  ////// Standard ERC721 Extension //////
  /**
   * Get a single NFT
   *
   * @example
   * ```javascript
   * const tokenId = 0;
   * const nft = await contract.erc721.get(tokenId);
   * ```
   * @param tokenId - the tokenId of the NFT to retrieve
   * @returns The NFT metadata
   * @twfeature ERC721
   */
  async get(tokenId) {
    const [owner, metadata] = await Promise.all([this.ownerOf(tokenId).catch(() => lib_exports.AddressZero), this.getTokenMetadata(tokenId).catch(() => ({
      id: tokenId.toString(),
      uri: "",
      ...FALLBACK_METADATA
    }))]);
    return {
      owner,
      metadata,
      type: "ERC721",
      supply: "1"
    };
  }
  /**
   * Get the current owner of an NFT
   *
   * @param tokenId - the tokenId of the NFT
   * @returns the address of the owner
   * @twfeature ERC721
   */
  async ownerOf(tokenId) {
    return await this.contractWrapper.read("ownerOf", [tokenId]);
  }
  /**
   * Get NFT balance of a specific wallet
   *
   * @remarks Get a wallets NFT balance (number of NFTs in this contract owned by the wallet).
   *
   * @example
   * ```javascript
   * const walletAddress = "{{wallet_address}}";
   * const balance = await contract.erc721.balanceOf(walletAddress);
   * console.log(balance);
   * ```
   * @twfeature ERC721
   */
  async balanceOf(address) {
    return await this.contractWrapper.read("balanceOf", [await resolveAddress(address)]);
  }
  /**
   * Get NFT balance for the currently connected wallet
   */
  async balance() {
    return await this.balanceOf(await this.contractWrapper.getSignerAddress());
  }
  /**
   * Get whether this wallet has approved transfers from the given operator
   * @param address - the wallet address
   * @param operator - the operator address
   */
  async isApproved(address, operator) {
    const [_address, _operator] = await Promise.all([resolveAddress(address), resolveAddress(operator)]);
    return await this.contractWrapper.read("isApprovedForAll", [_address, _operator]);
  }
  ////// ERC721 Supply Extension //////
  /**
   * Get all NFTs
   *
   * @remarks Get all the data associated with every NFT in this contract.
   *
   * By default, returns the first 100 NFTs, use queryParams to fetch more.
   *
   * @example
   * ```javascript
   * const nfts = await contract.erc721.getAll();
   * console.log(nfts);
   * ```
   * @param queryParams - optional filtering to only fetch a subset of results.
   * @returns The NFT metadata for all NFTs queried.
   * @twfeature ERC721Supply | ERC721Enumerable
   */
  async getAll(queryParams) {
    return assertEnabled(this.query, FEATURE_NFT_SUPPLY).all(queryParams);
  }
  /**
   * Get all NFT owners
   * @example
   * ```javascript
   * const owners = await contract.erc721.getAllOwners();
   * console.log(owners);
   * ```
   * @returns an array of token ids and owners
   * @twfeature ERC721Supply | ERC721Enumerable
   */
  async getAllOwners() {
    return assertEnabled(this.query, FEATURE_NFT_SUPPLY).allOwners();
  }
  /**
   * Get the total number of NFTs minted
   * @remarks This returns the total number of NFTs minted in this contract, **not** the total supply of a given token.
   * @example
   * ```javascript
   * const count = await contract.erc721.totalCount();
   * console.log(count);
   * ```
   *
   * @returns the total number of NFTs minted in this contract
   * @public
   */
  async totalCount() {
    return this.nextTokenIdToMint();
  }
  /**
   * Get the total count NFTs minted in this contract
   * @twfeature ERC721Supply | ERC721Enumerable
   */
  async totalCirculatingSupply() {
    return assertEnabled(this.query, FEATURE_NFT_SUPPLY).totalCirculatingSupply();
  }
  ////// ERC721 Enumerable Extension //////
  /**
   * Get all NFTs owned by a specific wallet
   *
   * @remarks Get all the data associated with the NFTs owned by a specific wallet.
   *
   * @example
   * ```javascript
   * // Address of the wallet to get the NFTs of
   * const address = "{{wallet_address}}";
   * const nfts = await contract.erc721.getOwned(address);
   * console.log(nfts);
   * ```
   * @param walletAddress - the wallet address to query, defaults to the connected wallet
   * @returns The NFT metadata for all NFTs in the contract.
   * @twfeature ERC721Supply | ERC721Enumerable
   */
  async getOwned(walletAddress) {
    var _a;
    if (walletAddress) {
      walletAddress = await resolveAddress(walletAddress);
    }
    if ((_a = this.query) == null ? void 0 : _a.owned) {
      return this.query.owned.all(walletAddress);
    } else {
      const [address, allOwners] = await Promise.all([walletAddress || this.contractWrapper.getSignerAddress(), this.getAllOwners()]);
      return await Promise.all((allOwners || []).filter((i) => {
        var _a2;
        return (address == null ? void 0 : address.toLowerCase()) === ((_a2 = i.owner) == null ? void 0 : _a2.toLowerCase());
      }).map((i) => this.get(i.tokenId)));
    }
  }
  /**
   * Get all token ids of NFTs owned by a specific wallet.
   * @param walletAddress - the wallet address to query, defaults to the connected wallet
   */
  async getOwnedTokenIds(walletAddress) {
    var _a;
    if (walletAddress) {
      walletAddress = await resolveAddress(walletAddress);
    }
    if ((_a = this.query) == null ? void 0 : _a.owned) {
      return this.query.owned.tokenIds(walletAddress);
    } else {
      const [address, allOwners] = await Promise.all([walletAddress || this.contractWrapper.getSignerAddress(), this.getAllOwners()]);
      return (allOwners || []).filter((i) => {
        var _a2;
        return (address == null ? void 0 : address.toLowerCase()) === ((_a2 = i.owner) == null ? void 0 : _a2.toLowerCase());
      }).map((i) => BigNumber.from(i.tokenId));
    }
  }
  /**
   * Construct a mint transaction without executing it.
   * This is useful for estimating the gas cost of a mint transaction, overriding transaction options and having fine grained control over the transaction execution.
   * @param receiver - Address you want to send the token to
   * @param metadata - The metadata of the NFT you want to mint
   *
   * @deprecated Use `contract.erc721.mint.prepare(...args)` instead
   * @twfeature ERC721Mintable
   */
  async getMintTransaction(receiver, metadata) {
    return this.mintTo.prepare(receiver, metadata);
  }
  /**
   * Construct a claim transaction without executing it.
   * This is useful for estimating the gas cost of a claim transaction, overriding transaction options and having fine grained control over the transaction execution.
   * @param destinationAddress
   * @param quantity
   * @param options
   *
   * @deprecated Use `contract.erc721.claim.prepare(...args)` instead
   * @twfeature ERC721ClaimCustom | ERC721ClaimPhasesV2 | ERC721ClaimPhasesV1 | ERC721ClaimConditionsV2 | ERC721ClaimConditionsV1
   */
  async getClaimTransaction(destinationAddress, quantity, options) {
    const claimWithConditions = this.claimWithConditions;
    const claim = this.claimCustom;
    if (claimWithConditions) {
      return claimWithConditions.conditions.getClaimTransaction(destinationAddress, quantity, options);
    }
    if (claim) {
      return claim.getClaimTransaction(destinationAddress, quantity, options);
    }
    throw new ExtensionNotImplementedError(FEATURE_NFT_CLAIM_CUSTOM);
  }
  /**
   * Get the claimed supply
   *
   * @remarks Get the number of claimed NFTs in this Drop.
   *
   * * @example
   * ```javascript
   * const claimedNFTCount = await contract.totalClaimedSupply();
   * console.log(`NFTs claimed: ${claimedNFTCount}`);
   * ```
   * @returns the unclaimed supply
   * @twfeature ERC721ClaimCustom | ERC721ClaimPhasesV2 | ERC721ClaimPhasesV1 | ERC721ClaimConditionsV2 | ERC721ClaimConditionsV1
   */
  async totalClaimedSupply() {
    const contract = this.contractWrapper;
    if (hasFunction("totalMinted", contract)) {
      return this.contractWrapper.read("totalMinted", []);
    }
    if (hasFunction("nextTokenIdToClaim", contract)) {
      return this.contractWrapper.read("nextTokenIdToClaim", []);
    }
    throw new Error("No function found on contract to get total claimed supply");
  }
  /**
   * Get the unclaimed supply
   *
   * @remarks Get the number of unclaimed NFTs in this Drop.
   *
   * * @example
   * ```javascript
   * const unclaimedNFTCount = await contract.totalUnclaimedSupply();
   * console.log(`NFTs left to claim: ${unclaimedNFTCount}`);
   * ```
   * @returns the unclaimed supply
   * @twfeature ERC721ClaimCustom | ERC721ClaimPhasesV2 | ERC721ClaimPhasesV1 | ERC721ClaimConditionsV2 | ERC721ClaimConditionsV1
   */
  async totalUnclaimedSupply() {
    const [nextTokenIdToMint, totalClaimedSupply] = await Promise.all([this.nextTokenIdToMint(), this.totalClaimedSupply()]);
    return nextTokenIdToMint.sub(totalClaimedSupply);
  }
  /**
   * Configure claim conditions
   * @remarks Define who can claim NFTs in the collection, when and how many.
   * @example
   * ```javascript
   * const presaleStartTime = new Date();
   * const publicSaleStartTime = new Date(Date.now() + 60 * 60 * 24 * 1000);
   * const claimConditions = [
   *   {
   *     startTime: presaleStartTime, // start the presale now
   *     maxClaimableSupply: 2, // limit how many mints for this presale
   *     price: 0.01, // presale price
   *     snapshot: ['0x...', '0x...'], // limit minting to only certain addresses
   *   },
   *   {
   *     startTime: publicSaleStartTime, // 24h after presale, start public sale
   *     price: 0.08, // public sale price
   *   }
   * ]);
   * await contract.erc721.claimConditions.set(claimConditions);
   * ```
   * @twfeature ERC721ClaimPhasesV2 | ERC721ClaimPhasesV1 | ERC721ClaimConditionsV2 | ERC721ClaimConditionsV1
   */
  get claimConditions() {
    return assertEnabled(this.claimWithConditions, FEATURE_NFT_CLAIM_CONDITIONS_V2).conditions;
  }
  ////// ERC721 Tiered Drop Extension //////
  /**
   * Tiered Drop
   * @remarks Drop lazy minted NFTs using a tiered drop mechanism.
   * @twfeature ERC721TieredDrop
   */
  get tieredDrop() {
    return assertEnabled(this.tieredDropable, FEATURE_NFT_TIERED_DROP);
  }
  ////// ERC721 SignatureMint Extension //////
  /**
   * Mint with signature
   * @remarks Generate dynamic NFTs with your own signature, and let others mint them using that signature.
   * @example
   * ```javascript
   * // see how to craft a payload to sign in the `contract.erc721.signature.generate()` documentation
   * const signedPayload = await contract.erc721.signature.generate(payload);
   *
   * // now anyone can mint the NFT
   * const tx = await contract.erc721.signature.mint(signedPayload);
   * const receipt = tx.receipt; // the mint transaction receipt
   * const mintedId = tx.id; // the id of the NFT minted
   * ```
   * @twfeature ERC721SignatureMintV1 | ERC721SignatureMintV2
   */
  get signature() {
    return assertEnabled(this.signatureMintable, FEATURE_NFT_SIGNATURE_MINTABLE_V2);
  }
  ////// ERC721 DelayedReveal Extension //////
  /**
   * Mint delayed reveal NFTs
   * @remarks Create a batch of encrypted NFTs that can be revealed at a later time.
   * @example
   * ```javascript
   * // the real NFTs, these will be encrypted until you reveal them
   * const realNFTs = [{
   *   name: "Common NFT #1",
   *   description: "Common NFT, one of many.",
   *   image: fs.readFileSync("path/to/image.png"),
   * }, {
   *   name: "Super Rare NFT #2",
   *   description: "You got a Super Rare NFT!",
   *   image: fs.readFileSync("path/to/image.png"),
   * }];
   * // A placeholder NFT that people will get immediately in their wallet, and will be converted to the real NFT at reveal time
   * const placeholderNFT = {
   *   name: "Hidden NFT",
   *   description: "Will be revealed next week!"
   * };
   * // Create and encrypt the NFTs
   * await contract.erc721.revealer.createDelayedRevealBatch(
   *   placeholderNFT,
   *   realNFTs,
   *   "my secret password",
   * );
   * // Whenever you're ready, reveal your NFTs at any time
   * const batchId = 0; // the batch to reveal
   * await contract.erc721.revealer.reveal(batchId, "my secret password");
   * ```
   * @twfeature ERC721Revealable
   */
  get revealer() {
    var _a;
    return assertEnabled((_a = this.lazyMintable) == null ? void 0 : _a.revealer, FEATURE_NFT_REVEALABLE);
  }
  ////// ERC721 Shared Metadata Extension (Open Edition) //////
  /**
   * Set shared metadata for all NFTs
   * @remarks Set shared metadata for all NFTs in the collection. (Open Edition)
   * @example
   * ```javascript
   * // defiine the metadata
   * const metadata = {
   *  name: "Shared Metadata",
   *  description: "Every NFT in this collection will share this metadata."
   * };
   *
   *
   * const tx = contract.erc721.sharedMetadata.set(metadata);
   * ```
   * @twfeature ERC721SharedMetadata
   */
  get sharedMetadata() {
    return assertEnabled(this.erc721SharedMetadata, FEATURE_NFT_SHARED_METADATA);
  }
  /** ******************************
   * PRIVATE FUNCTIONS
   *******************************/
  /**
   * @internal
   */
  async getTokenMetadata(tokenId) {
    const tokenUri = await this.contractWrapper.read("tokenURI", [tokenId]);
    if (!tokenUri) {
      throw new NotFoundError();
    }
    return fetchTokenMetadata(tokenId, tokenUri, this.storage);
  }
  /**
   * Return the next available token ID to mint
   * @internal
   */
  async nextTokenIdToMint() {
    if (hasFunction("nextTokenIdToMint", this.contractWrapper)) {
      let nextTokenIdToMint = await this.contractWrapper.read("nextTokenIdToMint", []);
      if (hasFunction("startTokenId", this.contractWrapper)) {
        nextTokenIdToMint = nextTokenIdToMint.sub(await this.contractWrapper.read("startTokenId", []));
      }
      return nextTokenIdToMint;
    } else if (hasFunction("totalSupply", this.contractWrapper)) {
      return await this.contractWrapper.read("totalSupply", []);
    } else {
      throw new Error("Contract requires either `nextTokenIdToMint` or `totalSupply` function available to determine the next token ID to mint");
    }
  }
  detectErc721Enumerable() {
    if (detectContractFeature(this.contractWrapper, "ERC721Supply") || hasFunction("nextTokenIdToMint", this.contractWrapper)) {
      return new Erc721Supply(this, this.contractWrapper);
    }
    return void 0;
  }
  detectErc721Mintable() {
    if (detectContractFeature(this.contractWrapper, "ERC721Mintable")) {
      return new Erc721Mintable(this, this.contractWrapper, this.storage);
    }
    return void 0;
  }
  detectErc721Burnable() {
    if (detectContractFeature(this.contractWrapper, "ERC721Burnable")) {
      return new Erc721Burnable(this.contractWrapper);
    }
    return void 0;
  }
  detectErc721LazyMintable() {
    if (detectContractFeature(this.contractWrapper, "ERC721LazyMintable")) {
      return new Erc721LazyMintable(this, this.contractWrapper, this.storage);
    }
    return void 0;
  }
  detectErc721TieredDrop() {
    if (detectContractFeature(this.contractWrapper, "ERC721TieredDrop")) {
      return new Erc721TieredDrop(this, this.contractWrapper, this.storage);
    }
    return void 0;
  }
  detectErc721SignatureMintable() {
    if (detectContractFeature(this.contractWrapper, "ERC721SignatureMintV1") || detectContractFeature(this.contractWrapper, "ERC721SignatureMintV2")) {
      return new Erc721WithQuantitySignatureMintable(this.contractWrapper, this.storage);
    }
    return void 0;
  }
  detectErc721ClaimableWithConditions() {
    if (detectContractFeature(this.contractWrapper, "ERC721ClaimConditionsV1") || detectContractFeature(this.contractWrapper, "ERC721ClaimConditionsV2") || detectContractFeature(this.contractWrapper, "ERC721ClaimPhasesV1") || detectContractFeature(this.contractWrapper, "ERC721ClaimPhasesV2")) {
      return new Erc721ClaimableWithConditions(this, this.contractWrapper, this.storage);
    }
    return void 0;
  }
  detectErc721Claimable() {
    if (detectContractFeature(this.contractWrapper, "ERC721ClaimCustom")) {
      return new Erc721Claimable(this, this.contractWrapper);
    }
    return void 0;
  }
  detectErc721ClaimableZora() {
    if (detectContractFeature(this.contractWrapper, "ERC721ClaimZora")) {
      return new Erc721ClaimableZora(this, this.contractWrapper);
    }
    return void 0;
  }
  detectErc721SharedMetadata() {
    if (detectContractFeature(this.contractWrapper, "ERC721SharedMetadata")) {
      return new Erc721SharedMetadata(this.contractWrapper, this.storage);
    }
    return void 0;
  }
  detectErc721LoyaltyCard() {
    if (detectContractFeature(this.contractWrapper, "ERC721LoyaltyCard")) {
      return new Erc721LoyaltyCard(this.contractWrapper);
    }
    return void 0;
  }
  detectErc721UpdatableMetadata() {
    if (detectContractFeature(this.contractWrapper, "ERC721UpdatableMetadata")) {
      return new Erc721UpdatableMetadata(this.contractWrapper, this.storage);
    }
    return void 0;
  }
};
var Erc1155BatchMintable = class {
  constructor(erc1155, contractWrapper, storage) {
    __publicField(this, "featureName", FEATURE_EDITION_BATCH_MINTABLE.name);
    /**
     * Mint Many NFTs with limited supplies
     *
     * @remarks Mint many different NFTs with limited supplies to a specified wallet.
     *
     * @example
     * ```javascript
     * // Address of the wallet you want to mint the NFT to
     * const toAddress = "{{wallet_address}}"
     *
     * // Custom metadata and supplies of your NFTs
     * const metadataWithSupply = [{
     *   supply: 50, // The number of this NFT you want to mint
     *   metadata: {
     *     name: "Cool NFT #1",
     *     description: "This is a cool NFT",
     *     image: fs.readFileSync("path/to/image.png"), // This can be an image url or file
     *   },
     * }, {
     *   supply: 100,
     *   metadata: {
     *     name: "Cool NFT #2",
     *     description: "This is a cool NFT",
     *     image: fs.readFileSync("path/to/image.png"), // This can be an image url or file
     *   },
     * }];
     *
     * const tx = await contract.edition.mint.batch.to(toAddress, metadataWithSupply);
     * const receipt = tx[0].receipt; // same transaction receipt for all minted NFTs
     * const firstTokenId = tx[0].id; // token id of the first minted NFT
     * const firstNFT = await tx[0].data(); // (optional) fetch details of the first minted NFT
     * ```
     */
    __publicField(this, "to", buildTransactionFunction(async (to, metadataWithSupply) => {
      const metadatas = metadataWithSupply.map((a) => a.metadata);
      const supplies = metadataWithSupply.map((a) => a.supply);
      const uris = await uploadOrExtractURIs(metadatas, this.storage);
      const resolvedAddress = await resolveAddress(to);
      const contractEncoder = new ContractEncoder(this.contractWrapper);
      const encoded = await Promise.all(uris.map(async (uri, index) => contractEncoder.encode("mintTo", [resolvedAddress, lib_exports.MaxUint256, uri, supplies[index]])));
      return Transaction.fromContractWrapper({
        contractWrapper: this.contractWrapper,
        method: "multicall",
        args: [encoded],
        parse: (receipt) => {
          const events = this.contractWrapper.parseLogs("TokensMinted", receipt.logs);
          if (events.length === 0 || events.length < metadatas.length) {
            throw new Error("TokenMinted event not found, minting failed");
          }
          return events.map((e) => {
            const id = e.args.tokenIdMinted;
            return {
              id,
              receipt,
              data: () => this.erc1155.get(id)
            };
          });
        }
      });
    }));
    this.erc1155 = erc1155;
    this.contractWrapper = contractWrapper;
    this.storage = storage;
  }
};
var Erc1155Burnable = class {
  constructor(contractWrapper) {
    __publicField(this, "featureName", FEATURE_EDITION_BURNABLE.name);
    /**
     * Burn a specified amount of a NFTs
     *
     * @remarks Burn the specified NFTs from the connected wallet
     *
     * @param tokenId - the token Id to burn
     * @param amount - amount to burn
     *
     * @example
     * ```javascript
     * // The token ID to burn NFTs of
     * const tokenId = 0;
     * // The amount of the NFT you want to burn
     * const amount = 2;
     *
     * const result = await contract.edition.burn.tokens(tokenId, amount);
     * ```
     */
    __publicField(this, "tokens", buildTransactionFunction(async (tokenId, amount) => {
      const account = await this.contractWrapper.getSignerAddress();
      return this.from.prepare(account, tokenId, amount);
    }));
    /**
     * Burn a specified amount of a NFTs
     *
     * @remarks Burn the specified NFTs from a specified wallet
     *
     * @param account - the address to burn NFTs from
     * @param tokenId - the tokenId to burn
     * @param amount - amount to burn
     *
     * @example
     * ```javascript
     * // The address of the wallet to burn NFTS from
     * const account = "0x...";
     * // The token ID to burn NFTs of
     * const tokenId = 0;
     * // The amount of this NFT you want to burn
     * const amount = 2;
     *
     * const result = await contract.edition.burn.from(account, tokenId, amount);
     * ```
     */
    __publicField(this, "from", buildTransactionFunction(async (account, tokenId, amount) => {
      return Transaction.fromContractWrapper({
        contractWrapper: this.contractWrapper,
        method: "burn",
        args: [await resolveAddress(account), tokenId, amount]
      });
    }));
    /**
     * Burn a batch of NFTs
     *
     * @remarks Burn the batch NFTs from the connected wallet
     *
     * @param tokenIds - the tokenIds to burn
     * @param amounts - amount of each token to burn
     *
     * @example
     * ```javascript
     * // The token IDs to burn NFTs of
     * const tokenIds = [0, 1];
     * // The amounts of each NFT you want to burn
     * const amounts = [2, 2];
     *
     * const result = await contract.edition.burn.batch(tokenIds, amounts);
     * ```
     */
    __publicField(this, "batch", buildTransactionFunction(async (tokenIds, amounts) => {
      const account = await this.contractWrapper.getSignerAddress();
      return this.batchFrom.prepare(account, tokenIds, amounts);
    }));
    /**
     * Burn a batch of NFTs
     *
     * @remarks Burn the batch NFTs from the specified wallet
     *
     * @param account - the address to burn NFTs from
     * @param tokenIds - the tokenIds to burn
     * @param amounts - amount of each token to burn
     *
     * @example
     * ```javascript
     * // The address of the wallet to burn NFTS from
     * const account = "0x...";
     * // The token IDs to burn NFTs of
     * const tokenIds = [0, 1];
     * // The amounts of each NFT you want to burn
     * const amounts = [2, 2];
     *
     * const result = await contract.edition.burn.batchFrom(account, tokenIds, amounts);
     * ```
     */
    __publicField(this, "batchFrom", buildTransactionFunction(async (account, tokenIds, amounts) => {
      return Transaction.fromContractWrapper({
        contractWrapper: this.contractWrapper,
        method: "burnBatch",
        args: [await resolveAddress(account), tokenIds, amounts]
      });
    }));
    this.contractWrapper = contractWrapper;
  }
};
var Erc1155Enumerable = class {
  constructor(erc1155, contractWrapper) {
    __publicField(this, "featureName", FEATURE_EDITION_ENUMERABLE.name);
    this.erc1155 = erc1155;
    this.contractWrapper = contractWrapper;
  }
  /**
   * Get All NFTs
   *
   * @remarks Get all the data associated with every NFT in this contract.
   *
   * By default, returns the first 100 NFTs, use queryParams to fetch more.
   *
   * @example
   * ```javascript
   * const nfts = await contract.edition.query.all();
   * ```
   * @param queryParams - optional filtering to only fetch a subset of results.
   * @returns The NFT metadata for all NFTs queried.
   */
  async all(queryParams) {
    const start = BigNumber.from((queryParams == null ? void 0 : queryParams.start) || 0).toNumber();
    const count = BigNumber.from((queryParams == null ? void 0 : queryParams.count) || DEFAULT_QUERY_ALL_COUNT).toNumber();
    const maxId = Math.min((await this.totalCount()).toNumber(), start + count);
    return await Promise.all([...Array(maxId - start).keys()].map((i) => this.erc1155.get((start + i).toString())));
  }
  /**
   * Get the number of NFTs minted
   * @remarks This returns the total number of NFTs minted in this contract, **not** the total supply of a given token.
   *
   * @returns the total number of NFTs minted in this contract
   * @public
   */
  async totalCount() {
    return await this.contractWrapper.read("nextTokenIdToMint", []);
  }
  /**
   * Get the supply of token for a given tokenId.
   * @remarks This is **not** the sum of supply of all NFTs in the contract.
   *
   * @returns the total number of NFTs minted in this contract
   * @public
   */
  async totalCirculatingSupply(tokenId) {
    return await this.contractWrapper.read("totalSupply", [tokenId]);
  }
  /**
   * Get all NFTs owned by a specific wallet
   *
   * @remarks Get all the data associated with the NFTs owned by a specific wallet.
   *
   * @example
   * ```javascript
   * // Address of the wallet to get the NFTs of
   * const address = "{{wallet_address}}";
   * const nfts = await contract.edition.query.owned(address);
   * ```
   *
   * @returns The NFT metadata for all NFTs in the contract.
   */
  async owned(walletAddress) {
    const [address, maxId] = await Promise.all([resolveAddress(walletAddress || await this.contractWrapper.getSignerAddress()), this.contractWrapper.read("nextTokenIdToMint", [])]);
    const balances = await this.contractWrapper.read("balanceOfBatch", [Array(maxId.toNumber()).fill(address), Array.from(Array(maxId.toNumber()).keys())]);
    const ownedBalances = balances.map((b, i) => {
      return {
        tokenId: i,
        balance: b
      };
    }).filter((b) => b.balance.gt(0));
    const nfts = (await Promise.all(ownedBalances.map((item) => this.erc1155.get(item.tokenId.toString())))).map((editionMetadata, index) => ({
      ...editionMetadata,
      owner: address,
      quantityOwned: ownedBalances[index].balance.toString()
    }));
    return nfts;
  }
};
async function getPrebuiltInfo(address, provider2) {
  try {
    const contract = new Contract(address, IThirdwebContract_default, provider2);
    const [type, version] = await Promise.all([utils_exports.toUtf8String(await contract.contractType()).replace(/\x00/g, ""), await contract.contractVersion()]);
    return {
      type,
      version
    };
  } catch (e) {
    return void 0;
  }
}
var Erc1155LazyMintable = class {
  /**
   * Delayed reveal
   * @remarks Create a batch of encrypted NFTs that can be revealed at a later time.
   * @example
   * ```javascript
   * // the real NFTs, these will be encrypted until you reveal them
   * const realNFTs = [{
   *   name: "Common NFT #1",
   *   description: "Common NFT, one of many.",
   *   image: fs.readFileSync("path/to/image.png"),
   * }, {
   *   name: "Super Rare NFT #2",
   *   description: "You got a Super Rare NFT!",
   *   image: fs.readFileSync("path/to/image.png"),
   * }];
   * // A placeholder NFT that people will get immediately in their wallet, and will be converted to the real NFT at reveal time
   * const placeholderNFT = {
   *   name: "Hidden NFT",
   *   description: "Will be revealed next week!"
   * };
   * // Create and encrypt the NFTs
   * await contract.edition.drop.revealer.createDelayedRevealBatch(
   *   placeholderNFT,
   *   realNFTs,
   *   "my secret password",
   * );
   * // Whenever you're ready, reveal your NFTs at any time
   * const batchId = 0; // the batch to reveal
   * await contract.edition.drop.revealer.reveal(batchId, "my secret password");
   * ```
   */
  constructor(erc1155, contractWrapper, storage) {
    __publicField(this, "featureName", FEATURE_EDITION_LAZY_MINTABLE_V2.name);
    /**
     * Create a batch of NFTs to be claimed in the future
     *
     * @remarks Create batch allows you to create a batch of many NFTs in one transaction.
     *
     * @example
     * ```javascript
     * // Custom metadata of the NFTs to create
     * const metadatas = [{
     *   name: "Cool NFT",
     *   description: "This is a cool NFT",
     *   image: fs.readFileSync("path/to/image.png"), // This can be an image url or file
     * }, {
     *   name: "Cool NFT",
     *   description: "This is a cool NFT",
     *   image: fs.readFileSync("path/to/image.png"),
     * }];
     *
     * const results = await contract.erc1155.lazyMint(metadatas); // uploads and creates the NFTs on chain
     * const firstTokenId = results[0].id; // token id of the first created NFT
     * const firstNFT = await results[0].data(); // (optional) fetch details of the first created NFT
     * ```
     *
     * @param metadatas - The metadata to include in the batch.
     * @param options - optional upload progress callback
     */
    __publicField(this, "lazyMint", buildTransactionFunction(async (metadatas, options) => {
      const startFileNumber = await this.erc1155.nextTokenIdToMint();
      const batch = await uploadOrExtractURIs(metadatas, this.storage, startFileNumber.toNumber(), options);
      const baseUri = batch[0].substring(0, batch[0].lastIndexOf("/"));
      for (let i = 0; i < batch.length; i++) {
        const uri = batch[i].substring(0, batch[i].lastIndexOf("/"));
        if (baseUri !== uri) {
          throw new Error(`Can only create batches with the same base URI for every entry in the batch. Expected '${baseUri}' but got '${uri}'`);
        }
      }
      const parse2 = (receipt) => {
        const event = this.contractWrapper.parseLogs("TokensLazyMinted", receipt == null ? void 0 : receipt.logs);
        const startingIndex = event[0].args.startTokenId;
        const endingIndex = event[0].args.endTokenId;
        const results = [];
        for (let id = startingIndex; id.lte(endingIndex); id = id.add(1)) {
          results.push({
            id,
            receipt,
            data: () => this.erc1155.getTokenMetadata(id)
          });
        }
        return results;
      };
      const prebuiltInfo = await getPrebuiltInfo(this.contractWrapper.address, this.contractWrapper.getProvider());
      if (this.isLegacyEditionDropContract(this.contractWrapper, prebuiltInfo)) {
        return Transaction.fromContractWrapper({
          contractWrapper: this.contractWrapper,
          method: "lazyMint",
          args: [batch.length, `${baseUri.endsWith("/") ? baseUri : `${baseUri}/`}`],
          parse: parse2
        });
      } else {
        return Transaction.fromContractWrapper({
          contractWrapper: this.contractWrapper,
          method: "lazyMint",
          args: [batch.length, `${baseUri.endsWith("/") ? baseUri : `${baseUri}/`}`, utils_exports.toUtf8Bytes("")],
          parse: parse2
        });
      }
    }));
    this.erc1155 = erc1155;
    this.contractWrapper = contractWrapper;
    this.storage = storage;
    this.revealer = this.detectErc1155Revealable();
  }
  /** ******************************
   * PRIVATE FUNCTIONS
   *******************************/
  detectErc1155Revealable() {
    if (detectContractFeature(this.contractWrapper, "ERC1155Revealable")) {
      return new DelayedReveal(this.contractWrapper, this.storage, FEATURE_EDITION_REVEALABLE.name, () => this.erc1155.nextTokenIdToMint());
    }
    return void 0;
  }
  isLegacyEditionDropContract(contractWrapper, info) {
    return info && info.type === "DropERC1155" && info.version < 3 || false;
  }
};
var Erc1155Mintable = class {
  /**
   * Batch mint Tokens to many addresses
   */
  constructor(erc1155, contractWrapper, storage) {
    __publicField(this, "featureName", FEATURE_EDITION_MINTABLE.name);
    /**
     * Mint an NFT with a limited supply
     *
     * @remarks Mint an NFT with a limited supply to a specified wallet.
     *
     * @example
     * ```javascript
     * // Address of the wallet you want to mint the NFT to
     * const toAddress = "{{wallet_address}}"
     *
     * // Custom metadata of the NFT, note that you can fully customize this metadata with other properties.
     * const metadata = {
     *   name: "Cool NFT",
     *   description: "This is a cool NFT",
     *   image: fs.readFileSync("path/to/image.png"), // This can be an image url or file
     * }
     *
     * const metadataWithSupply = {
     *   metadata,
     *   supply: 1000, // The number of this NFT you want to mint
     * }
     *
     * const tx = await contract.edition.mint.to(toAddress, metadataWithSupply);
     * const receipt = tx.receipt; // the transaction receipt
     * const tokenId = tx.id; // the id of the NFT minted
     * const nft = await tx.data(); // (optional) fetch details of minted NFT
     * ```
     *
     */
    __publicField(this, "to", buildTransactionFunction(async (to, metadataWithSupply) => {
      const tx = await this.getMintTransaction(to, metadataWithSupply);
      tx.setParse((receipt) => {
        const event = this.contractWrapper.parseLogs("TransferSingle", receipt == null ? void 0 : receipt.logs);
        if (event.length === 0) {
          throw new Error("TransferSingleEvent event not found");
        }
        const id = event[0].args.id;
        return {
          id,
          receipt,
          data: () => this.erc1155.get(id.toString())
        };
      });
      return tx;
    }));
    /**
     * Increase the supply of an existing NFT and mint it to a given wallet address
     *
     * @param to - the address to mint to
     * @param tokenId - the token id of the NFT to increase supply of
     * @param additionalSupply - the additional amount to mint
     *
     * @example
     * ```javascript
     * // Address of the wallet you want to mint the NFT to
     * const toAddress = "{{wallet_address}}"
     * const tokenId = 0;
     * const additionalSupply = 1000;
     *
     * const tx = await contract.edition.mint.additionalSupplyTo(toAddress, tokenId, additionalSupply);
     * ```
     */
    __publicField(this, "additionalSupplyTo", buildTransactionFunction(async (to, tokenId, additionalSupply) => {
      const metadata = await this.erc1155.getTokenMetadata(tokenId);
      return Transaction.fromContractWrapper({
        contractWrapper: this.contractWrapper,
        method: "mintTo",
        args: [await resolveAddress(to), tokenId, metadata.uri, additionalSupply],
        parse: (receipt) => {
          return {
            id: BigNumber.from(tokenId),
            receipt,
            data: () => this.erc1155.get(tokenId)
          };
        }
      });
    }));
    this.erc1155 = erc1155;
    this.contractWrapper = contractWrapper;
    this.storage = storage;
    this.batch = this.detectErc1155BatchMintable();
  }
  /**
   * @deprecated Use `contract.erc1155.mint.prepare(...args)` instead
   */
  async getMintTransaction(to, metadataWithSupply) {
    const uri = await uploadOrExtractURI(metadataWithSupply.metadata, this.storage);
    return Transaction.fromContractWrapper({
      contractWrapper: this.contractWrapper,
      method: "mintTo",
      args: [await resolveAddress(to), lib_exports.MaxUint256, uri, metadataWithSupply.supply]
    });
  }
  detectErc1155BatchMintable() {
    if (detectContractFeature(this.contractWrapper, "ERC1155BatchMintable")) {
      return new Erc1155BatchMintable(this.erc1155, this.contractWrapper, this.storage);
    }
  }
};
var AirdropAddressInput = (() => z.object({
  address: AddressOrEnsSchema,
  quantity: AmountSchema.default(1)
}))();
var AirdropInputSchema = (() => z.union([z.array(z.string()).transform(async (strings) => await Promise.all(strings.map((address) => AirdropAddressInput.parseAsync({
  address
})))), z.array(AirdropAddressInput)]))();
var ERC1155Claimable = class {
  constructor(contractWrapper) {
    __publicField(this, "featureName", FEATURE_EDITION_CLAIM_CUSTOM.name);
    /**
     * Claim NFTs to a specific Wallet
     *
     * @remarks Let the specified wallet claim NFTs.
     *
     * @example
     * ```javascript
     * const address = "{{wallet_address}}"; // address of the wallet you want to claim the NFTs
     * const tokenId = 0; // the id of the NFT you want to claim
     * const quantity = 1; // how many NFTs you want to claim
     *
     * const tx = await contract.erc1155.claimTo(address, tokenId, quantity);
     * const receipt = tx.receipt; // the transaction receipt
     * ```
     *
     * @param destinationAddress - Address you want to send the token to
     * @param tokenId - Id of the token you want to claim
     * @param quantity - Quantity of the tokens you want to claim
     * @param options - Options for claiming the NFTs
     *
     * @returns - Receipt for the transaction
     */
    __publicField(this, "to", buildTransactionFunction(async (destinationAddress, tokenId, quantity, options) => {
      return await this.getClaimTransaction(destinationAddress, tokenId, quantity, options);
    }));
    this.contractWrapper = contractWrapper;
  }
  /**
   * Construct a claim transaction without executing it.
   * This is useful for estimating the gas cost of a claim transaction, overriding transaction options and having fine grained control over the transaction execution.
   * @param destinationAddress - Address you want to send the token to
   * @param tokenId - Id of the token you want to claim
   * @param quantity - Quantity of the tokens you want to claim
   * @param options - Options for claiming the NFTs
   *
   * @deprecated Use `contract.erc1155.claim.prepare(...args)` instead
   */
  async getClaimTransaction(destinationAddress, tokenId, quantity, options) {
    let overrides = {};
    if (options && options.pricePerToken) {
      overrides = await calculateClaimCost(this.contractWrapper, options.pricePerToken, quantity, options.currencyAddress, options.checkERC20Allowance);
    }
    return Transaction.fromContractWrapper({
      contractWrapper: this.contractWrapper,
      method: "claim",
      args: [await resolveAddress(destinationAddress), tokenId, quantity],
      overrides
    });
  }
};
var Erc1155ClaimableWithConditions = class {
  constructor(contractWrapper, storage) {
    __publicField(this, "featureName", FEATURE_EDITION_CLAIM_CONDITIONS_V2.name);
    /**
     * Claim NFTs to a specific Wallet
     *
     * @remarks Let the specified wallet claim NFTs.
     *
     * @example
     * ```javascript
     * const address = "{{wallet_address}}"; // address of the wallet you want to claim the NFTs
     * const tokenId = 0; // the id of the NFT you want to claim
     * const quantity = 1; // how many NFTs you want to claim
     *
     * const tx = await contract.erc1155.claimTo(address, tokenId, quantity);
     * const receipt = tx.receipt; // the transaction receipt
     * ```
     *
     * @param destinationAddress - Address you want to send the token to
     * @param tokenId - Id of the token you want to claim
     * @param quantity - Quantity of the tokens you want to claim
     *
     * @returns - Receipt for the transaction
     */
    __publicField(this, "to", buildTransactionFunction(async (destinationAddress, tokenId, quantity, options) => {
      return await this.conditions.getClaimTransaction(destinationAddress, tokenId, quantity, options);
    }));
    this.contractWrapper = contractWrapper;
    this.storage = storage;
    const metadata = new ContractMetadata(this.contractWrapper, CustomContractSchema, this.storage);
    this.conditions = new DropErc1155ClaimConditions(contractWrapper, metadata, this.storage);
  }
};
var Erc1155SignatureMintable = class {
  constructor(contractWrapper, storage, roles) {
    __publicField(this, "featureName", FEATURE_EDITION_SIGNATURE_MINTABLE.name);
    /**
     * Mint a dynamically generated NFT
     *
     * @remarks Mint a dynamic NFT with a previously generated signature.
     *
     * @example
     * ```javascript
     * // see how to craft a payload to sign in the `generate()` documentation
     * const signedPayload = contract.erc1155.signature.generate(payload);
     *
     * // now anyone can mint the NFT
     * const tx = contract.erc1155.signature.mint(signedPayload);
     * ```
     * @param signedPayload - the previously generated payload and signature with {@link Erc1155SignatureMintable.generate}
     * @twfeature ERC1155SignatureMintable
     */
    __publicField(this, "mint", buildTransactionFunction(async (signedPayload) => {
      const mintRequest = signedPayload.payload;
      const signature = signedPayload.signature;
      const message = await this.mapPayloadToContractStruct(mintRequest);
      const overrides = await this.contractWrapper.getCallOverrides();
      await setErc20Allowance(this.contractWrapper, message.pricePerToken.mul(message.quantity), mintRequest.currencyAddress, overrides);
      return Transaction.fromContractWrapper({
        contractWrapper: this.contractWrapper,
        method: "mintWithSignature",
        args: [message, signature],
        overrides,
        parse: (receipt) => {
          const t = this.contractWrapper.parseLogs("TokensMintedWithSignature", receipt.logs);
          if (t.length === 0) {
            throw new Error("No MintWithSignature event found");
          }
          const id = t[0].args.tokenIdMinted;
          return {
            id,
            receipt
          };
        }
      });
    }));
    /**
     * Mint any number of dynamically generated NFT at once
     * @remarks Mint multiple dynamic NFTs in one transaction. Note that this is only possible for free mints (cannot batch mints with a price attached to it for security reasons)
     *
     * @example
     * ```javascript
     * // see how to craft a batch of payloads to sign in the `generateBatch()` documentation
     * const signedPayloads = contract.erc1155.signature.generateBatch(payloads);
     *
     * // now anyone can mint the NFT
     * const tx = contract.erc1155.signature.mintBatch(signedPayloads);
     * ```
     *
     * @param signedPayloads - the array of signed payloads to mint
     * @twfeature ERC1155SignatureMintable
     */
    __publicField(this, "mintBatch", buildTransactionFunction(async (signedPayloads) => {
      const contractPayloads = await Promise.all(signedPayloads.map(async (s) => {
        const message = await this.mapPayloadToContractStruct(s.payload);
        const signature = s.signature;
        const price = s.payload.price;
        if (BigNumber.from(price).gt(0)) {
          throw new Error("Can only batch free mints. For mints with a price, use regular mint()");
        }
        return {
          message,
          signature
        };
      }));
      const contractEncoder = new ContractEncoder(this.contractWrapper);
      const encoded = contractPayloads.map((p) => {
        return contractEncoder.encode("mintWithSignature", [p.message, p.signature]);
      });
      if (hasFunction("multicall", this.contractWrapper)) {
        return Transaction.fromContractWrapper({
          contractWrapper: this.contractWrapper,
          method: "multicall",
          args: [encoded],
          parse: (receipt) => {
            const events = this.contractWrapper.parseLogs("TokensMintedWithSignature", receipt.logs);
            if (events.length === 0) {
              throw new Error("No MintWithSignature event found");
            }
            return events.map((log) => ({
              id: log.args.tokenIdMinted,
              receipt
            }));
          }
        });
      } else {
        throw new Error("Multicall not supported on this contract!");
      }
    }));
    this.contractWrapper = contractWrapper;
    this.storage = storage;
    this.roles = roles;
  }
  /**
   * Verify that a payload is correctly signed
   * @param signedPayload - the payload to verify
   * @twfeature ERC1155SignatureMintable
   *
   * @example
   * ```javascript
   * const nftMetadata = {
   *   name: "Cool NFT #1",
   *   description: "This is a cool NFT",
   *   image: fs.readFileSync("path/to/image.png"), // This can be an image url or file
   * };
   *
   * const startTime = new Date();
   * const endTime = new Date(Date.now() + 60 * 60 * 24 * 1000);
   * const payload = {
   *   metadata: nftMetadata, // The NFT to mint
   *   to: {{wallet_address}}, // Who will receive the NFT
   *   quantity: 2, // the quantity of NFTs to mint
   *   price: 0.5, // the price per NFT
   *   currencyAddress: NATIVE_TOKEN_ADDRESS, // the currency to pay with
   *   mintStartTime: startTime, // can mint anytime from now
   *   mintEndTime: endTime, // to 24h from now
   *   royaltyRecipient: "0x...", // custom royalty recipient for this NFT
   *   royaltyBps: 100, // custom royalty fees for this NFT (in bps)
   *   primarySaleRecipient: "0x...", // custom sale recipient for this NFT
   * };
   *
   * const signedPayload = contract.erc1155.signature.generate(payload);
   * // Now you can verify that the payload is valid
   * const isValid = await contract.erc1155.signature.verify(signedPayload);
   * ```
   */
  async verify(signedPayload) {
    const mintRequest = signedPayload.payload;
    const signature = signedPayload.signature;
    const message = await this.mapPayloadToContractStruct(mintRequest);
    const verification = await this.contractWrapper.read("verify", [message, signature]);
    return verification[0];
  }
  /**
   * Generate a signature that can be used to mint an NFT dynamically.
   *
   * @remarks Takes in an NFT and some information about how it can be minted, uploads the metadata and signs it with your private key. The generated signature can then be used to mint an NFT using the exact payload and signature generated.
   *
   * @example
   * ```javascript
   * const nftMetadata = {
   *   name: "Cool NFT #1",
   *   description: "This is a cool NFT",
   *   image: fs.readFileSync("path/to/image.png"), // This can be an image url or file
   * };
   *
   * const startTime = new Date();
   * const endTime = new Date(Date.now() + 60 * 60 * 24 * 1000);
   * const payload = {
   *   metadata: nftMetadata, // The NFT to mint
   *   to: {{wallet_address}}, // Who will receive the NFT
   *   quantity: 2, // the quantity of NFTs to mint
   *   price: 0.5, // the price per NFT
   *   currencyAddress: NATIVE_TOKEN_ADDRESS, // the currency to pay with
   *   mintStartTime: startTime, // can mint anytime from now
   *   mintEndTime: endTime, // to 24h from now
   *   royaltyRecipient: "0x...", // custom royalty recipient for this NFT
   *   royaltyBps: 100, // custom royalty fees for this NFT (in bps)
   *   primarySaleRecipient: "0x...", // custom sale recipient for this NFT
   * };
   *
   * const signedPayload = await contract.erc1155.signature.generate(payload);
   * // now anyone can use these to mint the NFT using `contract.erc1155.signature.mint(signedPayload)`
   * ```
   * @param payloadToSign - the payload to sign
   * @returns the signed payload and the corresponding signature
   * @twfeature ERC1155SignatureMintable
   */
  async generate(payloadToSign) {
    const payload = {
      ...payloadToSign,
      tokenId: lib_exports.MaxUint256
    };
    return this.generateFromTokenId(payload);
  }
  /**
   * Generate a signature that can be used to mint additionaly supply to an existing NFT.
   *
   * @remarks Takes in a payload with the token ID of an existing NFT, and signs it with your private key. The generated signature can then be used to mint additional supply to the NFT using the exact payload and signature generated.
   *
   * @example
   * ```javascript
   * const nftMetadata = {
   *   name: "Cool NFT #1",
   *   description: "This is a cool NFT",
   *   image: fs.readFileSync("path/to/image.png"), // This can be an image url or file
   * };
   *
   * const startTime = new Date();
   * const endTime = new Date(Date.now() + 60 * 60 * 24 * 1000);
   * const payload = {
   *   tokenId: 0, // Instead of metadata, we specificy the token ID of the NFT to mint supply to
   *   to: {{wallet_address}}, // Who will receive the NFT (or AddressZero for anyone)
   *   quantity: 2, // the quantity of NFTs to mint
   *   price: 0.5, // the price per NFT
   *   currencyAddress: NATIVE_TOKEN_ADDRESS, // the currency to pay with
   *   mintStartTime: startTime, // can mint anytime from now
   *   mintEndTime: endTime, // to 24h from now
   *   royaltyRecipient: "0x...", // custom royalty recipient for this NFT
   *   royaltyBps: 100, // custom royalty fees for this NFT (in bps)
   *   primarySaleRecipient: "0x...", // custom sale recipient for this NFT
   * };
   *
   * const signedPayload = await contract.erc1155.signature.generateFromTokenId(payload);
   * // now anyone can use these to mint the NFT using `contract.erc1155.signature.mint(signedPayload)`
   * ```
   * @param payloadToSign - the payload to sign
   * @returns the signed payload and the corresponding signature
   * @twfeature ERC1155SignatureMintable
   */
  async generateFromTokenId(payloadToSign) {
    const payloads = await this.generateBatchFromTokenIds([payloadToSign]);
    return payloads[0];
  }
  /**
   * Generate a batch of signatures that can be used to mint many new NFTs dynamically.
   *
   * @remarks See {@link Erc1155SignatureMintable.generate}
   *
   * @param payloadsToSign - the payloads to sign
   * @returns an array of payloads and signatures
   * @twfeature ERC1155SignatureMintable
   */
  async generateBatch(payloadsToSign) {
    const payloads = payloadsToSign.map((payload) => ({
      ...payload,
      tokenId: lib_exports.MaxUint256
    }));
    return this.generateBatchFromTokenIds(payloads);
  }
  /**
   * Genrate a batch of signatures that can be used to mint new NFTs or additionaly supply to existing NFTs dynamically.
   *
   * @remarks See {@link Erc1155SignatureMintable.generateFromTokenId}
   *
   * @param payloadsToSign - the payloads to sign with tokenIds specified
   * @returns an array of payloads and signatures
   * @twfeature ERC1155SignatureMintable
   */
  async generateBatchFromTokenIds(payloadsToSign) {
    var _a;
    await ((_a = this.roles) == null ? void 0 : _a.verify(["minter"], await this.contractWrapper.getSignerAddress()));
    const parsedRequests = await Promise.all(payloadsToSign.map((m) => Signature1155PayloadInputWithTokenId.parseAsync(m)));
    const metadatas = parsedRequests.map((r) => r.metadata);
    const uris = await uploadOrExtractURIs(metadatas, this.storage);
    const chainId = await this.contractWrapper.getChainID();
    const signer = this.contractWrapper.getSigner();
    invariant(signer, "No signer available");
    const contractInfo = await getPrebuiltInfo(this.contractWrapper.address, this.contractWrapper.getProvider());
    const isLegacyContract = (contractInfo == null ? void 0 : contractInfo.type) === "TokenERC1155";
    return await Promise.all(parsedRequests.map(async (m, i) => {
      const uri = uris[i];
      const finalPayload = await Signature1155PayloadOutput.parseAsync({
        ...m,
        uri
      });
      const signature = await this.contractWrapper.signTypedData(
        signer,
        {
          name: isLegacyContract ? "TokenERC1155" : "SignatureMintERC1155",
          version: "1",
          chainId,
          verifyingContract: this.contractWrapper.address
        },
        {
          MintRequest: MintRequest1155
        },
        // TYPEHASH
        await this.mapPayloadToContractStruct(finalPayload)
      );
      return {
        payload: finalPayload,
        signature: signature.toString()
      };
    }));
  }
  /** ******************************
   * PRIVATE FUNCTIONS
   *******************************/
  /**
   * Maps a payload to the format expected by the contract
   *
   * @internal
   *
   * @param mintRequest - The payload to map.
   * @returns - The mapped payload.
   */
  async mapPayloadToContractStruct(mintRequest) {
    const normalizedPricePerToken = await normalizePriceValue(this.contractWrapper.getProvider(), mintRequest.price, mintRequest.currencyAddress);
    return {
      to: mintRequest.to,
      tokenId: mintRequest.tokenId,
      uri: mintRequest.uri,
      quantity: mintRequest.quantity,
      pricePerToken: normalizedPricePerToken,
      currency: mintRequest.currencyAddress,
      validityStartTimestamp: mintRequest.mintStartTime,
      validityEndTimestamp: mintRequest.mintEndTime,
      uid: mintRequest.uid,
      royaltyRecipient: mintRequest.royaltyRecipient,
      royaltyBps: mintRequest.royaltyBps,
      primarySaleRecipient: mintRequest.primarySaleRecipient
    };
  }
};
var Erc1155 = class {
  constructor(contractWrapper, storage, chainId) {
    __publicField(this, "featureName", FEATURE_EDITION.name);
    /**
     * Transfer an NFT
     *
     * @remarks Transfer an NFT from the connected wallet to another wallet.
     *
     * @example
     * ```javascript
     * // Address of the wallet you want to send the NFT to
     * const toAddress = "{{wallet_address}}";
     * const tokenId = "0"; // The token ID of the NFT you want to send
     * const amount = 3; // How many copies of the NFTs to transfer
     * await contract.erc1155.transfer(toAddress, tokenId, amount);
     * ```
     * @twfeature ERC1155
     */
    __publicField(this, "transfer", buildTransactionFunction((() => {
      var _this = this;
      return async function(to, tokenId, amount) {
        let data = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : [0];
        const from = await _this.contractWrapper.getSignerAddress();
        return Transaction.fromContractWrapper({
          contractWrapper: _this.contractWrapper,
          method: "safeTransferFrom",
          args: [from, await resolveAddress(to), tokenId, amount, data]
        });
      };
    })()));
    /**
     * Transfer an NFT from a specific wallet
     *
     * @remarks Transfer an NFT from a specific wallet to another wallet.
     *
     * @example
     * ```javascript
     * // Address of the wallet you want to send the NFT to
     * const toAddress = "{{wallet_address}}";
     * const tokenId = "0"; // The token ID of the NFT you want to send
     * const amount = 3; // How many copies of the NFTs to transfer
     * await contract.erc1155.transfer(toAddress, tokenId, amount);
     * ```
     * @twfeature ERC1155
     */
    __publicField(this, "transferFrom", buildTransactionFunction((() => {
      var _this2 = this;
      return async function(from, to, tokenId, amount) {
        let data = arguments.length > 4 && arguments[4] !== void 0 ? arguments[4] : [0];
        return Transaction.fromContractWrapper({
          contractWrapper: _this2.contractWrapper,
          method: "safeTransferFrom",
          args: [await resolveAddress(from), await resolveAddress(to), tokenId, amount, data]
        });
      };
    })()));
    /**
     * Set approval for all NFTs
     * @remarks Approve or remove operator as an operator for the caller. Operators can call transferFrom or safeTransferFrom for any token owned by the caller.
     * @example
     * ```javascript
     * const operator = "{{wallet_address}}";
     * await contract.erc1155.setApprovalForAll(operator, true);
     * ```
     * @param operator - the operator's address
     * @param approved - whether to approve or remove
     * @twfeature ERC1155
     */
    __publicField(this, "setApprovalForAll", buildTransactionFunction(async (operator, approved) => {
      return Transaction.fromContractWrapper({
        contractWrapper: this.contractWrapper,
        method: "setApprovalForAll",
        args: [operator, approved]
      });
    }));
    /**
     * Airdrop multiple NFTs
     *
     * @remarks Airdrop one or multiple NFTs to the provided wallet addresses.
     *
     * @example
     * ```javascript
     * // The token ID of the NFT you want to airdrop
     * const tokenId = "0";
     * // Array of objects of addresses and quantities to airdrop NFTs to
     * const addresses = [
     *  {
     *    address: "0x...",
     *    quantity: 2,
     *  },
     *  {
     *   address: "0x...",
     *    quantity: 3,
     *  },
     * ];
     * await contract.erc1155.airdrop(tokenId, addresses);
     *
     * // You can also pass an array of addresses, it will airdrop 1 NFT per address
     * const tokenId = "0";
     * const addresses = [
     *  "0x...", "0x...", "0x...",
     * ]
     * await contract.erc1155.airdrop(tokenId, addresses);
     * ```
     * @twfeature ERC1155BatchTransferable
     */
    __publicField(this, "airdrop", buildTransactionFunction((() => {
      var _this3 = this;
      return async function(tokenId, addresses, fromAddress) {
        let data = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : [0];
        const from = fromAddress ? await resolveAddress(fromAddress) : await _this3.contractWrapper.getSignerAddress();
        const balanceOf = await _this3.balanceOf(from, tokenId);
        const input = await AirdropInputSchema.parseAsync(addresses);
        const totalToAirdrop = input.reduce((prev, curr) => {
          return BigNumber.from(prev).add(BigNumber.from((curr == null ? void 0 : curr.quantity) || 1));
        }, BigNumber.from(0));
        if (balanceOf.lt(BigNumber.from(totalToAirdrop))) {
          throw new Error(`The caller owns ${balanceOf.toString()} NFTs, but wants to airdrop ${totalToAirdrop.toString()} NFTs.`);
        }
        const contractEncoder = new ContractEncoder(_this3.contractWrapper);
        const encoded = input.map((_ref) => {
          let {
            address: to,
            quantity
          } = _ref;
          return contractEncoder.encode("safeTransferFrom", [from, to, tokenId, quantity, data]);
        });
        return Transaction.fromContractWrapper({
          contractWrapper: _this3.contractWrapper,
          method: "multicall",
          args: [encoded]
        });
      };
    })()));
    ////// ERC1155 Mintable Extension //////
    /**
     * Mint an NFT
     *
     * @remarks Mint an NFT with a limited supply to the connected wallet.
     *
     * @example
     * ```javascript
     * // Address of the wallet you want to mint the NFT to
     * const toAddress = "{{wallet_address}}"
     *
     * // Custom metadata of the NFT, note that you can fully customize this metadata with other properties.
     * const metadata = {
     *   name: "Cool NFT",
     *   description: "This is a cool NFT",
     *   image: fs.readFileSync("path/to/image.png"), // This can be an image url or file
     * }
     *
     * const metadataWithSupply = {
     *   metadata,
     *   supply: 1000, // The number of this NFT you want to mint
     * }
     *
     * const tx = await contract.erc1155.mint(toAddress, metadataWithSupply);
     * const receipt = tx.receipt; // the transaction receipt
     * const tokenId = tx.id; // the id of the NFT minted
     * const nft = await tx.data(); // (optional) fetch details of minted NFT
     * ```
     * @twfeature ERC1155Mintable
     */
    __publicField(this, "mint", buildTransactionFunction(async (metadataWithSupply) => {
      return this.mintTo.prepare(await this.contractWrapper.getSignerAddress(), metadataWithSupply);
    }));
    /**
     * Mint an NFT to a specific wallet
     *
     * @remarks Mint an NFT with a limited supply to a specified wallet.
     *
     * @example
     * ```javascript
     * // Address of the wallet you want to mint the NFT to
     * const toAddress = "{{wallet_address}}"
     *
     * // Custom metadata of the NFT, note that you can fully customize this metadata with other properties.
     * const metadata = {
     *   name: "Cool NFT",
     *   description: "This is a cool NFT",
     *   image: fs.readFileSync("path/to/image.png"), // This can be an image url or file
     * }
     *
     * const metadataWithSupply = {
     *   metadata,
     *   supply: 1000, // The number of this NFT you want to mint
     * }
     *
     * const tx = await contract.erc1155.mintTo(toAddress, metadataWithSupply);
     * const receipt = tx.receipt; // the transaction receipt
     * const tokenId = tx.id; // the id of the NFT minted
     * const nft = await tx.data(); // (optional) fetch details of minted NFT
     * ```
     * @twfeature ERC1155Mintable
     */
    __publicField(this, "mintTo", buildTransactionFunction(async (receiver, metadataWithSupply) => {
      return assertEnabled(this.mintable, FEATURE_EDITION_MINTABLE).to.prepare(receiver, metadataWithSupply);
    }));
    /**
     * Increase the supply of an existing NFT
     * @remarks Increase the supply of an existing NFT and mint it to the connected wallet address
     * @example
     * ```javascript
     * const tokenId = 0;
     * const additionalSupply = 1000;
     * await contract.erc1155.mintAdditionalSupply(tokenId, additionalSupply);
     * ```
     *
     * @param tokenId - the token id of the NFT to increase supply of
     * @param additionalSupply - the additional amount to mint
     * @twfeature ERC1155Mintable
     */
    __publicField(this, "mintAdditionalSupply", buildTransactionFunction(async (tokenId, additionalSupply) => {
      return assertEnabled(this.mintable, FEATURE_EDITION_MINTABLE).additionalSupplyTo.prepare(await this.contractWrapper.getSignerAddress(), tokenId, additionalSupply);
    }));
    /**
     * Increase the supply of an existing NFT and mint it to a given wallet address
     *
     * @param to - the address to mint to
     * @param tokenId - the token id of the NFT to increase supply of
     * @param additionalSupply - the additional amount to mint
     * @twfeature ERC1155Mintable
     */
    __publicField(this, "mintAdditionalSupplyTo", buildTransactionFunction(async (receiver, tokenId, additionalSupply) => {
      return assertEnabled(this.mintable, FEATURE_EDITION_MINTABLE).additionalSupplyTo.prepare(receiver, tokenId, additionalSupply);
    }));
    ////// ERC1155 BatchMintable Extension //////
    /**
     * Mint multiple NFTs at once
     *
     * @remarks Mint multiple different NFTs with limited supplies to the connected wallet.
     *
     * @example
     * ```javascript
     * // Custom metadata and supplies of your NFTs
     * const metadataWithSupply = [{
     *   supply: 50, // The number of this NFT you want to mint
     *   metadata: {
     *     name: "Cool NFT #1",
     *     description: "This is a cool NFT",
     *     image: fs.readFileSync("path/to/image.png"), // This can be an image url or file
     *   },
     * }, {
     *   supply: 100,
     *   metadata: {
     *     name: "Cool NFT #2",
     *     description: "This is a cool NFT",
     *     image: fs.readFileSync("path/to/image.png"), // This can be an image url or file
     *   },
     * }];
     *
     * const tx = await contract.erc1155.mintBatch(metadataWithSupply);
     * const receipt = tx[0].receipt; // same transaction receipt for all minted NFTs
     * const firstTokenId = tx[0].id; // token id of the first minted NFT
     * const firstNFT = await tx[0].data(); // (optional) fetch details of the first minted NFT
     * ```
     * @twfeature ERC1155BatchMintable
     */
    __publicField(this, "mintBatch", buildTransactionFunction(async (metadataWithSupply) => {
      return this.mintBatchTo.prepare(await this.contractWrapper.getSignerAddress(), metadataWithSupply);
    }));
    /**
     * Mint multiple NFTs at once to a specific wallet
     *
     * @remarks Mint multiple different NFTs with limited supplies to a specified wallet.
     *
     * @example
     * ```javascript
     * // Address of the wallet you want to mint the NFT to
     * const toAddress = "{{wallet_address}}"
     *
     * // Custom metadata and supplies of your NFTs
     * const metadataWithSupply = [{
     *   supply: 50, // The number of this NFT you want to mint
     *   metadata: {
     *     name: "Cool NFT #1",
     *     description: "This is a cool NFT",
     *     image: fs.readFileSync("path/to/image.png"), // This can be an image url or file
     *   },
     * }, {
     *   supply: 100,
     *   metadata: {
     *     name: "Cool NFT #2",
     *     description: "This is a cool NFT",
     *     image: fs.readFileSync("path/to/image.png"), // This can be an image url or file
     *   },
     * }];
     *
     * const tx = await contract.erc1155.mintBatchTo(toAddress, metadataWithSupply);
     * const receipt = tx[0].receipt; // same transaction receipt for all minted NFTs
     * const firstTokenId = tx[0].id; // token id of the first minted NFT
     * const firstNFT = await tx[0].data(); // (optional) fetch details of the first minted NFT
     * ```
     * @twfeature ERC1155BatchMintable
     */
    __publicField(this, "mintBatchTo", buildTransactionFunction(async (receiver, metadataWithSupply) => {
      var _a;
      return assertEnabled((_a = this.mintable) == null ? void 0 : _a.batch, FEATURE_EDITION_BATCH_MINTABLE).to.prepare(receiver, metadataWithSupply);
    }));
    ////// ERC1155 Burnable Extension //////
    /**
     * Burn NFTs
     *
     * @remarks Burn the specified NFTs from the connected wallet
     *
     * @param tokenId - the token Id to burn
     * @param amount - amount to burn
     *
     * @example
     * ```javascript
     * // The token ID to burn NFTs of
     * const tokenId = 0;
     * // The amount of the NFT you want to burn
     * const amount = 2;
     *
     * const result = await contract.erc1155.burn(tokenId, amount);
     * ```
     * @twfeature ERC1155Burnable
     */
    __publicField(this, "burn", buildTransactionFunction(async (tokenId, amount) => {
      return assertEnabled(this.burnable, FEATURE_EDITION_BURNABLE).tokens.prepare(tokenId, amount);
    }));
    /**
     * Burn NFTs from a specific wallet
     *
     * @remarks Burn the specified NFTs from a specified wallet
     *
     * @param account - the address to burn NFTs from
     * @param tokenId - the tokenId to burn
     * @param amount - amount to burn
     *
     * @example
     * ```javascript
     * // The address of the wallet to burn NFTS from
     * const account = "0x...";
     * // The token ID to burn NFTs of
     * const tokenId = 0;
     * // The amount of this NFT you want to burn
     * const amount = 2;
     *
     * const result = await contract.erc1155.burnFrom(account, tokenId, amount);
     * ```
     * @twfeature ERC1155Burnable
     */
    __publicField(this, "burnFrom", buildTransactionFunction(async (account, tokenId, amount) => {
      return assertEnabled(this.burnable, FEATURE_EDITION_BURNABLE).from.prepare(account, tokenId, amount);
    }));
    /**
     * Burn a batch of NFTs
     *
     * @remarks Burn the batch NFTs from the connected wallet
     *
     * @param tokenIds - the tokenIds to burn
     * @param amounts - amount of each token to burn
     *
     * @example
     * ```javascript
     * // The token IDs to burn NFTs of
     * const tokenIds = [0, 1];
     * // The amounts of each NFT you want to burn
     * const amounts = [2, 2];
     *
     * const result = await contract.erc1155.burnBatch(tokenIds, amounts);
     * ```
     * @twfeature ERC1155Burnable
     */
    __publicField(this, "burnBatch", buildTransactionFunction(async (tokenIds, amounts) => {
      return assertEnabled(this.burnable, FEATURE_EDITION_BURNABLE).batch.prepare(tokenIds, amounts);
    }));
    /**
     * Burn a batch of NFTs from a specific wallet
     *
     * @remarks Burn the batch NFTs from the specified wallet
     *
     * @param account - the address to burn NFTs from
     * @param tokenIds - the tokenIds to burn
     * @param amounts - amount of each token to burn
     *
     * @example
     * ```javascript
     * // The address of the wallet to burn NFTS from
     * const account = "0x...";
     * // The token IDs to burn NFTs of
     * const tokenIds = [0, 1];
     * // The amounts of each NFT you want to burn
     * const amounts = [2, 2];
     *
     * const result = await contract.erc1155.burnBatchFrom(account, tokenIds, amounts);
     * ```
     * @twfeature ERC1155Burnable
     */
    __publicField(this, "burnBatchFrom", buildTransactionFunction(async (account, tokenIds, amounts) => {
      return assertEnabled(this.burnable, FEATURE_EDITION_BURNABLE).batchFrom.prepare(account, tokenIds, amounts);
    }));
    ////// ERC721 LazyMint Extension //////
    /**
     * Lazy mint NFTs
     *
     * @remarks Create batch allows you to create a batch of many NFTs in one transaction.
     *
     * @example
     * ```javascript
     * // Custom metadata of the NFTs to create
     * const metadatas = [{
     *   name: "Cool NFT",
     *   description: "This is a cool NFT",
     *   image: fs.readFileSync("path/to/image.png"), // This can be an image url or file
     * }, {
     *   name: "Cool NFT",
     *   description: "This is a cool NFT",
     *   image: fs.readFileSync("path/to/image.png"),
     * }];
     *
     * const results = await contract.erc1155.lazyMint(metadatas); // uploads and creates the NFTs on chain
     * const firstTokenId = results[0].id; // token id of the first created NFT
     * const firstNFT = await results[0].data(); // (optional) fetch details of the first created NFT
     * ```
     *
     * @param metadatas - The metadata to include in the batch.
     * @param options - optional upload progress callback
     * @twfeature ERC1155LazyMintableV1 | ERC1155LazyMintableV2
     */
    __publicField(this, "lazyMint", buildTransactionFunction(async (metadatas, options) => {
      return assertEnabled(this.lazyMintable, FEATURE_EDITION_LAZY_MINTABLE_V2).lazyMint.prepare(metadatas, options);
    }));
    /**
     * Claim NFTs
     *
     * @remarks Let the connected wallet claim NFTs.
     *
     * @example
     * ```javascript
     * const tokenId = 0; // the id of the NFT you want to claim
     * const quantity = 1; // how many NFTs you want to claim
     *
     * const tx = await contract.erc1155.claim(tokenId, quantity);
     * const receipt = tx.receipt; // the transaction receipt
     * ```
     *
     * @param tokenId - Id of the token you want to claim
     * @param quantity - Quantity of the tokens you want to claim
     * @param options - Optional claim verification data (e.g. price, currency, etc...)
     *
     * @returns - Receipt for the transaction
     * @twfeature ERC1155ClaimCustom | ERC1155ClaimPhasesV2 | ERC1155ClaimPhasesV1 | ERC1155ClaimConditionsV2 | ERC1155ClaimConditionsV1
     */
    __publicField(this, "claim", buildTransactionFunction(async (tokenId, quantity, options) => {
      return this.claimTo.prepare(await this.contractWrapper.getSignerAddress(), tokenId, quantity, options);
    }));
    /**
     * Claim NFTs to a specific Wallet
     *
     * @remarks Let the specified wallet claim NFTs.
     *
     * @example
     * ```javascript
     * const address = "{{wallet_address}}"; // address of the wallet you want to claim the NFTs
     * const tokenId = 0; // the id of the NFT you want to claim
     * const quantity = 1; // how many NFTs you want to claim
     *
     * const tx = await contract.erc1155.claimTo(address, tokenId, quantity);
     * const receipt = tx.receipt; // the transaction receipt
     * ```
     *
     * @param destinationAddress - Address you want to send the token to
     * @param tokenId - Id of the token you want to claim
     * @param quantity - Quantity of the tokens you want to claim
     * @param options - Optional claim verification data (e.g. price, currency, etc...)
     *
     * @returns - Receipt for the transaction
     * @twfeature ERC1155ClaimCustom | ERC1155ClaimPhasesV2 | ERC1155ClaimPhasesV1 | ERC1155ClaimConditionsV2 | ERC1155ClaimConditionsV1
     */
    __publicField(this, "claimTo", buildTransactionFunction(async (destinationAddress, tokenId, quantity, options) => {
      const claimWithConditions = this.claimWithConditions;
      const claim = this.claimCustom;
      if (claimWithConditions) {
        return claimWithConditions.to.prepare(destinationAddress, tokenId, quantity, options);
      }
      if (claim) {
        return claim.to.prepare(destinationAddress, tokenId, quantity, options);
      }
      throw new ExtensionNotImplementedError(FEATURE_EDITION_CLAIM_CUSTOM);
    }));
    this.contractWrapper = contractWrapper;
    this.storage = storage;
    this.query = this.detectErc1155Enumerable();
    this.mintable = this.detectErc1155Mintable();
    this.burnable = this.detectErc1155Burnable();
    this.lazyMintable = this.detectErc1155LazyMintable();
    this.signatureMintable = this.detectErc1155SignatureMintable();
    this.claimCustom = this.detectErc1155Claimable();
    this.claimWithConditions = this.detectErc1155ClaimableWithConditions();
    this._chainId = chainId;
  }
  get chainId() {
    return this._chainId;
  }
  /**
   * @internal
   */
  onNetworkUpdated(network) {
    this.contractWrapper.updateSignerOrProvider(network);
  }
  getAddress() {
    return this.contractWrapper.address;
  }
  ////// Standard ERC1155 functions //////
  /**
   * Get a single NFT
   *
   * @example
   * ```javascript
   * const tokenId = 0;
   * const nft = await contract.erc1155.get(tokenId);
   * ```
   * @param tokenId - the tokenId of the NFT to retrieve
   * @returns The NFT metadata
   * @twfeature ERC1155
   */
  async get(tokenId) {
    const [supply, metadata] = await Promise.all([this.contractWrapper.read("totalSupply", [tokenId]).catch(() => BigNumber.from(0)), this.getTokenMetadata(tokenId).catch(() => ({
      id: tokenId.toString(),
      uri: "",
      ...FALLBACK_METADATA
    }))]);
    return {
      owner: lib_exports.AddressZero,
      metadata,
      type: "ERC1155",
      supply: supply.toString()
    };
  }
  /**
   * Get the total supply of a specific token
   * @example
   * ```javascript
   * const tokenId = 0;
   * const nft = await contract.erc1155.totalSupply(tokenId);
   * ```
   * @param tokenId - The token ID to get the total supply of
   * @returns the total supply
   * @twfeature ERC1155
   */
  async totalSupply(tokenId) {
    if (detectContractFeature(this.contractWrapper, "ERC1155Supply")) {
      return await this.contractWrapper.read("totalSupply", [tokenId]);
    } else {
      throw new ExtensionNotImplementedError(FEATURE_EDITION_SUPPLY);
    }
  }
  /**
   * Get NFT balance of a specific wallet
   *
   * @remarks Get a wallets NFT balance (number of NFTs in this contract owned by the wallet).
   *
   * @example
   * ```javascript
   * // Address of the wallet to check NFT balance
   * const walletAddress = "{{wallet_address}}";
   * const tokenId = 0; // Id of the NFT to check
   * const balance = await contract.erc1155.balanceOf(walletAddress, tokenId);
   * ```
   * @twfeature ERC1155
   */
  async balanceOf(address, tokenId) {
    return await this.contractWrapper.read("balanceOf", [await resolveAddress(address), tokenId]);
  }
  /**
   * Get NFT balance for the currently connected wallet
   */
  async balance(tokenId) {
    return await this.balanceOf(await this.contractWrapper.getSignerAddress(), tokenId);
  }
  /**
   * Get whether this wallet has approved transfers from the given operator
   * @param address - the wallet address
   * @param operator - the operator address
   */
  async isApproved(address, operator) {
    return await this.contractWrapper.read("isApprovedForAll", [await resolveAddress(address), await resolveAddress(operator)]);
  }
  /**
   * Return the next available token ID to mint
   * @internal
   */
  async nextTokenIdToMint() {
    if (hasFunction("nextTokenIdToMint", this.contractWrapper)) {
      return await this.contractWrapper.read("nextTokenIdToMint", []);
    } else {
      throw new Error("Contract requires the `nextTokenIdToMint` function available to determine the next token ID to mint");
    }
  }
  ////// ERC1155 Enumerable Extension //////
  /**
   * Get all NFTs
   *
   * @remarks Get all the data associated with every NFT in this contract.
   *
   * By default, returns the first 100 NFTs, use queryParams to fetch more.
   *
   * @example
   * ```javascript
   * const nfts = await contract.erc1155.getAll();
   * ```
   * @param queryParams - optional filtering to only fetch a subset of results.
   * @returns The NFT metadata for all NFTs queried.
   * @twfeature ERC1155Enumerable
   */
  async getAll(queryParams) {
    return assertEnabled(this.query, FEATURE_EDITION_ENUMERABLE).all(queryParams);
  }
  /**
   * Get the total number of NFTs minted
   * @remarks This returns the total number of NFTs minted in this contract, **not** the total supply of a given token.
   * @example
   * ```javascript
   * const count = await contract.erc1155.totalCount();
   * console.log(count);
   * ```
   * @returns the total number of NFTs minted in this contract
   * @public
   * @twfeature ERC1155Enumerable
   */
  async totalCount() {
    return assertEnabled(this.query, FEATURE_EDITION_ENUMERABLE).totalCount();
  }
  /**
   * Get the total supply of a specific NFT
   * @remarks This is **not** the sum of supply of all NFTs in the contract.
   *
   * @returns the total number of NFTs minted in this contract
   * @public
   * @twfeature ERC1155Enumerable
   */
  async totalCirculatingSupply(tokenId) {
    return assertEnabled(this.query, FEATURE_EDITION_ENUMERABLE).totalCirculatingSupply(tokenId);
  }
  /**
   * Get all NFTs owned by a specific wallet
   *
   * @remarks Get all the data associated with the NFTs owned by a specific wallet.
   *
   * @example
   * ```javascript
   * // Address of the wallet to get the NFTs of
   * const address = "{{wallet_address}}";
   * const nfts = await contract.erc1155.getOwned(address);
   * ```
   *
   * @returns The NFT metadata for all NFTs in the contract.
   * @twfeature ERC1155Enumerable
   */
  async getOwned(walletAddress) {
    if (walletAddress) {
      walletAddress = await resolveAddress(walletAddress);
    }
    return assertEnabled(this.query, FEATURE_EDITION_ENUMERABLE).owned(walletAddress);
  }
  /**
   * Construct a mint transaction without executing it.
   * This is useful for estimating the gas cost of a mint transaction, overriding transaction options and having fine grained control over the transaction execution.
   * @param receiver - Address you want to send the token to
   * @param metadataWithSupply - The metadata of the NFT you want to mint
   *
   * @deprecated Use `contract.erc1155.mint.prepare(...args)` instead
   * @twfeature ERC1155Mintable
   */
  async getMintTransaction(receiver, metadataWithSupply) {
    return assertEnabled(this.mintable, FEATURE_EDITION_MINTABLE).getMintTransaction(receiver, metadataWithSupply);
  }
  ////// ERC1155 Claimable Extension //////
  /**
   * Construct a claim transaction without executing it.
   * This is useful for estimating the gas cost of a claim transaction, overriding transaction options and having fine grained control over the transaction execution.
   * @param destinationAddress - Address you want to send the token to
   * @param tokenId - Id of the token you want to claim
   * @param quantity - Quantity of the tokens you want to claim
   * @param options - Optional claim verification data (e.g. price, currency, etc...)
   *
   * @deprecated Use `contract.erc1155.claim.prepare(...args)` instead
   */
  async getClaimTransaction(destinationAddress, tokenId, quantity, options) {
    const claimWithConditions = this.claimWithConditions;
    const claim = this.claimCustom;
    if (claimWithConditions) {
      return claimWithConditions.conditions.getClaimTransaction(destinationAddress, tokenId, quantity, options);
    }
    if (claim) {
      return claim.getClaimTransaction(destinationAddress, tokenId, quantity, options);
    }
    throw new ExtensionNotImplementedError(FEATURE_EDITION_CLAIM_CUSTOM);
  }
  /**
   * Configure claim conditions
   * @remarks Define who can claim NFTs in the collection, when and how many.
   * @example
   * ```javascript
   * const presaleStartTime = new Date();
   * const publicSaleStartTime = new Date(Date.now() + 60 * 60 * 24 * 1000);
   * const claimConditions = [
   *   {
   *     startTime: presaleStartTime, // start the presale now
   *     maxClaimableSupply: 2, // limit how many mints for this presale
   *     price: 0.01, // presale price
   *     snapshot: ['0x...', '0x...'], // limit minting to only certain addresses
   *   },
   *   {
   *     startTime: publicSaleStartTime, // 24h after presale, start public sale
   *     price: 0.08, // public sale price
   *   }
   * ]);
   * await contract.erc1155.claimConditions.set(tokenId, claimConditions);
   * ```
   * @twfeature ERC1155ClaimPhasesV2 | ERC1155ClaimPhasesV1 | ERC1155ClaimConditionsV2 | ERC1155ClaimConditionsV1
   */
  get claimConditions() {
    return assertEnabled(this.claimWithConditions, FEATURE_EDITION_CLAIM_CONDITIONS_V2).conditions;
  }
  ////// ERC1155 SignatureMintable Extension //////
  /**
   * Mint with signature
   * @remarks Generate dynamic NFTs with your own signature, and let others mint them using that signature.
   * @example
   * ```javascript
   * // see how to craft a payload to sign in the `contract.erc1155.signature.generate()` documentation
   * const signedPayload = contract.erc1155.signature().generate(payload);
   *
   * // now anyone can mint the NFT
   * const tx = contract.erc1155.signature.mint(signedPayload);
   * const receipt = tx.receipt; // the mint transaction receipt
   * const mintedId = tx.id; // the id of the NFT minted
   * ```
   * @twfeature ERC1155SignatureMintable
   */
  get signature() {
    return assertEnabled(this.signatureMintable, FEATURE_EDITION_SIGNATURE_MINTABLE);
  }
  ////// ERC1155 DelayedReveal Extension //////
  /**
   * Mint delayed reveal NFTs
   * @remarks Create a batch of encrypted NFTs that can be revealed at a later time.
   * @example
   * ```javascript
   * // the real NFTs, these will be encrypted until you reveal them
   * const realNFTs = [{
   *   name: "Common NFT #1",
   *   description: "Common NFT, one of many.",
   *   image: fs.readFileSync("path/to/image.png"),
   * }, {
   *   name: "Super Rare NFT #2",
   *   description: "You got a Super Rare NFT!",
   *   image: fs.readFileSync("path/to/image.png"),
   * }];
   * // A placeholder NFT that people will get immediately in their wallet, and will be converted to the real NFT at reveal time
   * const placeholderNFT = {
   *   name: "Hidden NFT",
   *   description: "Will be revealed next week!"
   * };
   * // Create and encrypt the NFTs
   * await contract.erc1155.drop.revealer.createDelayedRevealBatch(
   *   placeholderNFT,
   *   realNFTs,
   *   "my secret password",
   * );
   * // Whenever you're ready, reveal your NFTs at any time
   * const batchId = 0; // the batch to reveal
   * await contract.erc1155.revealer.reveal(batchId, "my secret password");
   * ```
   * @twfeature ERC1155Revealable
   */
  get revealer() {
    var _a;
    return assertEnabled((_a = this.lazyMintable) == null ? void 0 : _a.revealer, FEATURE_EDITION_REVEALABLE);
  }
  /** ******************************
   * PRIVATE FUNCTIONS
   *******************************/
  /**
   * @internal
   * @param tokenId - the token Id to fetch
   */
  async getTokenMetadata(tokenId) {
    const tokenUri = await this.contractWrapper.read("uri", [tokenId]);
    if (!tokenUri) {
      throw new NotFoundError();
    }
    return fetchTokenMetadata(tokenId, tokenUri, this.storage);
  }
  detectErc1155Enumerable() {
    if (detectContractFeature(this.contractWrapper, "ERC1155Enumerable")) {
      return new Erc1155Enumerable(this, this.contractWrapper);
    }
  }
  detectErc1155Mintable() {
    if (detectContractFeature(this.contractWrapper, "ERC1155Mintable")) {
      return new Erc1155Mintable(this, this.contractWrapper, this.storage);
    }
    return void 0;
  }
  detectErc1155Burnable() {
    if (detectContractFeature(this.contractWrapper, "ERC1155Burnable")) {
      return new Erc1155Burnable(this.contractWrapper);
    }
    return void 0;
  }
  detectErc1155LazyMintable() {
    if (detectContractFeature(this.contractWrapper, "ERC1155LazyMintableV1") || detectContractFeature(this.contractWrapper, "ERC1155LazyMintableV2")) {
      return new Erc1155LazyMintable(this, this.contractWrapper, this.storage);
    }
    return void 0;
  }
  detectErc1155SignatureMintable() {
    if (detectContractFeature(this.contractWrapper, "ERC1155SignatureMintable")) {
      return new Erc1155SignatureMintable(this.contractWrapper, this.storage);
    }
    return void 0;
  }
  detectErc1155Claimable() {
    if (detectContractFeature(this.contractWrapper, "ERC1155ClaimCustom")) {
      return new ERC1155Claimable(this.contractWrapper);
    }
    return void 0;
  }
  detectErc1155ClaimableWithConditions() {
    if (detectContractFeature(this.contractWrapper, "ERC1155ClaimConditionsV1") || detectContractFeature(this.contractWrapper, "ERC1155ClaimConditionsV2") || detectContractFeature(this.contractWrapper, "ERC1155ClaimPhasesV1") || detectContractFeature(this.contractWrapper, "ERC1155ClaimPhasesV2")) {
      return new Erc1155ClaimableWithConditions(this.contractWrapper, this.storage);
    }
    return void 0;
  }
};
function cleanCurrencyAddress(currencyAddress) {
  if (isNativeToken(currencyAddress)) {
    return NATIVE_TOKEN_ADDRESS;
  }
  return currencyAddress;
}
async function isTokenApprovedForTransfer(provider2, transferrerContractAddress, assetContract, tokenId, owner) {
  try {
    const erc165 = new Contract(assetContract, IERC165_default, provider2);
    const isERC721 = await erc165.supportsInterface(InterfaceId_IERC721);
    const isERC1155 = await erc165.supportsInterface(InterfaceId_IERC1155);
    if (isERC721) {
      const asset = new Contract(assetContract, IERC721_default, provider2);
      const approved = await asset.isApprovedForAll(owner, transferrerContractAddress);
      if (approved) {
        return true;
      }
      let approvedAddress;
      try {
        approvedAddress = await asset.getApproved(tokenId);
      } catch (e) {
      }
      return (approvedAddress == null ? void 0 : approvedAddress.toLowerCase()) === transferrerContractAddress.toLowerCase();
    } else if (isERC1155) {
      const asset = new Contract(assetContract, IERC1155_default, provider2);
      return await asset.isApprovedForAll(owner, transferrerContractAddress);
    } else {
      console.error("Contract does not implement ERC 1155 or ERC 721.");
      return false;
    }
  } catch (err) {
    console.error("Failed to check if token is approved", err);
    return false;
  }
}
async function handleTokenApproval(contractWrapper, marketplaceAddress, assetContract, tokenId, from) {
  const erc165 = new ContractWrapper(contractWrapper.getSignerOrProvider(), assetContract, IERC165_default, contractWrapper.options, contractWrapper.storage);
  const isERC721 = await erc165.read("supportsInterface", [InterfaceId_IERC721]);
  const isERC1155 = await erc165.read("supportsInterface", [InterfaceId_IERC1155]);
  if (isERC721) {
    const asset = new ContractWrapper(contractWrapper.getSignerOrProvider(), assetContract, IERC721_default, contractWrapper.options, contractWrapper.storage);
    const approved = await asset.read("isApprovedForAll", [from, marketplaceAddress]);
    if (!approved) {
      const isTokenApproved = (await asset.read("getApproved", [tokenId])).toLowerCase() === marketplaceAddress.toLowerCase();
      if (!isTokenApproved) {
        await asset.sendTransaction("setApprovalForAll", [marketplaceAddress, true]);
      }
    }
  } else if (isERC1155) {
    const asset = new ContractWrapper(contractWrapper.getSignerOrProvider(), assetContract, IERC1155_default, contractWrapper.options, contractWrapper.storage);
    const approved = await asset.read("isApprovedForAll", [from, marketplaceAddress]);
    if (!approved) {
      await asset.sendTransaction("setApprovalForAll", [marketplaceAddress, true]);
    }
  } else {
    throw Error("Contract must implement ERC 1155 or ERC 721.");
  }
}
function validateNewListingParam(param) {
  invariant(param.assetContractAddress !== void 0 && param.assetContractAddress !== null, "Asset contract address is required");
  invariant(param.buyoutPricePerToken !== void 0 && param.buyoutPricePerToken !== null, "Buyout price is required");
  invariant(param.listingDurationInSeconds !== void 0 && param.listingDurationInSeconds !== null, "Listing duration is required");
  invariant(param.startTimestamp !== void 0 && param.startTimestamp !== null, "Start time is required");
  invariant(param.tokenId !== void 0 && param.tokenId !== null, "Token ID is required");
  invariant(param.quantity !== void 0 && param.quantity !== null, "Quantity is required");
  switch (param.type) {
    case "NewAuctionListing": {
      invariant(param.reservePricePerToken !== void 0 && param.reservePricePerToken !== null, "Reserve price is required");
    }
  }
}
async function mapOffer(provider2, listingId, offer) {
  return {
    quantity: offer.quantityDesired,
    pricePerToken: offer.pricePerToken,
    currencyContractAddress: offer.currency,
    buyerAddress: offer.offeror,
    quantityDesired: offer.quantityWanted,
    currencyValue: await fetchCurrencyValue(provider2, offer.currency, offer.quantityWanted.mul(offer.pricePerToken)),
    listingId
  };
}
function isWinningBid(winningPrice, newBidPrice, bidBuffer) {
  bidBuffer = BigNumber.from(bidBuffer);
  winningPrice = BigNumber.from(winningPrice);
  newBidPrice = BigNumber.from(newBidPrice);
  if (winningPrice.eq(BigNumber.from(0))) {
    return false;
  }
  const buffer = newBidPrice.sub(winningPrice).mul(MAX_BPS).div(winningPrice);
  return buffer.gte(bidBuffer);
}
async function getAllInBatches(start, end, fn) {
  const batches = [];
  while (end - start > DEFAULT_QUERY_ALL_COUNT) {
    batches.push(fn(start, start + DEFAULT_QUERY_ALL_COUNT - 1));
    start += DEFAULT_QUERY_ALL_COUNT;
  }
  batches.push(fn(start, end - 1));
  return await Promise.all(batches);
}
var ContractEvents = class {
  constructor(contractWrapper) {
    this.contractWrapper = contractWrapper;
  }
  /**
   * Subscribe to transactions in this contract.
   * @remarks Will emit an "event" object containing the transaction status ('submitted' and 'completed') and hash
   * @example
   * ```javascript
   * contract.events.addTransactionListener((event) => {
   *   console.log(event);
   * }
   * ```
   * @param listener - the callback function that will be called on every transaction
   * @public
   */
  addTransactionListener(listener) {
    this.contractWrapper.addListener(EventType.Transaction, listener);
  }
  /**
   * Remove a transaction listener
   * @remarks Remove a listener that was added with addTransactionListener
   * @example
   * ```javascript
   * contract.events.removeTransactionListener((event) => {
   *  console.log(event);
   * }
   * ```
   * @param listener - the callback function to remove
   * @public
   */
  removeTransactionListener(listener) {
    this.contractWrapper.off(EventType.Transaction, listener);
  }
  /**
   * Subscribe to contract events
   * @remarks You can add a listener for any contract event to run a function when
   * the event is emitted. For example, if you wanted to listen for a "TokensMinted" event,
   * you could do the following:
   * @example
   * ```javascript
   * contract.events.addEventListener("TokensMinted", (event) => {
   *   console.log(event);
   * });
   * ```
   * @public
   * @param eventName - the event name as defined in the contract
   * @param listener - the callback function that will be called on every new event
   * @returns a function to un-subscribe from the event
   */
  addEventListener(eventName, listener) {
    const event = this.contractWrapper.readContract.interface.getEvent(eventName);
    const address = this.contractWrapper.address;
    const filter = {
      address,
      topics: [this.contractWrapper.readContract.interface.getEventTopic(event)]
    };
    const wrappedListener = (log) => {
      const parsedLog = this.contractWrapper.readContract.interface.parseLog(log);
      listener(this.toContractEvent(parsedLog.eventFragment, parsedLog.args, log));
    };
    this.contractWrapper.getProvider().on(filter, wrappedListener);
    return () => {
      this.contractWrapper.getProvider().off(filter, wrappedListener);
    };
  }
  /**
   * Listen to all events emitted from this contract
   *
   * @example
   * ```javascript
   * contract.events.listenToAllEvents((event) => {
   *   console.log(event.eventName) // the name of the emitted event
   *   console.log(event.data) // event payload
   * }
   * ```
   * @public
   * @param listener - the callback function that will be called on every new event
   * @returns A function that can be called to stop listening to events
   */
  listenToAllEvents(listener) {
    const address = this.contractWrapper.address;
    const filter = {
      address
    };
    const wrappedListener = (log) => {
      try {
        const parsedLog = this.contractWrapper.readContract.interface.parseLog(log);
        listener(this.toContractEvent(parsedLog.eventFragment, parsedLog.args, log));
      } catch (e) {
        console.error("Could not parse event:", log, e);
      }
    };
    this.contractWrapper.getProvider().on(filter, wrappedListener);
    return () => {
      this.contractWrapper.getProvider().off(filter, wrappedListener);
    };
  }
  /**
   * Remove an event listener from this contract
   * @remarks Remove a listener that was added with addEventListener
   * @example
   * ```javascript
   * contract.events.removeEventListener("TokensMinted", (event) => {
   *   console.log(event);
   * });
   * ```
   * @public
   * @param eventName - the event name as defined in the contract
   * @param listener - the listener to unregister
   */
  removeEventListener(eventName, listener) {
    const event = this.contractWrapper.readContract.interface.getEvent(eventName);
    this.contractWrapper.readContract.off(event.name, listener);
  }
  /**
   * Remove all listeners on this contract
   * @remarks Remove all listeners from a contract
   * @example
   * ```javascript
   * contract.events.removeAllListeners();
   * ```
   * @public
   */
  removeAllListeners() {
    this.contractWrapper.readContract.removeAllListeners();
    const address = this.contractWrapper.address;
    const filter = {
      address
    };
    this.contractWrapper.getProvider().removeAllListeners(filter);
  }
  /**
   * Get All Events
   * @remarks Get a list of all the events emitted from this contract during the specified time period
   * @example
   * ```javascript
   * // Optionally pass in filters to limit the blocks from which events are retrieved
   * const filters = {
   *   fromBlock: 0,
   *   toBlock: 1000000,
   * }
   * const events = await contract.events.getAllEvents(filters);
   * console.log(events[0].eventName);
   * console.log(events[0].data);
   * ```
   *
   * @param filters - Specify the from and to block numbers to get events for, defaults to all blocks
   * @returns The event objects of the events emitted with event names and data for each event
   */
  async getAllEvents() {
    let filters = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {
      fromBlock: 0,
      toBlock: "latest",
      order: "desc"
    };
    const events = await this.contractWrapper.readContract.queryFilter({}, filters.fromBlock, filters.toBlock);
    const orderedEvents = events.sort((a, b) => {
      return filters.order === "desc" ? b.blockNumber - a.blockNumber : a.blockNumber - b.blockNumber;
    });
    return this.parseEvents(orderedEvents);
  }
  /**
   * Get Events
   * @remarks Get a list of the events of a specific type emitted from this contract during the specified time period
   * @example
   * ```javascript
   * // The name of the event to get logs for
   * const eventName = "Transfer";
   *
   * // Optionally pass in options to limit the blocks from which events are retrieved
   * const options = {
   *   fromBlock: 0,
   *   toBlock: 1000000, // can also pass "latest"
   *   order: "desc",
   *   // Configure event filters (filter on indexed event parameters)
   *   filters: {
   *     from: "0x...",
   *     to: "0x..."
   *   }
   * };
   *
   * const events = await contract.events.getEvents(eventName, options);
   * console.log(events[0].eventName);
   * console.log(events[0].data);
   * ```
   *
   * @param eventName - The name of the event to get logs for
   * @param options - Specify the from and to block numbers to get events for, defaults to all blocks. @see EventQueryOptions
   * @returns The requested event objects with event data
   */
  async getEvents(eventName) {
    let options = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {
      fromBlock: 0,
      toBlock: "latest",
      order: "desc"
    };
    const eventInterface = this.contractWrapper.readContract.interface.getEvent(eventName);
    const args = options.filters ? eventInterface.inputs.map((e) => options.filters[e.name]) : [];
    const filter = this.contractWrapper.readContract.filters[eventInterface.name](...args);
    const events = await this.contractWrapper.readContract.queryFilter(filter, options.fromBlock, options.toBlock);
    const orderedEvents = events.sort((a, b) => {
      return options.order === "desc" ? b.blockNumber - a.blockNumber : a.blockNumber - b.blockNumber;
    });
    return this.parseEvents(orderedEvents);
  }
  parseEvents(events) {
    return events.map((e) => {
      const transaction = Object.fromEntries(Object.entries(e).filter((a) => typeof a[1] !== "function" && a[0] !== "args"));
      if (e.args) {
        const entries = Object.entries(e.args);
        const args = entries.slice(entries.length / 2, entries.length);
        const data = {};
        for (const [key, value] of args) {
          data[key] = value;
        }
        return {
          eventName: e.event || "",
          data,
          transaction
        };
      }
      return {
        eventName: e.event || "",
        data: {},
        transaction
      };
    });
  }
  toContractEvent(event, args, rawLog) {
    const transaction = Object.fromEntries(Object.entries(rawLog).filter((a) => typeof a[1] !== "function" && a[0] !== "args"));
    const results = {};
    event.inputs.forEach((param, index) => {
      if (Array.isArray(args[index])) {
        const components = param.components;
        if (components) {
          const arr = args[index];
          if (param.type === "tuple[]") {
            const objArray = [];
            for (let i = 0; i < arr.length; i++) {
              const tuple = arr[i];
              const obj = {};
              for (let j = 0; j < components.length; j++) {
                const name = components[j].name;
                obj[name] = tuple[j];
              }
              objArray.push(obj);
            }
            results[param.name] = objArray;
          } else {
            const obj = {};
            for (let i = 0; i < components.length; i++) {
              const name = components[i].name;
              obj[name] = arr[i];
            }
            results[param.name] = obj;
          }
        }
      } else {
        results[param.name] = args[index];
      }
    });
    return {
      eventName: event.name,
      data: results,
      transaction
    };
  }
};
var DirectListingInputParamsSchema = (() => z.object({
  /**
   * The address of the asset being listed.
   */
  assetContractAddress: AddressOrEnsSchema,
  /**
   * The ID of the token to list.
   */
  tokenId: BigNumberishSchema,
  /**
   * The quantity of tokens to include in the listing.
   *
   * For ERC721s, this value should always be 1 (and will be forced internally regardless of what is passed here).
   */
  quantity: BigNumberishSchema.default(1),
  /**
   * The address of the currency to accept for the listing.
   */
  currencyContractAddress: AddressOrEnsSchema.default(NATIVE_TOKEN_ADDRESS),
  /**
   * The price to pay per unit of NFTs listed.
   */
  pricePerToken: AmountSchema,
  /**
   * The start time of the listing.
   */
  startTimestamp: RawDateSchema.default(/* @__PURE__ */ new Date()),
  /**
   * The end time of the listing.
   */
  endTimestamp: EndDateSchema,
  /**
   * Whether the listing is reserved to be bought from a specific set of buyers.
   */
  isReservedListing: z.boolean().default(false)
}))();
var ContractInterceptor = class {
  constructor(contractWrapper) {
    this.contractWrapper = contractWrapper;
  }
  /**
   * The next transaction executed will add/replace any overrides passed via the passed in hook.
   * @remarks Overridden values will be applied to the next transaction executed.
   * @example
   * ```javascript
   * contract.interceptor.overrideNextTransaction(() => ({
   *   gasLimit: 3000000,
   * }));
   * ```
   * @param hook - the hook to add or replace any CallOverrides (gas limit, gas price, nonce, from, value, etc...)
   * @public
   */
  overrideNextTransaction(hook) {
    this.contractWrapper.withTransactionOverride(hook);
  }
};
var GasCostEstimator = class {
  constructor(contractWrapper) {
    this.contractWrapper = contractWrapper;
  }
  /**
   * Estimates the cost of gas in native token of the current chain
   * Pass in the same parameters as the contract's function.
   * @remarks Estimate the cost of gas in native token of the current chain
   * @example
   * ```javascript
   * const costOfClaim = await nftDrop?.estimator.gasCostOf("claim", [
   *   "0x...", // receiver
   *   1, // quantity
   *   "0x...", // currency
   *   1, // price per token
   *   [], // proofs
   *   1, // proof max quantity per transaction
   * ]);
   * ```
   * @returns the estimated price in native currency (ETH, MATIC, etc) of calling this function
   * @public
   */
  async gasCostOf(fn, args) {
    const [price, gasUnits] = await Promise.all([this.contractWrapper.getProvider().getGasPrice(), this.contractWrapper.estimateGas(fn, args)]);
    return utils_exports.formatEther(gasUnits.mul(price));
  }
  /**
   * Estimates the gas limit of a transaction
   * Pass in the same parameters as the contract's function.
   * @remarks Estimates the gas limit of a transaction
   * @example
   * ```javascript
   * const gasLimitOfClaim = await nftDrop?.estimator.gasLimitOf("claim", [
   *   "0x...", // receiver
   *   1, // quantity
   *   "0x...", // currency
   *   1, // price per token
   *   [], // proofs
   *   1, // proof max quantity per transaction
   * ]);
   * ```
   * @returns the estimated gas limit of the transaction
   * @public
   */
  async gasLimitOf(fn, args) {
    return this.contractWrapper.estimateGas(fn, args);
  }
  /**
   * Returns the current gas price in gwei
   * @remarks Get the current gas price in gwei
   * @example
   * ```javascript
   * const gasCostInGwei = await contract.estimator.currentGasPriceInGwei();
   * ```
   * @returns the current gas price in gwei
   * @public
   */
  async currentGasPriceInGwei() {
    const price = await this.contractWrapper.getProvider().getGasPrice();
    return utils_exports.formatUnits(price, "gwei");
  }
};
var MarketplaceV3DirectListings = class {
  // utilities
  constructor(contractWrapper, storage) {
    __publicField(this, "featureName", FEATURE_DIRECT_LISTINGS.name);
    /** ******************************
     * WRITE FUNCTIONS
     *******************************/
    /**
     * Create new direct listing
     *
     * @remarks Create a new listing on the marketplace where people can buy an asset directly.
     *
     * @example
     * ```javascript
     * // Data of the listing you want to create
     * const listing = {
     *   // address of the contract the asset you want to list is on
     *   assetContractAddress: "0x...",
     *   // token ID of the asset you want to list
     *   tokenId: "0",
     *   // how many of the asset you want to list
     *   quantity: 1,
     *   // address of the currency contract that will be used to pay for the listing
     *   currencyContractAddress: NATIVE_TOKEN_ADDRESS,
     *   // The price to pay per unit of NFTs listed.
     *   pricePerToken: 1.5,
     *   // when should the listing open up for offers
     *   startTimestamp: new Date(Date.now()),
     *   // how long the listing will be open for
     *   endTimestamp: new Date(Date.now() + 5 * 24 * 60 * 60 * 1000),
     *   // Whether the listing is reserved for a specific set of buyers.
     *   isReservedListing: false
     * }
     *
     * const tx = await contract.directListings.createListing(listing);
     * const receipt = tx.receipt; // the transaction receipt
     * const id = tx.id; // the id of the newly created listing
     * ```
     * @twfeature DirectListings
     */
    __publicField(this, "createListing", buildTransactionFunction(async (listing) => {
      const parsedListing = await DirectListingInputParamsSchema.parseAsync(listing);
      await handleTokenApproval(this.contractWrapper, this.getAddress(), parsedListing.assetContractAddress, parsedListing.tokenId, await this.contractWrapper.getSignerAddress());
      const normalizedPricePerToken = await normalizePriceValue(this.contractWrapper.getProvider(), parsedListing.pricePerToken, parsedListing.currencyContractAddress);
      const block = await this.contractWrapper.getProvider().getBlock("latest");
      const blockTime = block.timestamp;
      if (parsedListing.startTimestamp.lt(blockTime)) {
        parsedListing.startTimestamp = BigNumber.from(blockTime);
      }
      return Transaction.fromContractWrapper({
        contractWrapper: this.contractWrapper,
        method: "createListing",
        args: [{
          assetContract: parsedListing.assetContractAddress,
          tokenId: parsedListing.tokenId,
          quantity: parsedListing.quantity,
          currency: cleanCurrencyAddress(parsedListing.currencyContractAddress),
          pricePerToken: normalizedPricePerToken,
          startTimestamp: parsedListing.startTimestamp,
          endTimestamp: parsedListing.endTimestamp,
          reserved: parsedListing.isReservedListing
        }],
        parse: (receipt) => {
          const event = this.contractWrapper.parseLogs("NewListing", receipt == null ? void 0 : receipt.logs);
          return {
            id: event[0].args.listingId,
            receipt
          };
        }
      });
    }));
    /**
     * Create a batch of new listings
     *
     * @remarks Create a batch of new listings on the marketplace
     *
     * @example
     * ```javascript
     * const listings = [...];
     * const tx = await contract.directListings.createListingsBatch(listings);
     * ```
     */
    __publicField(this, "createListingsBatch", buildTransactionFunction(async (listings) => {
      const data = await Promise.all(listings.map(async (listing) => {
        const tx = await this.createListing.prepare(listing);
        return tx.encode();
      }));
      return Transaction.fromContractWrapper({
        contractWrapper: this.contractWrapper,
        method: "multicall",
        args: [data],
        parse: (receipt) => {
          const events = this.contractWrapper.parseLogs("NewListing", receipt == null ? void 0 : receipt.logs);
          return events.map((event) => {
            return {
              id: event.args.listingId,
              receipt
            };
          });
        }
      });
    }));
    /**
     * Update a direct listing
     *
     * @param listing - the new listing information
     *
     * @example
     * ```javascript
     * // Data of the listing you want to update
     *
     * const listingId = 0; // ID of the listing you want to update
     *
     * const listing = {
     *   // address of the contract the asset you want to list is on
     *   assetContractAddress: "0x...", // should be same as original listing
     *   // token ID of the asset you want to list
     *   tokenId: "0", // should be same as original listing
     *   // how many of the asset you want to list
     *   quantity: 1,
     *   // address of the currency contract that will be used to pay for the listing
     *   currencyContractAddress: NATIVE_TOKEN_ADDRESS,
     *   // The price to pay per unit of NFTs listed.
     *   pricePerToken: 1.5,
     *   // when should the listing open up for offers
     *   startTimestamp: new Date(Date.now()), // can't change this if listing already active
     *   // how long the listing will be open for
     *   endTimestamp: new Date(Date.now() + 5 * 24 * 60 * 60 * 1000),
     *   // Whether the listing is reserved for a specific set of buyers.
     *   isReservedListing: false
     * }
     *
     * const tx = await contract.directListings.updateListing(listingId, listing);
     * const receipt = tx.receipt; // the transaction receipt
     * const id = tx.id; // the id of the newly created listing
     * ```
     * @twfeature DirectListings
     */
    __publicField(this, "updateListing", buildTransactionFunction(async (listingId, listing) => {
      const parsedListing = await DirectListingInputParamsSchema.parseAsync(listing);
      await handleTokenApproval(this.contractWrapper, this.getAddress(), parsedListing.assetContractAddress, parsedListing.tokenId, await this.contractWrapper.getSignerAddress());
      const normalizedPricePerToken = await normalizePriceValue(this.contractWrapper.getProvider(), parsedListing.pricePerToken, parsedListing.currencyContractAddress);
      return Transaction.fromContractWrapper({
        contractWrapper: this.contractWrapper,
        method: "updateListing",
        args: [listingId, {
          assetContract: parsedListing.assetContractAddress,
          tokenId: parsedListing.tokenId,
          quantity: parsedListing.quantity,
          currency: cleanCurrencyAddress(parsedListing.currencyContractAddress),
          pricePerToken: normalizedPricePerToken,
          startTimestamp: parsedListing.startTimestamp,
          endTimestamp: parsedListing.endTimestamp,
          reserved: parsedListing.isReservedListing
        }],
        parse: (receipt) => {
          const event = this.contractWrapper.parseLogs("UpdatedListing", receipt == null ? void 0 : receipt.logs);
          return {
            id: event[0].args.listingId,
            receipt
          };
        }
      });
    }));
    /**
     * Cancel Direct Listing
     *
     * @remarks Cancel a direct listing on the marketplace
     *
     * @example
     * ```javascript
     * // The listing ID of the direct listing you want to cancel
     * const listingId = 0;
     *
     * await contract.directListings.cancelListing(listingId);
     * ```
     * @twfeature DirectListings
     */
    __publicField(this, "cancelListing", buildTransactionFunction(async (listingId) => {
      return Transaction.fromContractWrapper({
        contractWrapper: this.contractWrapper,
        method: "cancelListing",
        args: [listingId]
      });
    }));
    /**
     * Buy direct listing for a specific wallet
     *
     * @remarks Buy from a specific direct listing from the marketplace.
     *
     * @example
     * ```javascript
     * // The ID of the listing you want to buy from
     * const listingId = 0;
     * // Quantity of the asset you want to buy
     * const quantityDesired = 1;
     *
     * await contract.directListings.buyFromListing(listingId, quantityDesired, "{{wallet_address}}");
     * ```
     *
     * @param listingId - The listing id to buy
     * @param quantityDesired - the quantity to buy
     * @param receiver - optional receiver of the bought listing if different from the connected wallet
     * @twfeature DirectListings
     */
    __publicField(this, "buyFromListing", buildTransactionFunction(async (listingId, quantityDesired, receiver) => {
      if (receiver) {
        receiver = await resolveAddress(receiver);
      }
      const listing = await this.validateListing(BigNumber.from(listingId));
      const {
        valid,
        error
      } = await this.isStillValidListing(listing, quantityDesired);
      if (!valid) {
        throw new Error(`Listing ${listingId} is no longer valid. ${error}`);
      }
      const buyFor = receiver ? receiver : await this.contractWrapper.getSignerAddress();
      const quantity = BigNumber.from(quantityDesired);
      const value = BigNumber.from(listing.pricePerToken).mul(quantity);
      const overrides = await this.contractWrapper.getCallOverrides() || {};
      await setErc20Allowance(this.contractWrapper, value, listing.currencyContractAddress, overrides);
      return Transaction.fromContractWrapper({
        contractWrapper: this.contractWrapper,
        method: "buyFromListing",
        args: [listingId, buyFor, quantity, listing.currencyContractAddress, value],
        overrides
      });
    }));
    /**
     * Approve buyer for a reserved direct listing
     *
     * @remarks Approve a buyer to buy from a reserved listing.
     *
     * @example
     * ```javascript
     * // The listing ID of the direct listing you want to approve buyer for
     * const listingId = "0";
     *
     * await contract.directListings.approveBuyerForReservedListing(listingId, "{{wallet_address}}");
     * ```
     *
     * @param listingId - The listing id to buy
     * @param buyer - Address of buyer being approved
     * @twfeature DirectListings
     */
    __publicField(this, "approveBuyerForReservedListing", buildTransactionFunction(async (listingId, buyer) => {
      const isApproved = await this.isBuyerApprovedForListing(listingId, buyer);
      if (!isApproved) {
        return Transaction.fromContractWrapper({
          contractWrapper: this.contractWrapper,
          method: "approveBuyerForListing",
          args: [listingId, buyer, true]
        });
      } else {
        throw new Error(`Buyer ${buyer} already approved for listing ${listingId}.`);
      }
    }));
    /**
     * Revoke approval of a buyer for a reserved direct listing
     *
     * @example
     * ```javascript
     * // The listing ID of the direct listing you want to approve buyer for
     * const listingId = "0";
     *
     * await contract.directListings.revokeBuyerApprovalForReservedListing(listingId, "{{wallet_address}}");
     * ```
     *
     * @param listingId - The listing id to buy
     * @param buyer - Address of buyer being approved
     */
    __publicField(this, "revokeBuyerApprovalForReservedListing", buildTransactionFunction(async (listingId, buyer) => {
      const isApproved = await this.isBuyerApprovedForListing(listingId, buyer);
      if (isApproved) {
        return Transaction.fromContractWrapper({
          contractWrapper: this.contractWrapper,
          method: "approveBuyerForListing",
          args: [listingId, buyer, false]
        });
      } else {
        throw new Error(`Buyer ${buyer} not approved for listing ${listingId}.`);
      }
    }));
    /**
     * Approve a currency for a direct listing
     *
     *
     * @example
     * ```javascript
     * // The listing ID of the direct listing you want to approve currency for
     * const listingId = "0";
     *
     * await contract.directListings.approveCurrencyForListing(listingId, currencyContractAddress, pricePerTokenInCurrency);
     * ```
     *
     * @param listingId - The listing id to buy
     * @param currencyContractAddress - Address of currency being approved
     * @param pricePerTokenInCurrency - Price per token in the currency
     * @twfeature DirectListings
     */
    __publicField(this, "approveCurrencyForListing", buildTransactionFunction(async (listingId, currencyContractAddress, pricePerTokenInCurrency) => {
      const listing = await this.validateListing(BigNumber.from(listingId));
      const resolvedCurrencyAddress = await resolveAddress(currencyContractAddress);
      if (resolvedCurrencyAddress === listing.currencyContractAddress) {
        invariant(pricePerTokenInCurrency === listing.pricePerToken, "Approving listing currency with a different price.");
      }
      const currencyPrice = await this.contractWrapper.read("currencyPriceForListing", [listingId, resolvedCurrencyAddress]);
      invariant(pricePerTokenInCurrency === currencyPrice, "Currency already approved with this price.");
      return Transaction.fromContractWrapper({
        contractWrapper: this.contractWrapper,
        method: "approveCurrencyForListing",
        args: [listingId, resolvedCurrencyAddress, pricePerTokenInCurrency]
      });
    }));
    /**
     * Revoke approval of a currency for a direct listing
     *
     *
     * @example
     * ```javascript
     * // The listing ID of the direct listing you want to revoke currency for
     * const listingId = "0";
     *
     * await contract.directListings.revokeCurrencyApprovalForListing(listingId, currencyContractAddress);
     * ```
     *
     * @param listingId - The listing id to buy
     * @param currencyContractAddress - Address of currency
     * @twfeature DirectListings
     */
    __publicField(this, "revokeCurrencyApprovalForListing", buildTransactionFunction(async (listingId, currencyContractAddress) => {
      const listing = await this.validateListing(BigNumber.from(listingId));
      const resolvedCurrencyAddress = await resolveAddress(currencyContractAddress);
      if (resolvedCurrencyAddress === listing.currencyContractAddress) {
        throw new Error(`Can't revoke approval for main listing currency.`);
      }
      const currencyPrice = await this.contractWrapper.read("currencyPriceForListing", [listingId, resolvedCurrencyAddress]);
      invariant(!currencyPrice.isZero(), "Currency not approved.");
      return Transaction.fromContractWrapper({
        contractWrapper: this.contractWrapper,
        method: "approveCurrencyForListing",
        args: [listingId, resolvedCurrencyAddress, BigNumber.from(0)]
      });
    }));
    this.contractWrapper = contractWrapper;
    this.storage = storage;
    this.events = new ContractEvents(this.contractWrapper);
    this.encoder = new ContractEncoder(this.contractWrapper);
    this.interceptor = new ContractInterceptor(this.contractWrapper);
    this.estimator = new GasCostEstimator(this.contractWrapper);
  }
  getAddress() {
    return this.contractWrapper.address;
  }
  /** ******************************
   * READ FUNCTIONS
   *******************************/
  /**
   * Get the total number of direct listings
   *
   * @returns Returns the total number of direct listings created.
   * @public
   *
   * @example
   * ```javascript
   * const totalListings = await contract.directListings.getTotalCount();
   * ```
   * @twfeature DirectListings
   */
  async getTotalCount() {
    return await this.contractWrapper.read("totalListings", []);
  }
  /**
   * Get all direct listings
   *
   * @example
   * ```javascript
   * const listings = await contract.directListings.getAll();
   * ```
   *
   * @param filter - optional filter parameters
   * @returns the Direct listing object array
   * @twfeature DirectListings
   */
  async getAll(filter) {
    const totalListings = await this.getTotalCount();
    const start = BigNumber.from((filter == null ? void 0 : filter.start) || 0).toNumber();
    const end = totalListings.toNumber();
    if (end === 0) {
      throw new Error(`No listings exist on the contract.`);
    }
    let rawListings = [];
    const batches = await getAllInBatches(start, end, (startId, endId) => this.contractWrapper.read("getAllListings", [startId, endId]));
    rawListings = batches.flat();
    const filteredListings = await this.applyFilter(rawListings, filter);
    return await Promise.all(filteredListings.map((listing) => this.mapListing(listing)));
  }
  /**
   * Get all valid direct listings
   *
   * @remarks A valid listing is where the listing is active, and the creator still owns & has approved Marketplace to transfer the listed NFTs.
   *
   * @example
   * ```javascript
   * const listings = await contract.directListings.getAllValid();
   * ```
   *
   * @param filter - optional filter parameters
   * @returns the Direct listing object array
   * @twfeature DirectListings
   */
  async getAllValid(filter) {
    const totalListings = await this.getTotalCount();
    const start = BigNumber.from((filter == null ? void 0 : filter.start) || 0).toNumber();
    const end = totalListings.toNumber();
    if (end === 0) {
      throw new Error(`No listings exist on the contract.`);
    }
    let rawListings = [];
    const batches = await getAllInBatches(start, end, (startId, endId) => this.contractWrapper.read("getAllValidListings", [startId, endId]));
    rawListings = batches.flat();
    const filteredListings = await this.applyFilter(rawListings, filter);
    return await Promise.all(filteredListings.map((listing) => this.mapListing(listing)));
  }
  /**
   * Get a single direct listing
   *
   * @example
   * ```javascript
   * const listingId = 0;
   * const listing = await contract.directListings.getListing(listingId);
   * ```
   *
   * @param listingId - the listing id
   * @returns the Direct listing object
   *
   * @example
   * ```javascript
   * const listingId = 0;
   * const listing = await contract.directListings.getListing(listingId);
   * ```
   * @twfeature DirectListings
   */
  async getListing(listingId) {
    const listing = await this.contractWrapper.read("getListing", [listingId]);
    return await this.mapListing(listing);
  }
  /**
   * Check if a buyer is approved for a specific direct listing
   *
   * @example
   * ```javascript
   * const listingId = 0;
   * const isBuyerApproved = await contract.directListings.isBuyerApprovedForListing(listingId, "{{wallet_address}}");
   *
   * @param listingId - the listing id
   * @param buyer - buyer address
   * @twfeature DirectListings
   */
  async isBuyerApprovedForListing(listingId, buyer) {
    const listing = await this.validateListing(BigNumber.from(listingId));
    if (!listing.isReservedListing) {
      throw new Error(`Listing ${listingId} is not a reserved listing.`);
    }
    return await this.contractWrapper.read("isBuyerApprovedForListing", [listingId, await resolveAddress(buyer)]);
  }
  /**
   * Check if a currency is approved for a specific direct listing
   *
   * @example
   * ```javascript
   * const listingId = 0;
   * const currencyContractAddress = '0x1234';
   * const isApproved = await contract.directListings.isCurrencyApprovedForListing(listingId, currencyContractAddress);
   * ```
   *
   * @param listingId - the listing id
   * @param currency - currency address
   * @twfeature DirectListings
   */
  async isCurrencyApprovedForListing(listingId, currency) {
    await this.validateListing(BigNumber.from(listingId));
    return await this.contractWrapper.read("isCurrencyApprovedForListing", [listingId, await resolveAddress(currency)]);
  }
  /**
   * Check price per token for an approved currency
   *
   * @example
   * ```javascript
   * const listingId = 0;
   * const currencyContractAddress = '0x1234';
   * const price = await contract.directListings.currencyPriceForListing(listingId, currencyContractAddress);
   * ```
   *
   * @param listingId - the listing id
   * @param currencyContractAddress - currency contract address
   * @twfeature DirectListings
   */
  async currencyPriceForListing(listingId, currencyContractAddress) {
    const listing = await this.validateListing(BigNumber.from(listingId));
    const resolvedCurrencyAddress = await resolveAddress(currencyContractAddress);
    if (resolvedCurrencyAddress === listing.currencyContractAddress) {
      return listing.pricePerToken;
    }
    const isApprovedCurrency = await this.isCurrencyApprovedForListing(listingId, resolvedCurrencyAddress);
    if (!isApprovedCurrency) {
      throw new Error(`Currency ${resolvedCurrencyAddress} is not approved for Listing ${listingId}.`);
    }
    return await this.contractWrapper.read("currencyPriceForListing", [listingId, resolvedCurrencyAddress]);
  }
  /** ******************************
   * PRIVATE FUNCTIONS
   *******************************/
  /**
   * Throws error if listing could not be found
   *
   * @param listingId - Listing to check for
   */
  async validateListing(listingId) {
    try {
      return await this.getListing(listingId);
    } catch (err) {
      console.error(`Error getting the listing with id ${listingId}`);
      throw err;
    }
  }
  /**
   * Helper method maps the auction listing to the direct listing interface.
   *
   * @internal
   * @param listing - The listing to map, as returned from the contract.
   * @returns - The mapped interface.
   */
  async mapListing(listing) {
    let status = Status.UNSET;
    const block = await this.contractWrapper.getProvider().getBlock("latest");
    const blockTime = block.timestamp;
    switch (listing.status) {
      case 1:
        status = BigNumber.from(listing.startTimestamp).gt(blockTime) ? Status.Created : BigNumber.from(listing.endTimestamp).lt(blockTime) ? Status.Expired : Status.Active;
        break;
      case 2:
        status = Status.Completed;
        break;
      case 3:
        status = Status.Cancelled;
        break;
    }
    return {
      assetContractAddress: listing.assetContract,
      currencyContractAddress: listing.currency,
      pricePerToken: listing.pricePerToken.toString(),
      currencyValuePerToken: await fetchCurrencyValue(this.contractWrapper.getProvider(), listing.currency, listing.pricePerToken),
      id: listing.listingId.toString(),
      tokenId: listing.tokenId.toString(),
      quantity: listing.quantity.toString(),
      startTimeInSeconds: BigNumber.from(listing.startTimestamp).toNumber(),
      asset: await fetchTokenMetadataForContract(listing.assetContract, this.contractWrapper.getProvider(), listing.tokenId, this.storage),
      endTimeInSeconds: BigNumber.from(listing.endTimestamp).toNumber(),
      creatorAddress: listing.listingCreator,
      isReservedListing: listing.reserved,
      status
    };
  }
  /**
   * Use this method to check if a direct listing is still valid.
   *
   * Ways a direct listing can become invalid:
   * 1. The asset holder transferred the asset to another wallet
   * 2. The asset holder burned the asset
   * 3. The asset holder removed the approval on the marketplace
   *
   * @internal
   * @param listing - The listing to check.
   * @returns - True if the listing is valid, false otherwise.
   */
  async isStillValidListing(listing, quantity) {
    const approved = await isTokenApprovedForTransfer(this.contractWrapper.getProvider(), this.getAddress(), listing.assetContractAddress, listing.tokenId, listing.creatorAddress);
    if (!approved) {
      return {
        valid: false,
        error: `Token '${listing.tokenId}' from contract '${listing.assetContractAddress}' is not approved for transfer`
      };
    }
    const provider2 = this.contractWrapper.getProvider();
    const erc165 = new Contract(listing.assetContractAddress, IERC165_default, provider2);
    const isERC721 = await erc165.supportsInterface(InterfaceId_IERC721);
    const isERC1155 = await erc165.supportsInterface(InterfaceId_IERC1155);
    if (isERC721) {
      const asset = new Contract(listing.assetContractAddress, IERC721_default, provider2);
      let owner;
      try {
        owner = await asset.ownerOf(listing.tokenId);
      } catch (e) {
      }
      const valid = (owner == null ? void 0 : owner.toLowerCase()) === listing.creatorAddress.toLowerCase();
      return {
        valid,
        error: valid ? void 0 : `Seller is not the owner of Token '${listing.tokenId}' from contract '${listing.assetContractAddress} anymore'`
      };
    } else if (isERC1155) {
      const asset = new Contract(listing.assetContractAddress, IERC1155_default, provider2);
      const balance = await asset.balanceOf(listing.creatorAddress, listing.tokenId);
      const valid = balance.gte(quantity || listing.quantity);
      return {
        valid,
        error: valid ? void 0 : `Seller does not have enough balance of Token '${listing.tokenId}' from contract '${listing.assetContractAddress} to fulfill the listing`
      };
    } else {
      return {
        valid: false,
        error: "Contract does not implement ERC 1155 or ERC 721."
      };
    }
  }
  async applyFilter(listings, filter) {
    let rawListings = [...listings];
    if (filter) {
      if (filter.seller) {
        const resolvedSeller = await resolveAddress(filter.seller);
        rawListings = rawListings.filter((seller) => seller.listingCreator.toString().toLowerCase() === (resolvedSeller == null ? void 0 : resolvedSeller.toString().toLowerCase()));
      }
      if (filter.tokenContract) {
        const resolvedToken = await resolveAddress(filter.tokenContract);
        rawListings = rawListings.filter((tokenContract) => tokenContract.assetContract.toString().toLowerCase() === (resolvedToken == null ? void 0 : resolvedToken.toString().toLowerCase()));
      }
      if (filter.tokenId !== void 0) {
        rawListings = rawListings.filter((tokenContract) => {
          var _a;
          return tokenContract.tokenId.toString() === ((_a = filter == null ? void 0 : filter.tokenId) == null ? void 0 : _a.toString());
        });
      }
    }
    return (filter == null ? void 0 : filter.count) && filter.count < rawListings.length ? rawListings.slice(0, filter.count) : rawListings;
  }
};
var EnglishAuctionInputParamsSchema = (() => z.object({
  /**
   * The address of the asset being auctioned.
   */
  assetContractAddress: AddressOrEnsSchema,
  /**
   * The ID of the token to auction.
   */
  tokenId: BigNumberishSchema,
  /**
   * The quantity of tokens to include in the listing.
   *
   * For ERC721s, this value should always be 1 (and will be forced internally regardless of what is passed here).
   */
  quantity: BigNumberishSchema.default(1),
  /**
   * The address of the currency to accept for the listing.
   */
  currencyContractAddress: AddressOrEnsSchema.default(NATIVE_TOKEN_ADDRESS),
  /**
   * The minimum price that a bid must be in order to be accepted.
   */
  minimumBidAmount: AmountSchema,
  /**
   * The buyout price of the auction.
   */
  buyoutBidAmount: AmountSchema,
  /**
   * This is a buffer e.g. x seconds.
   *
   * If a new winning bid is made less than x seconds before expirationTimestamp, the
   * expirationTimestamp is increased by x seconds.
   */
  timeBufferInSeconds: BigNumberishSchema.default(900),
  // 15 minutes by default
  /**
   * This is a buffer in basis points e.g. x%.
   *
   * To be considered as a new winning bid, a bid must be at least x% greater than
   * the current winning bid.
   */
  bidBufferBps: BigNumberishSchema.default(500),
  // 5% by default
  /**
   * The start time of the auction.
   */
  startTimestamp: RawDateSchema.default(/* @__PURE__ */ new Date()),
  /**
   * The end time of the auction.
   */
  endTimestamp: EndDateSchema
}))();
var MarketplaceV3EnglishAuctions = class {
  // utilities
  constructor(contractWrapper, storage) {
    __publicField(this, "featureName", FEATURE_ENGLISH_AUCTIONS.name);
    /** ******************************
     * WRITE FUNCTIONS
     *******************************/
    /**
     * Create an english auction
     *
     * @remarks Create a new auction where people can bid on an asset.
     *
     * @example
     * ```javascript
     * // Data of the auction you want to create
     * const auction = {
     *   // address of the contract of the asset you want to auction
     *   assetContractAddress: "0x...",
     *   // token ID of the asset you want to auction
     *   tokenId: "0",
     *   // how many of the asset you want to auction
     *   quantity: 1,
     *   // address of the currency contract that will be used to pay for the auctioned tokens
     *   currencyContractAddress: NATIVE_TOKEN_ADDRESS,
     *   // the minimum bid that will be accepted for the token
     *   minimumBidAmount: "1.5",
     *   // how much people would have to bid to instantly buy the asset
     *   buyoutBidAmount: "10",
     *   // If a bid is made less than these many seconds before expiration, the expiration time is increased by this.
     *   timeBufferInSeconds: "900", // 15 minutes by default
     *   // A bid must be at least this much bps greater than the current winning bid
     *   bidBufferBps: "500", // 5% by default
     *   // when should the auction open up for bidding
     *   startTimestamp: new Date(Date.now()),
     *   // end time of auction
     *   endTimestamp: new Date(Date.now() + 5 * 24 * 60 * 60 * 1000),
     * }
     *
     * const tx = await contract.englishAuctions.createAuction(auction);
     * const receipt = tx.receipt; // the transaction receipt
     * const id = tx.id; // the id of the newly created auction
     * ```
     * @param auction - the auction data
     * @returns the transaction hash and the auction id
     * @twfeature EnglishAuctions
     */
    __publicField(this, "createAuction", buildTransactionFunction(async (auction) => {
      const parsedAuction = EnglishAuctionInputParamsSchema.parse(auction);
      await handleTokenApproval(this.contractWrapper, this.getAddress(), parsedAuction.assetContractAddress, parsedAuction.tokenId, await this.contractWrapper.getSignerAddress());
      const normalizedBuyoutAmount = await normalizePriceValue(this.contractWrapper.getProvider(), parsedAuction.buyoutBidAmount, parsedAuction.currencyContractAddress);
      const normalizedMinBidAmount = await normalizePriceValue(this.contractWrapper.getProvider(), parsedAuction.minimumBidAmount, parsedAuction.currencyContractAddress);
      const block = await this.contractWrapper.getProvider().getBlock("latest");
      const blockTime = block.timestamp;
      if (parsedAuction.startTimestamp.lt(blockTime)) {
        parsedAuction.startTimestamp = BigNumber.from(blockTime);
      }
      return Transaction.fromContractWrapper({
        contractWrapper: this.contractWrapper,
        method: "createAuction",
        args: [{
          assetContract: parsedAuction.assetContractAddress,
          tokenId: parsedAuction.tokenId,
          quantity: parsedAuction.quantity,
          currency: cleanCurrencyAddress(parsedAuction.currencyContractAddress),
          minimumBidAmount: normalizedMinBidAmount,
          buyoutBidAmount: normalizedBuyoutAmount,
          timeBufferInSeconds: parsedAuction.timeBufferInSeconds,
          bidBufferBps: parsedAuction.bidBufferBps,
          startTimestamp: parsedAuction.startTimestamp,
          endTimestamp: parsedAuction.endTimestamp
        }],
        parse: (receipt) => {
          const event = this.contractWrapper.parseLogs("NewAuction", receipt.logs)[0];
          return {
            id: event.args.auctionId,
            receipt
          };
        }
      });
    }));
    /**
     * Create a batch of new auctions
     *
     * @remarks Create a batch of new auctions on the marketplace
     *
     * @example
     * ```javascript
     * const auctions = [...];
     * const tx = await contract.englishAuctions.createAuctionsBatch(auctions);
     * ```
     */
    __publicField(this, "createAuctionsBatch", buildTransactionFunction(async (listings) => {
      const data = await Promise.all(listings.map(async (listing) => {
        const tx = await this.createAuction.prepare(listing);
        return tx.encode();
      }));
      return Transaction.fromContractWrapper({
        contractWrapper: this.contractWrapper,
        method: "multicall",
        args: [data],
        parse: (receipt) => {
          const events = this.contractWrapper.parseLogs("NewAuction", receipt == null ? void 0 : receipt.logs);
          return events.map((event) => {
            return {
              id: event.args.auctionId,
              receipt
            };
          });
        }
      });
    }));
    /**
     * Buyout an english auction
     *
     * @remarks Buy a specific auction from the marketplace.
     *
     * @example
     * ```javascript
     * // The auction ID you want to buy
     * const auctionId = 0;
     *
     * await contract.englishAuctions.buyoutAuction(auctionId);
     * ```
     * @param auctionId - the auction id
     * @returns the transaction result
     * @twfeature EnglishAuctions
     */
    __publicField(this, "buyoutAuction", buildTransactionFunction(async (auctionId) => {
      const auction = await this.validateAuction(BigNumber.from(auctionId));
      const currencyMetadata = await fetchCurrencyMetadata(this.contractWrapper.getProvider(), auction.currencyContractAddress);
      return this.makeBid.prepare(auctionId, utils_exports.formatUnits(auction.buyoutBidAmount, currencyMetadata.decimals));
    }));
    /**
     * Bid on an english auction
     *
     * @remarks Make a bid on an auction
     *
     * @example
     * ```javascript
     * // The auction ID of the asset you want to bid on
     * const auctionId = 0;
     * // The total amount you are willing to bid for auctioned tokens
     * const bidAmount = 1;
     *
     * await contract.englishAuctions.makeBid(auctionId, bidAmount);
     * ```
     * @param auctionId - the auction id
     * @param bidAmount - the amount you are willing to bid
     * @returns the transaction result
     * @twfeature EnglishAuctions
     */
    __publicField(this, "makeBid", buildTransactionFunction(async (auctionId, bidAmount) => {
      const auction = await this.validateAuction(BigNumber.from(auctionId));
      const normalizedBidAmount = await normalizePriceValue(this.contractWrapper.getProvider(), bidAmount, auction.currencyContractAddress);
      if (normalizedBidAmount.eq(BigNumber.from(0))) {
        throw new Error("Cannot make a bid with 0 value");
      }
      if (BigNumber.from(auction.buyoutBidAmount).gt(0) && normalizedBidAmount.gt(auction.buyoutBidAmount)) {
        throw new Error("Bid amount must be less than or equal to buyoutBidAmount");
      }
      const winningBid = await this.getWinningBid(auctionId);
      if (winningBid) {
        const isWinnner = await this.isWinningBid(auctionId, normalizedBidAmount);
        invariant(isWinnner, "Bid price is too low based on the current winning bid and the bid buffer");
      } else {
        const tokenPrice = normalizedBidAmount;
        const minimumBidAmount = BigNumber.from(auction.minimumBidAmount);
        invariant(tokenPrice.gte(minimumBidAmount), "Bid price is too low based on minimum bid amount");
      }
      const overrides = await this.contractWrapper.getCallOverrides() || {};
      await setErc20Allowance(this.contractWrapper, normalizedBidAmount, auction.currencyContractAddress, overrides);
      return Transaction.fromContractWrapper({
        contractWrapper: this.contractWrapper,
        method: "bidInAuction",
        args: [auctionId, normalizedBidAmount],
        overrides
      });
    }));
    /**
     * Cancel an english auction
     *
     * @remarks Cancel an auction on the marketplace
     *
     * @example
     * ```javascript
     * // The ID of the auction you want to cancel
     * const auctionId = "0";
     *
     * await contract.englishAuctions.cancelAuction(auctionId);
     * ```
     * @param auctionId - the auction id
     * @returns the transaction result
     * @twfeature EnglishAuctions
     */
    __publicField(this, "cancelAuction", buildTransactionFunction(async (auctionId) => {
      const winningBid = await this.getWinningBid(auctionId);
      if (winningBid) {
        throw new Error(`Bids already made.`);
      }
      return Transaction.fromContractWrapper({
        contractWrapper: this.contractWrapper,
        method: "cancelAuction",
        args: [auctionId]
      });
    }));
    /**
     * Close the english auction for the bidder
     *
     * @remarks Closes the Auction and executes the sale for the buyer.
     *
     * @example
     * ```javascript
     * // The ID of the auction you want to close
     * const auction = "0";
     * await contract.englishAuctions.closeAuctionForBidder(auctionId);
     * ```
     *
     * @param auctionId - the auction id to close
     * @param closeFor - optionally pass the winning bid offeror address to close the auction on their behalf
     * @returns the transaction result
     * @twfeature EnglishAuctions
     */
    __publicField(this, "closeAuctionForBidder", buildTransactionFunction(async (auctionId, closeFor) => {
      if (!closeFor) {
        closeFor = await this.contractWrapper.getSignerAddress();
      }
      const auction = await this.validateAuction(BigNumber.from(auctionId));
      try {
        return Transaction.fromContractWrapper({
          contractWrapper: this.contractWrapper,
          method: "collectAuctionTokens",
          args: [BigNumber.from(auctionId)]
        });
      } catch (err) {
        if (err.message.includes("Marketplace: auction still active.")) {
          throw new AuctionHasNotEndedError(auctionId.toString(), auction.endTimeInSeconds.toString());
        } else {
          throw err;
        }
      }
    }));
    /**
     * Close the english auction for the seller
     *
     * @remarks Closes the Auction and executes the sale for the seller.
     *
     * @example
     * ```javascript
     * // The ID of the auction you want to close
     * const auctionId = "0";
     * await contract.englishAuctions.closeAuctionForSeller(auctionId);
     * ```
     *
     * @param auctionId - the auction id to close
     * @returns the transaction result
     * @twfeature EnglishAuctions
     */
    __publicField(this, "closeAuctionForSeller", buildTransactionFunction(async (auctionId) => {
      const auction = await this.validateAuction(BigNumber.from(auctionId));
      try {
        return Transaction.fromContractWrapper({
          contractWrapper: this.contractWrapper,
          method: "collectAuctionPayout",
          args: [BigNumber.from(auctionId)]
        });
      } catch (err) {
        if (err.message.includes("Marketplace: auction still active.")) {
          throw new AuctionHasNotEndedError(auctionId.toString(), auction.endTimeInSeconds.toString());
        } else {
          throw err;
        }
      }
    }));
    /**
     * Close the english auction for both the seller and the bidder
     *
     * @remarks Closes the Auction and executes the sale for both parties.
     *
     * @example
     * ```javascript
     * // The ID of the auction you want to close
     * const auction = "0";
     * await contract.englishAuctions.executeSale(auctionId);
     * ```
     *
     * @param auctionId - the auction to close
     * @returns the transaction result
     * @twfeature EnglishAuctions
     */
    __publicField(this, "executeSale", buildTransactionFunction(async (auctionId) => {
      const auction = await this.validateAuction(BigNumber.from(auctionId));
      try {
        const winningBid = await this.getWinningBid(auctionId);
        invariant(winningBid, "No winning bid found");
        const closeForSeller = this.encoder.encode("collectAuctionPayout", [auctionId]);
        const closeForBuyer = this.encoder.encode("collectAuctionTokens", [auctionId]);
        return Transaction.fromContractWrapper({
          contractWrapper: this.contractWrapper,
          method: "multicall",
          args: [[closeForSeller, closeForBuyer]]
        });
      } catch (err) {
        if (err.message.includes("Marketplace: auction still active.")) {
          throw new AuctionHasNotEndedError(auctionId.toString(), auction.endTimeInSeconds.toString());
        } else {
          throw err;
        }
      }
    }));
    this.contractWrapper = contractWrapper;
    this.storage = storage;
    this.events = new ContractEvents(this.contractWrapper);
    this.encoder = new ContractEncoder(this.contractWrapper);
    this.interceptor = new ContractInterceptor(this.contractWrapper);
    this.estimator = new GasCostEstimator(this.contractWrapper);
  }
  getAddress() {
    return this.contractWrapper.address;
  }
  /** ******************************
   * READ FUNCTIONS
   *******************************/
  /**
   * Get the total number of english auctions
   *
   * @returns Returns the total number of auctions created.
   * @public
   *
   * @example
   * ```javascript
   * const totalAuctions = await contract.englishAuctions.getTotalCount();
   * ```
   * @twfeature EnglishAuctions
   */
  async getTotalCount() {
    return await this.contractWrapper.read("totalAuctions", []);
  }
  /**
   * Get all english auctions
   *
   * @example
   * ```javascript
   * const auctions = await contract.englishAuctions.getAll();
   * ```
   *
   * @param filter - optional filter parameters
   * @returns the Auction object array
   * @twfeature EnglishAuctions
   */
  async getAll(filter) {
    const totalAuctions = await this.getTotalCount();
    const start = BigNumber.from((filter == null ? void 0 : filter.start) || 0).toNumber();
    const end = totalAuctions.toNumber();
    if (end === 0) {
      throw new Error(`No auctions exist on the contract.`);
    }
    let rawAuctions = [];
    const batches = await getAllInBatches(start, end, (startId, endId) => this.contractWrapper.read("getAllAuctions", [startId, endId]));
    rawAuctions = batches.flat();
    const filteredAuctions = await this.applyFilter(rawAuctions, filter);
    return await Promise.all(filteredAuctions.map((auction) => this.mapAuction(auction)));
  }
  /**
   * Get all valid english auctions
   *
   * @example
   * ```javascript
   * const auctions = await contract.englishAuctions.getAllValid();
   * ```
   *
   * @param filter - optional filter parameters
   * @returns the Auction object array
   * @twfeature EnglishAuctions
   */
  async getAllValid(filter) {
    const totalAuctions = await this.getTotalCount();
    const start = BigNumber.from((filter == null ? void 0 : filter.start) || 0).toNumber();
    const end = totalAuctions.toNumber();
    if (end === 0) {
      throw new Error(`No auctions exist on the contract.`);
    }
    let rawAuctions = [];
    const batches = await getAllInBatches(start, end, (startId, endId) => this.contractWrapper.read("getAllValidAuctions", [startId, endId]));
    rawAuctions = batches.flat();
    const filteredAuctions = await this.applyFilter(rawAuctions, filter);
    return await Promise.all(filteredAuctions.map((auction) => this.mapAuction(auction)));
  }
  /**
   * Get a single english auction
   *
   * @example
   * ```javascript
   * const auctionId = 0;
   * const auction = await contract.englishAuctions.getAuction(auctionId);
   * ```
   *
   * @param auctionId - the auction Id
   * @returns the Auction object
   * @twfeature EnglishAuctions
   */
  async getAuction(auctionId) {
    const auction = await this.contractWrapper.read("getAuction", [auctionId]);
    return await this.mapAuction(auction);
  }
  /**
   * Get winning bid of an english auction
   *
   * @remarks Get the current highest bid of an active auction.
   *
   * @example
   * ```javascript
   * // The ID of the auction
   * const auctionId = 0;
   * const winningBid = await contract.englishAuctions.getWinningBid(auctionId);
   * ```
   * @param auctionId - the auction Id
   * @twfeature EnglishAuctions
   */
  async getWinningBid(auctionId) {
    await this.validateAuction(BigNumber.from(auctionId));
    const bid = await this.contractWrapper.read("getWinningBid", [auctionId]);
    if (bid._bidder === lib_exports.AddressZero) {
      return void 0;
    }
    return await this.mapBid(auctionId.toString(), bid._bidder, bid._currency, bid._bidAmount.toString());
  }
  /**
   * Check if a bid is or will be a winning bid
   *
   * @example
   * ```javascript
   * const auctionId = 0;
   * const bidAmount = 100;
   * const isWinningBid = await contract.englishAuctions.isWinningBid(auctionId, bidAmount);
   * ```
   *
   * @param auctionId - Auction Id
   * @param bidAmount - Amount to bid
   * @returns true if the bid is or will be a winning bid
   * @twfeature EnglishAuctions
   */
  async isWinningBid(auctionId, bidAmount) {
    return await this.contractWrapper.read("isNewWinningBid", [auctionId, bidAmount]);
  }
  /**
   * Get the winner for a specific english auction
   *
   * @remarks Get the winner of the auction after an auction ends.
   *
   * @example
   * ```javascript
   * // The auction ID of a closed english auction
   * const auctionId = 0;
   * const auctionWinner = await contract.englishAuctions.getWinner(auctionId);
   * ```
   * @param auctionId - the auction Id
   * @returns the address of the auction winner
   * @twfeature EnglishAuctions
   */
  async getWinner(auctionId) {
    const auction = await this.validateAuction(BigNumber.from(auctionId));
    const bid = await this.contractWrapper.read("getWinningBid", [auctionId]);
    const now = BigNumber.from(Math.floor(Date.now() / 1e3));
    const endTime = BigNumber.from(auction.endTimeInSeconds);
    if (now.gt(endTime) && bid._bidder !== lib_exports.AddressZero) {
      return bid._bidder;
    }
    const contractEvent = new ContractEvents(this.contractWrapper);
    const closedAuctions = await contractEvent.getEvents("AuctionClosed");
    const closed = closedAuctions.find((a) => a.data.auctionId.eq(BigNumber.from(auctionId)));
    if (!closed) {
      throw new Error(`Could not find auction with ID ${auctionId} in closed auctions`);
    }
    return closed.data.winningBidder;
  }
  /**
   * Get the buffer for an english auction
   *
   * @example
   * ```javascript
   * // The ID of the auction you want to get the buffer for
   * const auctionId = "0";
   * const buffer = await contract.englishAuctions.getBidBufferBps(auctionId);
   * ```
   *
   * @param auctionId - id of the auction
   * @returns the buffer in basis points
   * @twfeature EnglishAuctions
   */
  async getBidBufferBps(auctionId) {
    return (await this.getAuction(auctionId)).bidBufferBps;
  }
  /**
   * Get the minimum next bid for an english auction
   *
   * @example
   * ```javascript
   * // The ID of the auction you want to get the minimum next bid for
   * const auctionId = "0";
   * const minimumNextBid = await contract.englishAuctions.getMinimumNextBid(auctionId);
   * ```
   *
   * @returns the minimum bid a user can place to outbid the previous highest bid
   * @param auctionId - id of the auction
   * @twfeature EnglishAuctions
   */
  async getMinimumNextBid(auctionId) {
    const [currentBidBufferBps, winningBid, auction] = await Promise.all([this.getBidBufferBps(auctionId), this.getWinningBid(auctionId), this.validateAuction(BigNumber.from(auctionId))]);
    const currentBidOrReservePrice = winningBid ? (
      // if there is a winning bid use the value of it
      BigNumber.from(winningBid.bidAmount)
    ) : (
      // if there is no winning bid use the reserve price
      BigNumber.from(auction.minimumBidAmount)
    );
    const minimumNextBid = currentBidOrReservePrice.add(
      // the addition of the current bid and the buffer
      // (have to divide by 10000 to get the fraction of the buffer (since it's in basis points))
      currentBidOrReservePrice.mul(currentBidBufferBps).div(1e4)
    );
    return fetchCurrencyValue(this.contractWrapper.getProvider(), auction.currencyContractAddress, minimumNextBid);
  }
  /** ******************************
   * PRIVATE FUNCTIONS
   *******************************/
  /**
   * Throws error if auction could not be found
   *
   * @param auctionId - Auction to check for
   */
  async validateAuction(auctionId) {
    try {
      return await this.getAuction(auctionId);
    } catch (err) {
      console.error(`Error getting the auction with id ${auctionId}`);
      throw err;
    }
  }
  /**
   * Helper method maps the auction to the auction interface.
   *
   * @internal
   * @param auction - The auction to map, as returned from the contract.
   * @returns - The mapped interface.
   */
  async mapAuction(auction) {
    let status = Status.UNSET;
    const block = await this.contractWrapper.getProvider().getBlock("latest");
    const blockTime = block.timestamp;
    switch (auction.status) {
      case 1:
        status = BigNumber.from(auction.startTimestamp).gt(blockTime) ? Status.Created : BigNumber.from(auction.endTimestamp).lt(blockTime) ? Status.Expired : Status.Active;
        break;
      case 2:
        status = Status.Completed;
        break;
      case 3:
        status = Status.Cancelled;
        break;
    }
    return {
      id: auction.auctionId.toString(),
      creatorAddress: auction.auctionCreator,
      assetContractAddress: auction.assetContract,
      tokenId: auction.tokenId.toString(),
      quantity: auction.quantity.toString(),
      currencyContractAddress: auction.currency,
      minimumBidAmount: auction.minimumBidAmount.toString(),
      minimumBidCurrencyValue: await fetchCurrencyValue(this.contractWrapper.getProvider(), auction.currency, auction.minimumBidAmount),
      buyoutBidAmount: auction.buyoutBidAmount.toString(),
      buyoutCurrencyValue: await fetchCurrencyValue(this.contractWrapper.getProvider(), auction.currency, auction.buyoutBidAmount),
      timeBufferInSeconds: BigNumber.from(auction.timeBufferInSeconds).toNumber(),
      bidBufferBps: BigNumber.from(auction.bidBufferBps).toNumber(),
      startTimeInSeconds: BigNumber.from(auction.startTimestamp).toNumber(),
      endTimeInSeconds: BigNumber.from(auction.endTimestamp).toNumber(),
      asset: await fetchTokenMetadataForContract(auction.assetContract, this.contractWrapper.getProvider(), auction.tokenId, this.storage),
      status
    };
  }
  /**
   * Maps an auction-bid to the strict interface
   *
   * @internal
   * @param bid
   * @returns - A `Bid` object
   */
  async mapBid(auctionId, bidderAddress, currencyContractAddress, bidAmount) {
    const resolvedBidderAddress = await resolveAddress(bidderAddress);
    const resolvedCurrencyAddress = await resolveAddress(currencyContractAddress);
    return {
      auctionId,
      bidderAddress: resolvedBidderAddress,
      currencyContractAddress: resolvedCurrencyAddress,
      bidAmount,
      bidAmountCurrencyValue: await fetchCurrencyValue(this.contractWrapper.getProvider(), resolvedCurrencyAddress, bidAmount)
    };
  }
  async applyFilter(auctions, filter) {
    let rawAuctions = [...auctions];
    if (filter) {
      if (filter.seller) {
        const resolvedSeller = await resolveAddress(filter.seller);
        rawAuctions = rawAuctions.filter((seller) => seller.auctionCreator.toString().toLowerCase() === (resolvedSeller == null ? void 0 : resolvedSeller.toString().toLowerCase()));
      }
      if (filter.tokenContract) {
        const resolvedToken = await resolveAddress(filter.tokenContract);
        rawAuctions = rawAuctions.filter((tokenContract) => tokenContract.assetContract.toString().toLowerCase() === (resolvedToken == null ? void 0 : resolvedToken.toString().toLowerCase()));
      }
      if (filter.tokenId !== void 0) {
        rawAuctions = rawAuctions.filter((tokenContract) => {
          var _a;
          return tokenContract.tokenId.toString() === ((_a = filter == null ? void 0 : filter.tokenId) == null ? void 0 : _a.toString());
        });
      }
    }
    return (filter == null ? void 0 : filter.count) && filter.count < rawAuctions.length ? rawAuctions.slice(0, filter.count) : rawAuctions;
  }
};
var OfferInputParamsSchema = (() => z.object({
  /**
   * The address of the asset being sought.
   */
  assetContractAddress: AddressOrEnsSchema,
  /**
   * The ID of the token.
   */
  tokenId: BigNumberishSchema,
  /**
   * The quantity of tokens to buy.
   *
   * For ERC721s, this value should always be 1 (and will be forced internally regardless of what is passed here).
   */
  quantity: BigNumberishSchema.default(1),
  /**
   * The address of the currency offered for the NFTs.
   */
  currencyContractAddress: AddressOrEnsSchema.default(NATIVE_TOKEN_ADDRESS),
  /**
   * The total offer amount for the NFTs.
   */
  totalPrice: AmountSchema,
  /**
   * The end time of the offer.
   */
  endTimestamp: EndDateSchema
}))();
var MarketplaceV3Offers = class {
  // utilities
  constructor(contractWrapper, storage) {
    __publicField(this, "featureName", FEATURE_OFFERS.name);
    /** ******************************
     * WRITE FUNCTIONS
     *******************************/
    /**
     * Make an offer
     *
     * @remarks Make an offer on the marketplace for an asset.
     *
     * @example
     * ```javascript
     * // Data of the offer you want to make
     * const offer = {
     *   // address of the contract the asset you want to make an offer for
     *   assetContractAddress: "0x...",
     *   // token ID of the asset you want to buy
     *   tokenId: "0",
     *   // how many of the asset you want to buy
     *   quantity: 1,
     *   // address of the currency contract that you offer to pay in
     *   currencyContractAddress: NATIVE_TOKEN_ADDRESS,
     *   // Total price you offer to pay for the mentioned token(s)
     *   totalPrice: "1.5",
     *   // Offer valid until
     *   endTimestamp: new Date(),
     * }
     *
     * const tx = await contract.offers.makeOffer(offer);
     * const receipt = tx.receipt; // the transaction receipt
     * const id = tx.id; // the id of the newly created offer
     * ```
     * @param offer - the offer data
     * @returns the transaction receipt and the id of the newly created offer
     * @twfeature Offers
     */
    __publicField(this, "makeOffer", buildTransactionFunction(async (offer) => {
      const parsedOffer = await OfferInputParamsSchema.parseAsync(offer);
      const chainId = await this.contractWrapper.getChainID();
      const currency = isNativeToken(parsedOffer.currencyContractAddress) ? NATIVE_TOKENS[chainId].wrapped.address : parsedOffer.currencyContractAddress;
      const normalizedTotalPrice = await normalizePriceValue(this.contractWrapper.getProvider(), parsedOffer.totalPrice, currency);
      const overrides = await this.contractWrapper.getCallOverrides();
      await setErc20Allowance(this.contractWrapper, normalizedTotalPrice, currency, overrides);
      return Transaction.fromContractWrapper({
        contractWrapper: this.contractWrapper,
        method: "makeOffer",
        args: [{
          assetContract: parsedOffer.assetContractAddress,
          tokenId: parsedOffer.tokenId,
          quantity: parsedOffer.quantity,
          currency,
          totalPrice: normalizedTotalPrice,
          expirationTimestamp: parsedOffer.endTimestamp
        }],
        parse: (receipt) => {
          const event = this.contractWrapper.parseLogs("NewOffer", receipt == null ? void 0 : receipt.logs);
          return {
            id: event[0].args.offerId,
            receipt
          };
        }
      });
    }));
    /**
     * Cancel an offer
     *
     * @remarks Cancel an offer on the marketplace
     *
     * @example
     * ```javascript
     * // The ID of the offer you want to cancel
     * const offerId = "0";
     *
     * await contract.offers.cancelOffer(offerId);
     * ```
     * @param offerId - the offer id
     * @returns the transaction receipt
     * @twfeature Offers
     */
    __publicField(this, "cancelOffer", buildTransactionFunction(async (offerId) => {
      return Transaction.fromContractWrapper({
        contractWrapper: this.contractWrapper,
        method: "cancelOffer",
        args: [offerId]
      });
    }));
    /**
     * Accept an offer
     *
     * @example
     * ```javascript
     * // The ID of the offer you want to accept
     * const offerId = 0;
     *
     * await contract.offers.acceptOffer(offerId);
     * ```
     *
     * @param offerId - The offer id
     * @returns the transaction receipt
     * @twfeature Offers
     */
    __publicField(this, "acceptOffer", buildTransactionFunction(async (offerId) => {
      const offer = await this.validateOffer(BigNumber.from(offerId));
      const {
        valid,
        error
      } = await this.isStillValidOffer(offer);
      if (!valid) {
        throw new Error(`Offer ${offerId} is no longer valid. ${error}`);
      }
      const overrides = await this.contractWrapper.getCallOverrides() || {};
      await handleTokenApproval(this.contractWrapper, this.getAddress(), offer.assetContractAddress, offer.tokenId, await this.contractWrapper.getSignerAddress());
      return Transaction.fromContractWrapper({
        contractWrapper: this.contractWrapper,
        method: "acceptOffer",
        args: [offerId],
        overrides
      });
    }));
    this.contractWrapper = contractWrapper;
    this.storage = storage;
    this.events = new ContractEvents(this.contractWrapper);
    this.encoder = new ContractEncoder(this.contractWrapper);
    this.interceptor = new ContractInterceptor(this.contractWrapper);
    this.estimator = new GasCostEstimator(this.contractWrapper);
  }
  getAddress() {
    return this.contractWrapper.address;
  }
  /** ******************************
   * READ FUNCTIONS
   *******************************/
  /**
   * Get the total number of offers
   *
   * @returns Returns the total number of offers created.
   * @public
   *
   * @example
   * ```javascript
   * const totalOffers = await contract.offers.getTotalCount();
   * ```
   * @twfeature Offers
   */
  async getTotalCount() {
    return await this.contractWrapper.read("totalOffers", []);
  }
  /**
   * Get all offers
   *
   * @example
   * ```javascript
   * const offers = await contract.offers.getAll();
   * ```
   *
   * @param filter - optional filter parameters
   * @returns the Offer object array
   * @twfeature Offers
   */
  async getAll(filter) {
    const totalOffers = await this.getTotalCount();
    const start = BigNumber.from((filter == null ? void 0 : filter.start) || 0).toNumber();
    const end = totalOffers.toNumber();
    if (end === 0) {
      throw new Error(`No offers exist on the contract.`);
    }
    let rawOffers = [];
    const batches = await getAllInBatches(start, end, (startId, endId) => this.contractWrapper.read("getAllOffers", [startId, endId]));
    rawOffers = batches.flat();
    const filteredOffers = await this.applyFilter(rawOffers, filter);
    return await Promise.all(filteredOffers.map((offer) => this.mapOffer(offer)));
  }
  /**
   * Get all valid offers
   *
   * @example
   * ```javascript
   * const offers = await contract.offers.getAllValid();
   * ```
   *
   * @param filter - optional filter parameters
   * @returns the Offer object array
   * @twfeature Offers
   */
  async getAllValid(filter) {
    const totalOffers = await this.getTotalCount();
    const start = BigNumber.from((filter == null ? void 0 : filter.start) || 0).toNumber();
    const end = totalOffers.toNumber();
    if (end === 0) {
      throw new Error(`No offers exist on the contract.`);
    }
    let rawOffers = [];
    const batches = await getAllInBatches(start, end, (startId, endId) => this.contractWrapper.read("getAllValidOffers", [startId, endId]));
    rawOffers = batches.flat();
    const filteredOffers = await this.applyFilter(rawOffers, filter);
    return await Promise.all(filteredOffers.map((offer) => this.mapOffer(offer)));
  }
  /**
   * Get a single offer
   *
   * @example
   * ```javascript
   * const offerId = 0;
   * const offer = await contract.offers.getOffer(offerId);
   * ```
   *
   * @param offerId - the listing id
   * @returns the Direct listing object
   * @twfeature Offers
   */
  async getOffer(offerId) {
    const offer = await this.contractWrapper.read("getOffer", [offerId]);
    return await this.mapOffer(offer);
  }
  /** ******************************
   * PRIVATE FUNCTIONS
   *******************************/
  /**
   * Throws error if offer could not be found
   *
   * @param offerId - offer to check for
   */
  async validateOffer(offerId) {
    try {
      return await this.getOffer(offerId);
    } catch (err) {
      console.error(`Error getting the offer with id ${offerId}`);
      throw err;
    }
  }
  /**
   * Helper method maps the offer to the offer interface.
   *
   * @internal
   * @param offer - The offer to map, as returned from the contract.
   * @returns - The mapped interface.
   */
  async mapOffer(offer) {
    let status = Status.UNSET;
    const block = await this.contractWrapper.getProvider().getBlock("latest");
    const blockTime = block.timestamp;
    switch (offer.status) {
      case 1:
        status = BigNumber.from(offer.expirationTimestamp).lt(blockTime) ? Status.Expired : Status.Active;
        break;
      case 2:
        status = Status.Completed;
        break;
      case 3:
        status = Status.Cancelled;
        break;
    }
    return {
      id: offer.offerId.toString(),
      offerorAddress: offer.offeror,
      assetContractAddress: offer.assetContract,
      currencyContractAddress: offer.currency,
      tokenId: offer.tokenId.toString(),
      quantity: offer.quantity.toString(),
      totalPrice: offer.totalPrice.toString(),
      currencyValue: await fetchCurrencyValue(this.contractWrapper.getProvider(), offer.currency, offer.totalPrice),
      asset: await fetchTokenMetadataForContract(offer.assetContract, this.contractWrapper.getProvider(), offer.tokenId, this.storage),
      endTimeInSeconds: BigNumber.from(offer.expirationTimestamp).toNumber(),
      status
    };
  }
  /**
   * Use this method to check if an offer is still valid.
   *
   * Ways an offer can become invalid:
   * 1. The offer has expired
   * 2. The offeror doesn't have enough balance of currency tokens
   * 3. The offeror removed the approval of currency tokens on the marketplace
   *
   * @internal
   * @param offer - The offer to check.
   * @returns - True if the offer is valid, false otherwise.
   */
  async isStillValidOffer(offer) {
    const now = BigNumber.from(Math.floor(Date.now() / 1e3));
    if (now.gt(offer.endTimeInSeconds)) {
      return {
        valid: false,
        error: `Offer with ID ${offer.id} has expired`
      };
    }
    const chainId = await this.contractWrapper.getChainID();
    const currency = isNativeToken(offer.currencyContractAddress) ? NATIVE_TOKENS[chainId].wrapped.address : offer.currencyContractAddress;
    const provider2 = this.contractWrapper.getProvider();
    const erc20 = new ContractWrapper(provider2, currency, IERC20_default, {}, this.storage);
    const offerorBalance = await erc20.read("balanceOf", [offer.offerorAddress]);
    if (offerorBalance.lt(offer.totalPrice)) {
      return {
        valid: false,
        error: `Offeror ${offer.offerorAddress} doesn't have enough balance of token ${currency}`
      };
    }
    const offerorAllowance = await erc20.read("allowance", [offer.offerorAddress, this.getAddress()]);
    if (offerorAllowance.lt(offer.totalPrice)) {
      return {
        valid: false,
        error: `Offeror ${offer.offerorAddress} hasn't approved enough amount of token ${currency}`
      };
    }
    return {
      valid: true,
      error: ""
    };
  }
  async applyFilter(offers, filter) {
    let rawOffers = [...offers];
    if (filter) {
      if (filter.offeror) {
        const resolvedOfferor = await resolveAddress(filter.offeror);
        rawOffers = rawOffers.filter((offeror) => offeror.offeror.toString().toLowerCase() === (resolvedOfferor == null ? void 0 : resolvedOfferor.toString().toLowerCase()));
      }
      if (filter.tokenContract) {
        const resolvedToken = await resolveAddress(filter.tokenContract);
        rawOffers = rawOffers.filter((tokenContract) => tokenContract.assetContract.toString().toLowerCase() === (resolvedToken == null ? void 0 : resolvedToken.toString().toLowerCase()));
      }
      if (filter.tokenId !== void 0) {
        rawOffers = rawOffers.filter((tokenContract) => {
          var _a;
          return tokenContract.tokenId.toString() === ((_a = filter == null ? void 0 : filter.tokenId) == null ? void 0 : _a.toString());
        });
      }
    }
    return (filter == null ? void 0 : filter.count) && filter.count < rawOffers.length ? rawOffers.slice(0, filter.count) : rawOffers;
  }
};
var ContractPlatformFee = class {
  constructor(contractWrapper) {
    __publicField(this, "featureName", FEATURE_PLATFORM_FEE.name);
    /**
     * Set the platform fee recipient and basis points
     *
     * @example
     * ```javascript
     * await contract.platformFees.set({
     *   platform_fee_basis_points: 100, // 1% fee
     *   platform_fee_recipient: "0x..." // the fee recipient
     * })
     * ```
     *
     * @param platformFeeInfo - the platform fee information
     * @twfeature PlatformFee
     */
    __publicField(this, "set", buildTransactionFunction(async (platformFeeInfo) => {
      const parsed = await CommonPlatformFeeSchema.parseAsync(platformFeeInfo);
      return Transaction.fromContractWrapper({
        contractWrapper: this.contractWrapper,
        method: "setPlatformFeeInfo",
        args: [parsed.platform_fee_recipient, parsed.platform_fee_basis_points]
      });
    }));
    this.contractWrapper = contractWrapper;
  }
  /**
   * Get the platform fee recipient and basis points
   *
   * @example
   * ```javascript
   * const feeInfo = await contract.platformFees.get();
   * console.log(feeInfo.platform_fee_recipient);
   * console.log(feeInfo.platform_fee_basis_points);
   * ```
   * @twfeature PlatformFee
   */
  async get() {
    const [platformFeeRecipient, platformFeeBps] = await this.contractWrapper.read("getPlatformFeeInfo", []);
    return CommonPlatformFeeSchema.parseAsync({
      platform_fee_recipient: platformFeeRecipient,
      platform_fee_basis_points: platformFeeBps
    });
  }
};
function extractEventsFromAbi(abi, metadata) {
  const parsedAbi = AbiSchema.parse(abi || []);
  const events = parsedAbi.filter((el) => el.type === "event");
  const parsed = [];
  for (const e of events) {
    const doc = extractCommentFromMetadata(e.name, metadata, "events");
    parsed.push({
      inputs: e.inputs || [],
      outputs: e.outputs || [],
      name: e.name || "unknown",
      comment: doc
    });
  }
  return parsed;
}
var ContractPublishedMetadata = class {
  constructor(contractWrapper, storage) {
    this.contractWrapper = contractWrapper;
    this.storage = storage;
  }
  /**
   * Get the published metadata for this contract
   * @public
   */
  async get() {
    if (this._cachedMetadata) {
      return this._cachedMetadata;
    }
    this._cachedMetadata = await fetchContractMetadataFromAddress(this.contractWrapper.address, this.contractWrapper.getProvider(), this.storage, this.contractWrapper.options);
    return this._cachedMetadata;
  }
  /**
   * @public
   */
  async extractFunctions() {
    let publishedMetadata;
    try {
      publishedMetadata = await this.get();
    } catch (e) {
    }
    return extractFunctionsFromAbi(AbiSchema.parse(this.contractWrapper.abi), publishedMetadata == null ? void 0 : publishedMetadata.metadata);
  }
  /**
   * @public
   */
  async extractEvents() {
    let publishedMetadata;
    try {
      publishedMetadata = await this.get();
    } catch (e) {
    }
    return extractEventsFromAbi(AbiSchema.parse(this.contractWrapper.abi), publishedMetadata == null ? void 0 : publishedMetadata.metadata);
  }
};
var ContractOwner = class {
  constructor(contractWrapper) {
    __publicField(this, "featureName", FEATURE_OWNER.name);
    /**
     * Set the new owner of the contract
     * @remarks Can only be called by the current owner.
     *
     * @param address - the address of the new owner
     *
     * @example
     * ```javascript
     * const newOwnerAddress = "{{wallet_address}}";
     * await contract.owner.set(newOwnerAddress);
     * ```
     * @twfeature Ownable
     */
    __publicField(this, "set", buildTransactionFunction(async (address) => {
      const resolvedAddress = await resolveAddress(address);
      return Transaction.fromContractWrapper({
        contractWrapper: this.contractWrapper,
        method: "setOwner",
        args: [resolvedAddress]
      });
    }));
    this.contractWrapper = contractWrapper;
  }
  /**
   * Get the current owner of the contract
   * @example
   * ```javascript
   * await contract.owner.get();
   * console.log("Owner address: ", ownerAddress);
   * ```
   * @returns the owner address
   * @twfeature Ownable
   */
  async get() {
    return this.contractWrapper.read("owner", []);
  }
};
var ContractAppURI = class {
  constructor(contractWrapper, metadata, storage) {
    __publicField(this, "featureName", FEATURE_APPURI.name);
    /**
     * Set App URI
     * @param appURI - the uri to set (typically an IPFS hash)
     * @example
     * ```javascript
     * const appURI = "ipfs://some_ipfs_hash";
     * await contract.app.set(appURI);
     * ```
     * @twfeature AppURI
     */
    __publicField(this, "set", buildTransactionFunction(async (appURI) => {
      if (detectContractFeature(this.contractWrapper, "AppURI")) {
        return Transaction.fromContractWrapper({
          contractWrapper: this.contractWrapper,
          method: "setAppURI",
          args: [appURI]
        });
      }
      return await this.metadata.update.prepare({
        app_uri: appURI
      });
    }));
    this.contractWrapper = contractWrapper;
    this.metadata = metadata;
    this.storage = storage;
  }
  /**
   * Get App URI
   * @returns the appURI (typically an IPFS hash)
   * @example
   * ```javascript
   * const appURI = await contract.app.get();
   * console.log(appURI) // "ipfs://some_ipfs_hash";
   * ```
   * @twfeature AppURI
   */
  async get() {
    if (detectContractFeature(this.contractWrapper, "AppURI")) {
      return await this.contractWrapper.read("appURI", []);
    }
    return replaceGatewayUrlWithScheme((await this.metadata.get()).app_uri || "", this.storage.getGatewayUrls());
  }
};
async function extractConstructorParams(predeployMetadataUri, storage) {
  const meta = await fetchPreDeployMetadata(predeployMetadataUri, storage);
  return extractConstructorParamsFromAbi(meta.abi);
}
async function extractFunctions(predeployMetadataUri, storage) {
  const metadata = await fetchPreDeployMetadata(predeployMetadataUri, storage);
  return extractFunctionsFromAbi(metadata.abi, metadata.metadata);
}
function getFunctionSignature(fnInputs) {
  return "(" + fnInputs.map((i) => {
    return i.type === "tuple" ? getFunctionSignature(i.components) : i.type === "tuple[]" ? getFunctionSignature(i.components) + `[]` : i.type;
  }).join(",") + ")";
}
function generatePluginFunctions(pluginAddress, pluginAbi) {
  const pluginInterface = new utils_exports.Interface(pluginAbi);
  const pluginFunctions = [];
  for (const fnFragment of Object.values(pluginInterface.functions)) {
    const fn = pluginInterface.getFunction(pluginInterface.getSighash(fnFragment));
    if (fn.name.includes("_")) {
      continue;
    }
    pluginFunctions.push({
      functionSelector: pluginInterface.getSighash(fn),
      functionSignature: fn.name + getFunctionSignature(fn.inputs),
      pluginAddress
    });
  }
  return pluginFunctions;
}
function generateExtensionFunctions(extensionAbi) {
  const extensionInterface = new utils_exports.Interface(extensionAbi);
  const extensionFunctions = [];
  for (const fnFragment of Object.values(extensionInterface.functions)) {
    const fn = extensionInterface.getFunction(extensionInterface.getSighash(fnFragment));
    if (fn.name.startsWith("_")) {
      continue;
    }
    extensionFunctions.push({
      functionSelector: extensionInterface.getSighash(fn),
      functionSignature: fn.name + getFunctionSignature(fn.inputs)
    });
  }
  return extensionFunctions;
}
async function getDeploymentInfo(metadataUri, storage, provider2, create2Factory, clientId, secretKey) {
  caches.deploymentPresets = {};
  const create2FactoryAddress = create2Factory ? create2Factory : await getCreate2FactoryAddress(provider2);
  const customParams = {};
  const finalDeploymentInfo = [];
  const {
    compilerMetadata,
    extendedMetadata
  } = await fetchAndCacheDeployMetadata(metadataUri, storage);
  const defaultExtensions = extendedMetadata == null ? void 0 : extendedMetadata.defaultExtensions;
  if ((extendedMetadata == null ? void 0 : extendedMetadata.routerType) === "plugin" && defaultExtensions) {
    invariant(clientId || secretKey, "Require Client Id / Secret Key");
    const publishedExtensions = await Promise.all(defaultExtensions.map((e) => {
      return fetchPublishedContractFromPolygon(e.publisherAddress, e.extensionName, e.extensionVersion, storage, clientId, secretKey);
    }));
    const pluginMetadata = (await Promise.all(publishedExtensions.map(async (c) => {
      return fetchAndCacheDeployMetadata(c.metadataUri, storage);
    }))).map((fetchedMetadata) => fetchedMetadata.compilerMetadata);
    const pluginDeploymentInfo = await Promise.all(pluginMetadata.map(async (metadata) => {
      const info = await computeDeploymentInfo("plugin", provider2, storage, create2FactoryAddress, {
        metadata
      }, clientId, secretKey);
      return info;
    }));
    const mapInput = [];
    pluginMetadata.forEach((metadata, index) => {
      const input = generatePluginFunctions(pluginDeploymentInfo[index].transaction.predictedAddress, metadata.abi);
      mapInput.push(...input);
    });
    const pluginMapTransaction = await computeDeploymentInfo("plugin", provider2, storage, create2FactoryAddress, {
      contractName: "PluginMap",
      constructorParams: {
        _pluginsToAdd: {
          value: mapInput
        }
      }
    }, clientId, secretKey);
    customParams["_pluginMap"] = {
      value: pluginMapTransaction.transaction.predictedAddress
    };
    finalDeploymentInfo.push(...pluginDeploymentInfo, pluginMapTransaction);
  } else if ((extendedMetadata == null ? void 0 : extendedMetadata.routerType) === "dynamic" && defaultExtensions) {
    invariant(clientId || secretKey, "Require Client Id / Secret Key");
    const publishedExtensions = await Promise.all(defaultExtensions.map((e) => {
      return fetchPublishedContractFromPolygon(e.publisherAddress, e.extensionName, e.extensionVersion, storage, clientId, secretKey);
    }));
    const extensionMetadata = (await Promise.all(publishedExtensions.map(async (c) => {
      return fetchAndCacheDeployMetadata(c.metadataUri, storage);
    }))).map((fetchedMetadata) => fetchedMetadata.compilerMetadata);
    const extensionDeploymentInfo = await Promise.all(extensionMetadata.map(async (metadata) => {
      const info = await computeDeploymentInfo("extension", provider2, storage, create2FactoryAddress, {
        metadata
      }, clientId, secretKey);
      return info;
    }));
    const routerInput = [];
    extensionMetadata.forEach((metadata, index) => {
      const extensionFunctions = generateExtensionFunctions(metadata.abi);
      routerInput.push({
        metadata: {
          name: metadata.name,
          metadataURI: "",
          implementation: extensionDeploymentInfo[index].transaction.predictedAddress
        },
        functions: extensionFunctions
      });
    });
    customParams["_extensions"] = {
      value: routerInput
    };
    finalDeploymentInfo.push(...extensionDeploymentInfo);
  }
  const implementationDeployInfo = await computeDeploymentInfo("implementation", provider2, storage, create2FactoryAddress, {
    metadata: compilerMetadata,
    constructorParams: customParams
  }, clientId, secretKey);
  const factoryInfo = await computeDeploymentInfo("infra", provider2, storage, create2FactoryAddress, {
    contractName: "TWCloneFactory"
  }, clientId, secretKey);
  finalDeploymentInfo.push(factoryInfo);
  finalDeploymentInfo.push(...Object.values(caches.deploymentPresets));
  finalDeploymentInfo.push(implementationDeployInfo);
  return finalDeploymentInfo;
}
async function deployContractDeterministic(signer, transaction, options) {
  var _a, _b;
  let gasLimit = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : 7e6;
  invariant(signer.provider, "Provider required");
  const contractDeployed = await isContractDeployed(transaction.predictedAddress, signer.provider);
  if (!contractDeployed) {
    console.debug(`deploying contract via create2 factory at: ${transaction.predictedAddress}`);
    const tx = {
      to: transaction.to,
      data: transaction.data
    };
    try {
      await signer.estimateGas(tx);
    } catch (e) {
      console.debug("error estimating gas while deploying prebuilt: ", e);
      tx.gasLimit = BigNumber.from(gasLimit);
    }
    (_a = options == null ? void 0 : options.notifier) == null ? void 0 : _a.call(options, "deploying", "preset");
    await (await signer.sendTransaction(tx)).wait();
    (_b = options == null ? void 0 : options.notifier) == null ? void 0 : _b.call(options, "deployed", "preset");
  }
}
function estimateGasForDeploy(initCode) {
  let gasLimit = utils_exports.arrayify(initCode).map((x) => x === 0 ? 4 : 16).reduce((sum, x) => sum + x) + 200 * initCode.length / 2 + 6 * Math.ceil(initCode.length / 64) + 32e3 + 21e3;
  gasLimit = Math.floor(gasLimit * 64 / 63);
  return gasLimit;
}
function createTransactionBatches(transactions) {
  let upperGasLimit = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : GAS_LIMIT_FOR_DEPLOYER;
  transactions = transactions.filter((tx) => {
    return tx.data.length > 0;
  });
  if (transactions.length === 0) {
    return [];
  }
  const transactionBatches = [];
  let sum = 0;
  let batch = [];
  transactions.forEach((tx) => {
    const gas = estimateGasForDeploy(tx.data);
    if (sum + gas > upperGasLimit) {
      if (batch.length === 0) {
        transactionBatches.push([tx]);
      } else {
        transactionBatches.push(batch);
        sum = gas;
        batch = [tx];
      }
    } else {
      sum += gas;
      batch.push(tx);
    }
  });
  if (batch.length > 0) {
    transactionBatches.push(batch);
  }
  return transactionBatches;
}
async function deployWithThrowawayDeployer(signer, transactions, options) {
  var _a, _b;
  const transactionBatches = createTransactionBatches(transactions);
  if (transactionBatches.length === 0) {
    return;
  }
  (_a = options == null ? void 0 : options.notifier) == null ? void 0 : _a.call(options, "deploying", "infra");
  const deployTxns = await Promise.all(transactionBatches.map((txBatch) => {
    const deployer = new ContractFactory(DEPLOYER_ABI, DEPLOYER_BYTECODE).connect(signer).deploy(txBatch);
    return deployer;
  }));
  await Promise.all(deployTxns.map((tx) => {
    return tx.deployed();
  }));
  (_b = options == null ? void 0 : options.notifier) == null ? void 0 : _b.call(options, "deployed", "infra");
}
async function getCompositeABIfromRelease(publishMetadataUri, storage) {
  const {
    extendedMetadata
  } = await fetchAndCacheDeployMetadata(publishMetadataUri, storage);
  const compositeAbi = (extendedMetadata == null ? void 0 : extendedMetadata.compositeAbi) || [];
  return compositeAbi;
}
async function getPluginABI(addresses, provider2, storage) {
  return (await Promise.all(addresses.map((address) => fetchContractMetadataFromAddress(address, provider2, storage).catch((err) => {
    console.error(`Failed to fetch plug-in for ${address}`, err);
    return {
      abi: []
    };
  })))).map((metadata) => metadata.abi);
}
async function getCompositePluginABI(address, abi, provider2, options, storage) {
  let pluginABIs = [];
  try {
    const isPluginRouter = isFeatureEnabled(AbiSchema.parse(abi), "PluginRouter");
    const isbaseRouter = isFeatureEnabled(AbiSchema.parse(abi), "DynamicContract");
    if (isbaseRouter) {
      const contract = new ContractWrapper(provider2, address, getAllExtensionsAbi, options, storage);
      const plugins = await contract.call("getAllExtensions");
      const pluginAddresses = plugins.map((item) => item.metadata.implementation);
      pluginABIs = await getPluginABI(pluginAddresses, provider2, storage);
    } else if (isPluginRouter) {
      const contract = new ContractWrapper(provider2, address, getAllPluginsAbi, options, storage);
      const pluginMap = await contract.call("getAllPlugins");
      const allPlugins = pluginMap.map((item) => item.pluginAddress);
      const plugins = Array.from(new Set(allPlugins));
      pluginABIs = await getPluginABI(plugins, provider2, storage);
    }
  } catch (err) {
  }
  return pluginABIs.length > 0 ? joinABIs([abi, ...pluginABIs]) : abi;
}
var DropErc20ContractInput = CommonContractSchema.merge(MerkleSchema).merge(CommonSymbolSchema);
var DropErc20ContractOutput = CommonContractOutputSchema.merge(MerkleSchema).merge(CommonSymbolSchema);
var DropErc20ContractDeploy = DropErc20ContractInput.merge(CommonPlatformFeeSchema).merge(CommonPrimarySaleSchema).merge(CommonTrustedForwarderSchema);
var DropErc20ContractSchema = {
  deploy: DropErc20ContractDeploy,
  output: DropErc20ContractOutput,
  input: DropErc20ContractInput
};
var MultiwrapContractInput = CommonContractSchema.merge(CommonRoyaltySchema).merge(CommonSymbolSchema);
var MultiwrapContractOutput = CommonContractOutputSchema.merge(CommonRoyaltySchema).merge(CommonSymbolSchema);
var MultiwrapContractDeploy = MultiwrapContractInput.merge(CommonTrustedForwarderSchema);
var MultiwrapContractSchema = {
  deploy: MultiwrapContractDeploy,
  output: MultiwrapContractOutput,
  input: MultiwrapContractInput
};
var ADMIN_ROLE = ["admin"];
var NFT_BASE_CONTRACT_ROLES = ["admin", "minter", "transfer"];
var MARKETPLACE_CONTRACT_ROLES = ["admin", "lister", "asset"];
var PACK_CONTRACT_ROLES = ["admin", "minter", "asset", "transfer"];
var TOKEN_DROP_CONTRACT_ROLES = ["admin", "transfer"];
var MULTIWRAP_CONTRACT_ROLES = ["admin", "transfer", "minter", "unwrap", "asset"];
var prebuiltContractTypes = {
  vote: "vote",
  token: "token",
  "edition-drop": "edition-drop",
  edition: "edition",
  marketplace: "marketplace",
  "marketplace-v3": "marketplace-v3",
  multiwrap: "multiwrap",
  "nft-collection": "nft-collection",
  "nft-drop": "nft-drop",
  pack: "pack",
  "signature-drop": "signature-drop",
  split: "split",
  "token-drop": "token-drop"
};
var EditionDropInitializer = {
  name: "DropERC1155",
  contractType: prebuiltContractTypes["edition-drop"],
  schema: DropErc1155ContractSchema,
  roles: NFT_BASE_CONTRACT_ROLES,
  initialize: async function() {
    for (var _len = arguments.length, _ref = new Array(_len), _key = 0; _key < _len; _key++) {
      _ref[_key] = arguments[_key];
    }
    let [network, address, storage, options] = _ref;
    const [, provider2] = getSignerAndProvider(network, options);
    const [abi, contract, _network] = await Promise.all([EditionDropInitializer.getAbi(address, provider2, storage), import("./edition-drop-24708d00.browser.esm-3L6Y72NG.js"), provider2.getNetwork()]);
    return new contract.EditionDrop(network, address, storage, options, abi, _network.chainId);
  },
  getAbi: async (address, provider2, storage) => {
    const abi = await fetchAbiFromAddress(address, provider2, storage);
    if (abi) {
      return abi;
    }
    const contractInfo = await getContractInfo(address, provider2);
    return !contractInfo || contractInfo.version > 2 ? (await import("./DropERC1155-U5QKPWDP.js")).default : (await import("./DropERC1155_V2-L76ALB3L.js")).default;
  }
};
var EditionInitializer = {
  name: "TokenERC1155",
  contractType: prebuiltContractTypes["edition"],
  schema: TokenErc1155ContractSchema,
  roles: NFT_BASE_CONTRACT_ROLES,
  initialize: async function() {
    for (var _len2 = arguments.length, _ref2 = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
      _ref2[_key2] = arguments[_key2];
    }
    let [network, address, storage, options] = _ref2;
    const [, provider2] = getSignerAndProvider(network, options);
    const [abi, contract, _network] = await Promise.all([EditionInitializer.getAbi(address, provider2, storage), import("./edition-b3122b64.browser.esm-6VZSQBVT.js"), provider2.getNetwork()]);
    return new contract.Edition(network, address, storage, options, abi, _network.chainId);
  },
  getAbi: async (address, provider2, storage) => {
    const abi = await fetchAbiFromAddress(address, provider2, storage);
    if (abi) {
      return abi;
    }
    return (await import("./TokenERC1155-XB2KIH7C.js")).default;
  }
};
var MarketplaceInitializer = {
  name: "Marketplace",
  contractType: prebuiltContractTypes.marketplace,
  schema: MarketplaceContractSchema,
  roles: MARKETPLACE_CONTRACT_ROLES,
  initialize: async function() {
    for (var _len3 = arguments.length, _ref3 = new Array(_len3), _key3 = 0; _key3 < _len3; _key3++) {
      _ref3[_key3] = arguments[_key3];
    }
    let [network, address, storage, options] = _ref3;
    const [, provider2] = getSignerAndProvider(network, options);
    const [abi, contract, _network] = await Promise.all([MarketplaceInitializer.getAbi(address, provider2, storage), import("./marketplace-5b738c1b.browser.esm-BVACXOGP.js"), provider2.getNetwork()]);
    return new contract.Marketplace(network, address, storage, options, abi, _network.chainId);
  },
  getAbi: async (address, provider2, storage) => {
    const abi = await fetchAbiFromAddress(address, provider2, storage);
    if (abi) {
      return abi;
    }
    return (await import("./Marketplace-VBZWSLOU.js")).default;
  }
};
var MarketplaceV3Initializer = {
  name: "MarketplaceV3",
  contractType: prebuiltContractTypes["marketplace-v3"],
  schema: MarketplaceContractSchema,
  roles: MARKETPLACE_CONTRACT_ROLES,
  initialize: async function() {
    for (var _len4 = arguments.length, _ref4 = new Array(_len4), _key4 = 0; _key4 < _len4; _key4++) {
      _ref4[_key4] = arguments[_key4];
    }
    let [network, address, storage, options] = _ref4;
    const [, provider2] = getSignerAndProvider(network, options);
    const [abi, contract, _network] = await Promise.all([MarketplaceV3Initializer.getAbi(address, provider2, storage, options), import("./marketplacev3-e02b24ac.browser.esm-AXUODV4S.js"), provider2.getNetwork()]);
    return new contract.MarketplaceV3(network, address, storage, options, abi, _network.chainId);
  },
  getAbi: async (address, provider2, storage, options) => {
    const chainId = (await provider2.getNetwork()).chainId;
    const isZkSync = chainId === 280 || chainId === 324;
    if (isZkSync) {
      const publishedContract = await fetchPublishedContractFromPolygon(THIRDWEB_DEPLOYER, "MarketplaceV3", "latest", storage, options == null ? void 0 : options.clientId, options == null ? void 0 : options.secretKey);
      const uri = publishedContract.metadataUri;
      const compositeAbi = await getCompositeABIfromRelease(uri, storage);
      return compositeAbi;
    }
    const abi = await fetchAbiFromAddress(address, provider2, storage);
    if (abi) {
      return await getCompositePluginABI(address, abi, provider2, {}, storage);
    }
    const localAbi = (await import("./MarketplaceV3-QP5OYRKC.js")).default;
    return await getCompositePluginABI(address, AbiSchema.parse(localAbi || []), provider2, {}, storage);
  }
};
var MultiwrapInitializer = {
  name: "Multiwrap",
  contractType: prebuiltContractTypes.multiwrap,
  schema: MultiwrapContractSchema,
  roles: MULTIWRAP_CONTRACT_ROLES,
  initialize: async function() {
    for (var _len5 = arguments.length, _ref5 = new Array(_len5), _key5 = 0; _key5 < _len5; _key5++) {
      _ref5[_key5] = arguments[_key5];
    }
    let [network, address, storage, options] = _ref5;
    const [, provider2] = getSignerAndProvider(network, options);
    const [abi, contract, _network] = await Promise.all([MultiwrapInitializer.getAbi(address, provider2, storage), import("./multiwrap-18fab528.browser.esm-JXTUZN3H.js"), provider2.getNetwork()]);
    return new contract.Multiwrap(network, address, storage, options, abi, _network.chainId);
  },
  getAbi: async (address, provider2, storage) => {
    const abi = await fetchAbiFromAddress(address, provider2, storage);
    if (abi) {
      return abi;
    }
    return (await import("./Multiwrap-SNQDA3XE.js")).default;
  }
};
var NFTCollectionInitializer = {
  name: "TokenERC721",
  contractType: prebuiltContractTypes["nft-collection"],
  schema: TokenErc721ContractSchema,
  roles: NFT_BASE_CONTRACT_ROLES,
  initialize: async function() {
    for (var _len6 = arguments.length, _ref6 = new Array(_len6), _key6 = 0; _key6 < _len6; _key6++) {
      _ref6[_key6] = arguments[_key6];
    }
    let [network, address, storage, options] = _ref6;
    const [, provider2] = getSignerAndProvider(network, options);
    const [abi, contract, _network] = await Promise.all([NFTCollectionInitializer.getAbi(address, provider2, storage), import("./nft-collection-0cf43f4d.browser.esm-YZO6CW55.js"), provider2.getNetwork()]);
    return new contract.NFTCollection(network, address, storage, options, abi, _network.chainId);
  },
  getAbi: async (address, provider2, storage) => {
    const abi = await fetchAbiFromAddress(address, provider2, storage);
    if (abi) {
      return abi;
    }
    return (await import("./TokenERC721-KVRTNDRM.js")).default;
  }
};
var NFTDropInitializer = {
  name: "DropERC721",
  contractType: prebuiltContractTypes["nft-drop"],
  schema: DropErc721ContractSchema,
  roles: NFT_BASE_CONTRACT_ROLES,
  initialize: async function() {
    for (var _len7 = arguments.length, _ref7 = new Array(_len7), _key7 = 0; _key7 < _len7; _key7++) {
      _ref7[_key7] = arguments[_key7];
    }
    let [network, address, storage, options] = _ref7;
    const [, provider2] = getSignerAndProvider(network, options);
    const [abi, contract, _network] = await Promise.all([NFTDropInitializer.getAbi(address, provider2, storage), import("./nft-drop-399edfe0.browser.esm-3VC76KLK.js"), provider2.getNetwork()]);
    return new contract.NFTDrop(network, address, storage, options, abi, _network.chainId);
  },
  getAbi: async (address, provider2, storage) => {
    const abi = await fetchAbiFromAddress(address, provider2, storage);
    if (abi) {
      return abi;
    }
    const contractInfo = await getContractInfo(address, provider2);
    return !contractInfo || contractInfo.version > 3 ? (await import("./DropERC721-3KIT75EB.js")).default : (await import("./DropERC721_V3-LWCXQLOS.js")).default;
  }
};
var PackInitializer = {
  name: "Pack",
  contractType: prebuiltContractTypes["pack"],
  schema: PackContractSchema,
  roles: PACK_CONTRACT_ROLES,
  initialize: async function() {
    for (var _len8 = arguments.length, _ref8 = new Array(_len8), _key8 = 0; _key8 < _len8; _key8++) {
      _ref8[_key8] = arguments[_key8];
    }
    let [network, address, storage, options] = _ref8;
    const [, provider2] = getSignerAndProvider(network, options);
    const [abi, contract, _network] = await Promise.all([PackInitializer.getAbi(address, provider2, storage), import("./pack-bd61f578.browser.esm-AIDNF74S.js"), provider2.getNetwork()]);
    return new contract.Pack(network, address, storage, options, abi, _network.chainId);
  },
  getAbi: async (address, provider2, storage) => {
    const abi = await fetchAbiFromAddress(address, provider2, storage);
    if (abi) {
      return abi;
    }
    return AbiSchema.parse((await import("./Pack-JDZPBGH3.js")).default || []);
  }
};
var SignatureDropInitializer = {
  name: "SignatureDrop",
  contractType: prebuiltContractTypes["signature-drop"],
  schema: DropErc721ContractSchema,
  roles: NFT_BASE_CONTRACT_ROLES,
  initialize: async function() {
    for (var _len9 = arguments.length, _ref9 = new Array(_len9), _key9 = 0; _key9 < _len9; _key9++) {
      _ref9[_key9] = arguments[_key9];
    }
    let [network, address, storage, options] = _ref9;
    const [, provider2] = getSignerAndProvider(network, options);
    const [abi, contract, _network] = await Promise.all([SignatureDropInitializer.getAbi(address, provider2, storage), import("./signature-drop-224b723c.browser.esm-B6GQDYFD.js"), provider2.getNetwork()]);
    return new contract.SignatureDrop(network, address, storage, options, abi, _network.chainId);
  },
  getAbi: async (address, provider2, storage) => {
    const abi = await fetchAbiFromAddress(address, provider2, storage);
    if (abi) {
      return abi;
    }
    const contractInfo = await getContractInfo(address, provider2);
    return !contractInfo || contractInfo.version > 4 ? (await import("./SignatureDrop-S7INMWB3.js")).default : (await import("./SignatureDrop_V4-32DOQO6M.js")).default;
  }
};
var SplitInitializer = {
  name: "Split",
  contractType: prebuiltContractTypes["split"],
  schema: SplitsContractSchema,
  roles: ADMIN_ROLE,
  initialize: async function() {
    for (var _len10 = arguments.length, _ref10 = new Array(_len10), _key10 = 0; _key10 < _len10; _key10++) {
      _ref10[_key10] = arguments[_key10];
    }
    let [network, address, storage, options] = _ref10;
    const [, provider2] = getSignerAndProvider(network, options);
    const [abi, contract, _network] = await Promise.all([SplitInitializer.getAbi(address, provider2, storage), import("./split-8c412664.browser.esm-AMRBAQ43.js"), provider2.getNetwork()]);
    return new contract.Split(network, address, storage, options, abi, _network.chainId);
  },
  getAbi: async (address, provider2, storage) => {
    const abi = await fetchAbiFromAddress(address, provider2, storage);
    if (abi) {
      return abi;
    }
    return (await import("./Split-5V7Q3NCD.js")).default;
  }
};
var TokenDropInitializer = {
  name: "DropERC20",
  contractType: prebuiltContractTypes["token-drop"],
  schema: DropErc20ContractSchema,
  roles: TOKEN_DROP_CONTRACT_ROLES,
  initialize: async function() {
    for (var _len11 = arguments.length, _ref11 = new Array(_len11), _key11 = 0; _key11 < _len11; _key11++) {
      _ref11[_key11] = arguments[_key11];
    }
    let [network, address, storage, options] = _ref11;
    const [, provider2] = getSignerAndProvider(network, options);
    const [abi, contract, _network] = await Promise.all([TokenDropInitializer.getAbi(address, provider2, storage), import("./token-drop-90cb00e6.browser.esm-JIPYZAGO.js"), provider2.getNetwork()]);
    return new contract.TokenDrop(network, address, storage, options, abi, _network.chainId);
  },
  getAbi: async (address, provider2, storage) => {
    const abi = await fetchAbiFromAddress(address, provider2, storage);
    if (abi) {
      return abi;
    }
    const contractInfo = await getContractInfo(address, provider2);
    return !contractInfo || contractInfo.version > 2 ? (await import("./DropERC20-EHSMWTFA.js")).default : (await import("./DropERC20_V2-J5S3MCBB.js")).default;
  }
};
var TokenInitializer = {
  name: "TokenERC20",
  contractType: prebuiltContractTypes.token,
  schema: TokenErc20ContractSchema,
  roles: NFT_BASE_CONTRACT_ROLES,
  initialize: async function() {
    for (var _len12 = arguments.length, _ref12 = new Array(_len12), _key12 = 0; _key12 < _len12; _key12++) {
      _ref12[_key12] = arguments[_key12];
    }
    let [network, address, storage, options] = _ref12;
    const [, provider2] = getSignerAndProvider(network, options);
    const [abi, contract, _network] = await Promise.all([TokenInitializer.getAbi(address, provider2, storage), import("./token-1023bf9c.browser.esm-W22DYPBO.js"), provider2.getNetwork()]);
    return new contract.Token(network, address, storage, options, abi, _network.chainId);
  },
  getAbi: async (address, provider2, storage) => {
    const abi = await fetchAbiFromAddress(address, provider2, storage);
    if (abi) {
      return abi;
    }
    return (await import("./TokenERC20-CR3Z2L5D.js")).default;
  }
};
var VoteInitializer = {
  name: "VoteERC20",
  contractType: prebuiltContractTypes.vote,
  schema: VoteContractSchema,
  roles: [],
  initialize: async function() {
    for (var _len13 = arguments.length, _ref13 = new Array(_len13), _key13 = 0; _key13 < _len13; _key13++) {
      _ref13[_key13] = arguments[_key13];
    }
    let [network, address, storage, options] = _ref13;
    const [, provider2] = getSignerAndProvider(network, options);
    const [abi, contract, _network] = await Promise.all([VoteInitializer.getAbi(address, provider2, storage), import("./vote-8af4ac9b.browser.esm-RIIEE5S4.js"), provider2.getNetwork()]);
    return new contract.Vote(network, address, storage, options, abi, _network.chainId);
  },
  getAbi: async (address, provider2, storage) => {
    const abi = await fetchAbiFromAddress(address, provider2, storage);
    if (abi) {
      return abi;
    }
    return (await import("./VoteERC20-AMYQMFEP.js")).default;
  }
};
async function getContractInfo(address, provider2) {
  try {
    return await getPrebuiltInfo(address, provider2);
  } catch (e) {
    return void 0;
  }
}
var PREBUILT_CONTRACTS_MAP = {
  [prebuiltContractTypes["edition-drop"]]: EditionDropInitializer,
  [prebuiltContractTypes.edition]: EditionInitializer,
  [prebuiltContractTypes.marketplace]: MarketplaceInitializer,
  [prebuiltContractTypes["marketplace-v3"]]: MarketplaceV3Initializer,
  [prebuiltContractTypes.multiwrap]: MultiwrapInitializer,
  [prebuiltContractTypes["nft-collection"]]: NFTCollectionInitializer,
  [prebuiltContractTypes["nft-drop"]]: NFTDropInitializer,
  [prebuiltContractTypes.pack]: PackInitializer,
  [prebuiltContractTypes["signature-drop"]]: SignatureDropInitializer,
  [prebuiltContractTypes.split]: SplitInitializer,
  [prebuiltContractTypes["token-drop"]]: TokenDropInitializer,
  [prebuiltContractTypes.token]: TokenInitializer,
  [prebuiltContractTypes.vote]: VoteInitializer
};
var PREBUILT_CONTRACTS_APPURI_MAP = {
  [prebuiltContractTypes["edition-drop"]]: "ipfs://QmNm3wRzpKYWo1SRtJfgfxtvudp5p2nXD6EttcsQJHwTmk",
  [prebuiltContractTypes.edition]: "",
  [prebuiltContractTypes.marketplace]: "ipfs://QmbAgC8YwY36n8H2kuvSWsRisxDZ15QZw3xGZyk9aDvcv7/marketplace.html",
  [prebuiltContractTypes["marketplace-v3"]]: "ipfs://QmbAgC8YwY36n8H2kuvSWsRisxDZ15QZw3xGZyk9aDvcv7/marketplace-v3.html",
  [prebuiltContractTypes.multiwrap]: "",
  [prebuiltContractTypes["nft-collection"]]: "",
  [prebuiltContractTypes["nft-drop"]]: "ipfs://QmZptmVipc6SGFbKAyXcxGgohzTwYRXZ9LauRX5ite1xDK",
  [prebuiltContractTypes.pack]: "",
  [prebuiltContractTypes["signature-drop"]]: "ipfs://QmZptmVipc6SGFbKAyXcxGgohzTwYRXZ9LauRX5ite1xDK",
  [prebuiltContractTypes.split]: "",
  [prebuiltContractTypes["token-drop"]]: "ipfs://QmbAgC8YwY36n8H2kuvSWsRisxDZ15QZw3xGZyk9aDvcv7/erc20.html",
  [prebuiltContractTypes.token]: "",
  [prebuiltContractTypes.vote]: ""
};
var SmartContract$1 = {
  name: "SmartContract",
  contractType: "custom",
  schema: {},
  roles: ALL_ROLES
};
var CONTRACTS_MAP = {
  ...PREBUILT_CONTRACTS_MAP,
  [SmartContract$1.contractType]: SmartContract$1
};
function getContractTypeForRemoteName(name) {
  var _a;
  return ((_a = Object.values(CONTRACTS_MAP).find((contract) => contract.name === name)) == null ? void 0 : _a.contractType) || "custom";
}
function getContractName(type) {
  var _a;
  return (_a = Object.values(CONTRACTS_MAP).find((contract) => contract.contractType === type)) == null ? void 0 : _a.name;
}
var SignerPermissionsSchema = z.object({
  startDate: StartDateSchema,
  expirationDate: EndDateSchema,
  nativeTokenLimitPerTransaction: AmountSchema.default(0),
  approvedCallTargets: z.array(AddressOrEnsSchema)
});
var PermissionSnapshotSchema = z.array(z.object({
  signer: AddressOrEnsSchema,
  makeAdmin: z.boolean(),
  permissions: SignerPermissionsSchema
}));
var SignerPermissionRequest = [{
  name: "signer",
  type: "address"
}, {
  name: "approvedTargets",
  type: "address[]"
}, {
  name: "nativeTokenLimitPerTransaction",
  type: "uint256"
}, {
  name: "permissionStartTimestamp",
  type: "uint128"
}, {
  name: "permissionEndTimestamp",
  type: "uint128"
}, {
  name: "reqValidityStartTimestamp",
  type: "uint128"
}, {
  name: "reqValidityEndTimestamp",
  type: "uint128"
}, {
  name: "uid",
  type: "bytes32"
}];
var AccountPermissions = class {
  constructor(contractWrapper) {
    __publicField(this, "featureName", FEATURE_ACCOUNT_PERMISSIONS.name);
    /*********************************
     * WRITE FUNCTIONS
     ********************************/
    /**
     * Grant an address admin access to the account.
     *
     * @remarks Grants an address admin access to the account. The admin will have complete authority over the account.
     *
     * @param signer - The address to be granted admin access to the account.
     *
     * @example
     * ```javascript
     * const tx = await contract.account.grantAdminAccess(signer);
     * const receipt = tx.receipt();
     * ```
     *
     * @twfeature AccountPermissions
     */
    __publicField(this, "grantAdminPermissions", buildTransactionFunction(async (signerAddress) => {
      const resolvedSignerAddress = await resolveAddress(signerAddress);
      return Transaction.fromContractWrapper({
        contractWrapper: this.contractWrapper,
        method: "setAdmin",
        args: [resolvedSignerAddress, true]
      });
    }));
    /**
     * Revoke an address' admin access to the account.
     *
     * @remarks Revokes an address' admin access to the account.
     *
     * @param signer - The address of an admin of the account.
     *
     * @example
     * ```javascript
     * const tx = await contract.account.revokeAdminAccess(signer);
     * const receipt = tx.receipt();
     * ```
     *
     * @twfeature AccountPermissions
     */
    __publicField(this, "revokeAdminPermissions", buildTransactionFunction(async (signerAddress) => {
      const resolvedSignerAddress = await resolveAddress(signerAddress);
      return Transaction.fromContractWrapper({
        contractWrapper: this.contractWrapper,
        method: "setAdmin",
        args: [resolvedSignerAddress, false]
      });
    }));
    /**
     * Grant a signer permissions to use the account.
     *
     * @remarks Grants a signer permissions to use the account.
     *
     * @param signer - The signer to be granted permissions to use the account.
     * @param permissions - The permissions to be applied to the signer's use of the account.
     *
     * @example
     * ```javascript
     * const tx = await contract.account.grantPermissions(signer, permissions);
     * const receipt = tx.receipt();
     * ```
     *
     * @twfeature AccountPermissions
     */
    __publicField(this, "grantPermissions", buildTransactionFunction(async (signerAddress, permissions) => {
      const resolvedSignerAddress = await resolveAddress(signerAddress);
      const resolvedPermissions = await SignerPermissionsSchema.parseAsync(permissions);
      if (await this.isAdmin(resolvedSignerAddress)) {
        throw new Error("Signer is already an admin. Cannot grant permissions to an existing admin.");
      }
      if (await this.isSigner(resolvedSignerAddress)) {
        throw new Error("Signer already has permissions. Cannot grant permissions to an existing signer. You can update permissions using `updatePermissions`.");
      }
      return await this.sendSignerPermissionRequest(resolvedSignerAddress, resolvedPermissions);
    }));
    /**
     * Update the permissions of a signer for using the account.
     *
     * @remarks Updates the permissions of a signer for using the account.
     *
     * @param signer - The signer whose permissions to use the account are to be updated.
     * @param permissions - The permissions to be applied to the signer's use of the account.
     *
     * @example
     * ```javascript
     * const tx = await contract.account.updatePermissions(signer, permissions);
     * const receipt = tx.receipt();
     * ```
     *
     * @twfeature AccountPermissions
     */
    __publicField(this, "updatePermissions", buildTransactionFunction(async (signerAddress, permissions) => {
      const resolvedSignerAddress = await resolveAddress(signerAddress);
      const resolvedPermissions = await SignerPermissionsSchema.parseAsync(permissions);
      if (await this.isAdmin(resolvedSignerAddress)) {
        throw new Error("Signer is already an admin. Cannot update permissions of an existing admin.");
      }
      if (!await this.isSigner(resolvedSignerAddress)) {
        throw new Error("Signer does not already have permissions. You can grant permissions using `grantPermissions`.");
      }
      return await this.sendSignerPermissionRequest(resolvedSignerAddress, resolvedPermissions);
    }));
    /**
     * Revoke a scoped access address to the account
     *
     * @remarks Revokes an address' access to the account.
     *
     * @param signer - The address whose access to the account is to be revoked.
     *
     * @example
     * ```javascript
     * const tx = await contract.account.revokeAccess(signer);
     * const receipt = tx.receipt();
     * ```
     *
     * @twfeature AccountPermissions
     */
    __publicField(this, "revokeAccess", buildTransactionFunction(async (signerAddress) => {
      const resolvedSignerAddress = await resolveAddress(signerAddress);
      if (await this.isAdmin(resolvedSignerAddress)) {
        throw new Error("Signer is already an admin. Cannot revoke permissions of an admin.");
      }
      if (!await this.isSigner(resolvedSignerAddress)) {
        throw new Error("Signer does not already have permissions. You can grant permissions using `grantPermissions`.");
      }
      return await this.sendSignerPermissionRequest(resolvedSignerAddress, {
        startDate: BigNumber.from(0),
        expirationDate: BigNumber.from(0),
        approvedCallTargets: [],
        nativeTokenLimitPerTransaction: "0"
      });
    }));
    /**
     * Approve an address as a call target for a given signer on the account
     *
     * @remarks Approves an address as a call target for a given signer on the account.
     *
     * @param signer - A signer with restricted access to the account.
     * @param target - The address to approve as a call target for the signer.
     *
     * @example
     * ```javascript
     * const tx = await contract.account.approveTargetForSigner(signer, target);
     * const receipt = tx.receipt();
     * ```
     *
     * @twfeature AccountPermissions
     */
    __publicField(this, "approveTargetForSigner", buildTransactionFunction(async (signerAddress, target) => {
      const resolvedSignerAddress = await resolveAddress(signerAddress);
      const resolvedTarget = await resolveAddress(target);
      if (await this.isAdmin(resolvedSignerAddress)) {
        throw new Error("Signer is already an admin. Cannot approve targets for an admin.");
      }
      if (!await this.isSigner(resolvedSignerAddress)) {
        throw new Error("Signer does not already have permissions. You can grant permissions using `grantPermissions`.");
      }
      const permissions = await this.contractWrapper.read("getPermissionsForSigner", [resolvedSignerAddress]);
      if (permissions.approvedTargets.includes(target)) {
        throw new Error("Target is already approved");
      }
      const newTargets = [...permissions.approvedTargets, resolvedTarget];
      return await this.sendSignerPermissionRequest(resolvedSignerAddress, {
        startDate: BigNumber.from(permissions.startTimestamp),
        expirationDate: BigNumber.from(permissions.endTimestamp),
        approvedCallTargets: newTargets,
        nativeTokenLimitPerTransaction: permissions.nativeTokenLimitPerTransaction.toString()
      });
    }));
    /**
     * Disapprove an address as a call target for a given signer on the account
     *
     * @remarks Disapprove an address as a call target for a given signer on the account.
     *
     * @param signer - A signer with restricted access to the account.
     * @param target - The address to disapprove as a call target for the signer.
     *
     * @example
     * ```javascript
     * const tx = await contract.account.disapproveTargetForSigner(signer, target);
     * const receipt = tx.receipt();
     * ```
     *
     * @twfeature AccountPermissions
     */
    __publicField(this, "disapproveTargetForSigner", buildTransactionFunction(async (signerAddress, target) => {
      const resolvedSignerAddress = await resolveAddress(signerAddress);
      const resolvedTarget = await resolveAddress(target);
      if (await this.isAdmin(resolvedSignerAddress)) {
        throw new Error("Signer is already an admin. Cannot approve targets for an admin.");
      }
      if (!await this.isSigner(resolvedSignerAddress)) {
        throw new Error("Signer does not already have permissions. You can grant permissions using `grantPermissions`.");
      }
      const permissions = await this.contractWrapper.read("getPermissionsForSigner", [resolvedSignerAddress]);
      if (!permissions.approvedTargets.includes(resolvedTarget)) {
        throw new Error("Target is currently not approved");
      }
      const newTargets = permissions.approvedTargets.filter((approvedTarget) => utils_exports.getAddress(approvedTarget) !== utils_exports.getAddress(resolvedTarget));
      return await this.sendSignerPermissionRequest(resolvedSignerAddress, {
        startDate: BigNumber.from(permissions.startTimestamp),
        expirationDate: BigNumber.from(permissions.endTimestamp),
        approvedCallTargets: newTargets,
        nativeTokenLimitPerTransaction: permissions.nativeTokenLimitPerTransaction.toString()
      });
    }));
    /**
     * Set the account's entire snapshot of permissions.
     *
     * @remarks Sets the account's entire snapshot of permissions.
     *
     * @param permissionSnapshot - the snapshot to set as the account's entire permission snapshot.
     *
     * @example
     * ```javascript
     * const tx = await contract.account.setAccess(permissionSnapshot);
     * const receipt = tx.receipt();
     * ```
     *
     * @twfeature AccountPermissions
     */
    __publicField(this, "resetAllPermissions", buildTransactionFunction(async (permissionSnapshot) => {
      const resolvedSnapshot = await PermissionSnapshotSchema.parseAsync(permissionSnapshot);
      if (this.hasDuplicateSigners(resolvedSnapshot)) {
        throw new Error("Duplicate signers found in input.");
      }
      const addAdminData = [];
      const removeAdminData = [];
      const addOrUpdateSignerData = [];
      const removeSignerData = [];
      const allAdmins = await this.getAllAdmins();
      const allToMakeAdmin = resolvedSnapshot.filter((item) => item.makeAdmin).map((item) => item.signer);
      allAdmins.forEach((admin) => {
        if (!allToMakeAdmin.includes(admin)) {
          removeAdminData.push(this.contractWrapper.writeContract.interface.encodeFunctionData("setAdmin", [admin, false]));
        }
      });
      const allSigners = await this.getAllSigners();
      const allToMakeSigners = resolvedSnapshot.filter((item) => {
        return !item.makeAdmin;
      }).map((item) => item.signer);
      await Promise.all(allSigners.map(async (item) => {
        if (!allToMakeSigners.includes(item.signer)) {
          const data2 = await this.buildSignerPermissionRequest(item.signer, {
            startDate: BigNumber.from(0),
            expirationDate: BigNumber.from(0),
            approvedCallTargets: [],
            nativeTokenLimitPerTransaction: "0"
          });
          removeSignerData.push(data2);
        }
      }));
      for (const member of resolvedSnapshot) {
        if (member.makeAdmin) {
          addAdminData.push(this.contractWrapper.writeContract.interface.encodeFunctionData("setAdmin", [member.signer, true]));
        } else {
          const data2 = await this.buildSignerPermissionRequest(member.signer, member.permissions);
          addOrUpdateSignerData.push(data2);
        }
      }
      const data = [];
      removeAdminData.forEach((item) => {
        data.push(item);
      });
      removeSignerData.forEach((item) => {
        data.push(item);
      });
      addOrUpdateSignerData.forEach((item) => {
        data.push(item);
      });
      return Transaction.fromContractWrapper({
        contractWrapper: this.contractWrapper,
        method: "multicall",
        args: [data]
      });
    }));
    this.contractWrapper = contractWrapper;
  }
  getAddress() {
    return this.contractWrapper.address;
  }
  /*********************************
   * HELPER FUNCTIONS
   ********************************/
  hasDuplicateSigners(snapshot) {
    const checkedSigner = {};
    const signers = snapshot.map((item) => item.signer);
    for (const signer of signers) {
      if (!checkedSigner[signer]) {
        checkedSigner[signer] = true;
      } else {
        return true;
      }
    }
    return false;
  }
  /**
   * Format the access restrictions for a given role
   *
   * @param restrictions - The access restrictions for a given role
   * @returns formatted role restrictions
   *
   */
  parseSignerPermissionsStruct(permissions) {
    return {
      startDate: new Date(parseInt(permissions.startTimestamp.toString()) * 1e3),
      expirationDate: new Date(parseInt(permissions.endTimestamp.toString()) * 1e3),
      nativeTokenLimitPerTransaction: BigNumber.from(permissions.nativeTokenLimitPerTransaction),
      approvedCallTargets: permissions.approvedTargets
    };
  }
  async sendSignerPermissionRequest(signerAddress, permissions) {
    const {
      payload,
      signature
    } = await this.generatePayload(signerAddress, permissions);
    const [success] = await this.contractWrapper.read("verifySignerPermissionRequest", [payload, signature]);
    if (!success) {
      throw new Error(`Invalid signature.`);
    }
    return Transaction.fromContractWrapper({
      contractWrapper: this.contractWrapper,
      method: "setPermissionsForSigner",
      args: [payload, signature]
    });
  }
  async buildSignerPermissionRequest(signerAddress, permissions) {
    const {
      payload,
      signature
    } = await this.generatePayload(signerAddress, permissions);
    const isValidSigner = await this.contractWrapper.read("verifySignerPermissionRequest", [payload, signature]);
    if (!isValidSigner) {
      throw new Error(`Invalid signature.`);
    }
    return this.contractWrapper.writeContract.interface.encodeFunctionData("setPermissionsForSigner", [payload, signature]);
  }
  /**
   * Generate and sign a payload to grant or revoke a signer's access to the account.
   *
   * @param signer - The address of the signer
   * @param roleAction - The address of the signer
   * @returns The generated payload and signature produced on signing that payload.
   *
   */
  async generatePayload(signerAddress, permissions) {
    const payload = {
      signer: signerAddress,
      approvedTargets: permissions.approvedCallTargets,
      nativeTokenLimitPerTransaction: utils_exports.parseEther(permissions.nativeTokenLimitPerTransaction),
      permissionStartTimestamp: permissions.startDate,
      permissionEndTimestamp: permissions.expirationDate,
      reqValidityStartTimestamp: 0,
      // Req validity ends 10 years from now.
      reqValidityEndTimestamp: BigNumber.from(Math.floor(new Date(Date.now() + 1e3 * 60 * 60 * 24 * 365 * 10).getTime() / 1e3)),
      uid: resolveOrGenerateId(void 0)
    };
    const chainId = await this.contractWrapper.getChainID();
    const connectedSigner = this.contractWrapper.getSigner();
    invariant(connectedSigner, "No signer available");
    const signature = await this.contractWrapper.signTypedData(connectedSigner, {
      name: "Account",
      version: "1",
      chainId,
      verifyingContract: this.getAddress()
    }, {
      SignerPermissionRequest
    }, payload);
    return {
      payload,
      signature
    };
  }
  /*********************************
   * READ FUNCTIONS
   ********************************/
  /**
   * Get whether a signer is an admin on the account.
   *
   * @example
   * ```javascript
   * const isAdmin = await contract.account.isAdmin(signer);
   * ```
   * @param signer - The address of a signer of the account.
   * @returns whether a signer is an admin on the account.
   *
   * @twfeature AccountPermissions
   */
  async isAdmin(signerAddress) {
    const resolvedSignerAddress = await resolveAddress(signerAddress);
    return await this.contractWrapper.read("isAdmin", [resolvedSignerAddress]);
  }
  /**
   * Get whether a signer has permissions to use the account.
   *
   * @example
   * ```javascript
   * const isAdmin = await contract.account.isSigner(signer);
   * ```
   * @param signer - The address of a signer of the account.
   * @returns whether a signer has permissions to use the account.
   *
   * @twfeature AccountPermissions
   */
  async isSigner(signerAddress) {
    const resolvedSignerAddress = await resolveAddress(signerAddress);
    return await this.contractWrapper.read("isActiveSigner", [resolvedSignerAddress]);
  }
  /**
   * Get all admins of the account.
   *
   * @example
   * ```javascript
   * const allAdmins = await contract.account.getAllAdmins();
   * ```
   *
   * @returns all admins of the account.
   *
   * @twfeature AccountPermissions
   */
  async getAllAdmins() {
    return await this.contractWrapper.read("getAllAdmins", []);
  }
  /**
   * Get all (non-admin) signers with permissions to use the account.
   *
   * @example
   * ```javascript
   * const allSigners = await contract.account.getAllSigners();
   * ```
   *
   * @returns all (non-admin) signers with permissions to use the account.
   *
   * @twfeature AccountPermissions
   */
  async getAllSigners() {
    const activeSignersWithPerms = await this.contractWrapper.read("getAllActiveSigners", []);
    return await Promise.all(activeSignersWithPerms.map(async (signerWithPermissions) => {
      const signer = signerWithPermissions.signer;
      const permissions = this.parseSignerPermissionsStruct(signerWithPermissions);
      return {
        signer,
        permissions
      };
    }));
  }
  /**
   * Get all admins and non-admin signers with permissions to use the account.
   *
   * @example
   * ```javascript
   * const allAdminsAndSigners = await contract.account.getAllAdminsAndSigners();
   * ```
   *
   * @returns all admins and non-admin signers with permissions to use the account.
   *
   * @twfeature AccountPermissions
   */
  async getAllAdminsAndSigners() {
    const allAdmins = await this.getAllAdmins();
    const transformedAdmins = allAdmins.map((admin) => {
      return {
        isAdmin: true,
        signer: admin,
        permissions: {
          startDate: /* @__PURE__ */ new Date(0),
          expirationDate: /* @__PURE__ */ new Date(0),
          nativeTokenLimitPerTransaction: BigNumber.from(0),
          approvedCallTargets: []
        }
      };
    });
    const allSigners = await this.getAllSigners();
    return [...transformedAdmins, ...allSigners];
  }
};
var Account = class {
  constructor(contractWrapper) {
    __publicField(this, "featureName", FEATURE_ACCOUNT.name);
    /*********************************
     * WRITE FUNCTIONS
     ********************************/
    /**
     * Grant an address admin access to the account.
     *
     * @remarks Grants an address admin access to the account. The admin will have complete authority over the account.
     *
     * @param signer - The address to be granted admin access to the account.
     *
     * @example
     * ```javascript
     * const tx = await contract.account.grantAdminAccess(signer);
     * const receipt = tx.receipt();
     * ```
     *
     * @twfeature AccountPermissions
     */
    __publicField(this, "grantAdminPermissions", buildTransactionFunction(async (signerAddress) => {
      return assertEnabled(this.accountPermissions, FEATURE_ACCOUNT_PERMISSIONS).grantAdminPermissions.prepare(signerAddress);
    }));
    /**
     * Revoke an address' admin access to the account.
     *
     * @remarks Revokes an address' admin access to the account.
     *
     * @param signer - The address of an admin of the account.
     *
     * @example
     * ```javascript
     * const tx = await contract.account.revokeAdminAccess(signer);
     * const receipt = tx.receipt();
     * ```
     *
     * @twfeature AccountPermissions
     */
    __publicField(this, "revokeAdminPermissions", buildTransactionFunction(async (signerAddress) => {
      return assertEnabled(this.accountPermissions, FEATURE_ACCOUNT_PERMISSIONS).revokeAdminPermissions.prepare(signerAddress);
    }));
    /**
     * Grant a signer permissions to use the account.
     *
     * @remarks Grants a signer permissions to use the account.
     *
     * @param signer - The signer to be granted permissions to use the account.
     * @param permissions - The permissions to be applied to the signer's use of the account.
     *
     * @example
     * ```javascript
     * const tx = await contract.account.grantPermissions(signer, permissions);
     * const receipt = tx.receipt();
     * ```
     *
     * @twfeature AccountPermissions
     */
    __publicField(this, "grantPermissions", buildTransactionFunction(async (signerAddress, permissions) => {
      return assertEnabled(this.accountPermissions, FEATURE_ACCOUNT_PERMISSIONS).grantPermissions.prepare(signerAddress, permissions);
    }));
    /**
     * Update the permissions of a signer for using the account.
     *
     * @remarks Updates the permissions of a signer for using the account.
     *
     * @param signer - The signer whose permissions to use the account are to be updated.
     * @param permissions - The permissions to be applied to the signer's use of the account.
     *
     * @example
     * ```javascript
     * const tx = await contract.account.updateAccess(signer, restrictions);
     * const receipt = tx.receipt();
     * ```
     *
     * @twfeature AccountPermissions
     */
    __publicField(this, "updatePermissions", buildTransactionFunction(async (signerAddress, permissions) => {
      return assertEnabled(this.accountPermissions, FEATURE_ACCOUNT_PERMISSIONS).updatePermissions.prepare(signerAddress, permissions);
    }));
    /**
     * Revoke a scoped access address to the account
     *
     * @remarks Revokes an address' access to the account.
     *
     * @param signer - The address whose access to the account is to be revoked.
     *
     * @example
     * ```javascript
     * const tx = await contract.account.revokeAccess(signer);
     * const receipt = tx.receipt();
     * ```
     *
     * @twfeature AccountPermissions
     */
    __publicField(this, "revokeAccess", buildTransactionFunction(async (signerAddress) => {
      return assertEnabled(this.accountPermissions, FEATURE_ACCOUNT_PERMISSIONS).revokeAccess.prepare(signerAddress);
    }));
    /**
     * Approve an address as a call target for a given signer on the account
     *
     * @remarks Approves an address as a call target for a given signer on the account.
     *
     * @param signer - A signer with restricted access to the account.
     * @param target - The address to approve as a call target for the signer.
     *
     * @example
     * ```javascript
     * const tx = await contract.account.approveTargetForSigner(signer, target);
     * const receipt = tx.receipt();
     * ```
     *
     * @twfeature AccountPermissions
     */
    __publicField(this, "approveTargetForSigner", buildTransactionFunction(async (signerAddress, target) => {
      return assertEnabled(this.accountPermissions, FEATURE_ACCOUNT_PERMISSIONS).approveTargetForSigner.prepare(signerAddress, target);
    }));
    /**
     * Disapprove an address as a call target for a given signer on the account
     *
     * @remarks Disapprove an address as a call target for a given signer on the account.
     *
     * @param signer - A signer with restricted access to the account.
     * @param target - The address to disapprove as a call target for the signer.
     *
     * @example
     * ```javascript
     * const tx = await contract.account.disapproveTargetForSigner(signer, target);
     * const receipt = tx.receipt();
     * ```
     *
     * @twfeature AccountPermissions
     */
    __publicField(this, "disapproveTargetForSigner", buildTransactionFunction(async (signerAddress, target) => {
      return assertEnabled(this.accountPermissions, FEATURE_ACCOUNT_PERMISSIONS).disapproveTargetForSigner.prepare(signerAddress, target);
    }));
    /**
     * Set the account's entire snapshot of permissions.
     *
     * @remarks Sets the account's entire snapshot of permissions.
     *
     * @param permissionSnapshot - the snapshot to set as the account's entire permission snapshot.
     *
     * @example
     * ```javascript
     * const tx = await contract.account.setAccess(permissionSnapshot);
     * const receipt = tx.receipt();
     * ```
     *
     * @twfeature AccountPermissions
     */
    __publicField(this, "resetAllPermissions", buildTransactionFunction(async (permissionSnapshot) => {
      return assertEnabled(this.accountPermissions, FEATURE_ACCOUNT_PERMISSIONS).resetAllPermissions.prepare(permissionSnapshot);
    }));
    this.contractWrapper = contractWrapper;
    this.accountPermissions = this.detectAccountPermissions();
  }
  detectAccountPermissions() {
    if (detectContractFeature(this.contractWrapper, "AccountPermissions")) {
      return new AccountPermissions(this.contractWrapper);
    }
    return void 0;
  }
  getAddress() {
    return this.contractWrapper.address;
  }
  /*********************************
   * READ FUNCTIONS
   ********************************/
  /**
   * Get whether a signer is an admin on the account.
   *
   * @example
   * ```javascript
   * const isAdmin = await contract.account.isAdmin(signer);
   * ```
   * @param signer - The address of a signer of the account.
   * @returns whether a signer is an admin on the account.
   *
   * @twfeature AccountPermissions
   */
  async isAdmin(signerAddress) {
    return assertEnabled(this.accountPermissions, FEATURE_ACCOUNT_PERMISSIONS).isAdmin(signerAddress);
  }
  /**
   * Get whether a signer has permissions to use the account.
   *
   * @example
   * ```javascript
   * const isAdmin = await contract.account.isSigner(signer);
   * ```
   * @param signer - The address of a signer of the account.
   * @returns whether a signer has permissions to use the account.
   *
   * @twfeature AccountPermissions
   */
  async isSigner(signerAddress) {
    return assertEnabled(this.accountPermissions, FEATURE_ACCOUNT_PERMISSIONS).isSigner(signerAddress);
  }
  /**
   * Get all admins of the account.
   *
   * @example
   * ```javascript
   * const allAdmins = await contract.account.getAllAdmins();
   * ```
   *
   * @returns all admins of the account.
   *
   * @twfeature AccountPermissions
   */
  async getAllAdmins() {
    return assertEnabled(this.accountPermissions, FEATURE_ACCOUNT_PERMISSIONS).getAllAdmins();
  }
  /**
   * Get all (non-admin) signers with permissions to use the account.
   *
   * @example
   * ```javascript
   * const allSigners = await contract.account.getAllSigners();
   * ```
   *
   * @returns all (non-admin) signers with permissions to use the account.
   *
   * @twfeature AccountPermissions
   */
  async getAllSigners() {
    return assertEnabled(this.accountPermissions, FEATURE_ACCOUNT_PERMISSIONS).getAllSigners();
  }
  /**
   * Get all admins and non-admin signers with permissions to use the account.
   *
   * @example
   * ```javascript
   * const allAdminsAndSigners = await contract.account.getAllAdminsAndSigners();
   * ```
   *
   * @returns all admins and non-admin signers with permissions to use the account.
   *
   * @twfeature AccountPermissions
   */
  async getAllAdminsAndSigners() {
    return assertEnabled(this.accountPermissions, FEATURE_ACCOUNT_PERMISSIONS).getAllAdminsAndSigners();
  }
};
var AccountFactory = class {
  // utilities
  constructor(contractWrapper) {
    __publicField(this, "featureName", FEATURE_ACCOUNT_FACTORY.name);
    /*********************************
     * WRITE FUNCTIONS
     *******************************/
    /**
     * Create a account
     *
     * @remarks Create a account for an admin. The admin will have complete authority over the account.
     *
     * @param admin - The admin of the account.
     * @param extraData - (Optional) Extra data to be passed to the account on creation.
     *
     * @example
     *  ```javascript
     * const tx = await contract.accountFactory.createAccount(admin, extraData);
     * const receipt = tx.receipt();
     * const accountAddress = tx.address;
     * ```
     *
     * @twfeature AccountFactory
     */
    __publicField(this, "createAccount", buildTransactionFunction(async (accountAdmin, extraData) => {
      if (await this.isAccountDeployed(accountAdmin, extraData)) {
        throw new Error(`Account already deployed for admin: ${accountAdmin}`);
      }
      let data = utils_exports.toUtf8Bytes("");
      if (extraData) {
        data = extraData;
      }
      return Transaction.fromContractWrapper({
        contractWrapper: this.contractWrapper,
        method: "createAccount",
        args: [accountAdmin, data],
        parse: (receipt) => {
          const event = this.contractWrapper.parseLogs("AccountCreated", receipt == null ? void 0 : receipt.logs);
          return {
            address: event[0].args.account,
            receipt
          };
        }
      });
    }));
    this.contractWrapper = contractWrapper;
    this.events = new ContractEvents(this.contractWrapper);
  }
  getAddress() {
    return this.contractWrapper.address;
  }
  /*********************************
   * READ FUNCTIONS
   *******************************/
  /**
   * Get the deterministic address of the account that will be created
   *
   * @example
   * ```javascript
   * const accountAddress = await contract.accountFactory.predictAccountAddress(admin);
   * ```
   * @param admin - The admin of the account.
   * @param extraData - (Optional) Extra data to be passed to the account on creation.
   * @returns the deterministic address of the account that will be created for the given admin.
   *
   * @twfeature AccountFactory
   */
  async predictAccountAddress(admin, extraData) {
    let data = utils_exports.toUtf8Bytes("");
    if (extraData) {
      data = extraData;
    }
    return this.contractWrapper.read("getAddress", [admin, data]);
  }
  /**
   * Get all accounts on which the given signer has authority
   *
   * @example
   * ```javascript
   * const allAccounts = await contract.accountFactory.getAssociatedAccounts(admin);
   * ```
   * @param signer - The account address.
   * @returns all accounts on which the given signer has authority.
   *
   * @twfeature AccountFactory
   */
  async getAssociatedAccounts(signer) {
    return this.contractWrapper.read("getAccountsOfSigner", [signer]);
  }
  /**
   * Get all accounts
   *
   * @example
   * ```javascript
   * const allAccounts = await contract.accountFactory.getAllAccounts();
   * ```
   *
   * @returns all accounts created via the account factory.
   *
   * @twfeature AccountFactory
   */
  async getAllAccounts() {
    return await this.contractWrapper.read("getAllAccounts", []);
  }
  /**
   * Check if a account has been deployed for the given admin
   *
   * @param admin - The admin of the account.
   * @param extraData - (Optional) Extra data to be passed to the account on creation.
   * @returns whether the account has been deployed for the given admin.
   */
  async isAccountDeployed(admin, extraData) {
    const addr = await this.predictAccountAddress(admin, extraData);
    return isContractDeployed(addr, this.contractWrapper.getProvider());
  }
};
var Airdrop1155 = class {
  constructor(contractWrapper) {
    __publicField(this, "featureName", FEATURE_AIRDROP_ERC1155.name);
    /** ******************************
     * WRITE FUNCTIONS
     *******************************/
    /**
     * Perform airdrop of ERC1155 tokens
     *
     * @example
     * ```javascript
     * // Airdrop content array, with recipients and tokenIds
     * const contents = [
     *      {
     *        recipient: "0xabc...", // first recipient address
     *        tokenId: 0,
     *        amount: "10" // number of tokens
     *      },
     *      {
     *        recipient: "0x123...", // second recipient address
     *        tokenId: 0
     *        amount: "20" // number of tokens
     *      }
     *   ]
     *
     * const tokenAddress = "0x..." // Address of the ERC1155 token being airdropped
     * const tokenOwner = "0x..." // Address of the owner of the tokens being airdropped
     *
     * const output = await contract.airdrop1155.drop(tokenAddress, tokenOwner, contents);
     *
     * // the `output` return value above contains:
     * //     - count of successful and failed drops
     * //     - array containing failed drops, if any
     *
     * ```
     * @param tokenAddress
     * @param tokenOwner
     * @param contents
     *
     * @returns an array of recipients for who the airdrop failed (empty means all transfers were successful)
     * @twfeature AirdropERC1155
     */
    __publicField(this, "drop", buildTransactionFunction(async (tokenAddress, tokenOwner, contents) => {
      return Transaction.fromContractWrapper({
        contractWrapper: this.contractWrapper,
        method: "airdropERC1155",
        args: [tokenAddress, tokenOwner, contents],
        parse: (receipt) => {
          const events = this.contractWrapper.parseLogs("AirdropFailed", receipt.logs);
          const failedDrops = events.map((e) => {
            return {
              recipient: e.args.recipient,
              tokenId: e.args.tokenId.toNumber(),
              amount: e.args.amount.toString()
            };
          });
          return {
            successfulDropCount: contents.length - failedDrops.length,
            failedDropCount: failedDrops.length,
            failedDrops
          };
        }
      });
    }));
    this.contractWrapper = contractWrapper;
  }
  /**
   * @internal
   */
  getAddress() {
    return this.contractWrapper.address;
  }
};
var Airdrop20 = class {
  constructor(contractWrapper) {
    __publicField(this, "featureName", FEATURE_AIRDROP_ERC20.name);
    /** ******************************
     * WRITE FUNCTIONS
     *******************************/
    /**
     * Perform airdrop of ERC20 tokens
     *
     * @example
     * ```javascript
     * // Airdrop content array, with recipients and token amounts
     * const contents = [
     *      {
     *        recipient: "0xabc...", // first recipient address
     *        amount: "10" // number of tokens in wei units
     *      },
     *      {
     *        recipient: "0x123...", // second recipient address
     *        amount: "20" // number of tokens in wei units
     *      }
     *   ]
     *
     * const tokenAddress = "0x..." // Address of the ERC20 token being airdropped
     * const tokenOwner = "0x..." // Address of the owner of the tokens being airdropped
     *
     * const output = await contract.airdrop20.drop(tokenAddress, tokenOwner, contents);
     *
     * // the `output` return value above contains:
     * //     - count of successful and failed drops
     * //     - array containing failed drops, if any
     *
     * ```
     * @param tokenAddress
     * @param tokenOwner
     * @param contents
     *
     * @returns an array of recipients for who the airdrop failed (empty means all transfers were successful)
     * @twfeature AirdropERC20
     */
    __publicField(this, "drop", buildTransactionFunction(async (tokenAddress, tokenOwner, contents) => {
      return Transaction.fromContractWrapper({
        contractWrapper: this.contractWrapper,
        method: "airdropERC20",
        args: [tokenAddress, tokenOwner, contents],
        parse: (receipt) => {
          const events = this.contractWrapper.parseLogs("AirdropFailed", receipt.logs);
          const failedDrops = events.map((e) => {
            return {
              recipient: e.args.recipient,
              amount: e.args.amount.toString()
            };
          });
          return {
            successfulDropCount: contents.length - failedDrops.length,
            failedDropCount: failedDrops.length,
            failedDrops
          };
        }
      });
    }));
    this.contractWrapper = contractWrapper;
  }
  /**
   * @internal
   */
  getAddress() {
    return this.contractWrapper.address;
  }
};
var Airdrop721 = class {
  constructor(contractWrapper) {
    __publicField(this, "featureName", FEATURE_AIRDROP_ERC721.name);
    /** ******************************
     * WRITE FUNCTIONS
     *******************************/
    /**
     * Perform airdrop of ERC721 tokens
     *
     * @example
     * ```javascript
     * // Airdrop content array, with recipients and tokenIds
     * const contents = [
     *      {
     *        recipient: "0xabc...", // first recipient address
     *        tokenId: 0
     *      },
     *      {
     *        recipient: "0x123...", // second recipient address
     *        tokenId: 2
     *      }
     *   ]
     *
     * const tokenAddress = "0x..." // Address of the ERC721 token being airdropped
     * const tokenOwner = "0x..." // Address of the owner of the tokens being airdropped
     *
     * const output = await contract.airdrop721.drop(tokenAddress, tokenOwner, contents);
     *
     * // the `output` return value above contains:
     * //     - count of successful and failed drops
     * //     - array containing failed drops, if any
     *
     * ```
     * @param tokenAddress
     * @param tokenOwner
     * @param contents
     *
     * @returns an array of recipients for who the airdrop failed (empty means all transfers were successful)
     * @twfeature AirdropERC721
     */
    __publicField(this, "drop", buildTransactionFunction(async (tokenAddress, tokenOwner, contents) => {
      return Transaction.fromContractWrapper({
        contractWrapper: this.contractWrapper,
        method: "airdropERC721",
        args: [tokenAddress, tokenOwner, contents],
        parse: (receipt) => {
          const events = this.contractWrapper.parseLogs("AirdropFailed", receipt.logs);
          const failedDrops = events.map((e) => {
            return {
              recipient: e.args.recipient,
              tokenId: e.args.tokenId.toNumber()
            };
          });
          return {
            successfulDropCount: contents.length - failedDrops.length,
            failedDropCount: failedDrops.length,
            failedDrops
          };
        }
      });
    }));
    this.contractWrapper = contractWrapper;
  }
  /**
   * @internal
   */
  getAddress() {
    return this.contractWrapper.address;
  }
};
var ExtensionManager = class {
  constructor(contractWrapper) {
    __publicField(this, "featureName", FEATURE_DYNAMIC_CONTRACT.name);
    /** ******************************
     * WRITE FUNCTIONS
     *******************************/
    /**
     * Adds an extension to the contract
     */
    __publicField(this, "add", buildTransactionFunction(async (inputArgs) => {
      return Transaction.fromContractWrapper({
        contractWrapper: this.contractWrapper,
        method: "addExtension",
        args: [inputArgs.extension],
        parse: async (receipt) => {
          const events = this.contractWrapper.parseLogs("ExtensionAdded", receipt.logs);
          if (events.length < 1) {
            throw new Error("No ExtensionAdded event found");
          }
          const extensionAbi = inputArgs.extensionAbi ? AbiSchema.parse(inputArgs.extensionAbi) : (await fetchContractMetadataFromAddress(inputArgs.extension.metadata.implementation, this.contractWrapper.getProvider(), this.contractWrapper.storage)).abi;
          const abiToAdd = this.filterAbiForAdd(extensionAbi, inputArgs.extension);
          const updatedAbi = joinABIs([AbiSchema.parse(this.contractWrapper.abi), abiToAdd]);
          this.contractWrapper.updateAbi(updatedAbi);
          return receipt;
        }
      });
    }));
    /**
     * Adds a deployed extension to the contract
     */
    __publicField(this, "addDeployed", buildTransactionFunction(async (inputArgs) => {
      let extensionAbi = inputArgs.extensionAbi;
      if (!extensionAbi) {
        const metadata = await fetchContractMetadataFromAddress(inputArgs.extensionAddress, this.contractWrapper.getProvider(), this.contractWrapper.storage, this.contractWrapper.options);
        extensionAbi = metadata.abi;
      }
      invariant(extensionAbi, "Require extension ABI");
      let extensionMetadataUri = "";
      if (inputArgs.extensionMetadata) {
        if (typeof inputArgs.extensionMetadata === "string") {
          extensionMetadataUri = inputArgs.extensionMetadata;
        } else {
          const parsedMetadata = await CommonContractSchema.parseAsync(inputArgs.extensionMetadata);
          extensionMetadataUri = await this.contractWrapper.storage.upload(parsedMetadata);
        }
      }
      const extensionFunctions = generateExtensionFunctions(AbiSchema.parse(extensionAbi));
      const extension = {
        metadata: {
          name: inputArgs.extensionName,
          metadataURI: extensionMetadataUri,
          implementation: inputArgs.extensionAddress
        },
        functions: extensionFunctions
      };
      return this.add.prepare({
        extension,
        extensionAbi
      });
    }));
    /**
     * Adds a published extension to the contract, and deploys it deterministically if necessary
     */
    __publicField(this, "addPublished", buildTransactionFunction(async (inputArgs) => {
      const version = inputArgs.version || "latest";
      const {
        deployedExtensionAddress,
        extensionMetadata
      } = await this.deployExtension(inputArgs.extensionName, inputArgs.publisherAddress || THIRDWEB_DEPLOYER, version);
      return this.addDeployed.prepare({
        extensionName: inputArgs.extensionName,
        extensionAddress: deployedExtensionAddress,
        extensionMetadata: inputArgs.extensionMetadataOverride || extensionMetadata
      });
    }));
    __publicField(this, "replace", buildTransactionFunction(async (inputArgs) => {
      return Transaction.fromContractWrapper({
        contractWrapper: this.contractWrapper,
        method: "replaceExtension",
        args: [inputArgs.extension],
        parse: async (receipt) => {
          const events = this.contractWrapper.parseLogs("ExtensionReplaced", receipt.logs);
          if (events.length < 1) {
            throw new Error("No ExtensionReplaced event found");
          }
          const extensionAbi = inputArgs.extensionAbi ? AbiSchema.parse(inputArgs.extensionAbi) : (await fetchContractMetadataFromAddress(inputArgs.extension.metadata.implementation, this.contractWrapper.getProvider(), this.contractWrapper.storage)).abi;
          const contractAbi = this.filterAbiForRemove(AbiSchema.parse(this.contractWrapper.abi), extensionAbi);
          const abiToAdd = this.filterAbiForAdd(extensionAbi, inputArgs.extension);
          const updatedAbi = joinABIs([contractAbi, abiToAdd]);
          this.contractWrapper.updateAbi(updatedAbi);
          return receipt;
        }
      });
    }));
    __publicField(this, "replaceDeployed", buildTransactionFunction(async (inputArgs) => {
      let extensionAbi = inputArgs.extensionAbi;
      if (!extensionAbi) {
        const metadata = await fetchContractMetadataFromAddress(inputArgs.extensionAddress, this.contractWrapper.getProvider(), this.contractWrapper.storage, this.contractWrapper.options);
        extensionAbi = metadata.abi;
      }
      invariant(extensionAbi, "Require extension ABI");
      let extensionMetadataUri = "";
      if (inputArgs.extensionMetadata) {
        if (typeof inputArgs.extensionMetadata === "string") {
          extensionMetadataUri = inputArgs.extensionMetadata;
        } else {
          const parsedMetadata = await CommonContractSchema.parseAsync(inputArgs.extensionMetadata);
          extensionMetadataUri = await this.contractWrapper.storage.upload(parsedMetadata);
        }
      }
      const extensionFunctions = generateExtensionFunctions(AbiSchema.parse(extensionAbi));
      const extension = {
        metadata: {
          name: inputArgs.extensionName,
          metadataURI: extensionMetadataUri,
          implementation: inputArgs.extensionAddress
        },
        functions: extensionFunctions
      };
      return this.replace.prepare({
        extension,
        extensionAbi
      });
    }));
    __publicField(this, "replacePublished", buildTransactionFunction(async (inputArgs) => {
      const version = inputArgs.version || "latest";
      const {
        deployedExtensionAddress,
        extensionMetadata
      } = await this.deployExtension(inputArgs.extensionName, inputArgs.publisherAddress || THIRDWEB_DEPLOYER, version);
      return this.replaceDeployed.prepare({
        extensionName: inputArgs.extensionName,
        extensionAddress: deployedExtensionAddress,
        extensionMetadata: inputArgs.extensionMetadataOverride || extensionMetadata
      });
    }));
    __publicField(this, "remove", buildTransactionFunction(async (inputArgs) => {
      const extensionAddress = await this.getExtensionAddress(inputArgs.extensionName);
      return Transaction.fromContractWrapper({
        contractWrapper: this.contractWrapper,
        method: "removeExtension",
        args: [inputArgs.extensionName],
        parse: async (receipt) => {
          const events = this.contractWrapper.parseLogs("ExtensionRemoved", receipt.logs);
          if (events.length < 1) {
            throw new Error("No ExtensionRemoved event found");
          }
          const extensionAbi = (await fetchContractMetadataFromAddress(extensionAddress, this.contractWrapper.getProvider(), this.contractWrapper.storage)).abi;
          const updatedAbi = this.filterAbiForRemove(AbiSchema.parse(this.contractWrapper.abi), extensionAbi);
          this.contractWrapper.updateAbi(updatedAbi);
          return receipt;
        }
      });
    }));
    this.contractWrapper = contractWrapper;
  }
  getAddress() {
    return this.contractWrapper.readContract.address;
  }
  /** ******************************
   * READ FUNCTIONS
   *******************************/
  async getAll() {
    const extensions = await this.contractWrapper.readContract.getAllExtensions();
    return extensions;
  }
  async get(extensionName) {
    const extension = await this.contractWrapper.readContract.getExtension(extensionName);
    return extension;
  }
  async getExtensionAddress(extensionName) {
    const extension = await this.get(extensionName);
    return extension.metadata.implementation;
  }
  async getAllFunctions(extensionName) {
    const extension = await this.get(extensionName);
    return extension.functions;
  }
  async getExtensionForFunction(functionInput) {
    let selector = functionInput.functionSelector;
    if (!selector) {
      invariant(functionInput.functionSignature, "Atleast one of function selector and signature must be provided");
      selector = utils_exports.id(functionInput.functionSignature).substring(0, 10);
    }
    const extensionMetadata = await this.contractWrapper.readContract.getMetadataForFunction(selector);
    return extensionMetadata;
  }
  async getExtensionAddressForFunction(functionInput) {
    const extensionMetadata = await this.getExtensionForFunction(functionInput);
    return extensionMetadata.implementation;
  }
  /** ******************************
   * Internal / private
   *******************************/
  filterAbiForAdd(extensionAbi, extension) {
    const extensionAbiInterface = new utils_exports.Interface(extensionAbi);
    const extensionFunctionSelectors = extension.functions.map((fn) => fn.functionSelector);
    const filtered = extensionAbi.filter((item) => {
      const fnFragment = Object.values(new utils_exports.Interface([item]).functions);
      if (fnFragment.length === 0) {
        return false;
      }
      const fnSigHash = extensionAbiInterface.getSighash(fnFragment[0]);
      return extensionFunctionSelectors.includes(fnSigHash);
    });
    return filtered;
  }
  filterAbiForRemove(fullAbi, abiToRemove) {
    const fullAbiInterface = new utils_exports.Interface(fullAbi);
    const interfaceToRemove = new utils_exports.Interface(abiToRemove);
    const functionsToRemove = Object.values(interfaceToRemove.functions).map((fn) => interfaceToRemove.getSighash(fn));
    const filtered = fullAbi.filter((item) => {
      const fnFragment = Object.values(new utils_exports.Interface([item]).functions);
      if (fnFragment.length === 0) {
        return false;
      }
      const fnSigHash = fullAbiInterface.getSighash(fnFragment[0]);
      return !functionsToRemove.includes(fnSigHash);
    });
    return filtered;
  }
  async deployExtension(extensionName, publisherAddress) {
    var _a;
    let version = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : "latest";
    const published = await fetchPublishedContractFromPolygon(publisherAddress, extensionName, version, this.contractWrapper.storage, this.contractWrapper.options.clientId, this.contractWrapper.options.secretKey);
    const deploymentInfo = await getDeploymentInfo(published.metadataUri, this.contractWrapper.storage, this.contractWrapper.getProvider(), "", this.contractWrapper.options.clientId, this.contractWrapper.options.secretKey);
    const implementationAddress = (_a = deploymentInfo.find((i) => i.type === "implementation")) == null ? void 0 : _a.transaction.predictedAddress;
    const transactionsToSend = deploymentInfo.filter((i) => i.transaction.data && i.transaction.data.length > 0);
    const transactionsforDirectDeploy = transactionsToSend.filter((i) => {
      return i.type !== "infra";
    }).map((i) => i.transaction);
    const transactionsForThrowawayDeployer = transactionsToSend.filter((i) => {
      return i.type === "infra";
    }).map((i) => i.transaction);
    const signer = this.contractWrapper.getSigner();
    invariant(signer, "Signer is required");
    await deployWithThrowawayDeployer(signer, transactionsForThrowawayDeployer, {});
    for (const tx of transactionsforDirectDeploy) {
      try {
        await deployContractDeterministic(signer, tx);
      } catch (e) {
        console.debug(`Error deploying contract at ${tx.predictedAddress}`, e == null ? void 0 : e.message);
      }
    }
    return {
      deployedExtensionAddress: implementationAddress,
      extensionMetadata: published.metadataUri
    };
  }
};
var SmartContract = class {
  // utilities
  get abi() {
    return AbiSchema.parse(this.contractWrapper.abi || []);
  }
  /**
   * Handle royalties
   */
  get royalties() {
    return assertEnabled(this.detectRoyalties(), FEATURE_ROYALTY);
  }
  /**
   * Handle permissions
   */
  get roles() {
    return assertEnabled(this.detectRoles(), FEATURE_PERMISSIONS);
  }
  /**
   * Handle primary sales
   */
  get sales() {
    return assertEnabled(this.detectPrimarySales(), FEATURE_PRIMARY_SALE);
  }
  /**
   * Handle platform fees
   */
  get platformFees() {
    return assertEnabled(this.detectPlatformFees(), FEATURE_PLATFORM_FEE);
  }
  /**
   * Set and get the owner of the contract
   */
  get owner() {
    return assertEnabled(this.detectOwnable(), FEATURE_OWNER);
  }
  /**
   * Auto-detects ERC20 standard functions.
   */
  get erc20() {
    return assertEnabled(this.detectErc20(), FEATURE_TOKEN);
  }
  /**
   * Auto-detects ERC721 standard functions.
   */
  get erc721() {
    return assertEnabled(this.detectErc721(), FEATURE_NFT);
  }
  /**
   * Auto-detects ERC1155 standard functions.
   */
  get erc1155() {
    return assertEnabled(this.detectErc1155(), FEATURE_EDITION);
  }
  /**
   * Auto-detects AppURI standard functions.
   */
  get app() {
    return assertEnabled(this.detectApp(), FEATURE_APPURI);
  }
  /**
   * Direct listings
   * @remarks Create and manage direct listings in your marketplace.
   * ```javascript
   * // Data of the listing you want to create
   * const listing = {
   *   // address of the contract the asset you want to list is on
   *   assetContractAddress: "0x...",
   *   // token ID of the asset you want to list
   *   tokenId: "0",
   *   // how many of the asset you want to list
   *   quantity: 1,
   *   // address of the currency contract that will be used to pay for the listing
   *   currencyContractAddress: NATIVE_TOKEN_ADDRESS,
   *   // The price to pay per unit of NFTs listed.
   *   pricePerToken: 1.5,
   *   // when should the listing open up for offers
   *   startTimestamp: new Date(Date.now()),
   *   // how long the listing will be open for
   *   endTimestamp: new Date(Date.now() + 5 * 24 * 60 * 60 * 1000),
   *   // Whether the listing is reserved for a specific set of buyers.
   *   isReservedListing: false
   * }
   *
   * const tx = await contract.directListings.createListing(listing);
   * const receipt = tx.receipt; // the transaction receipt
   * const id = tx.id; // the id of the newly created listing
   *
   * // And on the buyers side:
   * // The ID of the listing you want to buy from
   * const listingId = 0;
   * // Quantity of the asset you want to buy
   * const quantityDesired = 1;
   *
   * await contract.directListings.buyFromListing(listingId, quantityDesired);
   * ```
   */
  get directListings() {
    return assertEnabled(this.detectDirectListings(), FEATURE_DIRECT_LISTINGS);
  }
  /**
   * Auctions
   * @remarks Create and manage auctions in your marketplace.
   * @example
   * ```javascript
   * // Data of the auction you want to create
   * const auction = {
   *   // address of the contract of the asset you want to auction
   *   assetContractAddress: "0x...",
   *   // token ID of the asset you want to auction
   *   tokenId: "0",
   *   // how many of the asset you want to auction
   *   quantity: 1,
   *   // address of the currency contract that will be used to pay for the auctioned tokens
   *   currencyContractAddress: NATIVE_TOKEN_ADDRESS,
   *   // the minimum bid that will be accepted for the token
   *   minimumBidAmount: "1.5",
   *   // how much people would have to bid to instantly buy the asset
   *   buyoutBidAmount: "10",
   *   // If a bid is made less than these many seconds before expiration, the expiration time is increased by this.
   *   timeBufferInSeconds: "1000",
   *   // A bid must be at least this much bps greater than the current winning bid
   *   bidBufferBps: "100", // 100 bps stands for 1%
   *   // when should the auction open up for bidding
   *   startTimestamp: new Date(Date.now()),
   *   // end time of auction
   *   endTimestamp: new Date(Date.now() + 5 * 24 * 60 * 60 * 1000),
   * }
   *
   * const tx = await contract.englishAuctions.createAuction(auction);
   * const receipt = tx.receipt; // the transaction receipt
   * const id = tx.id; // the id of the newly created auction
   *
   * // And on the buyers side:
   * // The auction ID of the asset you want to bid on
   * const auctionId = 0;
   * // The total amount you are willing to bid for auctioned tokens
   * const bidAmount = 1;
   *
   * await contract.englishAuctions.makeBid(auctionId, bidAmount);
   * ```
   */
  get englishAuctions() {
    return assertEnabled(this.detectEnglishAuctions(), FEATURE_ENGLISH_AUCTIONS);
  }
  /**
   * Offers
   * @remarks Make and manage offers.
   * @example
   * ```javascript
   * // Data of the offer you want to make
   * const offer = {
   *   // address of the contract the asset you want to make an offer for
   *   assetContractAddress: "0x...",
   *   // token ID of the asset you want to buy
   *   tokenId: "0",
   *   // how many of the asset you want to buy
   *   quantity: 1,
   *   // address of the currency contract that you offer to pay in
   *   currencyContractAddress: NATIVE_TOKEN_ADDRESS,
   *   // Total price you offer to pay for the mentioned token(s)
   *   totalPrice: "1.5",
   *   // Offer valid until
   *   endTimestamp: new Date(),
   * }
   *
   * const tx = await contract.offers.makeOffer(offer);
   * const receipt = tx.receipt; // the transaction receipt
   * const id = tx.id; // the id of the newly created offer
   *
   * // And on the seller's side:
   * // The ID of the offer you want to accept
   * const offerId = 0;
   * await contract.offers.acceptOffer(offerId);
   * ```
   */
  get offers() {
    return assertEnabled(this.detectOffers(), FEATURE_OFFERS);
  }
  get airdrop20() {
    return assertEnabled(this.detectAirdrop20(), FEATURE_AIRDROP_ERC20);
  }
  get airdrop721() {
    return assertEnabled(this.detectAirdrop721(), FEATURE_AIRDROP_ERC721);
  }
  get airdrop1155() {
    return assertEnabled(this.detectAirdrop1155(), FEATURE_AIRDROP_ERC1155);
  }
  /**
   * Account Factory
   *
   * @remarks Create accounts and fetch data about them.
   * @example
   * ```javascript
   *
   * // Predict the address of the account that will be created for an admin.
   * const deterministicAddress = await contract.accountFactory.predictAccountAddress(admin, extraData);
   *
   * // Create accounts
   * const tx = await contract.accountFactory.createAccount(admin, extraData);
   * // the same as `deterministicAddress`
   * const accountAddress = tx.address;
   *
   * // Get all accounts created by the factory
   * const allAccounts = await contract.accountFactory.getAllAccounts();
   *
   * // Get all accounts on which a signer has been given authority.
   * const associatedAccounts = await contract.accountFactory.getAssociatedAccounts(signer);
   *
   * // Get all signers who have been given authority on a account.
   * const associatedSigners = await contract.accountFactory.getAssociatedSigners(accountAddress);
   *
   * // Check whether a account has already been created for a given admin.
   * const isAccountDeployed = await contract.accountFactory.isAccountDeployed(admin, extraData);
   * ```
   */
  get accountFactory() {
    return assertEnabled(this.detectAccountFactory(), FEATURE_ACCOUNT_FACTORY);
  }
  // TODO documentation
  get account() {
    return assertEnabled(this.detectAccount(), FEATURE_ACCOUNT);
  }
  get extensions() {
    return assertEnabled(this.detectBaseRouter(), FEATURE_DYNAMIC_CONTRACT);
  }
  get chainId() {
    return this._chainId;
  }
  constructor(network, address, abi, storage) {
    let options = arguments.length > 4 && arguments[4] !== void 0 ? arguments[4] : {};
    let chainId = arguments.length > 5 ? arguments[5] : void 0;
    let contractWrapper = arguments.length > 6 && arguments[6] !== void 0 ? arguments[6] : new ContractWrapper(network, address, abi, options, storage);
    this._chainId = chainId;
    this.storage = storage;
    this.contractWrapper = contractWrapper;
    this.events = new ContractEvents(this.contractWrapper);
    this.encoder = new ContractEncoder(this.contractWrapper);
    this.interceptor = new ContractInterceptor(this.contractWrapper);
    this.estimator = new GasCostEstimator(this.contractWrapper);
    this.publishedMetadata = new ContractPublishedMetadata(this.contractWrapper, this.storage);
    this.metadata = new ContractMetadata(this.contractWrapper, CustomContractSchema, this.storage);
  }
  onNetworkUpdated(network) {
    this.contractWrapper.updateSignerOrProvider(network);
  }
  getAddress() {
    return this.contractWrapper.address;
  }
  /**
   * Prepare a transaction for sending
   */
  prepare(method, args, overrides) {
    return Transaction.fromContractWrapper({
      contractWrapper: this.contractWrapper,
      method,
      args,
      overrides
    });
  }
  /**
   * Call any function on this contract
   * @example
   * ```javascript
   * // read functions will return the data from the contract
   * const myValue = await contract.call("myReadFunction");
   * console.log(myValue);
   *
   * // write functions will return the transaction receipt
   * const tx = await contract.call("myWriteFunction", [arg1, arg2]);
   * const receipt = tx.receipt;
   *
   * // Optionally override transaction options
   * await contract.call("myWriteFunction", [arg1, arg2], {
   *  gasLimit: 1000000, // override default gas limit
   *  value: ethers.utils.parseEther("0.1"), // send 0.1 ether with the contract call
   * };
   * ```
   * @param functionName - the name of the function to call
   * @param args - the arguments of the function
   */
  async call(functionName, args, overrides) {
    return this.contractWrapper.call(functionName, args, overrides);
  }
  /** ********************
   * FEATURE DETECTION
   * ********************/
  detectRoyalties() {
    if (detectContractFeature(this.contractWrapper, "Royalty")) {
      const metadata = new ContractMetadata(this.contractWrapper, CustomContractSchema, this.storage);
      return new ContractRoyalty(this.contractWrapper, metadata);
    }
    return void 0;
  }
  detectRoles() {
    if (detectContractFeature(this.contractWrapper, "Permissions")) {
      return new ContractRoles(this.contractWrapper, ALL_ROLES);
    }
    return void 0;
  }
  detectPrimarySales() {
    if (detectContractFeature(this.contractWrapper, "PrimarySale")) {
      return new ContractPrimarySale(this.contractWrapper);
    }
    return void 0;
  }
  detectPlatformFees() {
    if (detectContractFeature(this.contractWrapper, "PlatformFee")) {
      return new ContractPlatformFee(this.contractWrapper);
    }
    return void 0;
  }
  detectErc20() {
    if (detectContractFeature(this.contractWrapper, "ERC20")) {
      return new Erc20(this.contractWrapper, this.storage, this.chainId);
    }
    return void 0;
  }
  detectErc721() {
    if (detectContractFeature(this.contractWrapper, "ERC721")) {
      return new Erc721(this.contractWrapper, this.storage, this.chainId);
    }
    return void 0;
  }
  detectErc1155() {
    if (detectContractFeature(this.contractWrapper, "ERC1155")) {
      return new Erc1155(this.contractWrapper, this.storage, this.chainId);
    }
    return void 0;
  }
  detectOwnable() {
    if (detectContractFeature(this.contractWrapper, "Ownable")) {
      return new ContractOwner(this.contractWrapper);
    }
    return void 0;
  }
  detectApp() {
    const metadata = new ContractMetadata(this.contractWrapper, CustomContractSchema, this.storage);
    if (detectContractFeature(this.contractWrapper, "AppURI")) {
      return new ContractAppURI(this.contractWrapper, metadata, this.storage);
    } else if (detectContractFeature(this.contractWrapper, "ContractMetadata")) {
      return new ContractAppURI(this.contractWrapper, metadata, this.storage);
    }
    return void 0;
  }
  detectDirectListings() {
    if (detectContractFeature(this.contractWrapper, "DirectListings")) {
      return new MarketplaceV3DirectListings(this.contractWrapper, this.storage);
    }
    return void 0;
  }
  detectEnglishAuctions() {
    if (detectContractFeature(this.contractWrapper, "EnglishAuctions")) {
      return new MarketplaceV3EnglishAuctions(this.contractWrapper, this.storage);
    }
    return void 0;
  }
  detectOffers() {
    if (detectContractFeature(this.contractWrapper, "Offers")) {
      return new MarketplaceV3Offers(this.contractWrapper, this.storage);
    }
    return void 0;
  }
  detectBaseRouter() {
    if (detectContractFeature(this.contractWrapper, FEATURE_DYNAMIC_CONTRACT.name)) {
      return new ExtensionManager(this.contractWrapper);
    }
    return void 0;
  }
  detectAirdrop20() {
    if (detectContractFeature(this.contractWrapper, "AirdropERC20")) {
      return new Airdrop20(this.contractWrapper);
    }
    return void 0;
  }
  detectAirdrop721() {
    if (detectContractFeature(this.contractWrapper, "AirdropERC721")) {
      return new Airdrop721(this.contractWrapper);
    }
    return void 0;
  }
  detectAirdrop1155() {
    if (detectContractFeature(this.contractWrapper, "AirdropERC1155")) {
      return new Airdrop1155(this.contractWrapper);
    }
    return void 0;
  }
  // ========== Account features ==========
  detectAccountFactory() {
    if (detectContractFeature(this.contractWrapper, FEATURE_ACCOUNT_FACTORY.name)) {
      return new AccountFactory(this.contractWrapper);
    }
    return void 0;
  }
  detectAccount() {
    if (detectContractFeature(this.contractWrapper, FEATURE_ACCOUNT.name)) {
      return new Account(this.contractWrapper);
    }
    return void 0;
  }
};
var ContractPublisher = class extends RPCConnectionHandler {
  constructor(network, options, storage) {
    super(network, options);
    /**
     * @internal
     * @param profileMetadata
     */
    __publicField(this, "updatePublisherProfile", buildTransactionFunction(async (profileMetadata) => {
      const signer = this.getSigner();
      invariant(signer, "A signer is required");
      const publisher = await signer.getAddress();
      const profileUri = await this.storage.upload(profileMetadata);
      return Transaction.fromContractWrapper({
        contractWrapper: this.publisher,
        method: "setPublisherProfileUri",
        args: [publisher, profileUri]
      });
    }));
    __publicField(this, "publish", buildTransactionFunction(async (predeployUri, extraMetadata) => {
      const signer = this.getSigner();
      invariant(signer, "A signer is required");
      const publisher = await signer.getAddress();
      const predeployMetadata = await fetchRawPredeployMetadata(predeployUri, this.storage);
      const compilerMetadata = await fetchContractMetadata(predeployMetadata.metadataUri, this.storage);
      const isPlugin = isFeatureEnabled(AbiSchema.parse(compilerMetadata.abi), "PluginRouter");
      const isDynamic = isFeatureEnabled(AbiSchema.parse(compilerMetadata.abi), "DynamicContract");
      extraMetadata.routerType = isPlugin ? "plugin" : isDynamic ? "dynamic" : "none";
      if (isDynamic || isPlugin) {
        const defaultExtensions = extraMetadata.defaultExtensions;
        if (defaultExtensions && defaultExtensions.length > 0) {
          try {
            const publishedExtensions = await Promise.all(defaultExtensions.map((e) => {
              return fetchPublishedContractFromPolygon(e.publisherAddress, e.extensionName, e.extensionVersion, this.storage, this.options.clientId, this.options.secretKey);
            }));
            const publishedExtensionUris = publishedExtensions.map((ext) => ext.metadataUri);
            const extensionABIs = (await Promise.all(publishedExtensionUris.map(async (uri) => {
              return fetchAndCacheDeployMetadata(uri, this.storage);
            }))).map((fetchedMetadata) => fetchedMetadata.compilerMetadata.abi);
            const composite = joinABIs([compilerMetadata.abi, ...extensionABIs]);
            extraMetadata.compositeAbi = AbiSchema.parse(composite);
          } catch {
          }
        }
      }
      const latestContract = await this.getLatest(publisher, predeployMetadata.name);
      if (latestContract && latestContract.metadataUri) {
        const latestMetadata = await this.fetchPublishedContractInfo(latestContract);
        const latestVersion = latestMetadata.publishedMetadata.version;
        if (!isIncrementalVersion(latestVersion, extraMetadata.version)) {
          throw Error(`Version ${extraMetadata.version} is not greater than ${latestVersion}`);
        }
      }
      const fetchedBytecode = await (await this.storage.download(predeployMetadata.bytecodeUri)).text();
      const bytecode2 = fetchedBytecode.startsWith("0x") ? fetchedBytecode : `0x${fetchedBytecode}`;
      const bytecodeHash = utils_exports.solidityKeccak256(["bytes"], [bytecode2]);
      const contractId = predeployMetadata.name;
      const fullMetadata = await FullPublishMetadataSchemaInput.parseAsync({
        ...extraMetadata,
        metadataUri: predeployMetadata.metadataUri,
        bytecodeUri: predeployMetadata.bytecodeUri,
        name: predeployMetadata.name,
        analytics: predeployMetadata.analytics,
        publisher
      });
      const fullMetadataUri = await this.storage.upload(fullMetadata);
      return Transaction.fromContractWrapper({
        contractWrapper: this.publisher,
        method: "publishContract",
        args: [publisher, contractId, fullMetadataUri, predeployMetadata.metadataUri, bytecodeHash, lib_exports.AddressZero],
        parse: (receipt) => {
          const events = this.publisher.parseLogs("ContractPublished", receipt.logs);
          if (events.length < 1) {
            throw new Error("No ContractPublished event found");
          }
          const contract = events[0].args.publishedContract;
          return {
            receipt,
            data: async () => this.toPublishedContract(contract)
          };
        }
      });
    }));
    __publicField(this, "unpublish", buildTransactionFunction(async (publisher, contractId) => {
      const resolvedPublisher = await resolveAddress(publisher);
      return Transaction.fromContractWrapper({
        contractWrapper: this.publisher,
        method: "unpublishContract",
        args: [resolvedPublisher, contractId]
      });
    }));
    this.storage = storage;
    this.publisher = new ContractWrapper(network, getContractPublisherAddress(), ContractPublisher_default, options, storage);
  }
  updateSignerOrProvider(network) {
    super.updateSignerOrProvider(network);
    this.publisher.updateSignerOrProvider(network);
  }
  /**
   * @internal
   * @param metadataUri
   */
  async extractConstructorParams(metadataUri) {
    return extractConstructorParams(metadataUri, this.storage);
  }
  /**
   * @internal
   * @param predeployMetadataUri
   */
  async extractFunctions(predeployMetadataUri) {
    return extractFunctions(predeployMetadataUri, this.storage);
  }
  /**
   * @internal
   * @param predeployUri
   */
  async fetchCompilerMetadataFromPredeployURI(predeployUri) {
    return fetchPreDeployMetadata(predeployUri, this.storage);
  }
  /**
   * @internal
   * @param prepublishUri
   * @param publisherAddress
   */
  async fetchPrePublishMetadata(prepublishUri, publisherAddress) {
    const preDeployMetadataFetched = await fetchPreDeployMetadata(prepublishUri, this.storage);
    const latestPublishedContract = publisherAddress ? await this.getLatest(publisherAddress, preDeployMetadataFetched.name) : void 0;
    const latestPublishedContractMetadata = latestPublishedContract ? await this.fetchPublishedContractInfo(latestPublishedContract) : void 0;
    return {
      preDeployMetadata: preDeployMetadataFetched,
      latestPublishedContractMetadata
    };
  }
  /**
   * @internal
   * @param address
   */
  async fetchCompilerMetadataFromAddress(address) {
    const resolvedAddress = await resolveAddress(address);
    return fetchContractMetadataFromAddress(resolvedAddress, this.getProvider(), this.storage, this.options);
  }
  /**
   * @internal
   * Get the full information about a published contract
   * @param contract
   */
  async fetchPublishedContractInfo(contract) {
    return {
      name: contract.id,
      publishedTimestamp: contract.timestamp,
      publishedMetadata: await this.fetchFullPublishMetadata(contract.metadataUri)
    };
  }
  /**
   * @internal
   * @param publishedMetadataUri
   */
  async fetchFullPublishMetadata(publishedMetadataUri) {
    return fetchExtendedReleaseMetadata(publishedMetadataUri, this.storage);
  }
  /**
   * @internal
   * // TODO expose a resolvePublishMetadata(contractAddress, chainId) that handles the dual chain case
   * // TODO will be easy to do with the multichain pattern of 3.0
   * @param compilerMetadataUri
   */
  async resolvePublishMetadataFromCompilerMetadata(compilerMetadataUri) {
    const publishedMetadataUri = await this.publisher.read("getPublishedUriFromCompilerUri", [compilerMetadataUri]);
    if (publishedMetadataUri.length === 0) {
      throw Error(`Could not resolve published metadata URI from ${compilerMetadataUri}`);
    }
    return await Promise.all(publishedMetadataUri.filter((uri) => uri.length > 0).map((uri) => this.fetchFullPublishMetadata(uri)));
  }
  /**
   * @internal
   * TODO clean this up (see method above, too)
   */
  async resolveContractUriFromAddress(address) {
    const resolvedAddress = await resolveAddress(address);
    const contractUri = await resolveContractUriFromAddress(resolvedAddress, this.getProvider());
    invariant(contractUri, "Could not resolve contract URI from address");
    return contractUri;
  }
  /**
   * @internal
   * @param address
   */
  async fetchContractSourcesFromAddress(address) {
    const resolvedAddress = await resolveAddress(address);
    const metadata = await this.fetchCompilerMetadataFromAddress(resolvedAddress);
    return await fetchSourceFilesFromMetadata(metadata, this.storage);
  }
  /**
   * @internal
   * @param publisherAddress
   */
  async getPublisherProfile(publisherAddress) {
    const resolvedPublisherAddress = await resolveAddress(publisherAddress);
    const profileUri = await this.publisher.read("getPublisherProfileUri", [resolvedPublisherAddress]);
    if (!profileUri || profileUri.length === 0) {
      return {};
    }
    return ProfileSchemaOutput.parse(await this.storage.downloadJSON(profileUri));
  }
  /**
   * @internal
   * @param publisherAddress
   */
  async getAll(publisherAddress) {
    const resolvedPublisherAddress = await resolveAddress(publisherAddress);
    const data = await this.publisher.read("getAllPublishedContracts", [resolvedPublisherAddress]);
    const map = data.reduce((acc, curr) => {
      acc[curr.contractId] = curr;
      return acc;
    }, {});
    return Object.entries(map).map((_ref) => {
      let [, struct] = _ref;
      return this.toPublishedContract(struct);
    });
  }
  /**
   * @internal
   * @param publisherAddress
   * @param contractId
   */
  async getAllVersions(publisherAddress, contractId) {
    const resolvedPublisherAddress = await resolveAddress(publisherAddress);
    const contractStructs = await this.publisher.read("getPublishedContractVersions", [resolvedPublisherAddress, contractId]);
    if (contractStructs.length === 0) {
      throw Error("Not found");
    }
    return contractStructs.map((d) => this.toPublishedContract(d));
  }
  async getVersion(publisherAddress, contractId) {
    let version = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : "latest";
    const resolvedPublisherAddress = await resolveAddress(publisherAddress);
    if (version === "latest") {
      return this.getLatest(resolvedPublisherAddress, contractId);
    }
    const allVersions = await this.getAllVersions(resolvedPublisherAddress, contractId);
    const versionMetadata = await Promise.all(allVersions.map((contract) => this.fetchPublishedContractInfo(contract)));
    const versionMatch = versionMetadata.find((metadata) => metadata.publishedMetadata.version === version);
    invariant(versionMatch, "Contract version not found");
    return allVersions.find((contract) => contract.timestamp === versionMatch.publishedTimestamp);
  }
  async getLatest(publisherAddress, contractId) {
    const resolvedPublisherAddress = await resolveAddress(publisherAddress);
    const model = await this.publisher.read("getPublishedContract", [resolvedPublisherAddress, contractId]);
    if (model && model.publishMetadataUri) {
      return this.toPublishedContract(model);
    }
    return void 0;
  }
  toPublishedContract(contractModel) {
    return PublishedContractSchema.parse({
      id: contractModel.contractId,
      timestamp: contractModel.publishTimestamp,
      metadataUri: contractModel.publishMetadataUri
    });
  }
};

export {
  z,
  v4_default,
  invariant,
  AmountSchema,
  CommonNFTInput,
  NFTInputOrUriSchema,
  CommonNFTOutput,
  DEFAULT_QUERY_ALL_COUNT,
  ThirdwebStorage,
  IERC165_default,
  IERC20_default,
  require_fast_deep_equal,
  require_dist,
  IThirdwebContract_default,
  IERC1155_default,
  IERC721_default,
  ContractPublisher_default,
  require_bs58,
  TWMultichainRegistryLogic_default,
  IPackVRFDirect_default,
  toSemver,
  isIncrementalVersion,
  isDowngradeVersion,
  BigNumberSchema,
  BigNumberishSchema,
  BigNumberTransformSchema2 as BigNumberTransformSchema,
  isSigner,
  isProvider,
  StaticJsonRpcBatchProvider,
  getChainProvider,
  getChainIdFromNetwork,
  getChainIdOrName,
  isChainConfig,
  getProviderFromRpcUrl,
  getSignerAndProvider,
  resolveEns,
  AddressSchema,
  AddressOrEnsSchema,
  ChainId,
  setSupportedChains,
  getSupportedChains,
  NATIVE_TOKEN_ADDRESS,
  NATIVE_TOKENS,
  getNativeTokenByChainId,
  LINK_TOKEN_ADDRESS,
  RawDateSchema,
  StartDateSchema,
  EndDateSchema,
  CurrencySchema,
  CurrencyValueSchema,
  MerkleSchema,
  SnapshotEntryInput,
  SnapshotInputSchema,
  SnapshotEntryWithProofSchema,
  SnapshotSchema,
  SnapshotInfoSchema,
  ClaimConditionMetadataSchema,
  ClaimConditionInputSchema,
  ClaimConditionInputArray,
  PartialClaimConditionInputSchema,
  ClaimConditionOutputSchema,
  BaseSignaturePayloadInput,
  Signature20PayloadInput,
  Signature20PayloadOutput,
  Signature721PayloadInput,
  Signature721PayloadOutput,
  Signature1155PayloadInput,
  Signature1155PayloadInputWithTokenId,
  Signature1155PayloadOutput,
  Signature721WithQuantityInput,
  Signature721WithQuantityOutput,
  MintRequest20,
  MintRequest721,
  MintRequest1155,
  MintRequest721withQuantity,
  GenericRequest,
  CommonContractSchema,
  CommonContractOutputSchema,
  CommonRoyaltySchema,
  CommonPrimarySaleSchema,
  CommonPlatformFeeSchema,
  CommonTrustedForwarderSchema,
  CommonSymbolSchema,
  BYOCContractMetadataSchema,
  CustomContractInput,
  CustomContractOutput,
  CustomContractDeploy,
  CustomContractSchema,
  AbiTypeSchema,
  AbiObjectSchema,
  AbiSchema,
  PreDeployMetadata,
  ChainIdToAddressSchema,
  CustomFactoryInput,
  FactoryDeploymentSchema,
  DeployTypeInput,
  RouterTypeInput,
  DeploymentNetworkInput,
  ExtraPublishMetadataSchemaInput,
  ExtraPublishMetadataSchemaOutput,
  FullPublishMetadataSchemaInput,
  FullPublishMetadataSchemaOutput,
  ProfileSchemaInput,
  ProfileSchemaOutput,
  PublishedContractSchema,
  ContractInfoSchema,
  CompilerMetadataFetchedSchema,
  PreDeployMetadataFetchedSchema,
  CallOverrideSchema,
  ContractEncoder,
  NotFoundError,
  InvalidAddressError,
  MissingRoleError,
  AssetNotFoundError,
  UploadError,
  FileNameMissingError,
  DuplicateFileNameError,
  NotEnoughTokensError,
  MissingOwnerRoleError,
  QuantityAboveLimitError,
  FetchError,
  DuplicateLeafsError,
  AuctionAlreadyStartedError,
  FunctionDeprecatedError,
  ListingNotFoundError,
  WrongListingTypeError,
  RestrictedTransferError,
  AdminRoleMissingError,
  AuctionHasNotEndedError,
  ExtensionNotImplementedError,
  TransactionError,
  parseRevertReason,
  includesErrorMessage,
  FEATURE_NFT_REVEALABLE,
  FEATURE_PACK_VRF,
  FEATURE_DIRECT_LISTINGS,
  FEATURE_ENGLISH_AUCTIONS,
  FEATURE_OFFERS,
  SUPPORTED_FEATURES,
  extractCommentFromMetadata,
  extractFunctionsFromAbi,
  hasMatchingAbi,
  matchesAbiFromBytecode,
  detectFeatures,
  detectFeaturesFromBytecode,
  isFeatureEnabled,
  isExtensionEnabled,
  detectContractFeature,
  hasFunction,
  extractIPFSHashFromBytecode,
  extractMinimalProxyImplementationAddress,
  resolveContractUriFromAddress,
  resolveContractUriAndBytecode,
  resolveImplementation,
  fetchContractMetadata,
  getProcessEnv2 as getProcessEnv,
  getMultichainRegistryAddress,
  joinABIs,
  extractFeatures,
  getAllDetectedFeatures,
  getAllDetectedExtensionsFromBytecode,
  constructAbiFromBytecode,
  getAllDetectedExtensions,
  fetchContractMetadataFromAddress,
  fetchAbiFromAddress,
  buildDeployTransactionFunction,
  buildTransactionFunction,
  getDefaultGasOverrides,
  getDynamicFeeData,
  getGasPrice,
  getPolygonGasPriorityFee,
  fetchSourceFilesFromMetadata,
  CUSTOM_GAS_FOR_CHAIN,
  CREATE2_FACTORY_BYTECODE,
  SIGNATURE,
  COMMON_FACTORY,
  GAS_LIMIT_FOR_DEPLOYER,
  DEPLOYER_BYTECODE,
  DEPLOYER_ABI,
  isContractDeployed,
  isEIP155Enforced,
  getKeylessTxn,
  getCreate2FactoryDeploymentInfo,
  getCreate2FactoryAddress,
  getContractPublisherAddress,
  DropErc721ContractSchema,
  DropErc1155ContractSchema,
  MarketplaceContractSchema,
  PackContractSchema,
  SplitsContractSchema,
  TokenErc20ContractSchema,
  TokenErc721ContractSchema,
  TokenErc1155ContractSchema,
  VoteContractSchema,
  resolveAddress,
  fetchExtendedReleaseMetadata,
  fetchRawPredeployMetadata,
  fetchPreDeployMetadata,
  fetchAndCacheDeployMetadata,
  AddressZero,
  OZ_DEFENDER_FORWARDER_ADDRESS,
  CONTRACT_ADDRESSES,
  getContractAddressByChainId,
  InterfaceId_IERC721,
  InterfaceId_IERC1155,
  EventType,
  THIRDWEB_DEPLOYER,
  fetchPublishedContractFromPolygon,
  getSaltHash,
  getInitBytecodeWithSalt,
  computeDeploymentAddress,
  extractConstructorParamsFromAbi,
  computeDeploymentInfo,
  encodeConstructorParamsForImplementation,
  computeEOAForwarderAddress,
  computeForwarderAddress,
  signTypedDataInternal,
  Transaction,
  DeployTransaction,
  defaultGaslessSendFunction,
  biconomySendFunction,
  defenderSendFunction,
  prepareGaslessRequest,
  ContractMetadata,
  ALL_ROLES,
  getRoleHash,
  ContractRoles,
  ContractRoyalty,
  ContractPrimarySale,
  fetchTokenMetadataForContract,
  uploadOrExtractURI,
  DelayedReveal,
  isNativeToken,
  fetchCurrencyMetadata,
  fetchSnapshotEntryForAddress,
  RPCConnectionHandler,
  ContractWrapper,
  approveErc20Allowance,
  normalizePriceValue,
  createSnapshot,
  fetchCurrencyValue,
  convertToReadableQuantity,
  Status,
  ClaimEligibility,
  DropClaimConditions,
  DropErc1155ClaimConditions,
  Erc20BatchMintable,
  Erc20Burnable,
  Erc20ClaimableWithConditions,
  Erc20Droppable,
  Erc20Mintable,
  setErc20Allowance,
  Erc20SignatureMintable,
  assertEnabled,
  normalizeAmount,
  Erc20,
  Erc721BatchMintable,
  Erc721ClaimableWithConditions,
  Erc721Claimable,
  Erc721LazyMintable,
  Erc721Mintable,
  Erc721Enumerable,
  Erc721Supply,
  Erc721TieredDrop,
  Erc721Burnable,
  toWei,
  Erc721WithQuantitySignatureMintable,
  Erc721,
  Erc1155BatchMintable,
  Erc1155Burnable,
  Erc1155Enumerable,
  Erc1155LazyMintable,
  Erc1155Mintable,
  Erc1155SignatureMintable,
  Erc1155,
  cleanCurrencyAddress,
  isTokenApprovedForTransfer,
  handleTokenApproval,
  validateNewListingParam,
  mapOffer,
  isWinningBid,
  ContractEvents,
  ContractInterceptor,
  GasCostEstimator,
  MarketplaceV3DirectListings,
  MarketplaceV3EnglishAuctions,
  MarketplaceV3Offers,
  ContractPlatformFee,
  extractEventsFromAbi,
  ContractPublishedMetadata,
  ContractOwner,
  ContractAppURI,
  extractConstructorParams,
  extractFunctions,
  getDeploymentInfo,
  deployContractDeterministic,
  estimateGasForDeploy,
  createTransactionBatches,
  deployWithThrowawayDeployer,
  getCompositePluginABI,
  DropErc20ContractSchema,
  MultiwrapContractSchema,
  ADMIN_ROLE,
  NFT_BASE_CONTRACT_ROLES,
  MARKETPLACE_CONTRACT_ROLES,
  PACK_CONTRACT_ROLES,
  TOKEN_DROP_CONTRACT_ROLES,
  MULTIWRAP_CONTRACT_ROLES,
  EditionDropInitializer,
  EditionInitializer,
  MarketplaceInitializer,
  MarketplaceV3Initializer,
  MultiwrapInitializer,
  NFTCollectionInitializer,
  NFTDropInitializer,
  PackInitializer,
  SignatureDropInitializer,
  SplitInitializer,
  TokenDropInitializer,
  TokenInitializer,
  VoteInitializer,
  PREBUILT_CONTRACTS_MAP,
  PREBUILT_CONTRACTS_APPURI_MAP,
  CONTRACTS_MAP,
  getContractTypeForRemoteName,
  getContractName,
  SignerPermissionsSchema,
  PermissionSnapshotSchema,
  SignerPermissionRequest,
  Account,
  AccountFactory,
  SmartContract,
  ContractPublisher
};
/*! Bundled license information:

crypto-js/ripemd160.js:
  (** @preserve
  	(c) 2012 by Cédric Mesnil. All rights reserved.
  
  	Redistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met:
  
  	    - Redistributions of source code must retain the above copyright notice, this list of conditions and the following disclaimer.
  	    - Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the following disclaimer in the documentation and/or other materials provided with the distribution.
  
  	THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
  	*)

crypto-js/mode-ctr-gladman.js:
  (** @preserve
   * Counter block mode compatible with  Dr Brian Gladman fileenc.c
   * derived from CryptoJS.mode.CTR
   * Jan Hruby jhruby.web@gmail.com
   *)
*/
//# sourceMappingURL=chunk-PDTS4OI3.js.map
