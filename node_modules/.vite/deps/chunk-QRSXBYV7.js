import {
  getInjectedMetamaskProvider
} from "./chunk-5TYC53HJ.js";
import {
  Mr
} from "./chunk-NKSPCSHP.js";
import {
  getInjectedPhantomProvider
} from "./chunk-UR5JE42V.js";
import {
  getInjectedRainbowProvider
} from "./chunk-57S6E3JR.js";
import {
  _classPrivateMethodGet,
  _classPrivateMethodInitSpec
} from "./chunk-DVVEOT7N.js";
import {
  walletIds
} from "./chunk-3FKSJEH3.js";
import {
  assertWindowEthereum
} from "./chunk-JWNZQLNB.js";
import {
  normalizeChainId
} from "./chunk-M374DORU.js";
import {
  _classPrivateFieldGet,
  _classPrivateFieldInitSpec,
  _classPrivateFieldSet
} from "./chunk-7YNDDNAN.js";
import {
  IEvents,
  JsonRpcProvider,
  RELAY_JSONRPC,
  detect,
  encodeIss,
  esm_exports,
  f,
  formatJsonRpcError,
  formatJsonRpcRequest,
  formatJsonRpcResult,
  generateKeyPair,
  getBigIntRpcId,
  h,
  init_esm,
  isJsonRpcError,
  isJsonRpcRequest,
  isJsonRpcResponse,
  isJsonRpcResult,
  payloadId,
  require_browser,
  require_chacha20poly1305,
  require_cjs,
  require_cjs2,
  require_cjs3,
  require_cjs4,
  require_cjs5,
  require_decode_uri_component,
  require_filter_obj,
  require_hkdf,
  require_lodash,
  require_random,
  require_sha256,
  require_split_on_first,
  require_strict_uri_encode,
  require_x25519,
  safeJsonParse,
  safeJsonStringify,
  signJWT
} from "./chunk-XTQZUD4R.js";
import {
  Connector,
  WagmiAdapter
} from "./chunk-YVNWQO32.js";
import {
  _defineProperty
} from "./chunk-M52NFQDC.js";
import {
  n,
  o
} from "./chunk-EN6OYJQI.js";
import {
  require_events
} from "./chunk-OJYKRRB6.js";
import {
  NATIVE_TOKEN_ADDRESS,
  fetchCurrencyValue,
  isNativeToken,
  normalizePriceValue
} from "./chunk-PDTS4OI3.js";
import {
  concat,
  fromString,
  toString
} from "./chunk-KPMLBYIV.js";
import {
  require_utils
} from "./chunk-QJWU7UES.js";
import {
  c1,
  defaultChains,
  updateChainRPCs
} from "./chunk-F44DUYBV.js";
import {
  eventemitter3_default
} from "./chunk-LMS4WD7T.js";
import {
  Contract,
  Wallet,
  init_lib7 as init_lib3,
  utils_exports
} from "./chunk-FSHZLPV2.js";
import {
  Signer,
  getDefaultProvider,
  hashMessage,
  init_lib11 as init_lib,
  init_lib15 as init_lib2,
  lib_exports19 as lib_exports,
  recoverAddress
} from "./chunk-LXGF3WSV.js";
import {
  global,
  import_process,
  init_shim,
  require_buffer
} from "./chunk-DLIX7YGU.js";
import {
  __commonJS,
  __toESM
} from "./chunk-EUIKE2YQ.js";

// node_modules/@walletconnect/auth-client/node_modules/query-string/index.js
var require_query_string = __commonJS({
  "node_modules/@walletconnect/auth-client/node_modules/query-string/index.js"(exports) {
    "use strict";
    init_shim();
    var strictUriEncode = require_strict_uri_encode();
    var decodeComponent = require_decode_uri_component();
    var splitOnFirst = require_split_on_first();
    var filterObject = require_filter_obj();
    var isNullOrUndefined = (value) => value === null || value === void 0;
    var encodeFragmentIdentifier = Symbol("encodeFragmentIdentifier");
    function encoderForArrayFormat(options) {
      switch (options.arrayFormat) {
        case "index":
          return (key) => (result, value) => {
            const index = result.length;
            if (value === void 0 || options.skipNull && value === null || options.skipEmptyString && value === "") {
              return result;
            }
            if (value === null) {
              return [...result, [encode(key, options), "[", index, "]"].join("")];
            }
            return [
              ...result,
              [encode(key, options), "[", encode(index, options), "]=", encode(value, options)].join("")
            ];
          };
        case "bracket":
          return (key) => (result, value) => {
            if (value === void 0 || options.skipNull && value === null || options.skipEmptyString && value === "") {
              return result;
            }
            if (value === null) {
              return [...result, [encode(key, options), "[]"].join("")];
            }
            return [...result, [encode(key, options), "[]=", encode(value, options)].join("")];
          };
        case "colon-list-separator":
          return (key) => (result, value) => {
            if (value === void 0 || options.skipNull && value === null || options.skipEmptyString && value === "") {
              return result;
            }
            if (value === null) {
              return [...result, [encode(key, options), ":list="].join("")];
            }
            return [...result, [encode(key, options), ":list=", encode(value, options)].join("")];
          };
        case "comma":
        case "separator":
        case "bracket-separator": {
          const keyValueSep = options.arrayFormat === "bracket-separator" ? "[]=" : "=";
          return (key) => (result, value) => {
            if (value === void 0 || options.skipNull && value === null || options.skipEmptyString && value === "") {
              return result;
            }
            value = value === null ? "" : value;
            if (result.length === 0) {
              return [[encode(key, options), keyValueSep, encode(value, options)].join("")];
            }
            return [[result, encode(value, options)].join(options.arrayFormatSeparator)];
          };
        }
        default:
          return (key) => (result, value) => {
            if (value === void 0 || options.skipNull && value === null || options.skipEmptyString && value === "") {
              return result;
            }
            if (value === null) {
              return [...result, encode(key, options)];
            }
            return [...result, [encode(key, options), "=", encode(value, options)].join("")];
          };
      }
    }
    function parserForArrayFormat(options) {
      let result;
      switch (options.arrayFormat) {
        case "index":
          return (key, value, accumulator) => {
            result = /\[(\d*)\]$/.exec(key);
            key = key.replace(/\[\d*\]$/, "");
            if (!result) {
              accumulator[key] = value;
              return;
            }
            if (accumulator[key] === void 0) {
              accumulator[key] = {};
            }
            accumulator[key][result[1]] = value;
          };
        case "bracket":
          return (key, value, accumulator) => {
            result = /(\[\])$/.exec(key);
            key = key.replace(/\[\]$/, "");
            if (!result) {
              accumulator[key] = value;
              return;
            }
            if (accumulator[key] === void 0) {
              accumulator[key] = [value];
              return;
            }
            accumulator[key] = [].concat(accumulator[key], value);
          };
        case "colon-list-separator":
          return (key, value, accumulator) => {
            result = /(:list)$/.exec(key);
            key = key.replace(/:list$/, "");
            if (!result) {
              accumulator[key] = value;
              return;
            }
            if (accumulator[key] === void 0) {
              accumulator[key] = [value];
              return;
            }
            accumulator[key] = [].concat(accumulator[key], value);
          };
        case "comma":
        case "separator":
          return (key, value, accumulator) => {
            const isArray = typeof value === "string" && value.includes(options.arrayFormatSeparator);
            const isEncodedArray = typeof value === "string" && !isArray && decode(value, options).includes(options.arrayFormatSeparator);
            value = isEncodedArray ? decode(value, options) : value;
            const newValue = isArray || isEncodedArray ? value.split(options.arrayFormatSeparator).map((item) => decode(item, options)) : value === null ? value : decode(value, options);
            accumulator[key] = newValue;
          };
        case "bracket-separator":
          return (key, value, accumulator) => {
            const isArray = /(\[\])$/.test(key);
            key = key.replace(/\[\]$/, "");
            if (!isArray) {
              accumulator[key] = value ? decode(value, options) : value;
              return;
            }
            const arrayValue = value === null ? [] : value.split(options.arrayFormatSeparator).map((item) => decode(item, options));
            if (accumulator[key] === void 0) {
              accumulator[key] = arrayValue;
              return;
            }
            accumulator[key] = [].concat(accumulator[key], arrayValue);
          };
        default:
          return (key, value, accumulator) => {
            if (accumulator[key] === void 0) {
              accumulator[key] = value;
              return;
            }
            accumulator[key] = [].concat(accumulator[key], value);
          };
      }
    }
    function validateArrayFormatSeparator(value) {
      if (typeof value !== "string" || value.length !== 1) {
        throw new TypeError("arrayFormatSeparator must be single character string");
      }
    }
    function encode(value, options) {
      if (options.encode) {
        return options.strict ? strictUriEncode(value) : encodeURIComponent(value);
      }
      return value;
    }
    function decode(value, options) {
      if (options.decode) {
        return decodeComponent(value);
      }
      return value;
    }
    function keysSorter(input) {
      if (Array.isArray(input)) {
        return input.sort();
      }
      if (typeof input === "object") {
        return keysSorter(Object.keys(input)).sort((a3, b5) => Number(a3) - Number(b5)).map((key) => input[key]);
      }
      return input;
    }
    function removeHash(input) {
      const hashStart = input.indexOf("#");
      if (hashStart !== -1) {
        input = input.slice(0, hashStart);
      }
      return input;
    }
    function getHash(url) {
      let hash = "";
      const hashStart = url.indexOf("#");
      if (hashStart !== -1) {
        hash = url.slice(hashStart);
      }
      return hash;
    }
    function extract(input) {
      input = removeHash(input);
      const queryStart = input.indexOf("?");
      if (queryStart === -1) {
        return "";
      }
      return input.slice(queryStart + 1);
    }
    function parseValue(value, options) {
      if (options.parseNumbers && !Number.isNaN(Number(value)) && (typeof value === "string" && value.trim() !== "")) {
        value = Number(value);
      } else if (options.parseBooleans && value !== null && (value.toLowerCase() === "true" || value.toLowerCase() === "false")) {
        value = value.toLowerCase() === "true";
      }
      return value;
    }
    function parse3(query, options) {
      options = Object.assign({
        decode: true,
        sort: true,
        arrayFormat: "none",
        arrayFormatSeparator: ",",
        parseNumbers: false,
        parseBooleans: false
      }, options);
      validateArrayFormatSeparator(options.arrayFormatSeparator);
      const formatter = parserForArrayFormat(options);
      const ret = /* @__PURE__ */ Object.create(null);
      if (typeof query !== "string") {
        return ret;
      }
      query = query.trim().replace(/^[?#&]/, "");
      if (!query) {
        return ret;
      }
      for (const param of query.split("&")) {
        if (param === "") {
          continue;
        }
        let [key, value] = splitOnFirst(options.decode ? param.replace(/\+/g, " ") : param, "=");
        value = value === void 0 ? null : ["comma", "separator", "bracket-separator"].includes(options.arrayFormat) ? value : decode(value, options);
        formatter(decode(key, options), value, ret);
      }
      for (const key of Object.keys(ret)) {
        const value = ret[key];
        if (typeof value === "object" && value !== null) {
          for (const k4 of Object.keys(value)) {
            value[k4] = parseValue(value[k4], options);
          }
        } else {
          ret[key] = parseValue(value, options);
        }
      }
      if (options.sort === false) {
        return ret;
      }
      return (options.sort === true ? Object.keys(ret).sort() : Object.keys(ret).sort(options.sort)).reduce((result, key) => {
        const value = ret[key];
        if (Boolean(value) && typeof value === "object" && !Array.isArray(value)) {
          result[key] = keysSorter(value);
        } else {
          result[key] = value;
        }
        return result;
      }, /* @__PURE__ */ Object.create(null));
    }
    exports.extract = extract;
    exports.parse = parse3;
    exports.stringify = (object, options) => {
      if (!object) {
        return "";
      }
      options = Object.assign({
        encode: true,
        strict: true,
        arrayFormat: "none",
        arrayFormatSeparator: ","
      }, options);
      validateArrayFormatSeparator(options.arrayFormatSeparator);
      const shouldFilter = (key) => options.skipNull && isNullOrUndefined(object[key]) || options.skipEmptyString && object[key] === "";
      const formatter = encoderForArrayFormat(options);
      const objectCopy = {};
      for (const key of Object.keys(object)) {
        if (!shouldFilter(key)) {
          objectCopy[key] = object[key];
        }
      }
      const keys = Object.keys(objectCopy);
      if (options.sort !== false) {
        keys.sort(options.sort);
      }
      return keys.map((key) => {
        const value = object[key];
        if (value === void 0) {
          return "";
        }
        if (value === null) {
          return encode(key, options);
        }
        if (Array.isArray(value)) {
          if (value.length === 0 && options.arrayFormat === "bracket-separator") {
            return encode(key, options) + "[]";
          }
          return value.reduce(formatter(key), []).join("&");
        }
        return encode(key, options) + "=" + encode(value, options);
      }).filter((x4) => x4.length > 0).join("&");
    };
    exports.parseUrl = (url, options) => {
      options = Object.assign({
        decode: true
      }, options);
      const [url_, hash] = splitOnFirst(url, "#");
      return Object.assign(
        {
          url: url_.split("?")[0] || "",
          query: parse3(extract(url), options)
        },
        options && options.parseFragmentIdentifier && hash ? { fragmentIdentifier: decode(hash, options) } : {}
      );
    };
    exports.stringifyUrl = (object, options) => {
      options = Object.assign({
        encode: true,
        strict: true,
        [encodeFragmentIdentifier]: true
      }, options);
      const url = removeHash(object.url).split("?")[0] || "";
      const queryFromUrl = exports.extract(object.url);
      const parsedQueryFromUrl = exports.parse(queryFromUrl, { sort: false });
      const query = Object.assign(parsedQueryFromUrl, object.query);
      let queryString = exports.stringify(query, options);
      if (queryString) {
        queryString = `?${queryString}`;
      }
      let hash = getHash(object.url);
      if (object.fragmentIdentifier) {
        hash = `#${options[encodeFragmentIdentifier] ? encode(object.fragmentIdentifier, options) : object.fragmentIdentifier}`;
      }
      return `${url}${queryString}${hash}`;
    };
    exports.pick = (input, filter, options) => {
      options = Object.assign({
        parseFragmentIdentifier: true,
        [encodeFragmentIdentifier]: false
      }, options);
      const { url, query, fragmentIdentifier } = exports.parseUrl(input, options);
      return exports.stringifyUrl({
        url,
        query: filterObject(query, filter),
        fragmentIdentifier
      }, options);
    };
    exports.exclude = (input, filter, options) => {
      const exclusionFilter = Array.isArray(filter) ? (key) => !filter.includes(key) : (key, value) => !filter(key, value);
      return exports.pick(input, exclusionFilter, options);
    };
  }
});

// node_modules/@walletconnect/web3wallet/node_modules/query-string/index.js
var require_query_string2 = __commonJS({
  "node_modules/@walletconnect/web3wallet/node_modules/query-string/index.js"(exports) {
    "use strict";
    init_shim();
    var strictUriEncode = require_strict_uri_encode();
    var decodeComponent = require_decode_uri_component();
    var splitOnFirst = require_split_on_first();
    var filterObject = require_filter_obj();
    var isNullOrUndefined = (value) => value === null || value === void 0;
    var encodeFragmentIdentifier = Symbol("encodeFragmentIdentifier");
    function encoderForArrayFormat(options) {
      switch (options.arrayFormat) {
        case "index":
          return (key) => (result, value) => {
            const index = result.length;
            if (value === void 0 || options.skipNull && value === null || options.skipEmptyString && value === "") {
              return result;
            }
            if (value === null) {
              return [...result, [encode(key, options), "[", index, "]"].join("")];
            }
            return [
              ...result,
              [encode(key, options), "[", encode(index, options), "]=", encode(value, options)].join("")
            ];
          };
        case "bracket":
          return (key) => (result, value) => {
            if (value === void 0 || options.skipNull && value === null || options.skipEmptyString && value === "") {
              return result;
            }
            if (value === null) {
              return [...result, [encode(key, options), "[]"].join("")];
            }
            return [...result, [encode(key, options), "[]=", encode(value, options)].join("")];
          };
        case "colon-list-separator":
          return (key) => (result, value) => {
            if (value === void 0 || options.skipNull && value === null || options.skipEmptyString && value === "") {
              return result;
            }
            if (value === null) {
              return [...result, [encode(key, options), ":list="].join("")];
            }
            return [...result, [encode(key, options), ":list=", encode(value, options)].join("")];
          };
        case "comma":
        case "separator":
        case "bracket-separator": {
          const keyValueSep = options.arrayFormat === "bracket-separator" ? "[]=" : "=";
          return (key) => (result, value) => {
            if (value === void 0 || options.skipNull && value === null || options.skipEmptyString && value === "") {
              return result;
            }
            value = value === null ? "" : value;
            if (result.length === 0) {
              return [[encode(key, options), keyValueSep, encode(value, options)].join("")];
            }
            return [[result, encode(value, options)].join(options.arrayFormatSeparator)];
          };
        }
        default:
          return (key) => (result, value) => {
            if (value === void 0 || options.skipNull && value === null || options.skipEmptyString && value === "") {
              return result;
            }
            if (value === null) {
              return [...result, encode(key, options)];
            }
            return [...result, [encode(key, options), "=", encode(value, options)].join("")];
          };
      }
    }
    function parserForArrayFormat(options) {
      let result;
      switch (options.arrayFormat) {
        case "index":
          return (key, value, accumulator) => {
            result = /\[(\d*)\]$/.exec(key);
            key = key.replace(/\[\d*\]$/, "");
            if (!result) {
              accumulator[key] = value;
              return;
            }
            if (accumulator[key] === void 0) {
              accumulator[key] = {};
            }
            accumulator[key][result[1]] = value;
          };
        case "bracket":
          return (key, value, accumulator) => {
            result = /(\[\])$/.exec(key);
            key = key.replace(/\[\]$/, "");
            if (!result) {
              accumulator[key] = value;
              return;
            }
            if (accumulator[key] === void 0) {
              accumulator[key] = [value];
              return;
            }
            accumulator[key] = [].concat(accumulator[key], value);
          };
        case "colon-list-separator":
          return (key, value, accumulator) => {
            result = /(:list)$/.exec(key);
            key = key.replace(/:list$/, "");
            if (!result) {
              accumulator[key] = value;
              return;
            }
            if (accumulator[key] === void 0) {
              accumulator[key] = [value];
              return;
            }
            accumulator[key] = [].concat(accumulator[key], value);
          };
        case "comma":
        case "separator":
          return (key, value, accumulator) => {
            const isArray = typeof value === "string" && value.includes(options.arrayFormatSeparator);
            const isEncodedArray = typeof value === "string" && !isArray && decode(value, options).includes(options.arrayFormatSeparator);
            value = isEncodedArray ? decode(value, options) : value;
            const newValue = isArray || isEncodedArray ? value.split(options.arrayFormatSeparator).map((item) => decode(item, options)) : value === null ? value : decode(value, options);
            accumulator[key] = newValue;
          };
        case "bracket-separator":
          return (key, value, accumulator) => {
            const isArray = /(\[\])$/.test(key);
            key = key.replace(/\[\]$/, "");
            if (!isArray) {
              accumulator[key] = value ? decode(value, options) : value;
              return;
            }
            const arrayValue = value === null ? [] : value.split(options.arrayFormatSeparator).map((item) => decode(item, options));
            if (accumulator[key] === void 0) {
              accumulator[key] = arrayValue;
              return;
            }
            accumulator[key] = [].concat(accumulator[key], arrayValue);
          };
        default:
          return (key, value, accumulator) => {
            if (accumulator[key] === void 0) {
              accumulator[key] = value;
              return;
            }
            accumulator[key] = [].concat(accumulator[key], value);
          };
      }
    }
    function validateArrayFormatSeparator(value) {
      if (typeof value !== "string" || value.length !== 1) {
        throw new TypeError("arrayFormatSeparator must be single character string");
      }
    }
    function encode(value, options) {
      if (options.encode) {
        return options.strict ? strictUriEncode(value) : encodeURIComponent(value);
      }
      return value;
    }
    function decode(value, options) {
      if (options.decode) {
        return decodeComponent(value);
      }
      return value;
    }
    function keysSorter(input) {
      if (Array.isArray(input)) {
        return input.sort();
      }
      if (typeof input === "object") {
        return keysSorter(Object.keys(input)).sort((a3, b5) => Number(a3) - Number(b5)).map((key) => input[key]);
      }
      return input;
    }
    function removeHash(input) {
      const hashStart = input.indexOf("#");
      if (hashStart !== -1) {
        input = input.slice(0, hashStart);
      }
      return input;
    }
    function getHash(url) {
      let hash = "";
      const hashStart = url.indexOf("#");
      if (hashStart !== -1) {
        hash = url.slice(hashStart);
      }
      return hash;
    }
    function extract(input) {
      input = removeHash(input);
      const queryStart = input.indexOf("?");
      if (queryStart === -1) {
        return "";
      }
      return input.slice(queryStart + 1);
    }
    function parseValue(value, options) {
      if (options.parseNumbers && !Number.isNaN(Number(value)) && (typeof value === "string" && value.trim() !== "")) {
        value = Number(value);
      } else if (options.parseBooleans && value !== null && (value.toLowerCase() === "true" || value.toLowerCase() === "false")) {
        value = value.toLowerCase() === "true";
      }
      return value;
    }
    function parse3(query, options) {
      options = Object.assign({
        decode: true,
        sort: true,
        arrayFormat: "none",
        arrayFormatSeparator: ",",
        parseNumbers: false,
        parseBooleans: false
      }, options);
      validateArrayFormatSeparator(options.arrayFormatSeparator);
      const formatter = parserForArrayFormat(options);
      const ret = /* @__PURE__ */ Object.create(null);
      if (typeof query !== "string") {
        return ret;
      }
      query = query.trim().replace(/^[?#&]/, "");
      if (!query) {
        return ret;
      }
      for (const param of query.split("&")) {
        if (param === "") {
          continue;
        }
        let [key, value] = splitOnFirst(options.decode ? param.replace(/\+/g, " ") : param, "=");
        value = value === void 0 ? null : ["comma", "separator", "bracket-separator"].includes(options.arrayFormat) ? value : decode(value, options);
        formatter(decode(key, options), value, ret);
      }
      for (const key of Object.keys(ret)) {
        const value = ret[key];
        if (typeof value === "object" && value !== null) {
          for (const k4 of Object.keys(value)) {
            value[k4] = parseValue(value[k4], options);
          }
        } else {
          ret[key] = parseValue(value, options);
        }
      }
      if (options.sort === false) {
        return ret;
      }
      return (options.sort === true ? Object.keys(ret).sort() : Object.keys(ret).sort(options.sort)).reduce((result, key) => {
        const value = ret[key];
        if (Boolean(value) && typeof value === "object" && !Array.isArray(value)) {
          result[key] = keysSorter(value);
        } else {
          result[key] = value;
        }
        return result;
      }, /* @__PURE__ */ Object.create(null));
    }
    exports.extract = extract;
    exports.parse = parse3;
    exports.stringify = (object, options) => {
      if (!object) {
        return "";
      }
      options = Object.assign({
        encode: true,
        strict: true,
        arrayFormat: "none",
        arrayFormatSeparator: ","
      }, options);
      validateArrayFormatSeparator(options.arrayFormatSeparator);
      const shouldFilter = (key) => options.skipNull && isNullOrUndefined(object[key]) || options.skipEmptyString && object[key] === "";
      const formatter = encoderForArrayFormat(options);
      const objectCopy = {};
      for (const key of Object.keys(object)) {
        if (!shouldFilter(key)) {
          objectCopy[key] = object[key];
        }
      }
      const keys = Object.keys(objectCopy);
      if (options.sort !== false) {
        keys.sort(options.sort);
      }
      return keys.map((key) => {
        const value = object[key];
        if (value === void 0) {
          return "";
        }
        if (value === null) {
          return encode(key, options);
        }
        if (Array.isArray(value)) {
          if (value.length === 0 && options.arrayFormat === "bracket-separator") {
            return encode(key, options) + "[]";
          }
          return value.reduce(formatter(key), []).join("&");
        }
        return encode(key, options) + "=" + encode(value, options);
      }).filter((x4) => x4.length > 0).join("&");
    };
    exports.parseUrl = (url, options) => {
      options = Object.assign({
        decode: true
      }, options);
      const [url_, hash] = splitOnFirst(url, "#");
      return Object.assign(
        {
          url: url_.split("?")[0] || "",
          query: parse3(extract(url), options)
        },
        options && options.parseFragmentIdentifier && hash ? { fragmentIdentifier: decode(hash, options) } : {}
      );
    };
    exports.stringifyUrl = (object, options) => {
      options = Object.assign({
        encode: true,
        strict: true,
        [encodeFragmentIdentifier]: true
      }, options);
      const url = removeHash(object.url).split("?")[0] || "";
      const queryFromUrl = exports.extract(object.url);
      const parsedQueryFromUrl = exports.parse(queryFromUrl, { sort: false });
      const query = Object.assign(parsedQueryFromUrl, object.query);
      let queryString = exports.stringify(query, options);
      if (queryString) {
        queryString = `?${queryString}`;
      }
      let hash = getHash(object.url);
      if (object.fragmentIdentifier) {
        hash = `#${options[encodeFragmentIdentifier] ? encode(object.fragmentIdentifier, options) : object.fragmentIdentifier}`;
      }
      return `${url}${queryString}${hash}`;
    };
    exports.pick = (input, filter, options) => {
      options = Object.assign({
        parseFragmentIdentifier: true,
        [encodeFragmentIdentifier]: false
      }, options);
      const { url, query, fragmentIdentifier } = exports.parseUrl(input, options);
      return exports.stringifyUrl({
        url,
        query: filterObject(query, filter),
        fragmentIdentifier
      }, options);
    };
    exports.exclude = (input, filter, options) => {
      const exclusionFilter = Array.isArray(filter) ? (key) => !filter.includes(key) : (key, value) => !filter(key, value);
      return exports.pick(input, exclusionFilter, options);
    };
  }
});

// node_modules/@thirdweb-dev/react/node_modules/@thirdweb-dev/wallets/dist/smart-wallet-f5e628ca.browser.esm.js
init_shim();

// node_modules/@thirdweb-dev/react/node_modules/@thirdweb-dev/wallets/dist/base-402f7b12.browser.esm.js
init_shim();

// node_modules/@thirdweb-dev/react/node_modules/@thirdweb-dev/wallets/evm/wallets/abstract/dist/thirdweb-dev-wallets-evm-wallets-abstract.browser.esm.js
init_shim();
init_lib3();
var ERC20WithDecimalsAbi = [{
  anonymous: false,
  inputs: [{
    indexed: true,
    internalType: "address",
    name: "owner",
    type: "address"
  }, {
    indexed: true,
    internalType: "address",
    name: "spender",
    type: "address"
  }, {
    indexed: false,
    internalType: "uint256",
    name: "value",
    type: "uint256"
  }],
  name: "Approval",
  type: "event"
}, {
  anonymous: false,
  inputs: [{
    indexed: true,
    internalType: "address",
    name: "from",
    type: "address"
  }, {
    indexed: true,
    internalType: "address",
    name: "to",
    type: "address"
  }, {
    indexed: false,
    internalType: "uint256",
    name: "value",
    type: "uint256"
  }],
  name: "Transfer",
  type: "event"
}, {
  inputs: [{
    internalType: "address",
    name: "owner",
    type: "address"
  }, {
    internalType: "address",
    name: "spender",
    type: "address"
  }],
  name: "allowance",
  outputs: [{
    internalType: "uint256",
    name: "",
    type: "uint256"
  }],
  stateMutability: "view",
  type: "function"
}, {
  inputs: [{
    internalType: "address",
    name: "spender",
    type: "address"
  }, {
    internalType: "uint256",
    name: "value",
    type: "uint256"
  }],
  name: "approve",
  outputs: [{
    internalType: "bool",
    name: "",
    type: "bool"
  }],
  stateMutability: "nonpayable",
  type: "function"
}, {
  inputs: [{
    internalType: "address",
    name: "who",
    type: "address"
  }],
  name: "balanceOf",
  outputs: [{
    internalType: "uint256",
    name: "",
    type: "uint256"
  }],
  stateMutability: "view",
  type: "function"
}, {
  inputs: [],
  name: "totalSupply",
  outputs: [{
    internalType: "uint256",
    name: "",
    type: "uint256"
  }],
  stateMutability: "view",
  type: "function"
}, {
  inputs: [{
    internalType: "address",
    name: "to",
    type: "address"
  }, {
    internalType: "uint256",
    name: "value",
    type: "uint256"
  }],
  name: "transfer",
  outputs: [{
    internalType: "bool",
    name: "",
    type: "bool"
  }],
  stateMutability: "nonpayable",
  type: "function"
}, {
  inputs: [{
    internalType: "address",
    name: "from",
    type: "address"
  }, {
    internalType: "address",
    name: "to",
    type: "address"
  }, {
    internalType: "uint256",
    name: "value",
    type: "uint256"
  }],
  name: "transferFrom",
  outputs: [{
    internalType: "bool",
    name: "",
    type: "bool"
  }],
  stateMutability: "nonpayable",
  type: "function"
}, {
  inputs: [],
  name: "decimals",
  outputs: [{
    internalType: "uint8",
    name: "",
    type: "uint8"
  }],
  stateMutability: "view",
  type: "function"
}];
function createErc20(provider, currencyAddress) {
  return new Contract(currencyAddress, ERC20WithDecimalsAbi, provider);
}
function chainIdToThirdwebRpc(chainId, clientId) {
  return `https://${chainId}.rpc.thirdweb.com${clientId ? `/${clientId}` : ""}${typeof globalThis !== "undefined" && "APP_BUNDLE_ID" in globalThis ? `?bundleId=${globalThis.APP_BUNDLE_ID}` : ""}`;
}
var EIP1271_ABI = ["function isValidSignature(bytes32 _message, bytes _signature) public view returns (bytes4)"];
var EIP1271_MAGICVALUE = "0x1626ba7e";
async function checkContractWalletSignature(message, signature, address, chainId) {
  const provider = new lib_exports.JsonRpcProvider(chainIdToThirdwebRpc(chainId));
  const walletContract = new Contract(address, EIP1271_ABI, provider);
  const _hashMessage = utils_exports.hashMessage(message);
  try {
    const res = await walletContract.isValidSignature(_hashMessage, signature);
    return res === EIP1271_MAGICVALUE;
  } catch {
    return false;
  }
}
var AbstractWallet = class extends eventemitter3_default {
  constructor() {
    super(...arguments);
    _defineProperty(this, "type", "evm");
  }
  /**
   * @returns the account address from connected wallet
   */
  async getAddress() {
    const signer = await this.getSigner();
    return signer.getAddress();
  }
  /**
   * @returns the native token balance of the connected wallet
   */
  async getBalance() {
    let currencyAddress = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : NATIVE_TOKEN_ADDRESS;
    const signer = await this.getSigner();
    const address = await this.getAddress();
    if (!signer.provider) {
      throw new Error("Please connect a provider");
    }
    let balance;
    if (isNativeToken(currencyAddress)) {
      balance = await signer.provider.getBalance(address);
    } else {
      const erc20 = createErc20(signer, currencyAddress);
      balance = await erc20.balanceOf(address);
    }
    return await fetchCurrencyValue(signer.provider, currencyAddress, balance);
  }
  /**
   * @returns the chain id from connected wallet
   */
  async getChainId() {
    const signer = await this.getSigner();
    return signer.getChainId();
  }
  async transfer(to, amount) {
    let currencyAddress = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : NATIVE_TOKEN_ADDRESS;
    const signer = await this.getSigner();
    const from = await this.getAddress();
    if (!signer.provider) {
      throw new Error("Please connect a provider");
    }
    const value = await normalizePriceValue(signer.provider, amount, currencyAddress);
    if (isNativeToken(currencyAddress)) {
      const tx = await signer.sendTransaction({
        from,
        to,
        value
      });
      return {
        receipt: await tx.wait()
      };
    } else {
      const erc20 = createErc20(signer, currencyAddress);
      const tx = await erc20.transfer(to, value);
      return {
        receipt: await tx.wait()
      };
    }
  }
  /**
   * @returns the signature of the message
   */
  async signMessage(message) {
    const signer = await this.getSigner();
    return await signer.signMessage(message);
  }
  /**
   * verify the signature of a message
   * @returns `true` if the signature is valid, `false` otherwise
   */
  async verifySignature(message, signature, address, chainId) {
    try {
      const messageHash = utils_exports.hashMessage(message);
      const messageHashBytes = utils_exports.arrayify(messageHash);
      const recoveredAddress = utils_exports.recoverAddress(messageHashBytes, signature);
      if (recoveredAddress === address) {
        return true;
      }
    } catch {
    }
    if (chainId !== void 0) {
      try {
        const isValid = await checkContractWalletSignature(message, signature, address, chainId || 1);
        return isValid;
      } catch {
      }
    }
    return false;
  }
};

// node_modules/@thirdweb-dev/react/node_modules/@thirdweb-dev/wallets/dist/base-402f7b12.browser.esm.js
var PREFIX = "__TW__";
var AsyncLocalStorage = class {
  constructor(name) {
    this.name = name;
  }
  getItem(key) {
    return new Promise((res) => {
      res(localStorage.getItem(`${PREFIX}/${this.name}/${key}`));
    });
  }
  setItem(key, value) {
    return new Promise((res, rej) => {
      try {
        localStorage.setItem(`${PREFIX}/${this.name}/${key}`, value);
        res();
      } catch (e) {
        rej(e);
      }
    });
  }
  removeItem(key) {
    return new Promise((res) => {
      localStorage.removeItem(`${PREFIX}/${this.name}/${key}`);
      res();
    });
  }
};
function createAsyncLocalStorage(name) {
  return new AsyncLocalStorage(name);
}
var DEFAULT_DAPP_META = {
  name: "thirdweb powered dApp",
  url: "https://thirdweb.com",
  description: "thirdweb powered dApp",
  logoUrl: "https://thirdweb.com/favicon.ico",
  isDarkMode: true
};
var _connectParams = /* @__PURE__ */ new WeakMap();
var _connect = /* @__PURE__ */ new WeakSet();
var _subscribeToEvents = /* @__PURE__ */ new WeakSet();
var AbstractClientWallet = class extends AbstractWallet {
  getMeta() {
    return this.constructor.meta;
  }
  constructor(walletId, options) {
    super();
    _classPrivateMethodInitSpec(this, _subscribeToEvents);
    _classPrivateMethodInitSpec(this, _connect);
    _classPrivateFieldInitSpec(this, _connectParams, {
      writable: true,
      value: void 0
    });
    this.walletId = walletId;
    this.options = options;
    this.chains = ((options == null ? void 0 : options.chains) || defaultChains).map((c3) => updateChainRPCs(c3, options == null ? void 0 : options.clientId));
    this.dappMetadata = (options == null ? void 0 : options.dappMetadata) || DEFAULT_DAPP_META;
    this.walletStorage = (options == null ? void 0 : options.walletStorage) || createAsyncLocalStorage(this.walletId);
  }
  /**
   * tries to auto connect to the wallet
   */
  async autoConnect(connectOptions) {
    const options = connectOptions ? {
      ...connectOptions,
      chainId: void 0
    } : void 0;
    return _classPrivateMethodGet(this, _connect, _connect2).call(this, true, options);
  }
  /**
   * connect to the wallet
   */
  async connect(connectOptions) {
    _classPrivateFieldSet(this, _connectParams, connectOptions);
    const address = await _classPrivateMethodGet(this, _connect, _connect2).call(this, false, connectOptions);
    if (!address) {
      throw new Error("Failed to connect to the wallet.");
    }
    return address;
  }
  getConnectParams() {
    return _classPrivateFieldGet(this, _connectParams);
  }
  async getSigner() {
    const connector = await this.getConnector();
    if (!connector) {
      throw new Error("Wallet not connected");
    }
    return await connector.getSigner();
  }
  async disconnect() {
    const connector = await this.getConnector();
    if (connector) {
      await connector.disconnect();
      this.emit("disconnect");
      connector.removeAllListeners();
    }
  }
  async switchChain(chainId) {
    const connector = await this.getConnector();
    if (!connector) {
      throw new Error("Wallet not connected");
    }
    if (!connector.switchChain) {
      throw new Error("Wallet does not support switching chains");
    }
    return await connector.switchChain(chainId);
  }
  async updateChains(chains) {
    this.chains = chains.map((c3) => {
      var _a;
      return updateChainRPCs(c3, (_a = this.options) == null ? void 0 : _a.clientId);
    });
    const connector = await this.getConnector();
    connector.updateChains(this.chains);
  }
  /**
   * If the wallet uses a personal wallet under the hood, return it
   */
  getPersonalWallet() {
    return void 0;
  }
};
async function _connect2(isAutoConnect, connectOptions) {
  const connector = await this.getConnector();
  _classPrivateMethodGet(this, _subscribeToEvents, _subscribeToEvents2).call(this, connector);
  const isConnected = await connector.isConnected();
  if (isConnected) {
    const address = await connector.getAddress();
    connector.setupListeners();
    if (connectOptions == null ? void 0 : connectOptions.chainId) {
      await connector.switchChain(connectOptions == null ? void 0 : connectOptions.chainId);
    }
    this.emit("connect", {
      address,
      chainId: await this.getChainId()
    });
    return address;
  }
  if (isAutoConnect) {
    throw new Error("Failed to auto connect to the wallet.");
  }
  try {
    const address = await connector.connect(connectOptions);
    return address;
  } catch (error) {
    throw new Error(error.message);
  }
}
async function _subscribeToEvents2(connector) {
  connector.on("connect", (data2) => {
    var _a;
    this.emit("connect", {
      address: data2.account,
      chainId: (_a = data2.chain) == null ? void 0 : _a.id
    });
  });
  connector.on("change", (data2) => {
    var _a;
    this.emit("change", {
      address: data2.account,
      chainId: (_a = data2.chain) == null ? void 0 : _a.id
    });
  });
  connector.on("message", (data2) => {
    this.emit("message", data2);
  });
  connector.on("disconnect", async () => {
    this.emit("disconnect");
  });
  connector.on("error", (error) => this.emit("error", error));
}

// node_modules/@walletconnect/web3wallet/dist/index.es.js
init_shim();

// node_modules/@walletconnect/auth-client/dist/index.es.js
init_shim();

// node_modules/@walletconnect/auth-client/node_modules/@walletconnect/core/dist/index.es.js
init_shim();
var import_events3 = __toESM(require_events());
var import_heartbeat = __toESM(require_cjs2());
var import_logger = __toESM(require_cjs3());

// node_modules/@walletconnect/auth-client/node_modules/@walletconnect/types/dist/index.es.js
init_shim();
init_esm();
var import_events2 = __toESM(require_events());
var n2 = class extends IEvents {
  constructor(s) {
    super(), this.opts = s, this.protocol = "wc", this.version = 2;
  }
};
var h2 = class extends IEvents {
  constructor(s, t) {
    super(), this.core = s, this.logger = t, this.records = /* @__PURE__ */ new Map();
  }
};
var a = class {
  constructor(s, t) {
    this.logger = s, this.core = t;
  }
};
var u = class extends IEvents {
  constructor(s, t) {
    super(), this.relayer = s, this.logger = t;
  }
};
var g = class extends IEvents {
  constructor(s) {
    super();
  }
};
var p = class {
  constructor(s, t, o3, M6) {
    this.core = s, this.logger = t, this.name = o3;
  }
};
var d = class extends IEvents {
  constructor(s, t) {
    super(), this.relayer = s, this.logger = t;
  }
};
var E = class extends IEvents {
  constructor(s, t) {
    super(), this.core = s, this.logger = t;
  }
};
var y = class {
  constructor(s, t) {
    this.projectId = s, this.logger = t;
  }
};
var v = class {
  constructor(s, t) {
    this.projectId = s, this.logger = t;
  }
};

// node_modules/@walletconnect/auth-client/node_modules/@walletconnect/utils/dist/index.es.js
init_shim();
var import_chacha20poly1305 = __toESM(require_chacha20poly1305());
var import_hkdf = __toESM(require_hkdf());
var import_random = __toESM(require_random());
var import_sha256 = __toESM(require_sha256());
var fe = __toESM(require_x25519());
var import_time = __toESM(require_cjs());
var import_window_getters = __toESM(require_cjs4());
var import_window_metadata = __toESM(require_cjs5());
var M = __toESM(require_query_string());
var J = "base10";
var p2 = "base16";
var F = "base64pad";
var H = "utf8";
var Q = 0;
var _ = 1;
var Dn = 0;
var Te = 1;
var Z = 12;
var X = 32;
function kn() {
  const e = fe.generateKeyPair();
  return { privateKey: toString(e.secretKey, p2), publicKey: toString(e.publicKey, p2) };
}
function Vn() {
  const e = (0, import_random.randomBytes)(X);
  return toString(e, p2);
}
function Mn(e, n4) {
  const t = fe.sharedKey(fromString(e, p2), fromString(n4, p2), true), r = new import_hkdf.HKDF(import_sha256.SHA256, t).expand(X);
  return toString(r, p2);
}
function Kn(e) {
  const n4 = (0, import_sha256.hash)(fromString(e, p2));
  return toString(n4, p2);
}
function Ln(e) {
  const n4 = (0, import_sha256.hash)(fromString(e, H));
  return toString(n4, p2);
}
function Pe(e) {
  return fromString(`${e}`, J);
}
function j(e) {
  return Number(toString(e, J));
}
function xn(e) {
  const n4 = Pe(typeof e.type < "u" ? e.type : Q);
  if (j(n4) === _ && typeof e.senderPublicKey > "u")
    throw new Error("Missing sender public key for type 1 envelope");
  const t = typeof e.senderPublicKey < "u" ? fromString(e.senderPublicKey, p2) : void 0, r = typeof e.iv < "u" ? fromString(e.iv, p2) : (0, import_random.randomBytes)(Z), o3 = new import_chacha20poly1305.ChaCha20Poly1305(fromString(e.symKey, p2)).seal(r, fromString(e.message, H));
  return Re({ type: n4, sealed: o3, iv: r, senderPublicKey: t });
}
function Fn(e) {
  const n4 = new import_chacha20poly1305.ChaCha20Poly1305(fromString(e.symKey, p2)), { sealed: t, iv: r } = ee(e.encoded), o3 = n4.open(r, t);
  if (o3 === null)
    throw new Error("Failed to decrypt");
  return toString(o3, H);
}
function Re(e) {
  if (j(e.type) === _) {
    if (typeof e.senderPublicKey > "u")
      throw new Error("Missing sender public key for type 1 envelope");
    return toString(concat([e.type, e.senderPublicKey, e.iv, e.sealed]), F);
  }
  return toString(concat([e.type, e.iv, e.sealed]), F);
}
function ee(e) {
  const n4 = fromString(e, F), t = n4.slice(Dn, Te), r = Te;
  if (j(t) === _) {
    const d5 = r + X, l2 = d5 + Z, c3 = n4.slice(r, d5), u3 = n4.slice(d5, l2), a3 = n4.slice(l2);
    return { type: t, sealed: a3, iv: u3, senderPublicKey: c3 };
  }
  const o3 = r + Z, s = n4.slice(r, o3), i3 = n4.slice(o3);
  return { type: t, sealed: i3, iv: s };
}
function Hn(e, n4) {
  const t = ee(e);
  return Ae({ type: j(t.type), senderPublicKey: typeof t.senderPublicKey < "u" ? toString(t.senderPublicKey, p2) : void 0, receiverPublicKey: n4 == null ? void 0 : n4.receiverPublicKey });
}
function Ae(e) {
  const n4 = (e == null ? void 0 : e.type) || Q;
  if (n4 === _) {
    if (typeof (e == null ? void 0 : e.senderPublicKey) > "u")
      throw new Error("missing sender public key");
    if (typeof (e == null ? void 0 : e.receiverPublicKey) > "u")
      throw new Error("missing receiver public key");
  }
  return { type: n4, senderPublicKey: e == null ? void 0 : e.senderPublicKey, receiverPublicKey: e == null ? void 0 : e.receiverPublicKey };
}
function qn(e) {
  return e.type === _ && typeof e.senderPublicKey == "string" && typeof e.receiverPublicKey == "string";
}
var Bn = Object.defineProperty;
var Ue = Object.getOwnPropertySymbols;
var Gn = Object.prototype.hasOwnProperty;
var Wn = Object.prototype.propertyIsEnumerable;
var _e = (e, n4, t) => n4 in e ? Bn(e, n4, { enumerable: true, configurable: true, writable: true, value: t }) : e[n4] = t;
var $e = (e, n4) => {
  for (var t in n4 || (n4 = {}))
    Gn.call(n4, t) && _e(e, t, n4[t]);
  if (Ue)
    for (var t of Ue(n4))
      Wn.call(n4, t) && _e(e, t, n4[t]);
  return e;
};
var Ce = "ReactNative";
var m = { reactNative: "react-native", node: "node", browser: "browser", unknown: "unknown" };
var De = "js";
function te() {
  return typeof import_process.default < "u" && typeof import_process.default.versions < "u" && typeof import_process.default.versions.node < "u";
}
function $() {
  return !(0, import_window_getters.getDocument)() && !!(0, import_window_getters.getNavigator)() && navigator.product === Ce;
}
function D() {
  return !te() && !!(0, import_window_getters.getNavigator)() && !!(0, import_window_getters.getDocument)();
}
function R() {
  return $() ? m.reactNative : te() ? m.node : D() ? m.browser : m.unknown;
}
function Jn() {
  var e;
  try {
    return $() && typeof global < "u" && typeof (global == null ? void 0 : global.Application) < "u" ? (e = global.Application) == null ? void 0 : e.applicationId : void 0;
  } catch {
    return;
  }
}
function ke(e, n4) {
  let t = M.parse(e);
  return t = $e($e({}, t), n4), e = M.stringify(t), e;
}
function Ve() {
  if (R() === m.reactNative && typeof global < "u" && typeof (global == null ? void 0 : global.Platform) < "u") {
    const { OS: t, Version: r } = global.Platform;
    return [t, r].join("-");
  }
  const e = detect();
  if (e === null)
    return "unknown";
  const n4 = e.os ? e.os.replace(" ", "").toLowerCase() : "unknown";
  return e.type === "browser" ? [n4, e.name, e.version].join("-") : [n4, e.version].join("-");
}
function Me() {
  var e;
  const n4 = R();
  return n4 === m.browser ? [n4, ((e = (0, import_window_getters.getLocation)()) == null ? void 0 : e.host) || "unknown"].join(":") : n4;
}
function Ke(e, n4, t) {
  const r = Ve(), o3 = Me();
  return [[e, n4].join("-"), [De, t].join("-"), r, o3].join("/");
}
function Xn({ protocol: e, version: n4, relayUrl: t, sdkVersion: r, auth: o3, projectId: s, useOnCloseEvent: i3, bundleId: d5 }) {
  const l2 = t.split("?"), c3 = Ke(e, n4, r), u3 = { auth: o3, ua: c3, projectId: s, useOnCloseEvent: i3 || void 0, origin: d5 || void 0 }, a3 = ke(l2[1] || "", u3);
  return l2[0] + "?" + a3;
}
function rt(e) {
  return Object.fromEntries(e.entries());
}
function ot(e) {
  return new Map(Object.entries(e));
}
function at(e = import_time.FIVE_MINUTES, n4) {
  const t = (0, import_time.toMiliseconds)(e || import_time.FIVE_MINUTES);
  let r, o3, s;
  return { resolve: (i3) => {
    s && r && (clearTimeout(s), r(i3));
  }, reject: (i3) => {
    s && o3 && (clearTimeout(s), o3(i3));
  }, done: () => new Promise((i3, d5) => {
    s = setTimeout(() => {
      d5(new Error(n4));
    }, t), r = i3, o3 = d5;
  }) };
}
function ut(e, n4, t) {
  return new Promise(async (r, o3) => {
    const s = setTimeout(() => o3(new Error(t)), n4);
    try {
      const i3 = await e;
      r(i3);
    } catch (i3) {
      o3(i3);
    }
    clearTimeout(s);
  });
}
function re(e, n4) {
  if (typeof n4 == "string" && n4.startsWith(`${e}:`))
    return n4;
  if (e.toLowerCase() === "topic") {
    if (typeof n4 != "string")
      throw new Error('Value must be "string" for expirer target type: topic');
    return `topic:${n4}`;
  } else if (e.toLowerCase() === "id") {
    if (typeof n4 != "number")
      throw new Error('Value must be "number" for expirer target type: id');
    return `id:${n4}`;
  }
  throw new Error(`Unknown expirer target type: ${e}`);
}
function lt(e) {
  return re("topic", e);
}
function dt(e) {
  return re("id", e);
}
function ft(e) {
  const [n4, t] = e.split(":"), r = { id: void 0, topic: void 0 };
  if (n4 === "topic" && typeof t == "string")
    r.topic = t;
  else if (n4 === "id" && Number.isInteger(Number(t)))
    r.id = Number(t);
  else
    throw new Error(`Invalid target, expected id:number or topic:string, got ${n4}:${t}`);
  return r;
}
function pt(e, n4) {
  return (0, import_time.fromMiliseconds)((n4 || Date.now()) + (0, import_time.toMiliseconds)(e));
}
function mt(e) {
  return Date.now() >= (0, import_time.toMiliseconds)(e);
}
function yt(e, n4) {
  return `${e}${n4 ? `:${n4}` : ""}`;
}
var He = "irn";
function vt(e) {
  return (e == null ? void 0 : e.relay) || { protocol: He };
}
function Et(e) {
  const n4 = RELAY_JSONRPC[e];
  if (typeof n4 > "u")
    throw new Error(`Relay Protocol not supported: ${e}`);
  return n4;
}
var bt = Object.defineProperty;
var Nt = Object.defineProperties;
var Ot = Object.getOwnPropertyDescriptors;
var qe = Object.getOwnPropertySymbols;
var St = Object.prototype.hasOwnProperty;
var wt = Object.prototype.propertyIsEnumerable;
var Be = (e, n4, t) => n4 in e ? bt(e, n4, { enumerable: true, configurable: true, writable: true, value: t }) : e[n4] = t;
var It = (e, n4) => {
  for (var t in n4 || (n4 = {}))
    St.call(n4, t) && Be(e, t, n4[t]);
  if (qe)
    for (var t of qe(n4))
      wt.call(n4, t) && Be(e, t, n4[t]);
  return e;
};
var Tt = (e, n4) => Nt(e, Ot(n4));
function Ge(e, n4 = "-") {
  const t = {}, r = "relay" + n4;
  return Object.keys(e).forEach((o3) => {
    if (o3.startsWith(r)) {
      const s = o3.replace(r, ""), i3 = e[o3];
      t[s] = i3;
    }
  }), t;
}
function Pt(e) {
  e = e.includes("wc://") ? e.replace("wc://", "") : e, e = e.includes("wc:") ? e.replace("wc:", "") : e;
  const n4 = e.indexOf(":"), t = e.indexOf("?") !== -1 ? e.indexOf("?") : void 0, r = e.substring(0, n4), o3 = e.substring(n4 + 1, t).split("@"), s = typeof t < "u" ? e.substring(t) : "", i3 = M.parse(s);
  return { protocol: r, topic: We(o3[0]), version: parseInt(o3[1], 10), symKey: i3.symKey, relay: Ge(i3), expiryTimestamp: i3.expiryTimestamp ? parseInt(i3.expiryTimestamp, 10) : void 0 };
}
function We(e) {
  return e.startsWith("//") ? e.substring(2) : e;
}
function ze(e, n4 = "-") {
  const t = "relay", r = {};
  return Object.keys(e).forEach((o3) => {
    const s = t + n4 + o3;
    e[o3] && (r[s] = e[o3]);
  }), r;
}
function Rt(e) {
  return `${e.protocol}:${e.topic}@${e.version}?` + M.stringify(Tt(It({ symKey: e.symKey }, ze(e.relay)), { expiryTimestamp: e.expiryTimestamp }));
}
var nn = { INVALID_METHOD: { message: "Invalid method.", code: 1001 }, INVALID_EVENT: { message: "Invalid event.", code: 1002 }, INVALID_UPDATE_REQUEST: { message: "Invalid update request.", code: 1003 }, INVALID_EXTEND_REQUEST: { message: "Invalid extend request.", code: 1004 }, INVALID_SESSION_SETTLE_REQUEST: { message: "Invalid session settle request.", code: 1005 }, UNAUTHORIZED_METHOD: { message: "Unauthorized method.", code: 3001 }, UNAUTHORIZED_EVENT: { message: "Unauthorized event.", code: 3002 }, UNAUTHORIZED_UPDATE_REQUEST: { message: "Unauthorized update request.", code: 3003 }, UNAUTHORIZED_EXTEND_REQUEST: { message: "Unauthorized extend request.", code: 3004 }, USER_REJECTED: { message: "User rejected.", code: 5e3 }, USER_REJECTED_CHAINS: { message: "User rejected chains.", code: 5001 }, USER_REJECTED_METHODS: { message: "User rejected methods.", code: 5002 }, USER_REJECTED_EVENTS: { message: "User rejected events.", code: 5003 }, UNSUPPORTED_CHAINS: { message: "Unsupported chains.", code: 5100 }, UNSUPPORTED_METHODS: { message: "Unsupported methods.", code: 5101 }, UNSUPPORTED_EVENTS: { message: "Unsupported events.", code: 5102 }, UNSUPPORTED_ACCOUNTS: { message: "Unsupported accounts.", code: 5103 }, UNSUPPORTED_NAMESPACE_KEY: { message: "Unsupported namespace key.", code: 5104 }, USER_DISCONNECTED: { message: "User disconnected.", code: 6e3 }, SESSION_SETTLEMENT_FAILED: { message: "Session settlement failed.", code: 7e3 }, WC_METHOD_UNSUPPORTED: { message: "Unsupported wc_ method.", code: 10001 } };
var tn = { NOT_INITIALIZED: { message: "Not initialized.", code: 1 }, NO_MATCHING_KEY: { message: "No matching key.", code: 2 }, RESTORE_WILL_OVERRIDE: { message: "Restore will override.", code: 3 }, RESUBSCRIBED: { message: "Resubscribed.", code: 4 }, MISSING_OR_INVALID: { message: "Missing or invalid.", code: 5 }, EXPIRED: { message: "Expired.", code: 6 }, UNKNOWN_TYPE: { message: "Unknown type.", code: 7 }, MISMATCHED_TOPIC: { message: "Mismatched topic.", code: 8 }, NON_CONFORMING_NAMESPACES: { message: "Non conforming namespaces.", code: 9 } };
function N(e, n4) {
  const { message: t, code: r } = tn[e];
  return { message: n4 ? `${t} ${n4}` : t, code: r };
}
function U(e, n4) {
  const { message: t, code: r } = nn[e];
  return { message: n4 ? `${t} ${n4}` : t, code: r };
}
function k(e, n4) {
  return Array.isArray(e) ? typeof n4 < "u" && e.length ? e.every(n4) : true : false;
}
function w(e) {
  return typeof e > "u";
}
function g2(e, n4) {
  return n4 && w(e) ? true : typeof e == "string" && !!e.trim().length;
}
function G(e, n4) {
  return n4 && w(e) ? true : typeof e == "number" && !isNaN(e);
}
function Kt(e) {
  if (g2(e, false))
    try {
      return typeof new URL(e) < "u";
    } catch {
      return false;
    }
  return false;
}
function Lt(e) {
  var n4;
  return (n4 = e == null ? void 0 : e.proposer) == null ? void 0 : n4.publicKey;
}
function xt(e) {
  return e == null ? void 0 : e.topic;
}
function Gt(e) {
  return typeof e < "u" && typeof e !== null;
}
function tr(e, n4) {
  return G(e, false) && e <= n4.max && e >= n4.min;
}
function rr() {
  const e = R();
  return new Promise((n4) => {
    switch (e) {
      case m.browser:
        n4(mn());
        break;
      case m.reactNative:
        n4(yn());
        break;
      case m.node:
        n4(gn());
        break;
      default:
        n4(true);
    }
  });
}
function mn() {
  return D() && (navigator == null ? void 0 : navigator.onLine);
}
async function yn() {
  if ($() && typeof global < "u" && global != null && global.NetInfo) {
    const e = await (global == null ? void 0 : global.NetInfo.fetch());
    return e == null ? void 0 : e.isConnected;
  }
  return true;
}
function gn() {
  return true;
}
function or(e) {
  switch (R()) {
    case m.browser:
      hn(e);
      break;
    case m.reactNative:
      vn(e);
      break;
    case m.node:
      break;
  }
}
function hn(e) {
  !$() && D() && (window.addEventListener("online", () => e(true)), window.addEventListener("offline", () => e(false)));
}
function vn(e) {
  var _a;
  $() && typeof global < "u" && global != null && global.NetInfo && ((_a = global) == null ? void 0 : _a.NetInfo.addEventListener((n4) => e(n4 == null ? void 0 : n4.isConnected)));
}

// node_modules/@walletconnect/auth-client/node_modules/@walletconnect/core/dist/index.es.js
var import_time2 = __toESM(require_cjs());
var import_lodash = __toESM(require_lodash());
var import_isomorphic_unfetch = __toESM(require_browser());
function Hi(n4, e) {
  if (n4.length >= 255)
    throw new TypeError("Alphabet too long");
  for (var t = new Uint8Array(256), i3 = 0; i3 < t.length; i3++)
    t[i3] = 255;
  for (var s = 0; s < n4.length; s++) {
    var r = n4.charAt(s), o3 = r.charCodeAt(0);
    if (t[o3] !== 255)
      throw new TypeError(r + " is ambiguous");
    t[o3] = s;
  }
  var a3 = n4.length, h5 = n4.charAt(0), l2 = Math.log(a3) / Math.log(256), d5 = Math.log(256) / Math.log(a3);
  function p6(u3) {
    if (u3 instanceof Uint8Array || (ArrayBuffer.isView(u3) ? u3 = new Uint8Array(u3.buffer, u3.byteOffset, u3.byteLength) : Array.isArray(u3) && (u3 = Uint8Array.from(u3))), !(u3 instanceof Uint8Array))
      throw new TypeError("Expected Uint8Array");
    if (u3.length === 0)
      return "";
    for (var m3 = 0, z3 = 0, I4 = 0, _4 = u3.length; I4 !== _4 && u3[I4] === 0; )
      I4++, m3++;
    for (var T2 = (_4 - I4) * d5 + 1 >>> 0, f3 = new Uint8Array(T2); I4 !== _4; ) {
      for (var S3 = u3[I4], A3 = 0, C2 = T2 - 1; (S3 !== 0 || A3 < z3) && C2 !== -1; C2--, A3++)
        S3 += 256 * f3[C2] >>> 0, f3[C2] = S3 % a3 >>> 0, S3 = S3 / a3 >>> 0;
      if (S3 !== 0)
        throw new Error("Non-zero carry");
      z3 = A3, I4++;
    }
    for (var x4 = T2 - z3; x4 !== T2 && f3[x4] === 0; )
      x4++;
    for (var j4 = h5.repeat(m3); x4 < T2; ++x4)
      j4 += n4.charAt(f3[x4]);
    return j4;
  }
  function y4(u3) {
    if (typeof u3 != "string")
      throw new TypeError("Expected String");
    if (u3.length === 0)
      return new Uint8Array();
    var m3 = 0;
    if (u3[m3] !== " ") {
      for (var z3 = 0, I4 = 0; u3[m3] === h5; )
        z3++, m3++;
      for (var _4 = (u3.length - m3) * l2 + 1 >>> 0, T2 = new Uint8Array(_4); u3[m3]; ) {
        var f3 = t[u3.charCodeAt(m3)];
        if (f3 === 255)
          return;
        for (var S3 = 0, A3 = _4 - 1; (f3 !== 0 || S3 < I4) && A3 !== -1; A3--, S3++)
          f3 += a3 * T2[A3] >>> 0, T2[A3] = f3 % 256 >>> 0, f3 = f3 / 256 >>> 0;
        if (f3 !== 0)
          throw new Error("Non-zero carry");
        I4 = S3, m3++;
      }
      if (u3[m3] !== " ") {
        for (var C2 = _4 - I4; C2 !== _4 && T2[C2] === 0; )
          C2++;
        for (var x4 = new Uint8Array(z3 + (_4 - C2)), j4 = z3; C2 !== _4; )
          x4[j4++] = T2[C2++];
        return x4;
      }
    }
  }
  function M6(u3) {
    var m3 = y4(u3);
    if (m3)
      return m3;
    throw new Error(`Non-${e} character`);
  }
  return { encode: p6, decodeUnsafe: y4, decode: M6 };
}
var Ji = Hi;
var Xi = Ji;
var Ne = (n4) => {
  if (n4 instanceof Uint8Array && n4.constructor.name === "Uint8Array")
    return n4;
  if (n4 instanceof ArrayBuffer)
    return new Uint8Array(n4);
  if (ArrayBuffer.isView(n4))
    return new Uint8Array(n4.buffer, n4.byteOffset, n4.byteLength);
  throw new Error("Unknown type, must be binary type");
};
var Wi = (n4) => new TextEncoder().encode(n4);
var Qi = (n4) => new TextDecoder().decode(n4);
var Zi = class {
  constructor(e, t, i3) {
    this.name = e, this.prefix = t, this.baseEncode = i3;
  }
  encode(e) {
    if (e instanceof Uint8Array)
      return `${this.prefix}${this.baseEncode(e)}`;
    throw Error("Unknown type, must be binary type");
  }
};
var es = class {
  constructor(e, t, i3) {
    if (this.name = e, this.prefix = t, t.codePointAt(0) === void 0)
      throw new Error("Invalid prefix character");
    this.prefixCodePoint = t.codePointAt(0), this.baseDecode = i3;
  }
  decode(e) {
    if (typeof e == "string") {
      if (e.codePointAt(0) !== this.prefixCodePoint)
        throw Error(`Unable to decode multibase string ${JSON.stringify(e)}, ${this.name} decoder only supports inputs prefixed with ${this.prefix}`);
      return this.baseDecode(e.slice(this.prefix.length));
    } else
      throw Error("Can only multibase decode strings");
  }
  or(e) {
    return Ue2(this, e);
  }
};
var ts = class {
  constructor(e) {
    this.decoders = e;
  }
  or(e) {
    return Ue2(this, e);
  }
  decode(e) {
    const t = e[0], i3 = this.decoders[t];
    if (i3)
      return i3.decode(e);
    throw RangeError(`Unable to decode multibase string ${JSON.stringify(e)}, only inputs prefixed with ${Object.keys(this.decoders)} are supported`);
  }
};
var Ue2 = (n4, e) => new ts({ ...n4.decoders || { [n4.prefix]: n4 }, ...e.decoders || { [e.prefix]: e } });
var is = class {
  constructor(e, t, i3, s) {
    this.name = e, this.prefix = t, this.baseEncode = i3, this.baseDecode = s, this.encoder = new Zi(e, t, i3), this.decoder = new es(e, t, s);
  }
  encode(e) {
    return this.encoder.encode(e);
  }
  decode(e) {
    return this.decoder.decode(e);
  }
};
var W2 = ({ name: n4, prefix: e, encode: t, decode: i3 }) => new is(n4, e, t, i3);
var B = ({ prefix: n4, name: e, alphabet: t }) => {
  const { encode: i3, decode: s } = Xi(t, e);
  return W2({ prefix: n4, name: e, encode: i3, decode: (r) => Ne(s(r)) });
};
var ss = (n4, e, t, i3) => {
  const s = {};
  for (let d5 = 0; d5 < e.length; ++d5)
    s[e[d5]] = d5;
  let r = n4.length;
  for (; n4[r - 1] === "="; )
    --r;
  const o3 = new Uint8Array(r * t / 8 | 0);
  let a3 = 0, h5 = 0, l2 = 0;
  for (let d5 = 0; d5 < r; ++d5) {
    const p6 = s[n4[d5]];
    if (p6 === void 0)
      throw new SyntaxError(`Non-${i3} character`);
    h5 = h5 << t | p6, a3 += t, a3 >= 8 && (a3 -= 8, o3[l2++] = 255 & h5 >> a3);
  }
  if (a3 >= t || 255 & h5 << 8 - a3)
    throw new SyntaxError("Unexpected end of data");
  return o3;
};
var rs = (n4, e, t) => {
  const i3 = e[e.length - 1] === "=", s = (1 << t) - 1;
  let r = "", o3 = 0, a3 = 0;
  for (let h5 = 0; h5 < n4.length; ++h5)
    for (a3 = a3 << 8 | n4[h5], o3 += 8; o3 > t; )
      o3 -= t, r += e[s & a3 >> o3];
  if (o3 && (r += e[s & a3 << t - o3]), i3)
    for (; r.length * t & 7; )
      r += "=";
  return r;
};
var g3 = ({ name: n4, prefix: e, bitsPerChar: t, alphabet: i3 }) => W2({ prefix: e, name: n4, encode(s) {
  return rs(s, i3, t);
}, decode(s) {
  return ss(s, i3, t, n4);
} });
var ns = W2({ prefix: "\0", name: "identity", encode: (n4) => Qi(n4), decode: (n4) => Wi(n4) });
var os = Object.freeze({ __proto__: null, identity: ns });
var as = g3({ prefix: "0", name: "base2", alphabet: "01", bitsPerChar: 1 });
var hs = Object.freeze({ __proto__: null, base2: as });
var cs = g3({ prefix: "7", name: "base8", alphabet: "01234567", bitsPerChar: 3 });
var us = Object.freeze({ __proto__: null, base8: cs });
var ls = B({ prefix: "9", name: "base10", alphabet: "0123456789" });
var ds = Object.freeze({ __proto__: null, base10: ls });
var gs = g3({ prefix: "f", name: "base16", alphabet: "0123456789abcdef", bitsPerChar: 4 });
var ps = g3({ prefix: "F", name: "base16upper", alphabet: "0123456789ABCDEF", bitsPerChar: 4 });
var Ds = Object.freeze({ __proto__: null, base16: gs, base16upper: ps });
var ys = g3({ prefix: "b", name: "base32", alphabet: "abcdefghijklmnopqrstuvwxyz234567", bitsPerChar: 5 });
var ms = g3({ prefix: "B", name: "base32upper", alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZ234567", bitsPerChar: 5 });
var bs = g3({ prefix: "c", name: "base32pad", alphabet: "abcdefghijklmnopqrstuvwxyz234567=", bitsPerChar: 5 });
var fs = g3({ prefix: "C", name: "base32padupper", alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZ234567=", bitsPerChar: 5 });
var Es = g3({ prefix: "v", name: "base32hex", alphabet: "0123456789abcdefghijklmnopqrstuv", bitsPerChar: 5 });
var ws = g3({ prefix: "V", name: "base32hexupper", alphabet: "0123456789ABCDEFGHIJKLMNOPQRSTUV", bitsPerChar: 5 });
var vs = g3({ prefix: "t", name: "base32hexpad", alphabet: "0123456789abcdefghijklmnopqrstuv=", bitsPerChar: 5 });
var Is = g3({ prefix: "T", name: "base32hexpadupper", alphabet: "0123456789ABCDEFGHIJKLMNOPQRSTUV=", bitsPerChar: 5 });
var Cs = g3({ prefix: "h", name: "base32z", alphabet: "ybndrfg8ejkmcpqxot1uwisza345h769", bitsPerChar: 5 });
var Rs = Object.freeze({ __proto__: null, base32: ys, base32upper: ms, base32pad: bs, base32padupper: fs, base32hex: Es, base32hexupper: ws, base32hexpad: vs, base32hexpadupper: Is, base32z: Cs });
var _s = B({ prefix: "k", name: "base36", alphabet: "0123456789abcdefghijklmnopqrstuvwxyz" });
var Ts = B({ prefix: "K", name: "base36upper", alphabet: "0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ" });
var Ss = Object.freeze({ __proto__: null, base36: _s, base36upper: Ts });
var Ps = B({ name: "base58btc", prefix: "z", alphabet: "123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz" });
var xs = B({ name: "base58flickr", prefix: "Z", alphabet: "123456789abcdefghijkmnopqrstuvwxyzABCDEFGHJKLMNPQRSTUVWXYZ" });
var Os = Object.freeze({ __proto__: null, base58btc: Ps, base58flickr: xs });
var As = g3({ prefix: "m", name: "base64", alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/", bitsPerChar: 6 });
var zs = g3({ prefix: "M", name: "base64pad", alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=", bitsPerChar: 6 });
var Ns = g3({ prefix: "u", name: "base64url", alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_", bitsPerChar: 6 });
var Us = g3({ prefix: "U", name: "base64urlpad", alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_=", bitsPerChar: 6 });
var Ls = Object.freeze({ __proto__: null, base64: As, base64pad: zs, base64url: Ns, base64urlpad: Us });
var Le = Array.from("🚀🪐☄🛰🌌🌑🌒🌓🌔🌕🌖🌗🌘🌍🌏🌎🐉☀💻🖥💾💿😂❤😍🤣😊🙏💕😭😘👍😅👏😁🔥🥰💔💖💙😢🤔😆🙄💪😉☺👌🤗💜😔😎😇🌹🤦🎉💞✌✨🤷😱😌🌸🙌😋💗💚😏💛🙂💓🤩😄😀🖤😃💯🙈👇🎶😒🤭❣😜💋👀😪😑💥🙋😞😩😡🤪👊🥳😥🤤👉💃😳✋😚😝😴🌟😬🙃🍀🌷😻😓⭐✅🥺🌈😈🤘💦✔😣🏃💐☹🎊💘😠☝😕🌺🎂🌻😐🖕💝🙊😹🗣💫💀👑🎵🤞😛🔴😤🌼😫⚽🤙☕🏆🤫👈😮🙆🍻🍃🐶💁😲🌿🧡🎁⚡🌞🎈❌✊👋😰🤨😶🤝🚶💰🍓💢🤟🙁🚨💨🤬✈🎀🍺🤓😙💟🌱😖👶🥴▶➡❓💎💸⬇😨🌚🦋😷🕺⚠🙅😟😵👎🤲🤠🤧📌🔵💅🧐🐾🍒😗🤑🌊🤯🐷☎💧😯💆👆🎤🙇🍑❄🌴💣🐸💌📍🥀🤢👅💡💩👐📸👻🤐🤮🎼🥵🚩🍎🍊👼💍📣🥂");
var $s = Le.reduce((n4, e, t) => (n4[t] = e, n4), []);
var Fs = Le.reduce((n4, e, t) => (n4[e.codePointAt(0)] = t, n4), []);
function Ms(n4) {
  return n4.reduce((e, t) => (e += $s[t], e), "");
}
function ks(n4) {
  const e = [];
  for (const t of n4) {
    const i3 = Fs[t.codePointAt(0)];
    if (i3 === void 0)
      throw new Error(`Non-base256emoji character: ${t}`);
    e.push(i3);
  }
  return new Uint8Array(e);
}
var Ks = W2({ prefix: "🚀", name: "base256emoji", encode: Ms, decode: ks });
var Bs = Object.freeze({ __proto__: null, base256emoji: Ks });
var Vs = Fe;
var $e2 = 128;
var qs = 127;
var js = ~qs;
var Gs = Math.pow(2, 31);
function Fe(n4, e, t) {
  e = e || [], t = t || 0;
  for (var i3 = t; n4 >= Gs; )
    e[t++] = n4 & 255 | $e2, n4 /= 128;
  for (; n4 & js; )
    e[t++] = n4 & 255 | $e2, n4 >>>= 7;
  return e[t] = n4 | 0, Fe.bytes = t - i3 + 1, e;
}
var Ys = he2;
var Hs = 128;
var Me2 = 127;
function he2(n4, i3) {
  var t = 0, i3 = i3 || 0, s = 0, r = i3, o3, a3 = n4.length;
  do {
    if (r >= a3)
      throw he2.bytes = 0, new RangeError("Could not decode varint");
    o3 = n4[r++], t += s < 28 ? (o3 & Me2) << s : (o3 & Me2) * Math.pow(2, s), s += 7;
  } while (o3 >= Hs);
  return he2.bytes = r - i3, t;
}
var Js = Math.pow(2, 7);
var Xs = Math.pow(2, 14);
var Ws = Math.pow(2, 21);
var Qs = Math.pow(2, 28);
var Zs = Math.pow(2, 35);
var er = Math.pow(2, 42);
var tr2 = Math.pow(2, 49);
var ir = Math.pow(2, 56);
var sr = Math.pow(2, 63);
var rr2 = function(n4) {
  return n4 < Js ? 1 : n4 < Xs ? 2 : n4 < Ws ? 3 : n4 < Qs ? 4 : n4 < Zs ? 5 : n4 < er ? 6 : n4 < tr2 ? 7 : n4 < ir ? 8 : n4 < sr ? 9 : 10;
};
var nr = { encode: Vs, decode: Ys, encodingLength: rr2 };
var ke2 = nr;
var Ke2 = (n4, e, t = 0) => (ke2.encode(n4, e, t), e);
var Be2 = (n4) => ke2.encodingLength(n4);
var ce = (n4, e) => {
  const t = e.byteLength, i3 = Be2(n4), s = i3 + Be2(t), r = new Uint8Array(s + t);
  return Ke2(n4, r, 0), Ke2(t, r, i3), r.set(e, s), new or2(n4, t, e, r);
};
var or2 = class {
  constructor(e, t, i3, s) {
    this.code = e, this.size = t, this.digest = i3, this.bytes = s;
  }
};
var Ve2 = ({ name: n4, code: e, encode: t }) => new ar(n4, e, t);
var ar = class {
  constructor(e, t, i3) {
    this.name = e, this.code = t, this.encode = i3;
  }
  digest(e) {
    if (e instanceof Uint8Array) {
      const t = this.encode(e);
      return t instanceof Uint8Array ? ce(this.code, t) : t.then((i3) => ce(this.code, i3));
    } else
      throw Error("Unknown type, must be binary type");
  }
};
var qe2 = (n4) => async (e) => new Uint8Array(await crypto.subtle.digest(n4, e));
var hr = Ve2({ name: "sha2-256", code: 18, encode: qe2("SHA-256") });
var cr = Ve2({ name: "sha2-512", code: 19, encode: qe2("SHA-512") });
var ur = Object.freeze({ __proto__: null, sha256: hr, sha512: cr });
var je = 0;
var lr = "identity";
var Ge2 = Ne;
var dr = (n4) => ce(je, Ge2(n4));
var gr = { code: je, name: lr, encode: Ge2, digest: dr };
var pr = Object.freeze({ __proto__: null, identity: gr });
new TextEncoder(), new TextDecoder();
var Ye = { ...os, ...hs, ...us, ...ds, ...Ds, ...Rs, ...Ss, ...Os, ...Ls, ...Bs };
({ ...ur, ...pr });
function He2(n4) {
  return globalThis.Buffer != null ? new Uint8Array(n4.buffer, n4.byteOffset, n4.byteLength) : n4;
}
function Dr(n4 = 0) {
  return globalThis.Buffer != null && globalThis.Buffer.allocUnsafe != null ? He2(globalThis.Buffer.allocUnsafe(n4)) : new Uint8Array(n4);
}
function Je(n4, e, t, i3) {
  return { name: n4, prefix: e, encoder: { name: n4, prefix: e, encode: t }, decoder: { decode: i3 } };
}
var Xe = Je("utf8", "u", (n4) => "u" + new TextDecoder("utf8").decode(n4), (n4) => new TextEncoder().encode(n4.substring(1)));
var ue2 = Je("ascii", "a", (n4) => {
  let e = "a";
  for (let t = 0; t < n4.length; t++)
    e += String.fromCharCode(n4[t]);
  return e;
}, (n4) => {
  n4 = n4.substring(1);
  const e = Dr(n4.length);
  for (let t = 0; t < n4.length; t++)
    e[t] = n4.charCodeAt(t);
  return e;
});
var yr = { utf8: Xe, "utf-8": Xe, hex: Ye.base16, latin1: ue2, ascii: ue2, binary: ue2, ...Ye };
function mr(n4, e = "utf8") {
  const t = yr[e];
  if (!t)
    throw new Error(`Unsupported encoding "${e}"`);
  return (e === "utf8" || e === "utf-8") && globalThis.Buffer != null && globalThis.Buffer.from != null ? He2(globalThis.Buffer.from(n4, "utf-8")) : t.decoder.decode(`${t.prefix}${n4}`);
}
var le2 = "wc";
var We2 = 2;
var Q2 = "core";
var O = `${le2}@2:${Q2}:`;
var Qe = { name: Q2, logger: "error" };
var Ze = { database: ":memory:" };
var et = "crypto";
var de2 = "client_ed25519_seed";
var tt = import_time2.ONE_DAY;
var it = "keychain";
var st = "0.3";
var rt2 = "messages";
var nt = "0.3";
var ot2 = import_time2.SIX_HOURS;
var at2 = "publisher";
var ht = "irn";
var ct = "error";
var ge2 = "wss://relay.walletconnect.com";
var pe = "wss://relay.walletconnect.org";
var ut2 = "relayer";
var D2 = { message: "relayer_message", message_ack: "relayer_message_ack", connect: "relayer_connect", disconnect: "relayer_disconnect", error: "relayer_error", connection_stalled: "relayer_connection_stalled", transport_closed: "relayer_transport_closed", publish: "relayer_publish" };
var lt2 = "_subscription";
var P = { payload: "payload", connect: "connect", disconnect: "disconnect", error: "error" };
var dt2 = import_time2.ONE_SECOND;
var gt = "2.11.2";
var pt2 = 1e4;
var Dt = "0.3";
var yt2 = "WALLETCONNECT_CLIENT_ID";
var w2 = { created: "subscription_created", deleted: "subscription_deleted", expired: "subscription_expired", disabled: "subscription_disabled", sync: "subscription_sync", resubscribed: "subscription_resubscribed" };
var mt2 = "subscription";
var bt2 = "0.3";
var ft2 = import_time2.FIVE_SECONDS * 1e3;
var Et2 = "pairing";
var wt2 = "0.3";
var $2 = { wc_pairingDelete: { req: { ttl: import_time2.ONE_DAY, prompt: false, tag: 1e3 }, res: { ttl: import_time2.ONE_DAY, prompt: false, tag: 1001 } }, wc_pairingPing: { req: { ttl: import_time2.THIRTY_SECONDS, prompt: false, tag: 1002 }, res: { ttl: import_time2.THIRTY_SECONDS, prompt: false, tag: 1003 } }, unregistered_method: { req: { ttl: import_time2.ONE_DAY, prompt: false, tag: 0 }, res: { ttl: import_time2.ONE_DAY, prompt: false, tag: 0 } } };
var V = { create: "pairing_create", expire: "pairing_expire", delete: "pairing_delete", ping: "pairing_ping" };
var R2 = { created: "history_created", updated: "history_updated", deleted: "history_deleted", sync: "history_sync" };
var vt2 = "history";
var It2 = "0.3";
var Ct = "expirer";
var v2 = { created: "expirer_created", deleted: "expirer_deleted", expired: "expirer_expired", sync: "expirer_sync" };
var Rt2 = "0.3";
var Z2 = "verify-api";
var F2 = "https://verify.walletconnect.com";
var ee2 = "https://verify.walletconnect.org";
var _t = [F2, ee2];
var Tt2 = "echo";
var St2 = "https://echo.walletconnect.com";
var Pt2 = class {
  constructor(e, t) {
    this.core = e, this.logger = t, this.keychain = /* @__PURE__ */ new Map(), this.name = it, this.version = st, this.initialized = false, this.storagePrefix = O, this.init = async () => {
      if (!this.initialized) {
        const i3 = await this.getKeyChain();
        typeof i3 < "u" && (this.keychain = i3), this.initialized = true;
      }
    }, this.has = (i3) => (this.isInitialized(), this.keychain.has(i3)), this.set = async (i3, s) => {
      this.isInitialized(), this.keychain.set(i3, s), await this.persist();
    }, this.get = (i3) => {
      this.isInitialized();
      const s = this.keychain.get(i3);
      if (typeof s > "u") {
        const { message: r } = N("NO_MATCHING_KEY", `${this.name}: ${i3}`);
        throw new Error(r);
      }
      return s;
    }, this.del = async (i3) => {
      this.isInitialized(), this.keychain.delete(i3), await this.persist();
    }, this.core = e, this.logger = (0, import_logger.generateChildLogger)(t, this.name);
  }
  get context() {
    return (0, import_logger.getLoggerContext)(this.logger);
  }
  get storageKey() {
    return this.storagePrefix + this.version + this.core.customStoragePrefix + "//" + this.name;
  }
  async setKeyChain(e) {
    await this.core.storage.setItem(this.storageKey, rt(e));
  }
  async getKeyChain() {
    const e = await this.core.storage.getItem(this.storageKey);
    return typeof e < "u" ? ot(e) : void 0;
  }
  async persist() {
    await this.setKeyChain(this.keychain);
  }
  isInitialized() {
    if (!this.initialized) {
      const { message: e } = N("NOT_INITIALIZED", this.name);
      throw new Error(e);
    }
  }
};
var xt2 = class {
  constructor(e, t, i3) {
    this.core = e, this.logger = t, this.name = et, this.initialized = false, this.init = async () => {
      this.initialized || (await this.keychain.init(), this.initialized = true);
    }, this.hasKeys = (s) => (this.isInitialized(), this.keychain.has(s)), this.getClientId = async () => {
      this.isInitialized();
      const s = await this.getClientSeed(), r = generateKeyPair(s);
      return encodeIss(r.publicKey);
    }, this.generateKeyPair = () => {
      this.isInitialized();
      const s = kn();
      return this.setPrivateKey(s.publicKey, s.privateKey);
    }, this.signJWT = async (s) => {
      this.isInitialized();
      const r = await this.getClientSeed(), o3 = generateKeyPair(r), a3 = Vn(), h5 = tt;
      return await signJWT(a3, s, h5, o3);
    }, this.generateSharedKey = (s, r, o3) => {
      this.isInitialized();
      const a3 = this.getPrivateKey(s), h5 = Mn(a3, r);
      return this.setSymKey(h5, o3);
    }, this.setSymKey = async (s, r) => {
      this.isInitialized();
      const o3 = r || Kn(s);
      return await this.keychain.set(o3, s), o3;
    }, this.deleteKeyPair = async (s) => {
      this.isInitialized(), await this.keychain.del(s);
    }, this.deleteSymKey = async (s) => {
      this.isInitialized(), await this.keychain.del(s);
    }, this.encode = async (s, r, o3) => {
      this.isInitialized();
      const a3 = Ae(o3), h5 = safeJsonStringify(r);
      if (qn(a3)) {
        const y4 = a3.senderPublicKey, M6 = a3.receiverPublicKey;
        s = await this.generateSharedKey(y4, M6);
      }
      const l2 = this.getSymKey(s), { type: d5, senderPublicKey: p6 } = a3;
      return xn({ type: d5, symKey: l2, message: h5, senderPublicKey: p6 });
    }, this.decode = async (s, r, o3) => {
      this.isInitialized();
      const a3 = Hn(r, o3);
      if (qn(a3)) {
        const h5 = a3.receiverPublicKey, l2 = a3.senderPublicKey;
        s = await this.generateSharedKey(h5, l2);
      }
      try {
        const h5 = this.getSymKey(s), l2 = Fn({ symKey: h5, encoded: r });
        return safeJsonParse(l2);
      } catch (h5) {
        this.logger.error(`Failed to decode message from topic: '${s}', clientId: '${await this.getClientId()}'`), this.logger.error(h5);
      }
    }, this.getPayloadType = (s) => {
      const r = ee(s);
      return j(r.type);
    }, this.getPayloadSenderPublicKey = (s) => {
      const r = ee(s);
      return r.senderPublicKey ? toString(r.senderPublicKey, p2) : void 0;
    }, this.core = e, this.logger = (0, import_logger.generateChildLogger)(t, this.name), this.keychain = i3 || new Pt2(this.core, this.logger);
  }
  get context() {
    return (0, import_logger.getLoggerContext)(this.logger);
  }
  async setPrivateKey(e, t) {
    return await this.keychain.set(e, t), e;
  }
  getPrivateKey(e) {
    return this.keychain.get(e);
  }
  async getClientSeed() {
    let e = "";
    try {
      e = this.keychain.get(de2);
    } catch {
      e = Vn(), await this.keychain.set(de2, e);
    }
    return mr(e, "base16");
  }
  getSymKey(e) {
    return this.keychain.get(e);
  }
  isInitialized() {
    if (!this.initialized) {
      const { message: e } = N("NOT_INITIALIZED", this.name);
      throw new Error(e);
    }
  }
};
var Ot2 = class extends a {
  constructor(e, t) {
    super(e, t), this.logger = e, this.core = t, this.messages = /* @__PURE__ */ new Map(), this.name = rt2, this.version = nt, this.initialized = false, this.storagePrefix = O, this.init = async () => {
      if (!this.initialized) {
        this.logger.trace("Initialized");
        try {
          const i3 = await this.getRelayerMessages();
          typeof i3 < "u" && (this.messages = i3), this.logger.debug(`Successfully Restored records for ${this.name}`), this.logger.trace({ type: "method", method: "restore", size: this.messages.size });
        } catch (i3) {
          this.logger.debug(`Failed to Restore records for ${this.name}`), this.logger.error(i3);
        } finally {
          this.initialized = true;
        }
      }
    }, this.set = async (i3, s) => {
      this.isInitialized();
      const r = Ln(s);
      let o3 = this.messages.get(i3);
      return typeof o3 > "u" && (o3 = {}), typeof o3[r] < "u" || (o3[r] = s, this.messages.set(i3, o3), await this.persist()), r;
    }, this.get = (i3) => {
      this.isInitialized();
      let s = this.messages.get(i3);
      return typeof s > "u" && (s = {}), s;
    }, this.has = (i3, s) => {
      this.isInitialized();
      const r = this.get(i3), o3 = Ln(s);
      return typeof r[o3] < "u";
    }, this.del = async (i3) => {
      this.isInitialized(), this.messages.delete(i3), await this.persist();
    }, this.logger = (0, import_logger.generateChildLogger)(e, this.name), this.core = t;
  }
  get context() {
    return (0, import_logger.getLoggerContext)(this.logger);
  }
  get storageKey() {
    return this.storagePrefix + this.version + this.core.customStoragePrefix + "//" + this.name;
  }
  async setRelayerMessages(e) {
    await this.core.storage.setItem(this.storageKey, rt(e));
  }
  async getRelayerMessages() {
    const e = await this.core.storage.getItem(this.storageKey);
    return typeof e < "u" ? ot(e) : void 0;
  }
  async persist() {
    await this.setRelayerMessages(this.messages);
  }
  isInitialized() {
    if (!this.initialized) {
      const { message: e } = N("NOT_INITIALIZED", this.name);
      throw new Error(e);
    }
  }
};
var vr = class extends u {
  constructor(e, t) {
    super(e, t), this.relayer = e, this.logger = t, this.events = new import_events3.EventEmitter(), this.name = at2, this.queue = /* @__PURE__ */ new Map(), this.publishTimeout = (0, import_time2.toMiliseconds)(import_time2.TEN_SECONDS * 2), this.needsTransportRestart = false, this.publish = async (i3, s, r) => {
      var o3;
      this.logger.debug("Publishing Payload"), this.logger.trace({ type: "method", method: "publish", params: { topic: i3, message: s, opts: r } });
      try {
        const a3 = (r == null ? void 0 : r.ttl) || ot2, h5 = vt(r), l2 = (r == null ? void 0 : r.prompt) || false, d5 = (r == null ? void 0 : r.tag) || 0, p6 = (r == null ? void 0 : r.id) || getBigIntRpcId().toString(), y4 = { topic: i3, message: s, opts: { ttl: a3, relay: h5, prompt: l2, tag: d5, id: p6 } }, M6 = setTimeout(() => this.queue.set(p6, y4), this.publishTimeout);
        try {
          await await ut(this.rpcPublish(i3, s, a3, h5, l2, d5, p6), this.publishTimeout, `Failed to publish payload, please try again. id:${p6} tag:${d5}`), this.removeRequestFromQueue(p6), this.relayer.events.emit(D2.publish, y4);
        } catch (u3) {
          if (this.logger.debug("Publishing Payload stalled"), this.needsTransportRestart = true, (o3 = r == null ? void 0 : r.internal) != null && o3.throwOnFailedPublish)
            throw this.removeRequestFromQueue(p6), u3;
          return;
        } finally {
          clearTimeout(M6);
        }
        this.logger.debug("Successfully Published Payload"), this.logger.trace({ type: "method", method: "publish", params: { topic: i3, message: s, opts: r } });
      } catch (a3) {
        throw this.logger.debug("Failed to Publish Payload"), this.logger.error(a3), a3;
      }
    }, this.on = (i3, s) => {
      this.events.on(i3, s);
    }, this.once = (i3, s) => {
      this.events.once(i3, s);
    }, this.off = (i3, s) => {
      this.events.off(i3, s);
    }, this.removeListener = (i3, s) => {
      this.events.removeListener(i3, s);
    }, this.relayer = e, this.logger = (0, import_logger.generateChildLogger)(t, this.name), this.registerEventListeners();
  }
  get context() {
    return (0, import_logger.getLoggerContext)(this.logger);
  }
  rpcPublish(e, t, i3, s, r, o3, a3) {
    var h5, l2, d5, p6;
    const y4 = { method: Et(s.protocol).publish, params: { topic: e, message: t, ttl: i3, prompt: r, tag: o3 }, id: a3 };
    return w((h5 = y4.params) == null ? void 0 : h5.prompt) && ((l2 = y4.params) == null || delete l2.prompt), w((d5 = y4.params) == null ? void 0 : d5.tag) && ((p6 = y4.params) == null || delete p6.tag), this.logger.debug("Outgoing Relay Payload"), this.logger.trace({ type: "message", direction: "outgoing", request: y4 }), this.relayer.request(y4);
  }
  removeRequestFromQueue(e) {
    this.queue.delete(e);
  }
  checkQueue() {
    this.queue.forEach(async (e) => {
      const { topic: t, message: i3, opts: s } = e;
      await this.publish(t, i3, s);
    });
  }
  registerEventListeners() {
    this.relayer.core.heartbeat.on(import_heartbeat.HEARTBEAT_EVENTS.pulse, () => {
      if (this.needsTransportRestart) {
        this.needsTransportRestart = false, this.relayer.events.emit(D2.connection_stalled);
        return;
      }
      this.checkQueue();
    }), this.relayer.on(D2.message_ack, (e) => {
      this.removeRequestFromQueue(e.id.toString());
    });
  }
};
var Ir = class {
  constructor() {
    this.map = /* @__PURE__ */ new Map(), this.set = (e, t) => {
      const i3 = this.get(e);
      this.exists(e, t) || this.map.set(e, [...i3, t]);
    }, this.get = (e) => this.map.get(e) || [], this.exists = (e, t) => this.get(e).includes(t), this.delete = (e, t) => {
      if (typeof t > "u") {
        this.map.delete(e);
        return;
      }
      if (!this.map.has(e))
        return;
      const i3 = this.get(e);
      if (!this.exists(e, t))
        return;
      const s = i3.filter((r) => r !== t);
      if (!s.length) {
        this.map.delete(e);
        return;
      }
      this.map.set(e, s);
    }, this.clear = () => {
      this.map.clear();
    };
  }
  get topics() {
    return Array.from(this.map.keys());
  }
};
var Cr = Object.defineProperty;
var Rr = Object.defineProperties;
var _r = Object.getOwnPropertyDescriptors;
var At = Object.getOwnPropertySymbols;
var Tr = Object.prototype.hasOwnProperty;
var Sr = Object.prototype.propertyIsEnumerable;
var zt = (n4, e, t) => e in n4 ? Cr(n4, e, { enumerable: true, configurable: true, writable: true, value: t }) : n4[e] = t;
var q = (n4, e) => {
  for (var t in e || (e = {}))
    Tr.call(e, t) && zt(n4, t, e[t]);
  if (At)
    for (var t of At(e))
      Sr.call(e, t) && zt(n4, t, e[t]);
  return n4;
};
var De2 = (n4, e) => Rr(n4, _r(e));
var Nt2 = class extends d {
  constructor(e, t) {
    super(e, t), this.relayer = e, this.logger = t, this.subscriptions = /* @__PURE__ */ new Map(), this.topicMap = new Ir(), this.events = new import_events3.EventEmitter(), this.name = mt2, this.version = bt2, this.pending = /* @__PURE__ */ new Map(), this.cached = [], this.initialized = false, this.pendingSubscriptionWatchLabel = "pending_sub_watch_label", this.pollingInterval = 20, this.storagePrefix = O, this.subscribeTimeout = 1e4, this.restartInProgress = false, this.batchSubscribeTopicsLimit = 500, this.init = async () => {
      this.initialized || (this.logger.trace("Initialized"), this.registerEventListeners(), this.clientId = await this.relayer.core.crypto.getClientId());
    }, this.subscribe = async (i3, s) => {
      await this.restartToComplete(), this.isInitialized(), this.logger.debug("Subscribing Topic"), this.logger.trace({ type: "method", method: "subscribe", params: { topic: i3, opts: s } });
      try {
        const r = vt(s), o3 = { topic: i3, relay: r };
        this.pending.set(i3, o3);
        const a3 = await this.rpcSubscribe(i3, r);
        return this.onSubscribe(a3, o3), this.logger.debug("Successfully Subscribed Topic"), this.logger.trace({ type: "method", method: "subscribe", params: { topic: i3, opts: s } }), a3;
      } catch (r) {
        throw this.logger.debug("Failed to Subscribe Topic"), this.logger.error(r), r;
      }
    }, this.unsubscribe = async (i3, s) => {
      await this.restartToComplete(), this.isInitialized(), typeof (s == null ? void 0 : s.id) < "u" ? await this.unsubscribeById(i3, s.id, s) : await this.unsubscribeByTopic(i3, s);
    }, this.isSubscribed = async (i3) => {
      if (this.topics.includes(i3))
        return true;
      const s = `${this.pendingSubscriptionWatchLabel}_${i3}`;
      return await new Promise((r, o3) => {
        const a3 = new import_time2.Watch();
        a3.start(s);
        const h5 = setInterval(() => {
          !this.pending.has(i3) && this.topics.includes(i3) && (clearInterval(h5), a3.stop(s), r(true)), a3.elapsed(s) >= ft2 && (clearInterval(h5), a3.stop(s), o3(new Error("Subscription resolution timeout")));
        }, this.pollingInterval);
      }).catch(() => false);
    }, this.on = (i3, s) => {
      this.events.on(i3, s);
    }, this.once = (i3, s) => {
      this.events.once(i3, s);
    }, this.off = (i3, s) => {
      this.events.off(i3, s);
    }, this.removeListener = (i3, s) => {
      this.events.removeListener(i3, s);
    }, this.restart = async () => {
      this.restartInProgress = true, await this.restore(), await this.reset(), this.restartInProgress = false;
    }, this.relayer = e, this.logger = (0, import_logger.generateChildLogger)(t, this.name), this.clientId = "";
  }
  get context() {
    return (0, import_logger.getLoggerContext)(this.logger);
  }
  get storageKey() {
    return this.storagePrefix + this.version + this.relayer.core.customStoragePrefix + "//" + this.name;
  }
  get length() {
    return this.subscriptions.size;
  }
  get ids() {
    return Array.from(this.subscriptions.keys());
  }
  get values() {
    return Array.from(this.subscriptions.values());
  }
  get topics() {
    return this.topicMap.topics;
  }
  hasSubscription(e, t) {
    let i3 = false;
    try {
      i3 = this.getSubscription(e).topic === t;
    } catch {
    }
    return i3;
  }
  onEnable() {
    this.cached = [], this.initialized = true;
  }
  onDisable() {
    this.cached = this.values, this.subscriptions.clear(), this.topicMap.clear();
  }
  async unsubscribeByTopic(e, t) {
    const i3 = this.topicMap.get(e);
    await Promise.all(i3.map(async (s) => await this.unsubscribeById(e, s, t)));
  }
  async unsubscribeById(e, t, i3) {
    this.logger.debug("Unsubscribing Topic"), this.logger.trace({ type: "method", method: "unsubscribe", params: { topic: e, id: t, opts: i3 } });
    try {
      const s = vt(i3);
      await this.rpcUnsubscribe(e, t, s);
      const r = U("USER_DISCONNECTED", `${this.name}, ${e}`);
      await this.onUnsubscribe(e, t, r), this.logger.debug("Successfully Unsubscribed Topic"), this.logger.trace({ type: "method", method: "unsubscribe", params: { topic: e, id: t, opts: i3 } });
    } catch (s) {
      throw this.logger.debug("Failed to Unsubscribe Topic"), this.logger.error(s), s;
    }
  }
  async rpcSubscribe(e, t) {
    const i3 = { method: Et(t.protocol).subscribe, params: { topic: e } };
    this.logger.debug("Outgoing Relay Payload"), this.logger.trace({ type: "payload", direction: "outgoing", request: i3 });
    try {
      await await ut(this.relayer.request(i3), this.subscribeTimeout);
    } catch {
      this.logger.debug("Outgoing Relay Subscribe Payload stalled"), this.relayer.events.emit(D2.connection_stalled);
    }
    return Ln(e + this.clientId);
  }
  async rpcBatchSubscribe(e) {
    if (!e.length)
      return;
    const t = e[0].relay, i3 = { method: Et(t.protocol).batchSubscribe, params: { topics: e.map((s) => s.topic) } };
    this.logger.debug("Outgoing Relay Payload"), this.logger.trace({ type: "payload", direction: "outgoing", request: i3 });
    try {
      return await await ut(this.relayer.request(i3), this.subscribeTimeout);
    } catch {
      this.logger.debug("Outgoing Relay Payload stalled"), this.relayer.events.emit(D2.connection_stalled);
    }
  }
  rpcUnsubscribe(e, t, i3) {
    const s = { method: Et(i3.protocol).unsubscribe, params: { topic: e, id: t } };
    return this.logger.debug("Outgoing Relay Payload"), this.logger.trace({ type: "payload", direction: "outgoing", request: s }), this.relayer.request(s);
  }
  onSubscribe(e, t) {
    this.setSubscription(e, De2(q({}, t), { id: e })), this.pending.delete(t.topic);
  }
  onBatchSubscribe(e) {
    e.length && e.forEach((t) => {
      this.setSubscription(t.id, q({}, t)), this.pending.delete(t.topic);
    });
  }
  async onUnsubscribe(e, t, i3) {
    this.events.removeAllListeners(t), this.hasSubscription(t, e) && this.deleteSubscription(t, i3), await this.relayer.messages.del(e);
  }
  async setRelayerSubscriptions(e) {
    await this.relayer.core.storage.setItem(this.storageKey, e);
  }
  async getRelayerSubscriptions() {
    return await this.relayer.core.storage.getItem(this.storageKey);
  }
  setSubscription(e, t) {
    this.subscriptions.has(e) || (this.logger.debug("Setting subscription"), this.logger.trace({ type: "method", method: "setSubscription", id: e, subscription: t }), this.addSubscription(e, t));
  }
  addSubscription(e, t) {
    this.subscriptions.set(e, q({}, t)), this.topicMap.set(t.topic, e), this.events.emit(w2.created, t);
  }
  getSubscription(e) {
    this.logger.debug("Getting subscription"), this.logger.trace({ type: "method", method: "getSubscription", id: e });
    const t = this.subscriptions.get(e);
    if (!t) {
      const { message: i3 } = N("NO_MATCHING_KEY", `${this.name}: ${e}`);
      throw new Error(i3);
    }
    return t;
  }
  deleteSubscription(e, t) {
    this.logger.debug("Deleting subscription"), this.logger.trace({ type: "method", method: "deleteSubscription", id: e, reason: t });
    const i3 = this.getSubscription(e);
    this.subscriptions.delete(e), this.topicMap.delete(i3.topic, e), this.events.emit(w2.deleted, De2(q({}, i3), { reason: t }));
  }
  async persist() {
    await this.setRelayerSubscriptions(this.values), this.events.emit(w2.sync);
  }
  async reset() {
    if (this.cached.length) {
      const e = Math.ceil(this.cached.length / this.batchSubscribeTopicsLimit);
      for (let t = 0; t < e; t++) {
        const i3 = this.cached.splice(0, this.batchSubscribeTopicsLimit);
        await this.batchSubscribe(i3);
      }
    }
    this.events.emit(w2.resubscribed);
  }
  async restore() {
    try {
      const e = await this.getRelayerSubscriptions();
      if (typeof e > "u" || !e.length)
        return;
      if (this.subscriptions.size) {
        const { message: t } = N("RESTORE_WILL_OVERRIDE", this.name);
        throw this.logger.error(t), this.logger.error(`${this.name}: ${JSON.stringify(this.values)}`), new Error(t);
      }
      this.cached = e, this.logger.debug(`Successfully Restored subscriptions for ${this.name}`), this.logger.trace({ type: "method", method: "restore", subscriptions: this.values });
    } catch (e) {
      this.logger.debug(`Failed to Restore subscriptions for ${this.name}`), this.logger.error(e);
    }
  }
  async batchSubscribe(e) {
    if (!e.length)
      return;
    const t = await this.rpcBatchSubscribe(e);
    k(t) && this.onBatchSubscribe(t.map((i3, s) => De2(q({}, e[s]), { id: i3 })));
  }
  async onConnect() {
    this.restartInProgress || (await this.restart(), this.onEnable());
  }
  onDisconnect() {
    this.onDisable();
  }
  async checkPending() {
    if (!this.initialized || this.relayer.transportExplicitlyClosed)
      return;
    const e = [];
    this.pending.forEach((t) => {
      e.push(t);
    }), await this.batchSubscribe(e);
  }
  registerEventListeners() {
    this.relayer.core.heartbeat.on(import_heartbeat.HEARTBEAT_EVENTS.pulse, async () => {
      await this.checkPending();
    }), this.relayer.on(D2.connect, async () => {
      await this.onConnect();
    }), this.relayer.on(D2.disconnect, () => {
      this.onDisconnect();
    }), this.events.on(w2.created, async (e) => {
      const t = w2.created;
      this.logger.info(`Emitting ${t}`), this.logger.debug({ type: "event", event: t, data: e }), await this.persist();
    }), this.events.on(w2.deleted, async (e) => {
      const t = w2.deleted;
      this.logger.info(`Emitting ${t}`), this.logger.debug({ type: "event", event: t, data: e }), await this.persist();
    });
  }
  isInitialized() {
    if (!this.initialized) {
      const { message: e } = N("NOT_INITIALIZED", this.name);
      throw new Error(e);
    }
  }
  async restartToComplete() {
    this.restartInProgress && await new Promise((e) => {
      const t = setInterval(() => {
        this.restartInProgress || (clearInterval(t), e());
      }, this.pollingInterval);
    });
  }
};
var Pr = Object.defineProperty;
var Ut = Object.getOwnPropertySymbols;
var xr = Object.prototype.hasOwnProperty;
var Or = Object.prototype.propertyIsEnumerable;
var Lt2 = (n4, e, t) => e in n4 ? Pr(n4, e, { enumerable: true, configurable: true, writable: true, value: t }) : n4[e] = t;
var Ar = (n4, e) => {
  for (var t in e || (e = {}))
    xr.call(e, t) && Lt2(n4, t, e[t]);
  if (Ut)
    for (var t of Ut(e))
      Or.call(e, t) && Lt2(n4, t, e[t]);
  return n4;
};
var $t = class extends g {
  constructor(e) {
    super(e), this.protocol = "wc", this.version = 2, this.events = new import_events3.EventEmitter(), this.name = ut2, this.transportExplicitlyClosed = false, this.initialized = false, this.connectionAttemptInProgress = false, this.connectionStatusPollingInterval = 20, this.staleConnectionErrors = ["socket hang up", "socket stalled"], this.hasExperiencedNetworkDisruption = false, this.requestsInFlight = /* @__PURE__ */ new Map(), this.request = async (t) => {
      this.logger.debug("Publishing Request Payload");
      const i3 = t.id;
      try {
        await this.toEstablishConnection();
        const s = this.provider.request(t);
        return this.requestsInFlight.set(i3, { promise: s, request: t }), await s;
      } catch (s) {
        throw this.logger.debug("Failed to Publish Request"), this.logger.error(s), s;
      } finally {
        this.requestsInFlight.delete(i3);
      }
    }, this.onPayloadHandler = (t) => {
      this.onProviderPayload(t);
    }, this.onConnectHandler = () => {
      this.events.emit(D2.connect);
    }, this.onDisconnectHandler = () => {
      this.onProviderDisconnect();
    }, this.onProviderErrorHandler = (t) => {
      this.logger.error(t), this.events.emit(D2.error, t), this.logger.info("Fatal socket error received, closing transport"), this.transportClose();
    }, this.registerProviderListeners = () => {
      this.provider.on(P.payload, this.onPayloadHandler), this.provider.on(P.connect, this.onConnectHandler), this.provider.on(P.disconnect, this.onDisconnectHandler), this.provider.on(P.error, this.onProviderErrorHandler);
    }, this.core = e.core, this.logger = typeof e.logger < "u" && typeof e.logger != "string" ? (0, import_logger.generateChildLogger)(e.logger, this.name) : (0, import_logger.pino)((0, import_logger.getDefaultLoggerOptions)({ level: e.logger || ct })), this.messages = new Ot2(this.logger, e.core), this.subscriber = new Nt2(this, this.logger), this.publisher = new vr(this, this.logger), this.relayUrl = (e == null ? void 0 : e.relayUrl) || ge2, this.projectId = e.projectId, this.bundleId = Jn(), this.provider = {};
  }
  async init() {
    this.logger.trace("Initialized"), this.registerEventListeners(), await this.createProvider(), await Promise.all([this.messages.init(), this.subscriber.init()]);
    try {
      await this.transportOpen();
    } catch {
      this.logger.warn(`Connection via ${this.relayUrl} failed, attempting to connect via failover domain ${pe}...`), await this.restartTransport(pe);
    }
    this.initialized = true, setTimeout(async () => {
      this.subscriber.topics.length === 0 && (this.logger.info("No topics subscribed to after init, closing transport"), await this.transportClose(), this.transportExplicitlyClosed = false);
    }, pt2);
  }
  get context() {
    return (0, import_logger.getLoggerContext)(this.logger);
  }
  get connected() {
    return this.provider.connection.connected;
  }
  get connecting() {
    return this.provider.connection.connecting;
  }
  async publish(e, t, i3) {
    this.isInitialized(), await this.publisher.publish(e, t, i3), await this.recordMessageEvent({ topic: e, message: t, publishedAt: Date.now() });
  }
  async subscribe(e, t) {
    var i3;
    this.isInitialized();
    let s = ((i3 = this.subscriber.topicMap.get(e)) == null ? void 0 : i3[0]) || "";
    if (s)
      return s;
    let r;
    const o3 = (a3) => {
      a3.topic === e && (this.subscriber.off(w2.created, o3), r());
    };
    return await Promise.all([new Promise((a3) => {
      r = a3, this.subscriber.on(w2.created, o3);
    }), new Promise(async (a3) => {
      s = await this.subscriber.subscribe(e, t), a3();
    })]), s;
  }
  async unsubscribe(e, t) {
    this.isInitialized(), await this.subscriber.unsubscribe(e, t);
  }
  on(e, t) {
    this.events.on(e, t);
  }
  once(e, t) {
    this.events.once(e, t);
  }
  off(e, t) {
    this.events.off(e, t);
  }
  removeListener(e, t) {
    this.events.removeListener(e, t);
  }
  async transportClose() {
    this.requestsInFlight.size > 0 && (this.logger.debug("Waiting for all in-flight requests to finish before closing transport..."), this.requestsInFlight.forEach(async (e) => {
      await e.promise;
    })), this.transportExplicitlyClosed = true, this.hasExperiencedNetworkDisruption && this.connected ? await ut(this.provider.disconnect(), 1e3, "provider.disconnect()").catch(() => this.onProviderDisconnect()) : this.connected && await this.provider.disconnect();
  }
  async transportOpen(e) {
    if (this.transportExplicitlyClosed = false, await this.confirmOnlineStateOrThrow(), !this.connectionAttemptInProgress) {
      e && e !== this.relayUrl && (this.relayUrl = e, await this.transportClose(), await this.createProvider()), this.connectionAttemptInProgress = true;
      try {
        await Promise.all([new Promise((t) => {
          if (!this.initialized)
            return t();
          this.subscriber.once(w2.resubscribed, () => {
            t();
          });
        }), new Promise(async (t, i3) => {
          try {
            await ut(this.provider.connect(), 1e4, `Socket stalled when trying to connect to ${this.relayUrl}`);
          } catch (s) {
            i3(s);
            return;
          }
          t();
        })]);
      } catch (t) {
        this.logger.error(t);
        const i3 = t;
        if (!this.isConnectionStalled(i3.message))
          throw t;
        this.provider.events.emit(P.disconnect);
      } finally {
        this.connectionAttemptInProgress = false, this.hasExperiencedNetworkDisruption = false;
      }
    }
  }
  async restartTransport(e) {
    await this.confirmOnlineStateOrThrow(), !this.connectionAttemptInProgress && (this.relayUrl = e || this.relayUrl, await this.transportClose(), await this.createProvider(), await this.transportOpen());
  }
  async confirmOnlineStateOrThrow() {
    if (!await rr())
      throw new Error("No internet connection detected. Please restart your network and try again.");
  }
  isConnectionStalled(e) {
    return this.staleConnectionErrors.some((t) => e.includes(t));
  }
  async createProvider() {
    this.provider.connection && this.unregisterProviderListeners();
    const e = await this.core.crypto.signJWT(this.relayUrl);
    this.provider = new JsonRpcProvider(new f(Xn({ sdkVersion: gt, protocol: this.protocol, version: this.version, relayUrl: this.relayUrl, projectId: this.projectId, auth: e, useOnCloseEvent: true, bundleId: this.bundleId }))), this.registerProviderListeners();
  }
  async recordMessageEvent(e) {
    const { topic: t, message: i3 } = e;
    await this.messages.set(t, i3);
  }
  async shouldIgnoreMessageEvent(e) {
    const { topic: t, message: i3 } = e;
    if (!i3 || i3.length === 0)
      return this.logger.debug(`Ignoring invalid/empty message: ${i3}`), true;
    if (!await this.subscriber.isSubscribed(t))
      return this.logger.debug(`Ignoring message for non-subscribed topic ${t}`), true;
    const s = this.messages.has(t, i3);
    return s && this.logger.debug(`Ignoring duplicate message: ${i3}`), s;
  }
  async onProviderPayload(e) {
    if (this.logger.debug("Incoming Relay Payload"), this.logger.trace({ type: "payload", direction: "incoming", payload: e }), isJsonRpcRequest(e)) {
      if (!e.method.endsWith(lt2))
        return;
      const t = e.params, { topic: i3, message: s, publishedAt: r } = t.data, o3 = { topic: i3, message: s, publishedAt: r };
      this.logger.debug("Emitting Relayer Payload"), this.logger.trace(Ar({ type: "event", event: t.id }, o3)), this.events.emit(t.id, o3), await this.acknowledgePayload(e), await this.onMessageEvent(o3);
    } else
      isJsonRpcResponse(e) && this.events.emit(D2.message_ack, e);
  }
  async onMessageEvent(e) {
    await this.shouldIgnoreMessageEvent(e) || (this.events.emit(D2.message, e), await this.recordMessageEvent(e));
  }
  async acknowledgePayload(e) {
    const t = formatJsonRpcResult(e.id, true);
    await this.provider.connection.send(t);
  }
  unregisterProviderListeners() {
    this.provider.off(P.payload, this.onPayloadHandler), this.provider.off(P.connect, this.onConnectHandler), this.provider.off(P.disconnect, this.onDisconnectHandler), this.provider.off(P.error, this.onProviderErrorHandler);
  }
  async registerEventListeners() {
    this.events.on(D2.connection_stalled, () => {
      this.restartTransport().catch((t) => this.logger.error(t));
    });
    let e = await rr();
    or(async (t) => {
      this.initialized && e !== t && (e = t, t ? await this.restartTransport().catch((i3) => this.logger.error(i3)) : (this.hasExperiencedNetworkDisruption = true, await this.transportClose().catch((i3) => this.logger.error(i3))));
    });
  }
  onProviderDisconnect() {
    this.events.emit(D2.disconnect), this.attemptToReconnect();
  }
  attemptToReconnect() {
    this.transportExplicitlyClosed || (this.logger.info("attemptToReconnect called. Connecting..."), setTimeout(async () => {
      await this.restartTransport().catch((e) => this.logger.error(e));
    }, (0, import_time2.toMiliseconds)(dt2)));
  }
  isInitialized() {
    if (!this.initialized) {
      const { message: e } = N("NOT_INITIALIZED", this.name);
      throw new Error(e);
    }
  }
  async toEstablishConnection() {
    if (await this.confirmOnlineStateOrThrow(), !this.connected) {
      if (this.connectionAttemptInProgress)
        return await new Promise((e) => {
          const t = setInterval(() => {
            this.connected && (clearInterval(t), e());
          }, this.connectionStatusPollingInterval);
        });
      await this.restartTransport();
    }
  }
};
var zr = Object.defineProperty;
var Ft = Object.getOwnPropertySymbols;
var Nr = Object.prototype.hasOwnProperty;
var Ur = Object.prototype.propertyIsEnumerable;
var Mt = (n4, e, t) => e in n4 ? zr(n4, e, { enumerable: true, configurable: true, writable: true, value: t }) : n4[e] = t;
var kt = (n4, e) => {
  for (var t in e || (e = {}))
    Nr.call(e, t) && Mt(n4, t, e[t]);
  if (Ft)
    for (var t of Ft(e))
      Ur.call(e, t) && Mt(n4, t, e[t]);
  return n4;
};
var Kt2 = class extends p {
  constructor(e, t, i3, s = O, r = void 0) {
    super(e, t, i3, s), this.core = e, this.logger = t, this.name = i3, this.map = /* @__PURE__ */ new Map(), this.version = Dt, this.cached = [], this.initialized = false, this.storagePrefix = O, this.init = async () => {
      this.initialized || (this.logger.trace("Initialized"), await this.restore(), this.cached.forEach((o3) => {
        this.getKey && o3 !== null && !w(o3) ? this.map.set(this.getKey(o3), o3) : Lt(o3) ? this.map.set(o3.id, o3) : xt(o3) && this.map.set(o3.topic, o3);
      }), this.cached = [], this.initialized = true);
    }, this.set = async (o3, a3) => {
      this.isInitialized(), this.map.has(o3) ? await this.update(o3, a3) : (this.logger.debug("Setting value"), this.logger.trace({ type: "method", method: "set", key: o3, value: a3 }), this.map.set(o3, a3), await this.persist());
    }, this.get = (o3) => (this.isInitialized(), this.logger.debug("Getting value"), this.logger.trace({ type: "method", method: "get", key: o3 }), this.getData(o3)), this.getAll = (o3) => (this.isInitialized(), o3 ? this.values.filter((a3) => Object.keys(o3).every((h5) => (0, import_lodash.default)(a3[h5], o3[h5]))) : this.values), this.update = async (o3, a3) => {
      this.isInitialized(), this.logger.debug("Updating value"), this.logger.trace({ type: "method", method: "update", key: o3, update: a3 });
      const h5 = kt(kt({}, this.getData(o3)), a3);
      this.map.set(o3, h5), await this.persist();
    }, this.delete = async (o3, a3) => {
      this.isInitialized(), this.map.has(o3) && (this.logger.debug("Deleting value"), this.logger.trace({ type: "method", method: "delete", key: o3, reason: a3 }), this.map.delete(o3), await this.persist());
    }, this.logger = (0, import_logger.generateChildLogger)(t, this.name), this.storagePrefix = s, this.getKey = r;
  }
  get context() {
    return (0, import_logger.getLoggerContext)(this.logger);
  }
  get storageKey() {
    return this.storagePrefix + this.version + this.core.customStoragePrefix + "//" + this.name;
  }
  get length() {
    return this.map.size;
  }
  get keys() {
    return Array.from(this.map.keys());
  }
  get values() {
    return Array.from(this.map.values());
  }
  async setDataStore(e) {
    await this.core.storage.setItem(this.storageKey, e);
  }
  async getDataStore() {
    return await this.core.storage.getItem(this.storageKey);
  }
  getData(e) {
    const t = this.map.get(e);
    if (!t) {
      const { message: i3 } = N("NO_MATCHING_KEY", `${this.name}: ${e}`);
      throw this.logger.error(i3), new Error(i3);
    }
    return t;
  }
  async persist() {
    await this.setDataStore(this.values);
  }
  async restore() {
    try {
      const e = await this.getDataStore();
      if (typeof e > "u" || !e.length)
        return;
      if (this.map.size) {
        const { message: t } = N("RESTORE_WILL_OVERRIDE", this.name);
        throw this.logger.error(t), new Error(t);
      }
      this.cached = e, this.logger.debug(`Successfully Restored value for ${this.name}`), this.logger.trace({ type: "method", method: "restore", value: this.values });
    } catch (e) {
      this.logger.debug(`Failed to Restore value for ${this.name}`), this.logger.error(e);
    }
  }
  isInitialized() {
    if (!this.initialized) {
      const { message: e } = N("NOT_INITIALIZED", this.name);
      throw new Error(e);
    }
  }
};
var Bt = class {
  constructor(e, t) {
    this.core = e, this.logger = t, this.name = Et2, this.version = wt2, this.events = new import_events3.default(), this.initialized = false, this.storagePrefix = O, this.ignoredPayloadTypes = [_], this.registeredMethods = [], this.init = async () => {
      this.initialized || (await this.pairings.init(), await this.cleanup(), this.registerRelayerEvents(), this.registerExpirerEvents(), this.initialized = true, this.logger.trace("Initialized"));
    }, this.register = ({ methods: i3 }) => {
      this.isInitialized(), this.registeredMethods = [.../* @__PURE__ */ new Set([...this.registeredMethods, ...i3])];
    }, this.create = async () => {
      this.isInitialized();
      const i3 = Vn(), s = await this.core.crypto.setSymKey(i3), r = pt(import_time2.FIVE_MINUTES), o3 = { protocol: ht }, a3 = { topic: s, expiry: r, relay: o3, active: false }, h5 = Rt({ protocol: this.core.protocol, version: this.core.version, topic: s, symKey: i3, relay: o3, expiryTimestamp: r });
      return await this.pairings.set(s, a3), await this.core.relayer.subscribe(s), this.core.expirer.set(s, r), { topic: s, uri: h5 };
    }, this.pair = async (i3) => {
      this.isInitialized(), this.isValidPair(i3);
      const { topic: s, symKey: r, relay: o3, expiryTimestamp: a3 } = Pt(i3.uri);
      let h5;
      if (this.pairings.keys.includes(s) && (h5 = this.pairings.get(s), h5.active))
        throw new Error(`Pairing already exists: ${s}. Please try again with a new connection URI.`);
      const l2 = a3 || pt(import_time2.FIVE_MINUTES), d5 = { topic: s, relay: o3, expiry: l2, active: false };
      return await this.pairings.set(s, d5), this.core.expirer.set(s, l2), i3.activatePairing && await this.activate({ topic: s }), this.events.emit(V.create, d5), this.core.crypto.keychain.has(s) || (await this.core.crypto.setSymKey(r, s), await this.core.relayer.subscribe(s, { relay: o3 })), d5;
    }, this.activate = async ({ topic: i3 }) => {
      this.isInitialized();
      const s = pt(import_time2.THIRTY_DAYS);
      await this.pairings.update(i3, { active: true, expiry: s }), this.core.expirer.set(i3, s);
    }, this.ping = async (i3) => {
      this.isInitialized(), await this.isValidPing(i3);
      const { topic: s } = i3;
      if (this.pairings.keys.includes(s)) {
        const r = await this.sendRequest(s, "wc_pairingPing", {}), { done: o3, resolve: a3, reject: h5 } = at();
        this.events.once(yt("pairing_ping", r), ({ error: l2 }) => {
          l2 ? h5(l2) : a3();
        }), await o3();
      }
    }, this.updateExpiry = async ({ topic: i3, expiry: s }) => {
      this.isInitialized(), await this.pairings.update(i3, { expiry: s });
    }, this.updateMetadata = async ({ topic: i3, metadata: s }) => {
      this.isInitialized(), await this.pairings.update(i3, { peerMetadata: s });
    }, this.getPairings = () => (this.isInitialized(), this.pairings.values), this.disconnect = async (i3) => {
      this.isInitialized(), await this.isValidDisconnect(i3);
      const { topic: s } = i3;
      this.pairings.keys.includes(s) && (await this.sendRequest(s, "wc_pairingDelete", U("USER_DISCONNECTED")), await this.deletePairing(s));
    }, this.sendRequest = async (i3, s, r) => {
      const o3 = formatJsonRpcRequest(s, r), a3 = await this.core.crypto.encode(i3, o3), h5 = $2[s].req;
      return this.core.history.set(i3, o3), this.core.relayer.publish(i3, a3, h5), o3.id;
    }, this.sendResult = async (i3, s, r) => {
      const o3 = formatJsonRpcResult(i3, r), a3 = await this.core.crypto.encode(s, o3), h5 = await this.core.history.get(s, i3), l2 = $2[h5.request.method].res;
      await this.core.relayer.publish(s, a3, l2), await this.core.history.resolve(o3);
    }, this.sendError = async (i3, s, r) => {
      const o3 = formatJsonRpcError(i3, r), a3 = await this.core.crypto.encode(s, o3), h5 = await this.core.history.get(s, i3), l2 = $2[h5.request.method] ? $2[h5.request.method].res : $2.unregistered_method.res;
      await this.core.relayer.publish(s, a3, l2), await this.core.history.resolve(o3);
    }, this.deletePairing = async (i3, s) => {
      await this.core.relayer.unsubscribe(i3), await Promise.all([this.pairings.delete(i3, U("USER_DISCONNECTED")), this.core.crypto.deleteSymKey(i3), s ? Promise.resolve() : this.core.expirer.del(i3)]);
    }, this.cleanup = async () => {
      const i3 = this.pairings.getAll().filter((s) => mt(s.expiry));
      await Promise.all(i3.map((s) => this.deletePairing(s.topic)));
    }, this.onRelayEventRequest = (i3) => {
      const { topic: s, payload: r } = i3;
      switch (r.method) {
        case "wc_pairingPing":
          return this.onPairingPingRequest(s, r);
        case "wc_pairingDelete":
          return this.onPairingDeleteRequest(s, r);
        default:
          return this.onUnknownRpcMethodRequest(s, r);
      }
    }, this.onRelayEventResponse = async (i3) => {
      const { topic: s, payload: r } = i3, o3 = (await this.core.history.get(s, r.id)).request.method;
      switch (o3) {
        case "wc_pairingPing":
          return this.onPairingPingResponse(s, r);
        default:
          return this.onUnknownRpcMethodResponse(o3);
      }
    }, this.onPairingPingRequest = async (i3, s) => {
      const { id: r } = s;
      try {
        this.isValidPing({ topic: i3 }), await this.sendResult(r, i3, true), this.events.emit(V.ping, { id: r, topic: i3 });
      } catch (o3) {
        await this.sendError(r, i3, o3), this.logger.error(o3);
      }
    }, this.onPairingPingResponse = (i3, s) => {
      const { id: r } = s;
      setTimeout(() => {
        isJsonRpcResult(s) ? this.events.emit(yt("pairing_ping", r), {}) : isJsonRpcError(s) && this.events.emit(yt("pairing_ping", r), { error: s.error });
      }, 500);
    }, this.onPairingDeleteRequest = async (i3, s) => {
      const { id: r } = s;
      try {
        this.isValidDisconnect({ topic: i3 }), await this.deletePairing(i3), this.events.emit(V.delete, { id: r, topic: i3 });
      } catch (o3) {
        await this.sendError(r, i3, o3), this.logger.error(o3);
      }
    }, this.onUnknownRpcMethodRequest = async (i3, s) => {
      const { id: r, method: o3 } = s;
      try {
        if (this.registeredMethods.includes(o3))
          return;
        const a3 = U("WC_METHOD_UNSUPPORTED", o3);
        await this.sendError(r, i3, a3), this.logger.error(a3);
      } catch (a3) {
        await this.sendError(r, i3, a3), this.logger.error(a3);
      }
    }, this.onUnknownRpcMethodResponse = (i3) => {
      this.registeredMethods.includes(i3) || this.logger.error(U("WC_METHOD_UNSUPPORTED", i3));
    }, this.isValidPair = (i3) => {
      var s;
      if (!Gt(i3)) {
        const { message: o3 } = N("MISSING_OR_INVALID", `pair() params: ${i3}`);
        throw new Error(o3);
      }
      if (!Kt(i3.uri)) {
        const { message: o3 } = N("MISSING_OR_INVALID", `pair() uri: ${i3.uri}`);
        throw new Error(o3);
      }
      const r = Pt(i3.uri);
      if (!((s = r == null ? void 0 : r.relay) != null && s.protocol)) {
        const { message: o3 } = N("MISSING_OR_INVALID", "pair() uri#relay-protocol");
        throw new Error(o3);
      }
      if (!(r != null && r.symKey)) {
        const { message: o3 } = N("MISSING_OR_INVALID", "pair() uri#symKey");
        throw new Error(o3);
      }
      if (r != null && r.expiryTimestamp && (0, import_time2.toMiliseconds)(r == null ? void 0 : r.expiryTimestamp) < Date.now()) {
        const { message: o3 } = N("EXPIRED", "pair() URI has expired. Please try again with a new connection URI.");
        throw new Error(o3);
      }
    }, this.isValidPing = async (i3) => {
      if (!Gt(i3)) {
        const { message: r } = N("MISSING_OR_INVALID", `ping() params: ${i3}`);
        throw new Error(r);
      }
      const { topic: s } = i3;
      await this.isValidPairingTopic(s);
    }, this.isValidDisconnect = async (i3) => {
      if (!Gt(i3)) {
        const { message: r } = N("MISSING_OR_INVALID", `disconnect() params: ${i3}`);
        throw new Error(r);
      }
      const { topic: s } = i3;
      await this.isValidPairingTopic(s);
    }, this.isValidPairingTopic = async (i3) => {
      if (!g2(i3, false)) {
        const { message: s } = N("MISSING_OR_INVALID", `pairing topic should be a string: ${i3}`);
        throw new Error(s);
      }
      if (!this.pairings.keys.includes(i3)) {
        const { message: s } = N("NO_MATCHING_KEY", `pairing topic doesn't exist: ${i3}`);
        throw new Error(s);
      }
      if (mt(this.pairings.get(i3).expiry)) {
        await this.deletePairing(i3);
        const { message: s } = N("EXPIRED", `pairing topic: ${i3}`);
        throw new Error(s);
      }
    }, this.core = e, this.logger = (0, import_logger.generateChildLogger)(t, this.name), this.pairings = new Kt2(this.core, this.logger, this.name, this.storagePrefix);
  }
  get context() {
    return (0, import_logger.getLoggerContext)(this.logger);
  }
  isInitialized() {
    if (!this.initialized) {
      const { message: e } = N("NOT_INITIALIZED", this.name);
      throw new Error(e);
    }
  }
  registerRelayerEvents() {
    this.core.relayer.on(D2.message, async (e) => {
      const { topic: t, message: i3 } = e;
      if (!this.pairings.keys.includes(t) || this.ignoredPayloadTypes.includes(this.core.crypto.getPayloadType(i3)))
        return;
      const s = await this.core.crypto.decode(t, i3);
      try {
        isJsonRpcRequest(s) ? (this.core.history.set(t, s), this.onRelayEventRequest({ topic: t, payload: s })) : isJsonRpcResponse(s) && (await this.core.history.resolve(s), await this.onRelayEventResponse({ topic: t, payload: s }), this.core.history.delete(t, s.id));
      } catch (r) {
        this.logger.error(r);
      }
    });
  }
  registerExpirerEvents() {
    this.core.expirer.on(v2.expired, async (e) => {
      const { topic: t } = ft(e.target);
      t && this.pairings.keys.includes(t) && (await this.deletePairing(t, true), this.events.emit(V.expire, { topic: t }));
    });
  }
};
var Vt = class extends h2 {
  constructor(e, t) {
    super(e, t), this.core = e, this.logger = t, this.records = /* @__PURE__ */ new Map(), this.events = new import_events3.EventEmitter(), this.name = vt2, this.version = It2, this.cached = [], this.initialized = false, this.storagePrefix = O, this.init = async () => {
      this.initialized || (this.logger.trace("Initialized"), await this.restore(), this.cached.forEach((i3) => this.records.set(i3.id, i3)), this.cached = [], this.registerEventListeners(), this.initialized = true);
    }, this.set = (i3, s, r) => {
      if (this.isInitialized(), this.logger.debug("Setting JSON-RPC request history record"), this.logger.trace({ type: "method", method: "set", topic: i3, request: s, chainId: r }), this.records.has(s.id))
        return;
      const o3 = { id: s.id, topic: i3, request: { method: s.method, params: s.params || null }, chainId: r, expiry: pt(import_time2.THIRTY_DAYS) };
      this.records.set(o3.id, o3), this.events.emit(R2.created, o3);
    }, this.resolve = async (i3) => {
      if (this.isInitialized(), this.logger.debug("Updating JSON-RPC response history record"), this.logger.trace({ type: "method", method: "update", response: i3 }), !this.records.has(i3.id))
        return;
      const s = await this.getRecord(i3.id);
      typeof s.response > "u" && (s.response = isJsonRpcError(i3) ? { error: i3.error } : { result: i3.result }, this.records.set(s.id, s), this.events.emit(R2.updated, s));
    }, this.get = async (i3, s) => (this.isInitialized(), this.logger.debug("Getting record"), this.logger.trace({ type: "method", method: "get", topic: i3, id: s }), await this.getRecord(s)), this.delete = (i3, s) => {
      this.isInitialized(), this.logger.debug("Deleting record"), this.logger.trace({ type: "method", method: "delete", id: s }), this.values.forEach((r) => {
        if (r.topic === i3) {
          if (typeof s < "u" && r.id !== s)
            return;
          this.records.delete(r.id), this.events.emit(R2.deleted, r);
        }
      });
    }, this.exists = async (i3, s) => (this.isInitialized(), this.records.has(s) ? (await this.getRecord(s)).topic === i3 : false), this.on = (i3, s) => {
      this.events.on(i3, s);
    }, this.once = (i3, s) => {
      this.events.once(i3, s);
    }, this.off = (i3, s) => {
      this.events.off(i3, s);
    }, this.removeListener = (i3, s) => {
      this.events.removeListener(i3, s);
    }, this.logger = (0, import_logger.generateChildLogger)(t, this.name);
  }
  get context() {
    return (0, import_logger.getLoggerContext)(this.logger);
  }
  get storageKey() {
    return this.storagePrefix + this.version + this.core.customStoragePrefix + "//" + this.name;
  }
  get size() {
    return this.records.size;
  }
  get keys() {
    return Array.from(this.records.keys());
  }
  get values() {
    return Array.from(this.records.values());
  }
  get pending() {
    const e = [];
    return this.values.forEach((t) => {
      if (typeof t.response < "u")
        return;
      const i3 = { topic: t.topic, request: formatJsonRpcRequest(t.request.method, t.request.params, t.id), chainId: t.chainId };
      return e.push(i3);
    }), e;
  }
  async setJsonRpcRecords(e) {
    await this.core.storage.setItem(this.storageKey, e);
  }
  async getJsonRpcRecords() {
    return await this.core.storage.getItem(this.storageKey);
  }
  getRecord(e) {
    this.isInitialized();
    const t = this.records.get(e);
    if (!t) {
      const { message: i3 } = N("NO_MATCHING_KEY", `${this.name}: ${e}`);
      throw new Error(i3);
    }
    return t;
  }
  async persist() {
    await this.setJsonRpcRecords(this.values), this.events.emit(R2.sync);
  }
  async restore() {
    try {
      const e = await this.getJsonRpcRecords();
      if (typeof e > "u" || !e.length)
        return;
      if (this.records.size) {
        const { message: t } = N("RESTORE_WILL_OVERRIDE", this.name);
        throw this.logger.error(t), new Error(t);
      }
      this.cached = e, this.logger.debug(`Successfully Restored records for ${this.name}`), this.logger.trace({ type: "method", method: "restore", records: this.values });
    } catch (e) {
      this.logger.debug(`Failed to Restore records for ${this.name}`), this.logger.error(e);
    }
  }
  registerEventListeners() {
    this.events.on(R2.created, (e) => {
      const t = R2.created;
      this.logger.info(`Emitting ${t}`), this.logger.debug({ type: "event", event: t, record: e }), this.persist();
    }), this.events.on(R2.updated, (e) => {
      const t = R2.updated;
      this.logger.info(`Emitting ${t}`), this.logger.debug({ type: "event", event: t, record: e }), this.persist();
    }), this.events.on(R2.deleted, (e) => {
      const t = R2.deleted;
      this.logger.info(`Emitting ${t}`), this.logger.debug({ type: "event", event: t, record: e }), this.persist();
    }), this.core.heartbeat.on(import_heartbeat.HEARTBEAT_EVENTS.pulse, () => {
      this.cleanup();
    });
  }
  cleanup() {
    try {
      this.records.forEach((e) => {
        (0, import_time2.toMiliseconds)(e.expiry || 0) - Date.now() <= 0 && (this.logger.info(`Deleting expired history log: ${e.id}`), this.delete(e.topic, e.id));
      });
    } catch (e) {
      this.logger.warn(e);
    }
  }
  isInitialized() {
    if (!this.initialized) {
      const { message: e } = N("NOT_INITIALIZED", this.name);
      throw new Error(e);
    }
  }
};
var qt = class extends E {
  constructor(e, t) {
    super(e, t), this.core = e, this.logger = t, this.expirations = /* @__PURE__ */ new Map(), this.events = new import_events3.EventEmitter(), this.name = Ct, this.version = Rt2, this.cached = [], this.initialized = false, this.storagePrefix = O, this.init = async () => {
      this.initialized || (this.logger.trace("Initialized"), await this.restore(), this.cached.forEach((i3) => this.expirations.set(i3.target, i3)), this.cached = [], this.registerEventListeners(), this.initialized = true);
    }, this.has = (i3) => {
      try {
        const s = this.formatTarget(i3);
        return typeof this.getExpiration(s) < "u";
      } catch {
        return false;
      }
    }, this.set = (i3, s) => {
      this.isInitialized();
      const r = this.formatTarget(i3), o3 = { target: r, expiry: s };
      this.expirations.set(r, o3), this.checkExpiry(r, o3), this.events.emit(v2.created, { target: r, expiration: o3 });
    }, this.get = (i3) => {
      this.isInitialized();
      const s = this.formatTarget(i3);
      return this.getExpiration(s);
    }, this.del = (i3) => {
      if (this.isInitialized(), this.has(i3)) {
        const s = this.formatTarget(i3), r = this.getExpiration(s);
        this.expirations.delete(s), this.events.emit(v2.deleted, { target: s, expiration: r });
      }
    }, this.on = (i3, s) => {
      this.events.on(i3, s);
    }, this.once = (i3, s) => {
      this.events.once(i3, s);
    }, this.off = (i3, s) => {
      this.events.off(i3, s);
    }, this.removeListener = (i3, s) => {
      this.events.removeListener(i3, s);
    }, this.logger = (0, import_logger.generateChildLogger)(t, this.name);
  }
  get context() {
    return (0, import_logger.getLoggerContext)(this.logger);
  }
  get storageKey() {
    return this.storagePrefix + this.version + this.core.customStoragePrefix + "//" + this.name;
  }
  get length() {
    return this.expirations.size;
  }
  get keys() {
    return Array.from(this.expirations.keys());
  }
  get values() {
    return Array.from(this.expirations.values());
  }
  formatTarget(e) {
    if (typeof e == "string")
      return lt(e);
    if (typeof e == "number")
      return dt(e);
    const { message: t } = N("UNKNOWN_TYPE", `Target type: ${typeof e}`);
    throw new Error(t);
  }
  async setExpirations(e) {
    await this.core.storage.setItem(this.storageKey, e);
  }
  async getExpirations() {
    return await this.core.storage.getItem(this.storageKey);
  }
  async persist() {
    await this.setExpirations(this.values), this.events.emit(v2.sync);
  }
  async restore() {
    try {
      const e = await this.getExpirations();
      if (typeof e > "u" || !e.length)
        return;
      if (this.expirations.size) {
        const { message: t } = N("RESTORE_WILL_OVERRIDE", this.name);
        throw this.logger.error(t), new Error(t);
      }
      this.cached = e, this.logger.debug(`Successfully Restored expirations for ${this.name}`), this.logger.trace({ type: "method", method: "restore", expirations: this.values });
    } catch (e) {
      this.logger.debug(`Failed to Restore expirations for ${this.name}`), this.logger.error(e);
    }
  }
  getExpiration(e) {
    const t = this.expirations.get(e);
    if (!t) {
      const { message: i3 } = N("NO_MATCHING_KEY", `${this.name}: ${e}`);
      throw this.logger.error(i3), new Error(i3);
    }
    return t;
  }
  checkExpiry(e, t) {
    const { expiry: i3 } = t;
    (0, import_time2.toMiliseconds)(i3) - Date.now() <= 0 && this.expire(e, t);
  }
  expire(e, t) {
    this.expirations.delete(e), this.events.emit(v2.expired, { target: e, expiration: t });
  }
  checkExpirations() {
    this.core.relayer.connected && this.expirations.forEach((e, t) => this.checkExpiry(t, e));
  }
  registerEventListeners() {
    this.core.heartbeat.on(import_heartbeat.HEARTBEAT_EVENTS.pulse, () => this.checkExpirations()), this.events.on(v2.created, (e) => {
      const t = v2.created;
      this.logger.info(`Emitting ${t}`), this.logger.debug({ type: "event", event: t, data: e }), this.persist();
    }), this.events.on(v2.expired, (e) => {
      const t = v2.expired;
      this.logger.info(`Emitting ${t}`), this.logger.debug({ type: "event", event: t, data: e }), this.persist();
    }), this.events.on(v2.deleted, (e) => {
      const t = v2.deleted;
      this.logger.info(`Emitting ${t}`), this.logger.debug({ type: "event", event: t, data: e }), this.persist();
    });
  }
  isInitialized() {
    if (!this.initialized) {
      const { message: e } = N("NOT_INITIALIZED", this.name);
      throw new Error(e);
    }
  }
};
var jt = class extends y {
  constructor(e, t) {
    super(e, t), this.projectId = e, this.logger = t, this.name = Z2, this.initialized = false, this.queue = [], this.verifyDisabled = false, this.init = async (i3) => {
      if (this.verifyDisabled || $() || !D())
        return;
      const s = this.getVerifyUrl(i3 == null ? void 0 : i3.verifyUrl);
      this.verifyUrl !== s && this.removeIframe(), this.verifyUrl = s;
      try {
        await this.createIframe();
      } catch (r) {
        this.logger.info(`Verify iframe failed to load: ${this.verifyUrl}`), this.logger.info(r);
      }
      if (!this.initialized) {
        this.removeIframe(), this.verifyUrl = ee2;
        try {
          await this.createIframe();
        } catch (r) {
          this.logger.info(`Verify iframe failed to load: ${this.verifyUrl}`), this.logger.info(r), this.verifyDisabled = true;
        }
      }
    }, this.register = async (i3) => {
      this.initialized ? this.sendPost(i3.attestationId) : (this.addToQueue(i3.attestationId), await this.init());
    }, this.resolve = async (i3) => {
      if (this.isDevEnv)
        return "";
      const s = this.getVerifyUrl(i3 == null ? void 0 : i3.verifyUrl);
      let r;
      try {
        r = await this.fetchAttestation(i3.attestationId, s);
      } catch (o3) {
        this.logger.info(`failed to resolve attestation: ${i3.attestationId} from url: ${s}`), this.logger.info(o3), r = await this.fetchAttestation(i3.attestationId, ee2);
      }
      return r;
    }, this.fetchAttestation = async (i3, s) => {
      this.logger.info(`resolving attestation: ${i3} from url: ${s}`);
      const r = this.startAbortTimer(import_time2.ONE_SECOND * 2), o3 = await fetch(`${s}/attestation/${i3}`, { signal: this.abortController.signal });
      return clearTimeout(r), o3.status === 200 ? await o3.json() : void 0;
    }, this.addToQueue = (i3) => {
      this.queue.push(i3);
    }, this.processQueue = () => {
      this.queue.length !== 0 && (this.queue.forEach((i3) => this.sendPost(i3)), this.queue = []);
    }, this.sendPost = (i3) => {
      var s;
      try {
        if (!this.iframe)
          return;
        (s = this.iframe.contentWindow) == null || s.postMessage(i3, "*"), this.logger.info(`postMessage sent: ${i3} ${this.verifyUrl}`);
      } catch {
      }
    }, this.createIframe = async () => {
      let i3;
      const s = (r) => {
        r.data === "verify_ready" && (this.initialized = true, this.processQueue(), window.removeEventListener("message", s), i3());
      };
      await Promise.race([new Promise((r) => {
        if (document.getElementById(Z2))
          return r();
        window.addEventListener("message", s);
        const o3 = document.createElement("iframe");
        o3.id = Z2, o3.src = `${this.verifyUrl}/${this.projectId}`, o3.style.display = "none", document.body.append(o3), this.iframe = o3, i3 = r;
      }), new Promise((r, o3) => setTimeout(() => {
        window.removeEventListener("message", s), o3("verify iframe load timeout");
      }, (0, import_time2.toMiliseconds)(import_time2.FIVE_SECONDS)))]);
    }, this.removeIframe = () => {
      this.iframe && (this.iframe.remove(), this.iframe = void 0, this.initialized = false);
    }, this.getVerifyUrl = (i3) => {
      let s = i3 || F2;
      return _t.includes(s) || (this.logger.info(`verify url: ${s}, not included in trusted list, assigning default: ${F2}`), s = F2), s;
    }, this.logger = (0, import_logger.generateChildLogger)(t, this.name), this.verifyUrl = F2, this.abortController = new AbortController(), this.isDevEnv = te() && import_process.default.env.IS_VITEST;
  }
  get context() {
    return (0, import_logger.getLoggerContext)(this.logger);
  }
  startAbortTimer(e) {
    return this.abortController = new AbortController(), setTimeout(() => this.abortController.abort(), (0, import_time2.toMiliseconds)(e));
  }
};
var Gt2 = class extends v {
  constructor(e, t) {
    super(e, t), this.projectId = e, this.logger = t, this.context = Tt2, this.registerDeviceToken = async (i3) => {
      const { clientId: s, token: r, notificationType: o3, enableEncrypted: a3 = false } = i3, h5 = `${St2}/${this.projectId}/clients`;
      await (0, import_isomorphic_unfetch.default)(h5, { method: "POST", headers: { "Content-Type": "application/json" }, body: JSON.stringify({ client_id: s, type: o3, token: r, always_raw: a3 }) });
    }, this.logger = (0, import_logger.generateChildLogger)(t, this.context);
  }
};
var Lr = Object.defineProperty;
var Yt = Object.getOwnPropertySymbols;
var $r = Object.prototype.hasOwnProperty;
var Fr = Object.prototype.propertyIsEnumerable;
var Ht = (n4, e, t) => e in n4 ? Lr(n4, e, { enumerable: true, configurable: true, writable: true, value: t }) : n4[e] = t;
var Jt = (n4, e) => {
  for (var t in e || (e = {}))
    $r.call(e, t) && Ht(n4, t, e[t]);
  if (Yt)
    for (var t of Yt(e))
      Fr.call(e, t) && Ht(n4, t, e[t]);
  return n4;
};
var te2 = class _te extends n2 {
  constructor(e) {
    super(e), this.protocol = le2, this.version = We2, this.name = Q2, this.events = new import_events3.EventEmitter(), this.initialized = false, this.on = (i3, s) => this.events.on(i3, s), this.once = (i3, s) => this.events.once(i3, s), this.off = (i3, s) => this.events.off(i3, s), this.removeListener = (i3, s) => this.events.removeListener(i3, s), this.projectId = e == null ? void 0 : e.projectId, this.relayUrl = (e == null ? void 0 : e.relayUrl) || ge2, this.customStoragePrefix = e != null && e.customStoragePrefix ? `:${e.customStoragePrefix}` : "";
    const t = typeof (e == null ? void 0 : e.logger) < "u" && typeof (e == null ? void 0 : e.logger) != "string" ? e.logger : (0, import_logger.pino)((0, import_logger.getDefaultLoggerOptions)({ level: (e == null ? void 0 : e.logger) || Qe.logger }));
    this.logger = (0, import_logger.generateChildLogger)(t, this.name), this.heartbeat = new import_heartbeat.HeartBeat(), this.crypto = new xt2(this, this.logger, e == null ? void 0 : e.keychain), this.history = new Vt(this, this.logger), this.expirer = new qt(this, this.logger), this.storage = e != null && e.storage ? e.storage : new h(Jt(Jt({}, Ze), e == null ? void 0 : e.storageOptions)), this.relayer = new $t({ core: this, logger: this.logger, relayUrl: this.relayUrl, projectId: this.projectId }), this.pairing = new Bt(this, this.logger), this.verify = new jt(this.projectId || "", this.logger), this.echoClient = new Gt2(this.projectId || "", this.logger);
  }
  static async init(e) {
    const t = new _te(e);
    await t.initialize();
    const i3 = await t.crypto.getClientId();
    return await t.storage.setItem(yt2, i3), t;
  }
  get context() {
    return (0, import_logger.getLoggerContext)(this.logger);
  }
  async start() {
    this.initialized || await this.initialize();
  }
  async initialize() {
    this.logger.trace("Initialized");
    try {
      await this.crypto.init(), await this.history.init(), await this.expirer.init(), await this.relayer.init(), await this.heartbeat.init(), await this.pairing.init(), this.initialized = true, this.logger.info("Core Initialization Success");
    } catch (e) {
      throw this.logger.warn(`Core Initialization Failure at epoch ${Date.now()}`, e), this.logger.error(e.message), e;
    }
  }
};
var Mr2 = te2;

// node_modules/@walletconnect/auth-client/dist/index.es.js
var import_logger2 = __toESM(require_cjs3());
var import_events4 = __toESM(require_events());
var import_time3 = __toESM(require_cjs());
init_lib();
init_lib2();
var import_isomorphic_unfetch2 = __toESM(require_browser());
var import_random2 = __toESM(require_random());
var import_sha2562 = __toESM(require_sha256());
var G3 = class {
  constructor(t) {
    this.client = t;
  }
};
var H2 = class {
  constructor(t) {
    this.opts = t;
  }
};
var Y = "https://rpc.walletconnect.com/v1";
var R3 = { wc_authRequest: { req: { ttl: import_time3.ONE_DAY, prompt: true, tag: 3e3 }, res: { ttl: import_time3.ONE_DAY, prompt: false, tag: 3001 } } };
var U3 = { min: import_time3.FIVE_MINUTES, max: import_time3.SEVEN_DAYS };
var $3 = "wc";
var Q3 = 1;
var Z3 = "auth";
var B2 = "authClient";
var F3 = `${$3}@${1}:${Z3}:`;
var x = `${F3}:PUB_KEY`;
function z(r) {
  return r == null ? void 0 : r.split(":");
}
function Ze2(r) {
  const t = r && z(r);
  if (t)
    return t[3];
}
function We3(r) {
  const t = r && z(r);
  if (t)
    return t[2] + ":" + t[3];
}
function W3(r) {
  const t = r && z(r);
  if (t)
    return t.pop();
}
async function et2(r, t, e, i3, n4) {
  switch (e.t) {
    case "eip191":
      return tt2(r, t, e.s);
    case "eip1271":
      return await rt3(r, t, e.s, i3, n4);
    default:
      throw new Error(`verifySignature failed: Attempted to verify CacaoSignature with unknown type: ${e.t}`);
  }
}
function tt2(r, t, e) {
  return recoverAddress(hashMessage(t), e).toLowerCase() === r.toLowerCase();
}
async function rt3(r, t, e, i3, n4) {
  try {
    const s = "0x1626ba7e", o3 = "0000000000000000000000000000000000000000000000000000000000000040", u3 = "0000000000000000000000000000000000000000000000000000000000000041", a3 = e.substring(2), c3 = hashMessage(t).substring(2), h5 = s + c3 + o3 + u3 + a3, f3 = await (0, import_isomorphic_unfetch2.default)(`${Y}/?chainId=${i3}&projectId=${n4}`, { method: "POST", body: JSON.stringify({ id: it2(), jsonrpc: "2.0", method: "eth_call", params: [{ to: r, data: h5 }, "latest"] }) }), { result: p6 } = await f3.json();
    return p6 ? p6.slice(0, s.length).toLowerCase() === s.toLowerCase() : false;
  } catch (s) {
    return console.error("isValidEip1271Signature: ", s), false;
  }
}
function it2() {
  return Date.now() + Math.floor(Math.random() * 1e3);
}
function ee3(r) {
  return r.getAll().filter((t) => "requester" in t);
}
function te3(r, t) {
  return ee3(r).find((e) => e.id === t);
}
function nt2(r) {
  const t = Kt(r.aud), e = new RegExp(`${r.domain}`).test(r.aud), i3 = !!r.nonce, n4 = r.type ? r.type === "eip4361" : true, s = r.expiry;
  if (s && !tr(s, U3)) {
    const { message: o3 } = N("MISSING_OR_INVALID", `request() expiry: ${s}. Expiry must be a number (in seconds) between ${U3.min} and ${U3.max}`);
    throw new Error(o3);
  }
  return !!(t && e && i3 && n4);
}
function st2(r, t) {
  return !!te3(t, r.id);
}
function ot3(r = 0) {
  return globalThis.Buffer != null && globalThis.Buffer.allocUnsafe != null ? globalThis.Buffer.allocUnsafe(r) : new Uint8Array(r);
}
function ut3(r, t) {
  if (r.length >= 255)
    throw new TypeError("Alphabet too long");
  for (var e = new Uint8Array(256), i3 = 0; i3 < e.length; i3++)
    e[i3] = 255;
  for (var n4 = 0; n4 < r.length; n4++) {
    var s = r.charAt(n4), o3 = s.charCodeAt(0);
    if (e[o3] !== 255)
      throw new TypeError(s + " is ambiguous");
    e[o3] = n4;
  }
  var u3 = r.length, a3 = r.charAt(0), c3 = Math.log(u3) / Math.log(256), h5 = Math.log(256) / Math.log(u3);
  function f3(D7) {
    if (D7 instanceof Uint8Array || (ArrayBuffer.isView(D7) ? D7 = new Uint8Array(D7.buffer, D7.byteOffset, D7.byteLength) : Array.isArray(D7) && (D7 = Uint8Array.from(D7))), !(D7 instanceof Uint8Array))
      throw new TypeError("Expected Uint8Array");
    if (D7.length === 0)
      return "";
    for (var l2 = 0, m3 = 0, E7 = 0, y4 = D7.length; E7 !== y4 && D7[E7] === 0; )
      E7++, l2++;
    for (var w7 = (y4 - E7) * h5 + 1 >>> 0, g9 = new Uint8Array(w7); E7 !== y4; ) {
      for (var C2 = D7[E7], _4 = 0, b5 = w7 - 1; (C2 !== 0 || _4 < m3) && b5 !== -1; b5--, _4++)
        C2 += 256 * g9[b5] >>> 0, g9[b5] = C2 % u3 >>> 0, C2 = C2 / u3 >>> 0;
      if (C2 !== 0)
        throw new Error("Non-zero carry");
      m3 = _4, E7++;
    }
    for (var v5 = w7 - m3; v5 !== w7 && g9[v5] === 0; )
      v5++;
    for (var q4 = a3.repeat(l2); v5 < w7; ++v5)
      q4 += r.charAt(g9[v5]);
    return q4;
  }
  function p6(D7) {
    if (typeof D7 != "string")
      throw new TypeError("Expected String");
    if (D7.length === 0)
      return new Uint8Array();
    var l2 = 0;
    if (D7[l2] !== " ") {
      for (var m3 = 0, E7 = 0; D7[l2] === a3; )
        m3++, l2++;
      for (var y4 = (D7.length - l2) * c3 + 1 >>> 0, w7 = new Uint8Array(y4); D7[l2]; ) {
        var g9 = e[D7.charCodeAt(l2)];
        if (g9 === 255)
          return;
        for (var C2 = 0, _4 = y4 - 1; (g9 !== 0 || C2 < E7) && _4 !== -1; _4--, C2++)
          g9 += u3 * w7[_4] >>> 0, w7[_4] = g9 % 256 >>> 0, g9 = g9 / 256 >>> 0;
        if (g9 !== 0)
          throw new Error("Non-zero carry");
        E7 = C2, l2++;
      }
      if (D7[l2] !== " ") {
        for (var b5 = y4 - E7; b5 !== y4 && w7[b5] === 0; )
          b5++;
        for (var v5 = new Uint8Array(m3 + (y4 - b5)), q4 = m3; b5 !== y4; )
          v5[q4++] = w7[b5++];
        return v5;
      }
    }
  }
  function A3(D7) {
    var l2 = p6(D7);
    if (l2)
      return l2;
    throw new Error(`Non-${t} character`);
  }
  return { encode: f3, decodeUnsafe: p6, decode: A3 };
}
var at3 = ut3;
var Dt2 = at3;
var re2 = (r) => {
  if (r instanceof Uint8Array && r.constructor.name === "Uint8Array")
    return r;
  if (r instanceof ArrayBuffer)
    return new Uint8Array(r);
  if (ArrayBuffer.isView(r))
    return new Uint8Array(r.buffer, r.byteOffset, r.byteLength);
  throw new Error("Unknown type, must be binary type");
};
var ct2 = (r) => new TextEncoder().encode(r);
var ht2 = (r) => new TextDecoder().decode(r);
var lt3 = class {
  constructor(t, e, i3) {
    this.name = t, this.prefix = e, this.baseEncode = i3;
  }
  encode(t) {
    if (t instanceof Uint8Array)
      return `${this.prefix}${this.baseEncode(t)}`;
    throw Error("Unknown type, must be binary type");
  }
};
var dt3 = class {
  constructor(t, e, i3) {
    if (this.name = t, this.prefix = e, e.codePointAt(0) === void 0)
      throw new Error("Invalid prefix character");
    this.prefixCodePoint = e.codePointAt(0), this.baseDecode = i3;
  }
  decode(t) {
    if (typeof t == "string") {
      if (t.codePointAt(0) !== this.prefixCodePoint)
        throw Error(`Unable to decode multibase string ${JSON.stringify(t)}, ${this.name} decoder only supports inputs prefixed with ${this.prefix}`);
      return this.baseDecode(t.slice(this.prefix.length));
    } else
      throw Error("Can only multibase decode strings");
  }
  or(t) {
    return ie(this, t);
  }
};
var pt3 = class {
  constructor(t) {
    this.decoders = t;
  }
  or(t) {
    return ie(this, t);
  }
  decode(t) {
    const e = t[0], i3 = this.decoders[e];
    if (i3)
      return i3.decode(t);
    throw RangeError(`Unable to decode multibase string ${JSON.stringify(t)}, only inputs prefixed with ${Object.keys(this.decoders)} are supported`);
  }
};
var ie = (r, t) => new pt3({ ...r.decoders || { [r.prefix]: r }, ...t.decoders || { [t.prefix]: t } });
var ft3 = class {
  constructor(t, e, i3, n4) {
    this.name = t, this.prefix = e, this.baseEncode = i3, this.baseDecode = n4, this.encoder = new lt3(t, e, i3), this.decoder = new dt3(t, e, n4);
  }
  encode(t) {
    return this.encoder.encode(t);
  }
  decode(t) {
    return this.decoder.decode(t);
  }
};
var O2 = ({ name: r, prefix: t, encode: e, decode: i3 }) => new ft3(r, t, e, i3);
var T = ({ prefix: r, name: t, alphabet: e }) => {
  const { encode: i3, decode: n4 } = Dt2(e, t);
  return O2({ prefix: r, name: t, encode: i3, decode: (s) => re2(n4(s)) });
};
var gt2 = (r, t, e, i3) => {
  const n4 = {};
  for (let h5 = 0; h5 < t.length; ++h5)
    n4[t[h5]] = h5;
  let s = r.length;
  for (; r[s - 1] === "="; )
    --s;
  const o3 = new Uint8Array(s * e / 8 | 0);
  let u3 = 0, a3 = 0, c3 = 0;
  for (let h5 = 0; h5 < s; ++h5) {
    const f3 = n4[r[h5]];
    if (f3 === void 0)
      throw new SyntaxError(`Non-${i3} character`);
    a3 = a3 << e | f3, u3 += e, u3 >= 8 && (u3 -= 8, o3[c3++] = 255 & a3 >> u3);
  }
  if (u3 >= e || 255 & a3 << 8 - u3)
    throw new SyntaxError("Unexpected end of data");
  return o3;
};
var Et3 = (r, t, e) => {
  const i3 = t[t.length - 1] === "=", n4 = (1 << e) - 1;
  let s = "", o3 = 0, u3 = 0;
  for (let a3 = 0; a3 < r.length; ++a3)
    for (u3 = u3 << 8 | r[a3], o3 += 8; o3 > e; )
      o3 -= e, s += t[n4 & u3 >> o3];
  if (o3 && (s += t[n4 & u3 << e - o3]), i3)
    for (; s.length * e & 7; )
      s += "=";
  return s;
};
var d2 = ({ name: r, prefix: t, bitsPerChar: e, alphabet: i3 }) => O2({ prefix: t, name: r, encode(n4) {
  return Et3(n4, i3, e);
}, decode(n4) {
  return gt2(n4, i3, e, r);
} });
var bt3 = O2({ prefix: "\0", name: "identity", encode: (r) => ht2(r), decode: (r) => ct2(r) });
var yt3 = Object.freeze({ __proto__: null, identity: bt3 });
var wt3 = d2({ prefix: "0", name: "base2", alphabet: "01", bitsPerChar: 1 });
var Ct2 = Object.freeze({ __proto__: null, base2: wt3 });
var mt3 = d2({ prefix: "7", name: "base8", alphabet: "01234567", bitsPerChar: 3 });
var vt3 = Object.freeze({ __proto__: null, base8: mt3 });
var At2 = T({ prefix: "9", name: "base10", alphabet: "0123456789" });
var _t2 = Object.freeze({ __proto__: null, base10: At2 });
var xt3 = d2({ prefix: "f", name: "base16", alphabet: "0123456789abcdef", bitsPerChar: 4 });
var Rt3 = d2({ prefix: "F", name: "base16upper", alphabet: "0123456789ABCDEF", bitsPerChar: 4 });
var Ft2 = Object.freeze({ __proto__: null, base16: xt3, base16upper: Rt3 });
var Tt3 = d2({ prefix: "b", name: "base32", alphabet: "abcdefghijklmnopqrstuvwxyz234567", bitsPerChar: 5 });
var It3 = d2({ prefix: "B", name: "base32upper", alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZ234567", bitsPerChar: 5 });
var qt2 = d2({ prefix: "c", name: "base32pad", alphabet: "abcdefghijklmnopqrstuvwxyz234567=", bitsPerChar: 5 });
var Ut2 = d2({ prefix: "C", name: "base32padupper", alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZ234567=", bitsPerChar: 5 });
var Ot3 = d2({ prefix: "v", name: "base32hex", alphabet: "0123456789abcdefghijklmnopqrstuv", bitsPerChar: 5 });
var St3 = d2({ prefix: "V", name: "base32hexupper", alphabet: "0123456789ABCDEFGHIJKLMNOPQRSTUV", bitsPerChar: 5 });
var Pt3 = d2({ prefix: "t", name: "base32hexpad", alphabet: "0123456789abcdefghijklmnopqrstuv=", bitsPerChar: 5 });
var Nt3 = d2({ prefix: "T", name: "base32hexpadupper", alphabet: "0123456789ABCDEFGHIJKLMNOPQRSTUV=", bitsPerChar: 5 });
var $t2 = d2({ prefix: "h", name: "base32z", alphabet: "ybndrfg8ejkmcpqxot1uwisza345h769", bitsPerChar: 5 });
var Bt2 = Object.freeze({ __proto__: null, base32: Tt3, base32upper: It3, base32pad: qt2, base32padupper: Ut2, base32hex: Ot3, base32hexupper: St3, base32hexpad: Pt3, base32hexpadupper: Nt3, base32z: $t2 });
var zt2 = T({ prefix: "k", name: "base36", alphabet: "0123456789abcdefghijklmnopqrstuvwxyz" });
var jt2 = T({ prefix: "K", name: "base36upper", alphabet: "0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ" });
var Mt2 = Object.freeze({ __proto__: null, base36: zt2, base36upper: jt2 });
var Lt3 = T({ name: "base58btc", prefix: "z", alphabet: "123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz" });
var Kt3 = T({ name: "base58flickr", prefix: "Z", alphabet: "123456789abcdefghijkmnopqrstuvwxyzABCDEFGHJKLMNPQRSTUVWXYZ" });
var Vt2 = Object.freeze({ __proto__: null, base58btc: Lt3, base58flickr: Kt3 });
var kt2 = d2({ prefix: "m", name: "base64", alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/", bitsPerChar: 6 });
var Jt2 = d2({ prefix: "M", name: "base64pad", alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=", bitsPerChar: 6 });
var Xt2 = d2({ prefix: "u", name: "base64url", alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_", bitsPerChar: 6 });
var Gt3 = d2({ prefix: "U", name: "base64urlpad", alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_=", bitsPerChar: 6 });
var Ht2 = Object.freeze({ __proto__: null, base64: kt2, base64pad: Jt2, base64url: Xt2, base64urlpad: Gt3 });
var ne = Array.from("🚀🪐☄🛰🌌🌑🌒🌓🌔🌕🌖🌗🌘🌍🌏🌎🐉☀💻🖥💾💿😂❤😍🤣😊🙏💕😭😘👍😅👏😁🔥🥰💔💖💙😢🤔😆🙄💪😉☺👌🤗💜😔😎😇🌹🤦🎉💞✌✨🤷😱😌🌸🙌😋💗💚😏💛🙂💓🤩😄😀🖤😃💯🙈👇🎶😒🤭❣😜💋👀😪😑💥🙋😞😩😡🤪👊🥳😥🤤👉💃😳✋😚😝😴🌟😬🙃🍀🌷😻😓⭐✅🥺🌈😈🤘💦✔😣🏃💐☹🎊💘😠☝😕🌺🎂🌻😐🖕💝🙊😹🗣💫💀👑🎵🤞😛🔴😤🌼😫⚽🤙☕🏆🤫👈😮🙆🍻🍃🐶💁😲🌿🧡🎁⚡🌞🎈❌✊👋😰🤨😶🤝🚶💰🍓💢🤟🙁🚨💨🤬✈🎀🍺🤓😙💟🌱😖👶🥴▶➡❓💎💸⬇😨🌚🦋😷🕺⚠🙅😟😵👎🤲🤠🤧📌🔵💅🧐🐾🍒😗🤑🌊🤯🐷☎💧😯💆👆🎤🙇🍑❄🌴💣🐸💌📍🥀🤢👅💡💩👐📸👻🤐🤮🎼🥵🚩🍎🍊👼💍📣🥂");
var Yt2 = ne.reduce((r, t, e) => (r[e] = t, r), []);
var Qt2 = ne.reduce((r, t, e) => (r[t.codePointAt(0)] = e, r), []);
function Zt(r) {
  return r.reduce((t, e) => (t += Yt2[e], t), "");
}
function Wt(r) {
  const t = [];
  for (const e of r) {
    const i3 = Qt2[e.codePointAt(0)];
    if (i3 === void 0)
      throw new Error(`Non-base256emoji character: ${e}`);
    t.push(i3);
  }
  return new Uint8Array(t);
}
var er2 = O2({ prefix: "🚀", name: "base256emoji", encode: Zt, decode: Wt });
var tr3 = Object.freeze({ __proto__: null, base256emoji: er2 });
var rr3 = oe;
var se = 128;
var ir2 = 127;
var nr2 = ~ir2;
var sr2 = Math.pow(2, 31);
function oe(r, t, e) {
  t = t || [], e = e || 0;
  for (var i3 = e; r >= sr2; )
    t[e++] = r & 255 | se, r /= 128;
  for (; r & nr2; )
    t[e++] = r & 255 | se, r >>>= 7;
  return t[e] = r | 0, oe.bytes = e - i3 + 1, t;
}
var or3 = j2;
var ur2 = 128;
var ue3 = 127;
function j2(r, i3) {
  var e = 0, i3 = i3 || 0, n4 = 0, s = i3, o3, u3 = r.length;
  do {
    if (s >= u3)
      throw j2.bytes = 0, new RangeError("Could not decode varint");
    o3 = r[s++], e += n4 < 28 ? (o3 & ue3) << n4 : (o3 & ue3) * Math.pow(2, n4), n4 += 7;
  } while (o3 >= ur2);
  return j2.bytes = s - i3, e;
}
var ar2 = Math.pow(2, 7);
var Dr2 = Math.pow(2, 14);
var cr2 = Math.pow(2, 21);
var hr2 = Math.pow(2, 28);
var lr2 = Math.pow(2, 35);
var dr2 = Math.pow(2, 42);
var pr2 = Math.pow(2, 49);
var fr = Math.pow(2, 56);
var gr2 = Math.pow(2, 63);
var Er = function(r) {
  return r < ar2 ? 1 : r < Dr2 ? 2 : r < cr2 ? 3 : r < hr2 ? 4 : r < lr2 ? 5 : r < dr2 ? 6 : r < pr2 ? 7 : r < fr ? 8 : r < gr2 ? 9 : 10;
};
var br = { encode: rr3, decode: or3, encodingLength: Er };
var ae = br;
var De3 = (r, t, e = 0) => (ae.encode(r, t, e), t);
var ce2 = (r) => ae.encodingLength(r);
var M2 = (r, t) => {
  const e = t.byteLength, i3 = ce2(r), n4 = i3 + ce2(e), s = new Uint8Array(n4 + e);
  return De3(r, s, 0), De3(e, s, i3), s.set(t, n4), new yr2(r, e, t, s);
};
var yr2 = class {
  constructor(t, e, i3, n4) {
    this.code = t, this.size = e, this.digest = i3, this.bytes = n4;
  }
};
var he3 = ({ name: r, code: t, encode: e }) => new wr(r, t, e);
var wr = class {
  constructor(t, e, i3) {
    this.name = t, this.code = e, this.encode = i3;
  }
  digest(t) {
    if (t instanceof Uint8Array) {
      const e = this.encode(t);
      return e instanceof Uint8Array ? M2(this.code, e) : e.then((i3) => M2(this.code, i3));
    } else
      throw Error("Unknown type, must be binary type");
  }
};
var le3 = (r) => async (t) => new Uint8Array(await crypto.subtle.digest(r, t));
var Cr2 = he3({ name: "sha2-256", code: 18, encode: le3("SHA-256") });
var mr2 = he3({ name: "sha2-512", code: 19, encode: le3("SHA-512") });
var vr2 = Object.freeze({ __proto__: null, sha256: Cr2, sha512: mr2 });
var de3 = 0;
var Ar2 = "identity";
var pe2 = re2;
var _r2 = (r) => M2(de3, pe2(r));
var xr2 = { code: de3, name: Ar2, encode: pe2, digest: _r2 };
var Rr2 = Object.freeze({ __proto__: null, identity: xr2 });
new TextEncoder(), new TextDecoder();
var fe2 = { ...yt3, ...Ct2, ...vt3, ..._t2, ...Ft2, ...Bt2, ...Mt2, ...Vt2, ...Ht2, ...tr3 };
({ ...vr2, ...Rr2 });
function ge3(r, t, e, i3) {
  return { name: r, prefix: t, encoder: { name: r, prefix: t, encode: e }, decoder: { decode: i3 } };
}
var Ee = ge3("utf8", "u", (r) => "u" + new TextDecoder("utf8").decode(r), (r) => new TextEncoder().encode(r.substring(1)));
var L2 = ge3("ascii", "a", (r) => {
  let t = "a";
  for (let e = 0; e < r.length; e++)
    t += String.fromCharCode(r[e]);
  return t;
}, (r) => {
  r = r.substring(1);
  const t = ot3(r.length);
  for (let e = 0; e < r.length; e++)
    t[e] = r.charCodeAt(e);
  return t;
});
var be = { utf8: Ee, "utf-8": Ee, hex: fe2.base16, latin1: L2, ascii: L2, binary: L2, ...fe2 };
function Fr2(r, t = "utf8") {
  const e = be[t];
  if (!e)
    throw new Error(`Unsupported encoding "${t}"`);
  return (t === "utf8" || t === "utf-8") && globalThis.Buffer != null && globalThis.Buffer.from != null ? globalThis.Buffer.from(r, "utf8") : e.decoder.decode(`${e.prefix}${r}`);
}
function Tr2(r, t = "utf8") {
  const e = be[t];
  if (!e)
    throw new Error(`Unsupported encoding "${t}"`);
  return (t === "utf8" || t === "utf-8") && globalThis.Buffer != null && globalThis.Buffer.from != null ? globalThis.Buffer.from(r.buffer, r.byteOffset, r.byteLength).toString("utf8") : e.encoder.encode(r).substring(1);
}
var ye3 = "base16";
var we = "utf8";
function K(r) {
  const t = (0, import_sha2562.hash)(Fr2(r, we));
  return Tr2(t, ye3);
}
var Or2 = Object.defineProperty;
var Sr2 = Object.defineProperties;
var Pr2 = Object.getOwnPropertyDescriptors;
var Ce2 = Object.getOwnPropertySymbols;
var Nr2 = Object.prototype.hasOwnProperty;
var $r2 = Object.prototype.propertyIsEnumerable;
var me3 = (r, t, e) => t in r ? Or2(r, t, { enumerable: true, configurable: true, writable: true, value: e }) : r[t] = e;
var I = (r, t) => {
  for (var e in t || (t = {}))
    Nr2.call(t, e) && me3(r, e, t[e]);
  if (Ce2)
    for (var e of Ce2(t))
      $r2.call(t, e) && me3(r, e, t[e]);
  return r;
};
var V2 = (r, t) => Sr2(r, Pr2(t));
var Br = class extends G3 {
  constructor(t) {
    super(t), this.initialized = false, this.name = "authEngine", this.init = () => {
      this.initialized || (this.registerRelayerEvents(), this.registerPairingEvents(), this.client.core.pairing.register({ methods: Object.keys(R3) }), this.initialized = true);
    }, this.request = async (e, i3) => {
      if (this.isInitialized(), !nt2(e))
        throw new Error("Invalid request");
      if (i3 != null && i3.topic)
        return await this.requestOnKnownPairing(i3.topic, e);
      const { chainId: n4, statement: s, aud: o3, domain: u3, nonce: a3, type: c3, exp: h5, nbf: f3 } = e, { topic: p6, uri: A3 } = await this.client.core.pairing.create();
      this.client.logger.info({ message: "Generated new pairing", pairing: { topic: p6, uri: A3 } });
      const D7 = await this.client.core.crypto.generateKeyPair(), l2 = Kn(D7);
      await this.client.authKeys.set(x, { responseTopic: l2, publicKey: D7 }), await this.client.pairingTopics.set(l2, { topic: l2, pairingTopic: p6 }), await this.client.core.relayer.subscribe(l2), this.client.logger.info(`sending request to new pairing topic: ${p6}`);
      const m3 = await this.sendRequest(p6, "wc_authRequest", { payloadParams: { type: c3 ?? "eip4361", chainId: n4, statement: s, aud: o3, domain: u3, version: "1", nonce: a3, iat: (/* @__PURE__ */ new Date()).toISOString(), exp: h5, nbf: f3 }, requester: { publicKey: D7, metadata: this.client.metadata } }, {}, e.expiry);
      return this.client.logger.info(`sent request to new pairing topic: ${p6}`), { uri: A3, id: m3 };
    }, this.respond = async (e, i3) => {
      if (this.isInitialized(), !st2(e, this.client.requests))
        throw new Error("Invalid response");
      const n4 = te3(this.client.requests, e.id);
      if (!n4)
        throw new Error(`Could not find pending auth request with id ${e.id}`);
      const s = n4.requester.publicKey, o3 = await this.client.core.crypto.generateKeyPair(), u3 = Kn(s), a3 = { type: _, receiverPublicKey: s, senderPublicKey: o3 };
      if ("error" in e) {
        await this.sendError(n4.id, u3, e, a3);
        return;
      }
      const c3 = { h: { t: "eip4361" }, p: V2(I({}, n4.cacaoPayload), { iss: i3 }), s: e.signature };
      await this.sendResult(n4.id, u3, c3, a3), await this.client.core.pairing.activate({ topic: n4.pairingTopic }), await this.client.requests.update(n4.id, I({}, c3));
    }, this.getPendingRequests = () => ee3(this.client.requests), this.formatMessage = (e, i3) => {
      this.client.logger.debug(`formatMessage, cacao is: ${JSON.stringify(e)}`);
      const n4 = `${e.domain} wants you to sign in with your Ethereum account:`, s = W3(i3), o3 = e.statement, u3 = `URI: ${e.aud}`, a3 = `Version: ${e.version}`, c3 = `Chain ID: ${Ze2(i3)}`, h5 = `Nonce: ${e.nonce}`, f3 = `Issued At: ${e.iat}`, p6 = e.exp ? `Expiry: ${e.exp}` : void 0, A3 = e.resources && e.resources.length > 0 ? `Resources:
${e.resources.map((D7) => `- ${D7}`).join(`
`)}` : void 0;
      return [n4, s, "", o3, "", u3, a3, c3, h5, f3, p6, A3].filter((D7) => D7 != null).join(`
`);
    }, this.setExpiry = async (e, i3) => {
      this.client.core.pairing.pairings.keys.includes(e) && await this.client.core.pairing.updateExpiry({ topic: e, expiry: i3 }), this.client.core.expirer.set(e, i3);
    }, this.sendRequest = async (e, i3, n4, s, o3) => {
      const u3 = formatJsonRpcRequest(i3, n4), a3 = await this.client.core.crypto.encode(e, u3, s), c3 = R3[i3].req;
      if (o3 && (c3.ttl = o3), this.client.core.history.set(e, u3), D()) {
        const h5 = K(JSON.stringify(u3));
        this.client.core.verify.register({ attestationId: h5 });
      }
      return await this.client.core.relayer.publish(e, a3, V2(I({}, c3), { internal: { throwOnFailedPublish: true } })), u3.id;
    }, this.sendResult = async (e, i3, n4, s) => {
      const o3 = formatJsonRpcResult(e, n4), u3 = await this.client.core.crypto.encode(i3, o3, s), a3 = await this.client.core.history.get(i3, e), c3 = R3[a3.request.method].res;
      return await this.client.core.relayer.publish(i3, u3, V2(I({}, c3), { internal: { throwOnFailedPublish: true } })), await this.client.core.history.resolve(o3), o3.id;
    }, this.sendError = async (e, i3, n4, s) => {
      const o3 = formatJsonRpcError(e, n4.error), u3 = await this.client.core.crypto.encode(i3, o3, s), a3 = await this.client.core.history.get(i3, e), c3 = R3[a3.request.method].res;
      return await this.client.core.relayer.publish(i3, u3, c3), await this.client.core.history.resolve(o3), o3.id;
    }, this.requestOnKnownPairing = async (e, i3) => {
      const n4 = this.client.core.pairing.pairings.getAll({ active: true }).find((A3) => A3.topic === e);
      if (!n4)
        throw new Error(`Could not find pairing for provided topic ${e}`);
      const { publicKey: s } = this.client.authKeys.get(x), { chainId: o3, statement: u3, aud: a3, domain: c3, nonce: h5, type: f3 } = i3, p6 = await this.sendRequest(n4.topic, "wc_authRequest", { payloadParams: { type: f3 ?? "eip4361", chainId: o3, statement: u3, aud: a3, domain: c3, version: "1", nonce: h5, iat: (/* @__PURE__ */ new Date()).toISOString() }, requester: { publicKey: s, metadata: this.client.metadata } }, {}, i3.expiry);
      return this.client.logger.info(`sent request to known pairing topic: ${n4.topic}`), { id: p6 };
    }, this.onPairingCreated = (e) => {
      const i3 = this.getPendingRequests();
      if (i3) {
        const n4 = Object.values(i3).find((s) => s.pairingTopic === e.topic);
        n4 && this.handleAuthRequest(n4);
      }
    }, this.onRelayEventRequest = (e) => {
      const { topic: i3, payload: n4 } = e, s = n4.method;
      switch (s) {
        case "wc_authRequest":
          return this.onAuthRequest(i3, n4);
        default:
          return this.client.logger.info(`Unsupported request method ${s}`);
      }
    }, this.onRelayEventResponse = async (e) => {
      const { topic: i3, payload: n4 } = e, s = (await this.client.core.history.get(i3, n4.id)).request.method;
      switch (s) {
        case "wc_authRequest":
          return this.onAuthResponse(i3, n4);
        default:
          return this.client.logger.info(`Unsupported response method ${s}`);
      }
    }, this.onAuthRequest = async (e, i3) => {
      const { requester: n4, payloadParams: s } = i3.params;
      this.client.logger.info({ type: "onAuthRequest", topic: e, payload: i3 });
      const o3 = K(JSON.stringify(i3)), u3 = await this.getVerifyContext(o3, this.client.metadata), a3 = { requester: n4, pairingTopic: e, id: i3.id, cacaoPayload: s, verifyContext: u3 };
      await this.client.requests.set(i3.id, a3), this.handleAuthRequest(a3);
    }, this.handleAuthRequest = async (e) => {
      const { id: i3, pairingTopic: n4, requester: s, cacaoPayload: o3, verifyContext: u3 } = e;
      try {
        this.client.emit("auth_request", { id: i3, topic: n4, params: { requester: s, cacaoPayload: o3 }, verifyContext: u3 });
      } catch (a3) {
        await this.sendError(e.id, e.pairingTopic, a3), this.client.logger.error(a3);
      }
    }, this.onAuthResponse = async (e, i3) => {
      const { id: n4 } = i3;
      if (this.client.logger.info({ type: "onAuthResponse", topic: e, response: i3 }), isJsonRpcResult(i3)) {
        const { pairingTopic: s } = this.client.pairingTopics.get(e);
        await this.client.core.pairing.activate({ topic: s });
        const { s: o3, p: u3 } = i3.result;
        await this.client.requests.set(n4, I({ id: n4, pairingTopic: s }, i3.result));
        const a3 = this.formatMessage(u3, u3.iss);
        this.client.logger.debug(`reconstructed message:
`, JSON.stringify(a3)), this.client.logger.debug("payload.iss:", u3.iss), this.client.logger.debug("signature:", o3);
        const c3 = W3(u3.iss), h5 = We3(u3.iss);
        if (!c3)
          throw new Error("Could not derive address from `payload.iss`");
        if (!h5)
          throw new Error("Could not derive chainId from `payload.iss`");
        this.client.logger.debug("walletAddress extracted from `payload.iss`:", c3), await et2(c3, a3, o3, h5, this.client.projectId) ? this.client.emit("auth_response", { id: n4, topic: e, params: i3 }) : this.client.emit("auth_response", { id: n4, topic: e, params: { message: "Invalid signature", code: -1 } });
      } else
        isJsonRpcError(i3) && this.client.emit("auth_response", { id: n4, topic: e, params: i3 });
    }, this.getVerifyContext = async (e, i3) => {
      const n4 = { verified: { verifyUrl: i3.verifyUrl || "", validation: "UNKNOWN", origin: i3.url || "" } };
      try {
        const s = await this.client.core.verify.resolve({ attestationId: e, verifyUrl: i3.verifyUrl });
        s && (n4.verified.origin = s.origin, n4.verified.isScam = s.isScam, n4.verified.validation = origin === new URL(i3.url).origin ? "VALID" : "INVALID");
      } catch (s) {
        this.client.logger.error(s);
      }
      return this.client.logger.info(`Verify context: ${JSON.stringify(n4)}`), n4;
    };
  }
  isInitialized() {
    if (!this.initialized) {
      const { message: t } = N("NOT_INITIALIZED", this.name);
      throw new Error(t);
    }
  }
  registerRelayerEvents() {
    this.client.core.relayer.on(D2.message, async (t) => {
      const { topic: e, message: i3 } = t, { responseTopic: n4, publicKey: s } = this.client.authKeys.keys.includes(x) ? this.client.authKeys.get(x) : { responseTopic: void 0, publicKey: void 0 };
      if (n4 && e !== n4) {
        this.client.logger.debug("[Auth] Ignoring message from unknown topic", e);
        return;
      }
      const o3 = await this.client.core.crypto.decode(e, i3, { receiverPublicKey: s });
      isJsonRpcRequest(o3) ? (this.client.core.history.set(e, o3), this.onRelayEventRequest({ topic: e, payload: o3 })) : isJsonRpcResponse(o3) && (await this.client.core.history.resolve(o3), this.onRelayEventResponse({ topic: e, payload: o3 }));
    });
  }
  registerPairingEvents() {
    this.client.core.pairing.events.on(V.create, (t) => this.onPairingCreated(t));
  }
};
var S = class _S extends H2 {
  constructor(t) {
    super(t), this.protocol = $3, this.version = Q3, this.name = B2, this.events = new import_events4.EventEmitter(), this.emit = (i3, n4) => this.events.emit(i3, n4), this.on = (i3, n4) => this.events.on(i3, n4), this.once = (i3, n4) => this.events.once(i3, n4), this.off = (i3, n4) => this.events.off(i3, n4), this.removeListener = (i3, n4) => this.events.removeListener(i3, n4), this.request = async (i3, n4) => {
      try {
        return await this.engine.request(i3, n4);
      } catch (s) {
        throw this.logger.error(s.message), s;
      }
    }, this.respond = async (i3, n4) => {
      try {
        return await this.engine.respond(i3, n4);
      } catch (s) {
        throw this.logger.error(s.message), s;
      }
    }, this.getPendingRequests = () => {
      try {
        return this.engine.getPendingRequests();
      } catch (i3) {
        throw this.logger.error(i3.message), i3;
      }
    }, this.formatMessage = (i3, n4) => {
      try {
        return this.engine.formatMessage(i3, n4);
      } catch (s) {
        throw this.logger.error(s.message), s;
      }
    };
    const e = typeof t.logger < "u" && typeof t.logger != "string" ? t.logger : (0, import_logger2.pino)((0, import_logger2.getDefaultLoggerOptions)({ level: t.logger || "error" }));
    this.name = (t == null ? void 0 : t.name) || B2, this.metadata = t.metadata, this.projectId = t.projectId, this.core = t.core || new Mr2(t), this.logger = (0, import_logger2.generateChildLogger)(e, this.name), this.authKeys = new Kt2(this.core, this.logger, "authKeys", F3, () => x), this.pairingTopics = new Kt2(this.core, this.logger, "pairingTopics", F3), this.requests = new Kt2(this.core, this.logger, "requests", F3, (i3) => i3.id), this.engine = new Br(this);
  }
  static async init(t) {
    const e = new _S(t);
    return await e.initialize(), e;
  }
  get context() {
    return (0, import_logger2.getLoggerContext)(this.logger);
  }
  async initialize() {
    this.logger.trace("Initialized");
    try {
      await this.core.start(), await this.authKeys.init(), await this.requests.init(), await this.pairingTopics.init(), await this.engine.init(), this.logger.info("AuthClient Initialization Success"), this.logger.info({ authClient: this });
    } catch (t) {
      throw this.logger.info("AuthClient Initialization Failure"), this.logger.error(t.message), t;
    }
  }
};
var zr2 = S;

// node_modules/@walletconnect/web3wallet/node_modules/@walletconnect/sign-client/dist/index.es.js
init_shim();

// node_modules/@walletconnect/web3wallet/node_modules/@walletconnect/core/dist/index.es.js
init_shim();
var import_events7 = __toESM(require_events());
var import_heartbeat2 = __toESM(require_cjs2());
var import_logger3 = __toESM(require_cjs3());

// node_modules/@walletconnect/web3wallet/node_modules/@walletconnect/types/dist/index.es.js
init_shim();
init_esm();
var import_events6 = __toESM(require_events());
var n3 = class extends IEvents {
  constructor(s) {
    super(), this.opts = s, this.protocol = "wc", this.version = 2;
  }
};
var h3 = class extends IEvents {
  constructor(s, t) {
    super(), this.core = s, this.logger = t, this.records = /* @__PURE__ */ new Map();
  }
};
var a2 = class {
  constructor(s, t) {
    this.logger = s, this.core = t;
  }
};
var u2 = class extends IEvents {
  constructor(s, t) {
    super(), this.relayer = s, this.logger = t;
  }
};
var g4 = class extends IEvents {
  constructor(s) {
    super();
  }
};
var p3 = class {
  constructor(s, t, o3, M6) {
    this.core = s, this.logger = t, this.name = o3;
  }
};
var d3 = class extends IEvents {
  constructor(s, t) {
    super(), this.relayer = s, this.logger = t;
  }
};
var E3 = class extends IEvents {
  constructor(s, t) {
    super(), this.core = s, this.logger = t;
  }
};
var y2 = class {
  constructor(s, t) {
    this.projectId = s, this.logger = t;
  }
};
var v3 = class {
  constructor(s, t) {
    this.projectId = s, this.logger = t;
  }
};
var b2 = class {
  constructor(s) {
    this.opts = s, this.protocol = "wc", this.version = 2;
  }
};
var w3 = class {
  constructor(s) {
    this.client = s;
  }
};

// node_modules/@walletconnect/web3wallet/node_modules/@walletconnect/utils/dist/index.es.js
init_shim();
var import_chacha20poly13052 = __toESM(require_chacha20poly1305());
var import_hkdf2 = __toESM(require_hkdf());
var import_random3 = __toESM(require_random());
var import_sha2563 = __toESM(require_sha256());
var fe3 = __toESM(require_x25519());
var import_time4 = __toESM(require_cjs());
var import_window_getters2 = __toESM(require_cjs4());
var import_window_metadata2 = __toESM(require_cjs5());
var M3 = __toESM(require_query_string2());
function L3(e, n4) {
  return e.includes(":") ? [e] : n4.chains || [];
}
var J2 = "base10";
var p4 = "base16";
var F4 = "base64pad";
var H3 = "utf8";
var Q4 = 0;
var _2 = 1;
var Dn2 = 0;
var Te4 = 1;
var Z4 = 12;
var X3 = 32;
function kn2() {
  const e = fe3.generateKeyPair();
  return { privateKey: toString(e.secretKey, p4), publicKey: toString(e.publicKey, p4) };
}
function Vn2() {
  const e = (0, import_random3.randomBytes)(X3);
  return toString(e, p4);
}
function Mn2(e, n4) {
  const t = fe3.sharedKey(fromString(e, p4), fromString(n4, p4), true), r = new import_hkdf2.HKDF(import_sha2563.SHA256, t).expand(X3);
  return toString(r, p4);
}
function Kn2(e) {
  const n4 = (0, import_sha2563.hash)(fromString(e, p4));
  return toString(n4, p4);
}
function Ln2(e) {
  const n4 = (0, import_sha2563.hash)(fromString(e, H3));
  return toString(n4, p4);
}
function Pe2(e) {
  return fromString(`${e}`, J2);
}
function j3(e) {
  return Number(toString(e, J2));
}
function xn2(e) {
  const n4 = Pe2(typeof e.type < "u" ? e.type : Q4);
  if (j3(n4) === _2 && typeof e.senderPublicKey > "u")
    throw new Error("Missing sender public key for type 1 envelope");
  const t = typeof e.senderPublicKey < "u" ? fromString(e.senderPublicKey, p4) : void 0, r = typeof e.iv < "u" ? fromString(e.iv, p4) : (0, import_random3.randomBytes)(Z4), o3 = new import_chacha20poly13052.ChaCha20Poly1305(fromString(e.symKey, p4)).seal(r, fromString(e.message, H3));
  return Re4({ type: n4, sealed: o3, iv: r, senderPublicKey: t });
}
function Fn2(e) {
  const n4 = new import_chacha20poly13052.ChaCha20Poly1305(fromString(e.symKey, p4)), { sealed: t, iv: r } = ee4(e.encoded), o3 = n4.open(r, t);
  if (o3 === null)
    throw new Error("Failed to decrypt");
  return toString(o3, H3);
}
function Re4(e) {
  if (j3(e.type) === _2) {
    if (typeof e.senderPublicKey > "u")
      throw new Error("Missing sender public key for type 1 envelope");
    return toString(concat([e.type, e.senderPublicKey, e.iv, e.sealed]), F4);
  }
  return toString(concat([e.type, e.iv, e.sealed]), F4);
}
function ee4(e) {
  const n4 = fromString(e, F4), t = n4.slice(Dn2, Te4), r = Te4;
  if (j3(t) === _2) {
    const d5 = r + X3, l2 = d5 + Z4, c3 = n4.slice(r, d5), u3 = n4.slice(d5, l2), a3 = n4.slice(l2);
    return { type: t, sealed: a3, iv: u3, senderPublicKey: c3 };
  }
  const o3 = r + Z4, s = n4.slice(r, o3), i3 = n4.slice(o3);
  return { type: t, sealed: i3, iv: s };
}
function Hn2(e, n4) {
  const t = ee4(e);
  return Ae2({ type: j3(t.type), senderPublicKey: typeof t.senderPublicKey < "u" ? toString(t.senderPublicKey, p4) : void 0, receiverPublicKey: n4 == null ? void 0 : n4.receiverPublicKey });
}
function Ae2(e) {
  const n4 = (e == null ? void 0 : e.type) || Q4;
  if (n4 === _2) {
    if (typeof (e == null ? void 0 : e.senderPublicKey) > "u")
      throw new Error("missing sender public key");
    if (typeof (e == null ? void 0 : e.receiverPublicKey) > "u")
      throw new Error("missing receiver public key");
  }
  return { type: n4, senderPublicKey: e == null ? void 0 : e.senderPublicKey, receiverPublicKey: e == null ? void 0 : e.receiverPublicKey };
}
function qn2(e) {
  return e.type === _2 && typeof e.senderPublicKey == "string" && typeof e.receiverPublicKey == "string";
}
var Bn2 = Object.defineProperty;
var Ue3 = Object.getOwnPropertySymbols;
var Gn2 = Object.prototype.hasOwnProperty;
var Wn2 = Object.prototype.propertyIsEnumerable;
var _e3 = (e, n4, t) => n4 in e ? Bn2(e, n4, { enumerable: true, configurable: true, writable: true, value: t }) : e[n4] = t;
var $e3 = (e, n4) => {
  for (var t in n4 || (n4 = {}))
    Gn2.call(n4, t) && _e3(e, t, n4[t]);
  if (Ue3)
    for (var t of Ue3(n4))
      Wn2.call(n4, t) && _e3(e, t, n4[t]);
  return e;
};
var Ce3 = "ReactNative";
var m2 = { reactNative: "react-native", node: "node", browser: "browser", unknown: "unknown" };
var De4 = "js";
function te4() {
  return typeof import_process.default < "u" && typeof import_process.default.versions < "u" && typeof import_process.default.versions.node < "u";
}
function $4() {
  return !(0, import_window_getters2.getDocument)() && !!(0, import_window_getters2.getNavigator)() && navigator.product === Ce3;
}
function D3() {
  return !te4() && !!(0, import_window_getters2.getNavigator)() && !!(0, import_window_getters2.getDocument)();
}
function R4() {
  return $4() ? m2.reactNative : te4() ? m2.node : D3() ? m2.browser : m2.unknown;
}
function Jn2() {
  var e;
  try {
    return $4() && typeof global < "u" && typeof (global == null ? void 0 : global.Application) < "u" ? (e = global.Application) == null ? void 0 : e.applicationId : void 0;
  } catch {
    return;
  }
}
function ke4(e, n4) {
  let t = M3.parse(e);
  return t = $e3($e3({}, t), n4), e = M3.stringify(t), e;
}
function Qn() {
  return (0, import_window_metadata2.getWindowMetadata)() || { name: "", description: "", url: "", icons: [""] };
}
function Ve3() {
  if (R4() === m2.reactNative && typeof global < "u" && typeof (global == null ? void 0 : global.Platform) < "u") {
    const { OS: t, Version: r } = global.Platform;
    return [t, r].join("-");
  }
  const e = detect();
  if (e === null)
    return "unknown";
  const n4 = e.os ? e.os.replace(" ", "").toLowerCase() : "unknown";
  return e.type === "browser" ? [n4, e.name, e.version].join("-") : [n4, e.version].join("-");
}
function Me3() {
  var e;
  const n4 = R4();
  return n4 === m2.browser ? [n4, ((e = (0, import_window_getters2.getLocation)()) == null ? void 0 : e.host) || "unknown"].join(":") : n4;
}
function Ke4(e, n4, t) {
  const r = Ve3(), o3 = Me3();
  return [[e, n4].join("-"), [De4, t].join("-"), r, o3].join("/");
}
function Xn2({ protocol: e, version: n4, relayUrl: t, sdkVersion: r, auth: o3, projectId: s, useOnCloseEvent: i3, bundleId: d5 }) {
  const l2 = t.split("?"), c3 = Ke4(e, n4, r), u3 = { auth: o3, ua: c3, projectId: s, useOnCloseEvent: i3 || void 0, origin: d5 || void 0 }, a3 = ke4(l2[1] || "", u3);
  return l2[0] + "?" + a3;
}
function O3(e, n4) {
  return e.filter((t) => n4.includes(t)).length === e.length;
}
function rt4(e) {
  return Object.fromEntries(e.entries());
}
function ot4(e) {
  return new Map(Object.entries(e));
}
function at4(e = import_time4.FIVE_MINUTES, n4) {
  const t = (0, import_time4.toMiliseconds)(e || import_time4.FIVE_MINUTES);
  let r, o3, s;
  return { resolve: (i3) => {
    s && r && (clearTimeout(s), r(i3));
  }, reject: (i3) => {
    s && o3 && (clearTimeout(s), o3(i3));
  }, done: () => new Promise((i3, d5) => {
    s = setTimeout(() => {
      d5(new Error(n4));
    }, t), r = i3, o3 = d5;
  }) };
}
function ut4(e, n4, t) {
  return new Promise(async (r, o3) => {
    const s = setTimeout(() => o3(new Error(t)), n4);
    try {
      const i3 = await e;
      r(i3);
    } catch (i3) {
      o3(i3);
    }
    clearTimeout(s);
  });
}
function re3(e, n4) {
  if (typeof n4 == "string" && n4.startsWith(`${e}:`))
    return n4;
  if (e.toLowerCase() === "topic") {
    if (typeof n4 != "string")
      throw new Error('Value must be "string" for expirer target type: topic');
    return `topic:${n4}`;
  } else if (e.toLowerCase() === "id") {
    if (typeof n4 != "number")
      throw new Error('Value must be "number" for expirer target type: id');
    return `id:${n4}`;
  }
  throw new Error(`Unknown expirer target type: ${e}`);
}
function lt4(e) {
  return re3("topic", e);
}
function dt4(e) {
  return re3("id", e);
}
function ft4(e) {
  const [n4, t] = e.split(":"), r = { id: void 0, topic: void 0 };
  if (n4 === "topic" && typeof t == "string")
    r.topic = t;
  else if (n4 === "id" && Number.isInteger(Number(t)))
    r.id = Number(t);
  else
    throw new Error(`Invalid target, expected id:number or topic:string, got ${n4}:${t}`);
  return r;
}
function pt4(e, n4) {
  return (0, import_time4.fromMiliseconds)((n4 || Date.now()) + (0, import_time4.toMiliseconds)(e));
}
function mt4(e) {
  return Date.now() >= (0, import_time4.toMiliseconds)(e);
}
function yt4(e, n4) {
  return `${e}${n4 ? `:${n4}` : ""}`;
}
async function gt3({ id: e, topic: n4, wcDeepLink: t }) {
  try {
    if (!t)
      return;
    const r = typeof t == "string" ? JSON.parse(t) : t;
    let o3 = r == null ? void 0 : r.href;
    if (typeof o3 != "string")
      return;
    o3.endsWith("/") && (o3 = o3.slice(0, -1));
    const s = `${o3}/wc?requestId=${e}&sessionTopic=${n4}`, i3 = R4();
    i3 === m2.browser ? s.startsWith("https://") ? window.open(s, "_blank", "noreferrer noopener") : window.open(s, "_self", "noreferrer noopener") : i3 === m2.reactNative && typeof (global == null ? void 0 : global.Linking) < "u" && await global.Linking.openURL(s);
  } catch (r) {
    console.error(r);
  }
}
async function ht3(e, n4) {
  try {
    return await e.getItem(n4) || (D3() ? localStorage.getItem(n4) : void 0);
  } catch (t) {
    console.error(t);
  }
}
var He3 = "irn";
function vt4(e) {
  return (e == null ? void 0 : e.relay) || { protocol: He3 };
}
function Et4(e) {
  const n4 = RELAY_JSONRPC[e];
  if (typeof n4 > "u")
    throw new Error(`Relay Protocol not supported: ${e}`);
  return n4;
}
var bt4 = Object.defineProperty;
var Nt4 = Object.defineProperties;
var Ot4 = Object.getOwnPropertyDescriptors;
var qe3 = Object.getOwnPropertySymbols;
var St4 = Object.prototype.hasOwnProperty;
var wt4 = Object.prototype.propertyIsEnumerable;
var Be3 = (e, n4, t) => n4 in e ? bt4(e, n4, { enumerable: true, configurable: true, writable: true, value: t }) : e[n4] = t;
var It4 = (e, n4) => {
  for (var t in n4 || (n4 = {}))
    St4.call(n4, t) && Be3(e, t, n4[t]);
  if (qe3)
    for (var t of qe3(n4))
      wt4.call(n4, t) && Be3(e, t, n4[t]);
  return e;
};
var Tt4 = (e, n4) => Nt4(e, Ot4(n4));
function Ge3(e, n4 = "-") {
  const t = {}, r = "relay" + n4;
  return Object.keys(e).forEach((o3) => {
    if (o3.startsWith(r)) {
      const s = o3.replace(r, ""), i3 = e[o3];
      t[s] = i3;
    }
  }), t;
}
function Pt4(e) {
  e = e.includes("wc://") ? e.replace("wc://", "") : e, e = e.includes("wc:") ? e.replace("wc:", "") : e;
  const n4 = e.indexOf(":"), t = e.indexOf("?") !== -1 ? e.indexOf("?") : void 0, r = e.substring(0, n4), o3 = e.substring(n4 + 1, t).split("@"), s = typeof t < "u" ? e.substring(t) : "", i3 = M3.parse(s);
  return { protocol: r, topic: We4(o3[0]), version: parseInt(o3[1], 10), symKey: i3.symKey, relay: Ge3(i3), expiryTimestamp: i3.expiryTimestamp ? parseInt(i3.expiryTimestamp, 10) : void 0 };
}
function We4(e) {
  return e.startsWith("//") ? e.substring(2) : e;
}
function ze2(e, n4 = "-") {
  const t = "relay", r = {};
  return Object.keys(e).forEach((o3) => {
    const s = t + n4 + o3;
    e[o3] && (r[s] = e[o3]);
  }), r;
}
function Rt4(e) {
  return `${e.protocol}:${e.topic}@${e.version}?` + M3.stringify(Tt4(It4({ symKey: e.symKey }, ze2(e.relay)), { expiryTimestamp: e.expiryTimestamp }));
}
function A(e) {
  const n4 = [];
  return e.forEach((t) => {
    const [r, o3] = t.split(":");
    n4.push(`${r}:${o3}`);
  }), n4;
}
function Qe2(e) {
  const n4 = [];
  return Object.values(e).forEach((t) => {
    n4.push(...A(t.accounts));
  }), n4;
}
function Ze3(e, n4) {
  const t = [];
  return Object.values(e).forEach((r) => {
    A(r.accounts).includes(n4) && t.push(...r.methods);
  }), t;
}
function Xe3(e, n4) {
  const t = [];
  return Object.values(e).forEach((r) => {
    A(r.accounts).includes(n4) && t.push(...r.events);
  }), t;
}
var nn2 = { INVALID_METHOD: { message: "Invalid method.", code: 1001 }, INVALID_EVENT: { message: "Invalid event.", code: 1002 }, INVALID_UPDATE_REQUEST: { message: "Invalid update request.", code: 1003 }, INVALID_EXTEND_REQUEST: { message: "Invalid extend request.", code: 1004 }, INVALID_SESSION_SETTLE_REQUEST: { message: "Invalid session settle request.", code: 1005 }, UNAUTHORIZED_METHOD: { message: "Unauthorized method.", code: 3001 }, UNAUTHORIZED_EVENT: { message: "Unauthorized event.", code: 3002 }, UNAUTHORIZED_UPDATE_REQUEST: { message: "Unauthorized update request.", code: 3003 }, UNAUTHORIZED_EXTEND_REQUEST: { message: "Unauthorized extend request.", code: 3004 }, USER_REJECTED: { message: "User rejected.", code: 5e3 }, USER_REJECTED_CHAINS: { message: "User rejected chains.", code: 5001 }, USER_REJECTED_METHODS: { message: "User rejected methods.", code: 5002 }, USER_REJECTED_EVENTS: { message: "User rejected events.", code: 5003 }, UNSUPPORTED_CHAINS: { message: "Unsupported chains.", code: 5100 }, UNSUPPORTED_METHODS: { message: "Unsupported methods.", code: 5101 }, UNSUPPORTED_EVENTS: { message: "Unsupported events.", code: 5102 }, UNSUPPORTED_ACCOUNTS: { message: "Unsupported accounts.", code: 5103 }, UNSUPPORTED_NAMESPACE_KEY: { message: "Unsupported namespace key.", code: 5104 }, USER_DISCONNECTED: { message: "User disconnected.", code: 6e3 }, SESSION_SETTLEMENT_FAILED: { message: "Session settlement failed.", code: 7e3 }, WC_METHOD_UNSUPPORTED: { message: "Unsupported wc_ method.", code: 10001 } };
var tn2 = { NOT_INITIALIZED: { message: "Not initialized.", code: 1 }, NO_MATCHING_KEY: { message: "No matching key.", code: 2 }, RESTORE_WILL_OVERRIDE: { message: "Restore will override.", code: 3 }, RESUBSCRIBED: { message: "Resubscribed.", code: 4 }, MISSING_OR_INVALID: { message: "Missing or invalid.", code: 5 }, EXPIRED: { message: "Expired.", code: 6 }, UNKNOWN_TYPE: { message: "Unknown type.", code: 7 }, MISMATCHED_TOPIC: { message: "Mismatched topic.", code: 8 }, NON_CONFORMING_NAMESPACES: { message: "Non conforming namespaces.", code: 9 } };
function N4(e, n4) {
  const { message: t, code: r } = tn2[e];
  return { message: n4 ? `${t} ${n4}` : t, code: r };
}
function U4(e, n4) {
  const { message: t, code: r } = nn2[e];
  return { message: n4 ? `${t} ${n4}` : t, code: r };
}
function k2(e, n4) {
  return Array.isArray(e) ? typeof n4 < "u" && e.length ? e.every(n4) : true : false;
}
function B3(e) {
  return Object.getPrototypeOf(e) === Object.prototype && Object.keys(e).length;
}
function w4(e) {
  return typeof e > "u";
}
function g5(e, n4) {
  return n4 && w4(e) ? true : typeof e == "string" && !!e.trim().length;
}
function G4(e, n4) {
  return n4 && w4(e) ? true : typeof e == "number" && !isNaN(e);
}
function Mt3(e, n4) {
  const { requiredNamespaces: t } = n4, r = Object.keys(e.namespaces), o3 = Object.keys(t);
  let s = true;
  return O3(o3, r) ? (r.forEach((i3) => {
    const { accounts: d5, methods: l2, events: c3 } = e.namespaces[i3], u3 = A(d5), a3 = t[i3];
    (!O3(L3(i3, a3), u3) || !O3(a3.methods, l2) || !O3(a3.events, c3)) && (s = false);
  }), s) : false;
}
function V3(e) {
  return g5(e, false) && e.includes(":") ? e.split(":").length === 2 : false;
}
function rn(e) {
  if (g5(e, false) && e.includes(":")) {
    const n4 = e.split(":");
    if (n4.length === 3) {
      const t = n4[0] + ":" + n4[1];
      return !!n4[2] && V3(t);
    }
  }
  return false;
}
function Kt4(e) {
  if (g5(e, false))
    try {
      return typeof new URL(e) < "u";
    } catch {
      return false;
    }
  return false;
}
function Lt4(e) {
  var n4;
  return (n4 = e == null ? void 0 : e.proposer) == null ? void 0 : n4.publicKey;
}
function xt4(e) {
  return e == null ? void 0 : e.topic;
}
function Ft3(e, n4) {
  let t = null;
  return g5(e == null ? void 0 : e.publicKey, false) || (t = N4("MISSING_OR_INVALID", `${n4} controller public key should be a string`)), t;
}
function ie2(e) {
  let n4 = true;
  return k2(e) ? e.length && (n4 = e.every((t) => g5(t, false))) : n4 = false, n4;
}
function on(e, n4, t) {
  let r = null;
  return k2(n4) && n4.length ? n4.forEach((o3) => {
    r || V3(o3) || (r = U4("UNSUPPORTED_CHAINS", `${t}, chain ${o3} should be a string and conform to "namespace:chainId" format`));
  }) : V3(e) || (r = U4("UNSUPPORTED_CHAINS", `${t}, chains must be defined as "namespace:chainId" e.g. "eip155:1": {...} in the namespace key OR as an array of CAIP-2 chainIds e.g. eip155: { chains: ["eip155:1", "eip155:5"] }`)), r;
}
function sn(e, n4, t) {
  let r = null;
  return Object.entries(e).forEach(([o3, s]) => {
    if (r)
      return;
    const i3 = on(o3, L3(o3, s), `${n4} ${t}`);
    i3 && (r = i3);
  }), r;
}
function cn(e, n4) {
  let t = null;
  return k2(e) ? e.forEach((r) => {
    t || rn(r) || (t = U4("UNSUPPORTED_ACCOUNTS", `${n4}, account ${r} should be a string and conform to "namespace:chainId:address" format`));
  }) : t = U4("UNSUPPORTED_ACCOUNTS", `${n4}, accounts should be an array of strings conforming to "namespace:chainId:address" format`), t;
}
function an(e, n4) {
  let t = null;
  return Object.values(e).forEach((r) => {
    if (t)
      return;
    const o3 = cn(r == null ? void 0 : r.accounts, `${n4} namespace`);
    o3 && (t = o3);
  }), t;
}
function un(e, n4) {
  let t = null;
  return ie2(e == null ? void 0 : e.methods) ? ie2(e == null ? void 0 : e.events) || (t = U4("UNSUPPORTED_EVENTS", `${n4}, events should be an array of strings or empty array for no events`)) : t = U4("UNSUPPORTED_METHODS", `${n4}, methods should be an array of strings or empty array for no methods`), t;
}
function ce3(e, n4) {
  let t = null;
  return Object.values(e).forEach((r) => {
    if (t)
      return;
    const o3 = un(r, `${n4}, namespace`);
    o3 && (t = o3);
  }), t;
}
function Ht3(e, n4, t) {
  let r = null;
  if (e && B3(e)) {
    const o3 = ce3(e, n4);
    o3 && (r = o3);
    const s = sn(e, n4, t);
    s && (r = s);
  } else
    r = N4("MISSING_OR_INVALID", `${n4}, ${t} should be an object with data`);
  return r;
}
function ln(e, n4) {
  let t = null;
  if (e && B3(e)) {
    const r = ce3(e, n4);
    r && (t = r);
    const o3 = an(e, n4);
    o3 && (t = o3);
  } else
    t = N4("MISSING_OR_INVALID", `${n4}, namespaces should be an object with data`);
  return t;
}
function dn(e) {
  return g5(e.protocol, true);
}
function qt3(e, n4) {
  let t = false;
  return n4 && !e ? t = true : e && k2(e) && e.length && e.forEach((r) => {
    t = dn(r);
  }), t;
}
function Bt3(e) {
  return typeof e == "number";
}
function Gt4(e) {
  return typeof e < "u" && typeof e !== null;
}
function Wt2(e) {
  return !(!e || typeof e != "object" || !e.code || !G4(e.code, false) || !e.message || !g5(e.message, false));
}
function zt3(e) {
  return !(w4(e) || !g5(e.method, false));
}
function Yt3(e) {
  return !(w4(e) || w4(e.result) && w4(e.error) || !G4(e.id, false) || !g5(e.jsonrpc, false));
}
function Jt3(e) {
  return !(w4(e) || !g5(e.name, false));
}
function Qt3(e, n4) {
  return !(!V3(n4) || !Qe2(e).includes(n4));
}
function Zt2(e, n4, t) {
  return g5(t, false) ? Ze3(e, n4).includes(t) : false;
}
function Xt3(e, n4, t) {
  return g5(t, false) ? Xe3(e, n4).includes(t) : false;
}
function fn(e, n4, t) {
  let r = null;
  const o3 = er3(e), s = nr3(n4), i3 = Object.keys(o3), d5 = Object.keys(s), l2 = pn(Object.keys(e)), c3 = pn(Object.keys(n4)), u3 = l2.filter((a3) => !c3.includes(a3));
  return u3.length && (r = N4("NON_CONFORMING_NAMESPACES", `${t} namespaces keys don't satisfy requiredNamespaces.
      Required: ${u3.toString()}
      Received: ${Object.keys(n4).toString()}`)), O3(i3, d5) || (r = N4("NON_CONFORMING_NAMESPACES", `${t} namespaces chains don't satisfy required namespaces.
      Required: ${i3.toString()}
      Approved: ${d5.toString()}`)), Object.keys(n4).forEach((a3) => {
    if (!a3.includes(":") || r)
      return;
    const b5 = A(n4[a3].accounts);
    b5.includes(a3) || (r = N4("NON_CONFORMING_NAMESPACES", `${t} namespaces accounts don't satisfy namespace accounts for ${a3}
        Required: ${a3}
        Approved: ${b5.toString()}`));
  }), i3.forEach((a3) => {
    r || (O3(o3[a3].methods, s[a3].methods) ? O3(o3[a3].events, s[a3].events) || (r = N4("NON_CONFORMING_NAMESPACES", `${t} namespaces events don't satisfy namespace events for ${a3}`)) : r = N4("NON_CONFORMING_NAMESPACES", `${t} namespaces methods don't satisfy namespace methods for ${a3}`));
  }), r;
}
function er3(e) {
  const n4 = {};
  return Object.keys(e).forEach((t) => {
    var r;
    t.includes(":") ? n4[t] = e[t] : (r = e[t].chains) == null || r.forEach((o3) => {
      n4[o3] = { methods: e[t].methods, events: e[t].events };
    });
  }), n4;
}
function pn(e) {
  return [...new Set(e.map((n4) => n4.includes(":") ? n4.split(":")[0] : n4))];
}
function nr3(e) {
  const n4 = {};
  return Object.keys(e).forEach((t) => {
    if (t.includes(":"))
      n4[t] = e[t];
    else {
      const r = A(e[t].accounts);
      r == null ? void 0 : r.forEach((o3) => {
        n4[o3] = { accounts: e[t].accounts.filter((s) => s.includes(`${o3}:`)), methods: e[t].methods, events: e[t].events };
      });
    }
  }), n4;
}
function tr4(e, n4) {
  return G4(e, false) && e <= n4.max && e >= n4.min;
}
function rr4() {
  const e = R4();
  return new Promise((n4) => {
    switch (e) {
      case m2.browser:
        n4(mn2());
        break;
      case m2.reactNative:
        n4(yn2());
        break;
      case m2.node:
        n4(gn2());
        break;
      default:
        n4(true);
    }
  });
}
function mn2() {
  return D3() && (navigator == null ? void 0 : navigator.onLine);
}
async function yn2() {
  if ($4() && typeof global < "u" && global != null && global.NetInfo) {
    const e = await (global == null ? void 0 : global.NetInfo.fetch());
    return e == null ? void 0 : e.isConnected;
  }
  return true;
}
function gn2() {
  return true;
}
function or4(e) {
  switch (R4()) {
    case m2.browser:
      hn2(e);
      break;
    case m2.reactNative:
      vn2(e);
      break;
    case m2.node:
      break;
  }
}
function hn2(e) {
  !$4() && D3() && (window.addEventListener("online", () => e(true)), window.addEventListener("offline", () => e(false)));
}
function vn2(e) {
  var _a;
  $4() && typeof global < "u" && global != null && global.NetInfo && ((_a = global) == null ? void 0 : _a.NetInfo.addEventListener((n4) => e(n4 == null ? void 0 : n4.isConnected)));
}
var ae2 = {};
var sr3 = class {
  static get(n4) {
    return ae2[n4];
  }
  static set(n4, t) {
    ae2[n4] = t;
  }
  static delete(n4) {
    delete ae2[n4];
  }
};

// node_modules/@walletconnect/web3wallet/node_modules/@walletconnect/core/dist/index.es.js
var import_time5 = __toESM(require_cjs());
var import_lodash2 = __toESM(require_lodash());
var import_isomorphic_unfetch3 = __toESM(require_browser());
function Hi2(n4, e) {
  if (n4.length >= 255)
    throw new TypeError("Alphabet too long");
  for (var t = new Uint8Array(256), i3 = 0; i3 < t.length; i3++)
    t[i3] = 255;
  for (var s = 0; s < n4.length; s++) {
    var r = n4.charAt(s), o3 = r.charCodeAt(0);
    if (t[o3] !== 255)
      throw new TypeError(r + " is ambiguous");
    t[o3] = s;
  }
  var a3 = n4.length, h5 = n4.charAt(0), l2 = Math.log(a3) / Math.log(256), d5 = Math.log(256) / Math.log(a3);
  function p6(u3) {
    if (u3 instanceof Uint8Array || (ArrayBuffer.isView(u3) ? u3 = new Uint8Array(u3.buffer, u3.byteOffset, u3.byteLength) : Array.isArray(u3) && (u3 = Uint8Array.from(u3))), !(u3 instanceof Uint8Array))
      throw new TypeError("Expected Uint8Array");
    if (u3.length === 0)
      return "";
    for (var m3 = 0, z3 = 0, I4 = 0, _4 = u3.length; I4 !== _4 && u3[I4] === 0; )
      I4++, m3++;
    for (var T2 = (_4 - I4) * d5 + 1 >>> 0, f3 = new Uint8Array(T2); I4 !== _4; ) {
      for (var S3 = u3[I4], A3 = 0, C2 = T2 - 1; (S3 !== 0 || A3 < z3) && C2 !== -1; C2--, A3++)
        S3 += 256 * f3[C2] >>> 0, f3[C2] = S3 % a3 >>> 0, S3 = S3 / a3 >>> 0;
      if (S3 !== 0)
        throw new Error("Non-zero carry");
      z3 = A3, I4++;
    }
    for (var x4 = T2 - z3; x4 !== T2 && f3[x4] === 0; )
      x4++;
    for (var j4 = h5.repeat(m3); x4 < T2; ++x4)
      j4 += n4.charAt(f3[x4]);
    return j4;
  }
  function y4(u3) {
    if (typeof u3 != "string")
      throw new TypeError("Expected String");
    if (u3.length === 0)
      return new Uint8Array();
    var m3 = 0;
    if (u3[m3] !== " ") {
      for (var z3 = 0, I4 = 0; u3[m3] === h5; )
        z3++, m3++;
      for (var _4 = (u3.length - m3) * l2 + 1 >>> 0, T2 = new Uint8Array(_4); u3[m3]; ) {
        var f3 = t[u3.charCodeAt(m3)];
        if (f3 === 255)
          return;
        for (var S3 = 0, A3 = _4 - 1; (f3 !== 0 || S3 < I4) && A3 !== -1; A3--, S3++)
          f3 += a3 * T2[A3] >>> 0, T2[A3] = f3 % 256 >>> 0, f3 = f3 / 256 >>> 0;
        if (f3 !== 0)
          throw new Error("Non-zero carry");
        I4 = S3, m3++;
      }
      if (u3[m3] !== " ") {
        for (var C2 = _4 - I4; C2 !== _4 && T2[C2] === 0; )
          C2++;
        for (var x4 = new Uint8Array(z3 + (_4 - C2)), j4 = z3; C2 !== _4; )
          x4[j4++] = T2[C2++];
        return x4;
      }
    }
  }
  function M6(u3) {
    var m3 = y4(u3);
    if (m3)
      return m3;
    throw new Error(`Non-${e} character`);
  }
  return { encode: p6, decodeUnsafe: y4, decode: M6 };
}
var Ji2 = Hi2;
var Xi2 = Ji2;
var Ne2 = (n4) => {
  if (n4 instanceof Uint8Array && n4.constructor.name === "Uint8Array")
    return n4;
  if (n4 instanceof ArrayBuffer)
    return new Uint8Array(n4);
  if (ArrayBuffer.isView(n4))
    return new Uint8Array(n4.buffer, n4.byteOffset, n4.byteLength);
  throw new Error("Unknown type, must be binary type");
};
var Wi2 = (n4) => new TextEncoder().encode(n4);
var Qi2 = (n4) => new TextDecoder().decode(n4);
var Zi2 = class {
  constructor(e, t, i3) {
    this.name = e, this.prefix = t, this.baseEncode = i3;
  }
  encode(e) {
    if (e instanceof Uint8Array)
      return `${this.prefix}${this.baseEncode(e)}`;
    throw Error("Unknown type, must be binary type");
  }
};
var es2 = class {
  constructor(e, t, i3) {
    if (this.name = e, this.prefix = t, t.codePointAt(0) === void 0)
      throw new Error("Invalid prefix character");
    this.prefixCodePoint = t.codePointAt(0), this.baseDecode = i3;
  }
  decode(e) {
    if (typeof e == "string") {
      if (e.codePointAt(0) !== this.prefixCodePoint)
        throw Error(`Unable to decode multibase string ${JSON.stringify(e)}, ${this.name} decoder only supports inputs prefixed with ${this.prefix}`);
      return this.baseDecode(e.slice(this.prefix.length));
    } else
      throw Error("Can only multibase decode strings");
  }
  or(e) {
    return Ue4(this, e);
  }
};
var ts2 = class {
  constructor(e) {
    this.decoders = e;
  }
  or(e) {
    return Ue4(this, e);
  }
  decode(e) {
    const t = e[0], i3 = this.decoders[t];
    if (i3)
      return i3.decode(e);
    throw RangeError(`Unable to decode multibase string ${JSON.stringify(e)}, only inputs prefixed with ${Object.keys(this.decoders)} are supported`);
  }
};
var Ue4 = (n4, e) => new ts2({ ...n4.decoders || { [n4.prefix]: n4 }, ...e.decoders || { [e.prefix]: e } });
var is2 = class {
  constructor(e, t, i3, s) {
    this.name = e, this.prefix = t, this.baseEncode = i3, this.baseDecode = s, this.encoder = new Zi2(e, t, i3), this.decoder = new es2(e, t, s);
  }
  encode(e) {
    return this.encoder.encode(e);
  }
  decode(e) {
    return this.decoder.decode(e);
  }
};
var W5 = ({ name: n4, prefix: e, encode: t, decode: i3 }) => new is2(n4, e, t, i3);
var B4 = ({ prefix: n4, name: e, alphabet: t }) => {
  const { encode: i3, decode: s } = Xi2(t, e);
  return W5({ prefix: n4, name: e, encode: i3, decode: (r) => Ne2(s(r)) });
};
var ss2 = (n4, e, t, i3) => {
  const s = {};
  for (let d5 = 0; d5 < e.length; ++d5)
    s[e[d5]] = d5;
  let r = n4.length;
  for (; n4[r - 1] === "="; )
    --r;
  const o3 = new Uint8Array(r * t / 8 | 0);
  let a3 = 0, h5 = 0, l2 = 0;
  for (let d5 = 0; d5 < r; ++d5) {
    const p6 = s[n4[d5]];
    if (p6 === void 0)
      throw new SyntaxError(`Non-${i3} character`);
    h5 = h5 << t | p6, a3 += t, a3 >= 8 && (a3 -= 8, o3[l2++] = 255 & h5 >> a3);
  }
  if (a3 >= t || 255 & h5 << 8 - a3)
    throw new SyntaxError("Unexpected end of data");
  return o3;
};
var rs2 = (n4, e, t) => {
  const i3 = e[e.length - 1] === "=", s = (1 << t) - 1;
  let r = "", o3 = 0, a3 = 0;
  for (let h5 = 0; h5 < n4.length; ++h5)
    for (a3 = a3 << 8 | n4[h5], o3 += 8; o3 > t; )
      o3 -= t, r += e[s & a3 >> o3];
  if (o3 && (r += e[s & a3 << t - o3]), i3)
    for (; r.length * t & 7; )
      r += "=";
  return r;
};
var g6 = ({ name: n4, prefix: e, bitsPerChar: t, alphabet: i3 }) => W5({ prefix: e, name: n4, encode(s) {
  return rs2(s, i3, t);
}, decode(s) {
  return ss2(s, i3, t, n4);
} });
var ns2 = W5({ prefix: "\0", name: "identity", encode: (n4) => Qi2(n4), decode: (n4) => Wi2(n4) });
var os2 = Object.freeze({ __proto__: null, identity: ns2 });
var as2 = g6({ prefix: "0", name: "base2", alphabet: "01", bitsPerChar: 1 });
var hs2 = Object.freeze({ __proto__: null, base2: as2 });
var cs2 = g6({ prefix: "7", name: "base8", alphabet: "01234567", bitsPerChar: 3 });
var us2 = Object.freeze({ __proto__: null, base8: cs2 });
var ls2 = B4({ prefix: "9", name: "base10", alphabet: "0123456789" });
var ds2 = Object.freeze({ __proto__: null, base10: ls2 });
var gs2 = g6({ prefix: "f", name: "base16", alphabet: "0123456789abcdef", bitsPerChar: 4 });
var ps2 = g6({ prefix: "F", name: "base16upper", alphabet: "0123456789ABCDEF", bitsPerChar: 4 });
var Ds2 = Object.freeze({ __proto__: null, base16: gs2, base16upper: ps2 });
var ys2 = g6({ prefix: "b", name: "base32", alphabet: "abcdefghijklmnopqrstuvwxyz234567", bitsPerChar: 5 });
var ms2 = g6({ prefix: "B", name: "base32upper", alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZ234567", bitsPerChar: 5 });
var bs2 = g6({ prefix: "c", name: "base32pad", alphabet: "abcdefghijklmnopqrstuvwxyz234567=", bitsPerChar: 5 });
var fs2 = g6({ prefix: "C", name: "base32padupper", alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZ234567=", bitsPerChar: 5 });
var Es2 = g6({ prefix: "v", name: "base32hex", alphabet: "0123456789abcdefghijklmnopqrstuv", bitsPerChar: 5 });
var ws2 = g6({ prefix: "V", name: "base32hexupper", alphabet: "0123456789ABCDEFGHIJKLMNOPQRSTUV", bitsPerChar: 5 });
var vs2 = g6({ prefix: "t", name: "base32hexpad", alphabet: "0123456789abcdefghijklmnopqrstuv=", bitsPerChar: 5 });
var Is2 = g6({ prefix: "T", name: "base32hexpadupper", alphabet: "0123456789ABCDEFGHIJKLMNOPQRSTUV=", bitsPerChar: 5 });
var Cs2 = g6({ prefix: "h", name: "base32z", alphabet: "ybndrfg8ejkmcpqxot1uwisza345h769", bitsPerChar: 5 });
var Rs2 = Object.freeze({ __proto__: null, base32: ys2, base32upper: ms2, base32pad: bs2, base32padupper: fs2, base32hex: Es2, base32hexupper: ws2, base32hexpad: vs2, base32hexpadupper: Is2, base32z: Cs2 });
var _s2 = B4({ prefix: "k", name: "base36", alphabet: "0123456789abcdefghijklmnopqrstuvwxyz" });
var Ts2 = B4({ prefix: "K", name: "base36upper", alphabet: "0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ" });
var Ss2 = Object.freeze({ __proto__: null, base36: _s2, base36upper: Ts2 });
var Ps2 = B4({ name: "base58btc", prefix: "z", alphabet: "123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz" });
var xs2 = B4({ name: "base58flickr", prefix: "Z", alphabet: "123456789abcdefghijkmnopqrstuvwxyzABCDEFGHJKLMNPQRSTUVWXYZ" });
var Os2 = Object.freeze({ __proto__: null, base58btc: Ps2, base58flickr: xs2 });
var As2 = g6({ prefix: "m", name: "base64", alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/", bitsPerChar: 6 });
var zs2 = g6({ prefix: "M", name: "base64pad", alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=", bitsPerChar: 6 });
var Ns2 = g6({ prefix: "u", name: "base64url", alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_", bitsPerChar: 6 });
var Us2 = g6({ prefix: "U", name: "base64urlpad", alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_=", bitsPerChar: 6 });
var Ls2 = Object.freeze({ __proto__: null, base64: As2, base64pad: zs2, base64url: Ns2, base64urlpad: Us2 });
var Le3 = Array.from("🚀🪐☄🛰🌌🌑🌒🌓🌔🌕🌖🌗🌘🌍🌏🌎🐉☀💻🖥💾💿😂❤😍🤣😊🙏💕😭😘👍😅👏😁🔥🥰💔💖💙😢🤔😆🙄💪😉☺👌🤗💜😔😎😇🌹🤦🎉💞✌✨🤷😱😌🌸🙌😋💗💚😏💛🙂💓🤩😄😀🖤😃💯🙈👇🎶😒🤭❣😜💋👀😪😑💥🙋😞😩😡🤪👊🥳😥🤤👉💃😳✋😚😝😴🌟😬🙃🍀🌷😻😓⭐✅🥺🌈😈🤘💦✔😣🏃💐☹🎊💘😠☝😕🌺🎂🌻😐🖕💝🙊😹🗣💫💀👑🎵🤞😛🔴😤🌼😫⚽🤙☕🏆🤫👈😮🙆🍻🍃🐶💁😲🌿🧡🎁⚡🌞🎈❌✊👋😰🤨😶🤝🚶💰🍓💢🤟🙁🚨💨🤬✈🎀🍺🤓😙💟🌱😖👶🥴▶➡❓💎💸⬇😨🌚🦋😷🕺⚠🙅😟😵👎🤲🤠🤧📌🔵💅🧐🐾🍒😗🤑🌊🤯🐷☎💧😯💆👆🎤🙇🍑❄🌴💣🐸💌📍🥀🤢👅💡💩👐📸👻🤐🤮🎼🥵🚩🍎🍊👼💍📣🥂");
var $s2 = Le3.reduce((n4, e, t) => (n4[t] = e, n4), []);
var Fs2 = Le3.reduce((n4, e, t) => (n4[e.codePointAt(0)] = t, n4), []);
function Ms2(n4) {
  return n4.reduce((e, t) => (e += $s2[t], e), "");
}
function ks2(n4) {
  const e = [];
  for (const t of n4) {
    const i3 = Fs2[t.codePointAt(0)];
    if (i3 === void 0)
      throw new Error(`Non-base256emoji character: ${t}`);
    e.push(i3);
  }
  return new Uint8Array(e);
}
var Ks2 = W5({ prefix: "🚀", name: "base256emoji", encode: Ms2, decode: ks2 });
var Bs2 = Object.freeze({ __proto__: null, base256emoji: Ks2 });
var Vs2 = Fe3;
var $e4 = 128;
var qs2 = 127;
var js2 = ~qs2;
var Gs2 = Math.pow(2, 31);
function Fe3(n4, e, t) {
  e = e || [], t = t || 0;
  for (var i3 = t; n4 >= Gs2; )
    e[t++] = n4 & 255 | $e4, n4 /= 128;
  for (; n4 & js2; )
    e[t++] = n4 & 255 | $e4, n4 >>>= 7;
  return e[t] = n4 | 0, Fe3.bytes = t - i3 + 1, e;
}
var Ys2 = he5;
var Hs2 = 128;
var Me4 = 127;
function he5(n4, i3) {
  var t = 0, i3 = i3 || 0, s = 0, r = i3, o3, a3 = n4.length;
  do {
    if (r >= a3)
      throw he5.bytes = 0, new RangeError("Could not decode varint");
    o3 = n4[r++], t += s < 28 ? (o3 & Me4) << s : (o3 & Me4) * Math.pow(2, s), s += 7;
  } while (o3 >= Hs2);
  return he5.bytes = r - i3, t;
}
var Js2 = Math.pow(2, 7);
var Xs2 = Math.pow(2, 14);
var Ws2 = Math.pow(2, 21);
var Qs2 = Math.pow(2, 28);
var Zs2 = Math.pow(2, 35);
var er4 = Math.pow(2, 42);
var tr5 = Math.pow(2, 49);
var ir3 = Math.pow(2, 56);
var sr4 = Math.pow(2, 63);
var rr5 = function(n4) {
  return n4 < Js2 ? 1 : n4 < Xs2 ? 2 : n4 < Ws2 ? 3 : n4 < Qs2 ? 4 : n4 < Zs2 ? 5 : n4 < er4 ? 6 : n4 < tr5 ? 7 : n4 < ir3 ? 8 : n4 < sr4 ? 9 : 10;
};
var nr4 = { encode: Vs2, decode: Ys2, encodingLength: rr5 };
var ke5 = nr4;
var Ke5 = (n4, e, t = 0) => (ke5.encode(n4, e, t), e);
var Be4 = (n4) => ke5.encodingLength(n4);
var ce4 = (n4, e) => {
  const t = e.byteLength, i3 = Be4(n4), s = i3 + Be4(t), r = new Uint8Array(s + t);
  return Ke5(n4, r, 0), Ke5(t, r, i3), r.set(e, s), new or5(n4, t, e, r);
};
var or5 = class {
  constructor(e, t, i3, s) {
    this.code = e, this.size = t, this.digest = i3, this.bytes = s;
  }
};
var Ve4 = ({ name: n4, code: e, encode: t }) => new ar3(n4, e, t);
var ar3 = class {
  constructor(e, t, i3) {
    this.name = e, this.code = t, this.encode = i3;
  }
  digest(e) {
    if (e instanceof Uint8Array) {
      const t = this.encode(e);
      return t instanceof Uint8Array ? ce4(this.code, t) : t.then((i3) => ce4(this.code, i3));
    } else
      throw Error("Unknown type, must be binary type");
  }
};
var qe4 = (n4) => async (e) => new Uint8Array(await crypto.subtle.digest(n4, e));
var hr3 = Ve4({ name: "sha2-256", code: 18, encode: qe4("SHA-256") });
var cr3 = Ve4({ name: "sha2-512", code: 19, encode: qe4("SHA-512") });
var ur3 = Object.freeze({ __proto__: null, sha256: hr3, sha512: cr3 });
var je2 = 0;
var lr3 = "identity";
var Ge4 = Ne2;
var dr3 = (n4) => ce4(je2, Ge4(n4));
var gr3 = { code: je2, name: lr3, encode: Ge4, digest: dr3 };
var pr3 = Object.freeze({ __proto__: null, identity: gr3 });
new TextEncoder(), new TextDecoder();
var Ye2 = { ...os2, ...hs2, ...us2, ...ds2, ...Ds2, ...Rs2, ...Ss2, ...Os2, ...Ls2, ...Bs2 };
({ ...ur3, ...pr3 });
function He4(n4) {
  return globalThis.Buffer != null ? new Uint8Array(n4.buffer, n4.byteOffset, n4.byteLength) : n4;
}
function Dr3(n4 = 0) {
  return globalThis.Buffer != null && globalThis.Buffer.allocUnsafe != null ? He4(globalThis.Buffer.allocUnsafe(n4)) : new Uint8Array(n4);
}
function Je3(n4, e, t, i3) {
  return { name: n4, prefix: e, encoder: { name: n4, prefix: e, encode: t }, decoder: { decode: i3 } };
}
var Xe4 = Je3("utf8", "u", (n4) => "u" + new TextDecoder("utf8").decode(n4), (n4) => new TextEncoder().encode(n4.substring(1)));
var ue5 = Je3("ascii", "a", (n4) => {
  let e = "a";
  for (let t = 0; t < n4.length; t++)
    e += String.fromCharCode(n4[t]);
  return e;
}, (n4) => {
  n4 = n4.substring(1);
  const e = Dr3(n4.length);
  for (let t = 0; t < n4.length; t++)
    e[t] = n4.charCodeAt(t);
  return e;
});
var yr3 = { utf8: Xe4, "utf-8": Xe4, hex: Ye2.base16, latin1: ue5, ascii: ue5, binary: ue5, ...Ye2 };
function mr3(n4, e = "utf8") {
  const t = yr3[e];
  if (!t)
    throw new Error(`Unsupported encoding "${e}"`);
  return (e === "utf8" || e === "utf-8") && globalThis.Buffer != null && globalThis.Buffer.from != null ? He4(globalThis.Buffer.from(n4, "utf-8")) : t.decoder.decode(`${t.prefix}${n4}`);
}
var le5 = "wc";
var We5 = 2;
var Q5 = "core";
var O4 = `${le5}@2:${Q5}:`;
var Qe3 = { name: Q5, logger: "error" };
var Ze4 = { database: ":memory:" };
var et3 = "crypto";
var de5 = "client_ed25519_seed";
var tt3 = import_time5.ONE_DAY;
var it3 = "keychain";
var st3 = "0.3";
var rt5 = "messages";
var nt3 = "0.3";
var ot5 = import_time5.SIX_HOURS;
var at5 = "publisher";
var ht4 = "irn";
var ct3 = "error";
var ge5 = "wss://relay.walletconnect.com";
var pe3 = "wss://relay.walletconnect.org";
var ut5 = "relayer";
var D4 = { message: "relayer_message", message_ack: "relayer_message_ack", connect: "relayer_connect", disconnect: "relayer_disconnect", error: "relayer_error", connection_stalled: "relayer_connection_stalled", transport_closed: "relayer_transport_closed", publish: "relayer_publish" };
var lt5 = "_subscription";
var P2 = { payload: "payload", connect: "connect", disconnect: "disconnect", error: "error" };
var dt5 = import_time5.ONE_SECOND;
var gt4 = "2.11.2";
var pt5 = 1e4;
var Dt3 = "0.3";
var yt5 = "WALLETCONNECT_CLIENT_ID";
var w5 = { created: "subscription_created", deleted: "subscription_deleted", expired: "subscription_expired", disabled: "subscription_disabled", sync: "subscription_sync", resubscribed: "subscription_resubscribed" };
var mt5 = "subscription";
var bt5 = "0.3";
var ft5 = import_time5.FIVE_SECONDS * 1e3;
var Et5 = "pairing";
var wt5 = "0.3";
var $5 = { wc_pairingDelete: { req: { ttl: import_time5.ONE_DAY, prompt: false, tag: 1e3 }, res: { ttl: import_time5.ONE_DAY, prompt: false, tag: 1001 } }, wc_pairingPing: { req: { ttl: import_time5.THIRTY_SECONDS, prompt: false, tag: 1002 }, res: { ttl: import_time5.THIRTY_SECONDS, prompt: false, tag: 1003 } }, unregistered_method: { req: { ttl: import_time5.ONE_DAY, prompt: false, tag: 0 }, res: { ttl: import_time5.ONE_DAY, prompt: false, tag: 0 } } };
var V4 = { create: "pairing_create", expire: "pairing_expire", delete: "pairing_delete", ping: "pairing_ping" };
var R5 = { created: "history_created", updated: "history_updated", deleted: "history_deleted", sync: "history_sync" };
var vt5 = "history";
var It5 = "0.3";
var Ct3 = "expirer";
var v4 = { created: "expirer_created", deleted: "expirer_deleted", expired: "expirer_expired", sync: "expirer_sync" };
var Rt5 = "0.3";
var Z5 = "verify-api";
var F5 = "https://verify.walletconnect.com";
var ee5 = "https://verify.walletconnect.org";
var _t3 = [F5, ee5];
var Tt5 = "echo";
var St5 = "https://echo.walletconnect.com";
var Pt5 = class {
  constructor(e, t) {
    this.core = e, this.logger = t, this.keychain = /* @__PURE__ */ new Map(), this.name = it3, this.version = st3, this.initialized = false, this.storagePrefix = O4, this.init = async () => {
      if (!this.initialized) {
        const i3 = await this.getKeyChain();
        typeof i3 < "u" && (this.keychain = i3), this.initialized = true;
      }
    }, this.has = (i3) => (this.isInitialized(), this.keychain.has(i3)), this.set = async (i3, s) => {
      this.isInitialized(), this.keychain.set(i3, s), await this.persist();
    }, this.get = (i3) => {
      this.isInitialized();
      const s = this.keychain.get(i3);
      if (typeof s > "u") {
        const { message: r } = N4("NO_MATCHING_KEY", `${this.name}: ${i3}`);
        throw new Error(r);
      }
      return s;
    }, this.del = async (i3) => {
      this.isInitialized(), this.keychain.delete(i3), await this.persist();
    }, this.core = e, this.logger = (0, import_logger3.generateChildLogger)(t, this.name);
  }
  get context() {
    return (0, import_logger3.getLoggerContext)(this.logger);
  }
  get storageKey() {
    return this.storagePrefix + this.version + this.core.customStoragePrefix + "//" + this.name;
  }
  async setKeyChain(e) {
    await this.core.storage.setItem(this.storageKey, rt4(e));
  }
  async getKeyChain() {
    const e = await this.core.storage.getItem(this.storageKey);
    return typeof e < "u" ? ot4(e) : void 0;
  }
  async persist() {
    await this.setKeyChain(this.keychain);
  }
  isInitialized() {
    if (!this.initialized) {
      const { message: e } = N4("NOT_INITIALIZED", this.name);
      throw new Error(e);
    }
  }
};
var xt5 = class {
  constructor(e, t, i3) {
    this.core = e, this.logger = t, this.name = et3, this.initialized = false, this.init = async () => {
      this.initialized || (await this.keychain.init(), this.initialized = true);
    }, this.hasKeys = (s) => (this.isInitialized(), this.keychain.has(s)), this.getClientId = async () => {
      this.isInitialized();
      const s = await this.getClientSeed(), r = generateKeyPair(s);
      return encodeIss(r.publicKey);
    }, this.generateKeyPair = () => {
      this.isInitialized();
      const s = kn2();
      return this.setPrivateKey(s.publicKey, s.privateKey);
    }, this.signJWT = async (s) => {
      this.isInitialized();
      const r = await this.getClientSeed(), o3 = generateKeyPair(r), a3 = Vn2(), h5 = tt3;
      return await signJWT(a3, s, h5, o3);
    }, this.generateSharedKey = (s, r, o3) => {
      this.isInitialized();
      const a3 = this.getPrivateKey(s), h5 = Mn2(a3, r);
      return this.setSymKey(h5, o3);
    }, this.setSymKey = async (s, r) => {
      this.isInitialized();
      const o3 = r || Kn2(s);
      return await this.keychain.set(o3, s), o3;
    }, this.deleteKeyPair = async (s) => {
      this.isInitialized(), await this.keychain.del(s);
    }, this.deleteSymKey = async (s) => {
      this.isInitialized(), await this.keychain.del(s);
    }, this.encode = async (s, r, o3) => {
      this.isInitialized();
      const a3 = Ae2(o3), h5 = safeJsonStringify(r);
      if (qn2(a3)) {
        const y4 = a3.senderPublicKey, M6 = a3.receiverPublicKey;
        s = await this.generateSharedKey(y4, M6);
      }
      const l2 = this.getSymKey(s), { type: d5, senderPublicKey: p6 } = a3;
      return xn2({ type: d5, symKey: l2, message: h5, senderPublicKey: p6 });
    }, this.decode = async (s, r, o3) => {
      this.isInitialized();
      const a3 = Hn2(r, o3);
      if (qn2(a3)) {
        const h5 = a3.receiverPublicKey, l2 = a3.senderPublicKey;
        s = await this.generateSharedKey(h5, l2);
      }
      try {
        const h5 = this.getSymKey(s), l2 = Fn2({ symKey: h5, encoded: r });
        return safeJsonParse(l2);
      } catch (h5) {
        this.logger.error(`Failed to decode message from topic: '${s}', clientId: '${await this.getClientId()}'`), this.logger.error(h5);
      }
    }, this.getPayloadType = (s) => {
      const r = ee4(s);
      return j3(r.type);
    }, this.getPayloadSenderPublicKey = (s) => {
      const r = ee4(s);
      return r.senderPublicKey ? toString(r.senderPublicKey, p4) : void 0;
    }, this.core = e, this.logger = (0, import_logger3.generateChildLogger)(t, this.name), this.keychain = i3 || new Pt5(this.core, this.logger);
  }
  get context() {
    return (0, import_logger3.getLoggerContext)(this.logger);
  }
  async setPrivateKey(e, t) {
    return await this.keychain.set(e, t), e;
  }
  getPrivateKey(e) {
    return this.keychain.get(e);
  }
  async getClientSeed() {
    let e = "";
    try {
      e = this.keychain.get(de5);
    } catch {
      e = Vn2(), await this.keychain.set(de5, e);
    }
    return mr3(e, "base16");
  }
  getSymKey(e) {
    return this.keychain.get(e);
  }
  isInitialized() {
    if (!this.initialized) {
      const { message: e } = N4("NOT_INITIALIZED", this.name);
      throw new Error(e);
    }
  }
};
var Ot5 = class extends a2 {
  constructor(e, t) {
    super(e, t), this.logger = e, this.core = t, this.messages = /* @__PURE__ */ new Map(), this.name = rt5, this.version = nt3, this.initialized = false, this.storagePrefix = O4, this.init = async () => {
      if (!this.initialized) {
        this.logger.trace("Initialized");
        try {
          const i3 = await this.getRelayerMessages();
          typeof i3 < "u" && (this.messages = i3), this.logger.debug(`Successfully Restored records for ${this.name}`), this.logger.trace({ type: "method", method: "restore", size: this.messages.size });
        } catch (i3) {
          this.logger.debug(`Failed to Restore records for ${this.name}`), this.logger.error(i3);
        } finally {
          this.initialized = true;
        }
      }
    }, this.set = async (i3, s) => {
      this.isInitialized();
      const r = Ln2(s);
      let o3 = this.messages.get(i3);
      return typeof o3 > "u" && (o3 = {}), typeof o3[r] < "u" || (o3[r] = s, this.messages.set(i3, o3), await this.persist()), r;
    }, this.get = (i3) => {
      this.isInitialized();
      let s = this.messages.get(i3);
      return typeof s > "u" && (s = {}), s;
    }, this.has = (i3, s) => {
      this.isInitialized();
      const r = this.get(i3), o3 = Ln2(s);
      return typeof r[o3] < "u";
    }, this.del = async (i3) => {
      this.isInitialized(), this.messages.delete(i3), await this.persist();
    }, this.logger = (0, import_logger3.generateChildLogger)(e, this.name), this.core = t;
  }
  get context() {
    return (0, import_logger3.getLoggerContext)(this.logger);
  }
  get storageKey() {
    return this.storagePrefix + this.version + this.core.customStoragePrefix + "//" + this.name;
  }
  async setRelayerMessages(e) {
    await this.core.storage.setItem(this.storageKey, rt4(e));
  }
  async getRelayerMessages() {
    const e = await this.core.storage.getItem(this.storageKey);
    return typeof e < "u" ? ot4(e) : void 0;
  }
  async persist() {
    await this.setRelayerMessages(this.messages);
  }
  isInitialized() {
    if (!this.initialized) {
      const { message: e } = N4("NOT_INITIALIZED", this.name);
      throw new Error(e);
    }
  }
};
var vr3 = class extends u2 {
  constructor(e, t) {
    super(e, t), this.relayer = e, this.logger = t, this.events = new import_events7.EventEmitter(), this.name = at5, this.queue = /* @__PURE__ */ new Map(), this.publishTimeout = (0, import_time5.toMiliseconds)(import_time5.TEN_SECONDS * 2), this.needsTransportRestart = false, this.publish = async (i3, s, r) => {
      var o3;
      this.logger.debug("Publishing Payload"), this.logger.trace({ type: "method", method: "publish", params: { topic: i3, message: s, opts: r } });
      try {
        const a3 = (r == null ? void 0 : r.ttl) || ot5, h5 = vt4(r), l2 = (r == null ? void 0 : r.prompt) || false, d5 = (r == null ? void 0 : r.tag) || 0, p6 = (r == null ? void 0 : r.id) || getBigIntRpcId().toString(), y4 = { topic: i3, message: s, opts: { ttl: a3, relay: h5, prompt: l2, tag: d5, id: p6 } }, M6 = setTimeout(() => this.queue.set(p6, y4), this.publishTimeout);
        try {
          await await ut4(this.rpcPublish(i3, s, a3, h5, l2, d5, p6), this.publishTimeout, `Failed to publish payload, please try again. id:${p6} tag:${d5}`), this.removeRequestFromQueue(p6), this.relayer.events.emit(D4.publish, y4);
        } catch (u3) {
          if (this.logger.debug("Publishing Payload stalled"), this.needsTransportRestart = true, (o3 = r == null ? void 0 : r.internal) != null && o3.throwOnFailedPublish)
            throw this.removeRequestFromQueue(p6), u3;
          return;
        } finally {
          clearTimeout(M6);
        }
        this.logger.debug("Successfully Published Payload"), this.logger.trace({ type: "method", method: "publish", params: { topic: i3, message: s, opts: r } });
      } catch (a3) {
        throw this.logger.debug("Failed to Publish Payload"), this.logger.error(a3), a3;
      }
    }, this.on = (i3, s) => {
      this.events.on(i3, s);
    }, this.once = (i3, s) => {
      this.events.once(i3, s);
    }, this.off = (i3, s) => {
      this.events.off(i3, s);
    }, this.removeListener = (i3, s) => {
      this.events.removeListener(i3, s);
    }, this.relayer = e, this.logger = (0, import_logger3.generateChildLogger)(t, this.name), this.registerEventListeners();
  }
  get context() {
    return (0, import_logger3.getLoggerContext)(this.logger);
  }
  rpcPublish(e, t, i3, s, r, o3, a3) {
    var h5, l2, d5, p6;
    const y4 = { method: Et4(s.protocol).publish, params: { topic: e, message: t, ttl: i3, prompt: r, tag: o3 }, id: a3 };
    return w4((h5 = y4.params) == null ? void 0 : h5.prompt) && ((l2 = y4.params) == null || delete l2.prompt), w4((d5 = y4.params) == null ? void 0 : d5.tag) && ((p6 = y4.params) == null || delete p6.tag), this.logger.debug("Outgoing Relay Payload"), this.logger.trace({ type: "message", direction: "outgoing", request: y4 }), this.relayer.request(y4);
  }
  removeRequestFromQueue(e) {
    this.queue.delete(e);
  }
  checkQueue() {
    this.queue.forEach(async (e) => {
      const { topic: t, message: i3, opts: s } = e;
      await this.publish(t, i3, s);
    });
  }
  registerEventListeners() {
    this.relayer.core.heartbeat.on(import_heartbeat2.HEARTBEAT_EVENTS.pulse, () => {
      if (this.needsTransportRestart) {
        this.needsTransportRestart = false, this.relayer.events.emit(D4.connection_stalled);
        return;
      }
      this.checkQueue();
    }), this.relayer.on(D4.message_ack, (e) => {
      this.removeRequestFromQueue(e.id.toString());
    });
  }
};
var Ir2 = class {
  constructor() {
    this.map = /* @__PURE__ */ new Map(), this.set = (e, t) => {
      const i3 = this.get(e);
      this.exists(e, t) || this.map.set(e, [...i3, t]);
    }, this.get = (e) => this.map.get(e) || [], this.exists = (e, t) => this.get(e).includes(t), this.delete = (e, t) => {
      if (typeof t > "u") {
        this.map.delete(e);
        return;
      }
      if (!this.map.has(e))
        return;
      const i3 = this.get(e);
      if (!this.exists(e, t))
        return;
      const s = i3.filter((r) => r !== t);
      if (!s.length) {
        this.map.delete(e);
        return;
      }
      this.map.set(e, s);
    }, this.clear = () => {
      this.map.clear();
    };
  }
  get topics() {
    return Array.from(this.map.keys());
  }
};
var Cr3 = Object.defineProperty;
var Rr3 = Object.defineProperties;
var _r3 = Object.getOwnPropertyDescriptors;
var At3 = Object.getOwnPropertySymbols;
var Tr3 = Object.prototype.hasOwnProperty;
var Sr3 = Object.prototype.propertyIsEnumerable;
var zt4 = (n4, e, t) => e in n4 ? Cr3(n4, e, { enumerable: true, configurable: true, writable: true, value: t }) : n4[e] = t;
var q2 = (n4, e) => {
  for (var t in e || (e = {}))
    Tr3.call(e, t) && zt4(n4, t, e[t]);
  if (At3)
    for (var t of At3(e))
      Sr3.call(e, t) && zt4(n4, t, e[t]);
  return n4;
};
var De5 = (n4, e) => Rr3(n4, _r3(e));
var Nt5 = class extends d3 {
  constructor(e, t) {
    super(e, t), this.relayer = e, this.logger = t, this.subscriptions = /* @__PURE__ */ new Map(), this.topicMap = new Ir2(), this.events = new import_events7.EventEmitter(), this.name = mt5, this.version = bt5, this.pending = /* @__PURE__ */ new Map(), this.cached = [], this.initialized = false, this.pendingSubscriptionWatchLabel = "pending_sub_watch_label", this.pollingInterval = 20, this.storagePrefix = O4, this.subscribeTimeout = 1e4, this.restartInProgress = false, this.batchSubscribeTopicsLimit = 500, this.init = async () => {
      this.initialized || (this.logger.trace("Initialized"), this.registerEventListeners(), this.clientId = await this.relayer.core.crypto.getClientId());
    }, this.subscribe = async (i3, s) => {
      await this.restartToComplete(), this.isInitialized(), this.logger.debug("Subscribing Topic"), this.logger.trace({ type: "method", method: "subscribe", params: { topic: i3, opts: s } });
      try {
        const r = vt4(s), o3 = { topic: i3, relay: r };
        this.pending.set(i3, o3);
        const a3 = await this.rpcSubscribe(i3, r);
        return this.onSubscribe(a3, o3), this.logger.debug("Successfully Subscribed Topic"), this.logger.trace({ type: "method", method: "subscribe", params: { topic: i3, opts: s } }), a3;
      } catch (r) {
        throw this.logger.debug("Failed to Subscribe Topic"), this.logger.error(r), r;
      }
    }, this.unsubscribe = async (i3, s) => {
      await this.restartToComplete(), this.isInitialized(), typeof (s == null ? void 0 : s.id) < "u" ? await this.unsubscribeById(i3, s.id, s) : await this.unsubscribeByTopic(i3, s);
    }, this.isSubscribed = async (i3) => {
      if (this.topics.includes(i3))
        return true;
      const s = `${this.pendingSubscriptionWatchLabel}_${i3}`;
      return await new Promise((r, o3) => {
        const a3 = new import_time5.Watch();
        a3.start(s);
        const h5 = setInterval(() => {
          !this.pending.has(i3) && this.topics.includes(i3) && (clearInterval(h5), a3.stop(s), r(true)), a3.elapsed(s) >= ft5 && (clearInterval(h5), a3.stop(s), o3(new Error("Subscription resolution timeout")));
        }, this.pollingInterval);
      }).catch(() => false);
    }, this.on = (i3, s) => {
      this.events.on(i3, s);
    }, this.once = (i3, s) => {
      this.events.once(i3, s);
    }, this.off = (i3, s) => {
      this.events.off(i3, s);
    }, this.removeListener = (i3, s) => {
      this.events.removeListener(i3, s);
    }, this.restart = async () => {
      this.restartInProgress = true, await this.restore(), await this.reset(), this.restartInProgress = false;
    }, this.relayer = e, this.logger = (0, import_logger3.generateChildLogger)(t, this.name), this.clientId = "";
  }
  get context() {
    return (0, import_logger3.getLoggerContext)(this.logger);
  }
  get storageKey() {
    return this.storagePrefix + this.version + this.relayer.core.customStoragePrefix + "//" + this.name;
  }
  get length() {
    return this.subscriptions.size;
  }
  get ids() {
    return Array.from(this.subscriptions.keys());
  }
  get values() {
    return Array.from(this.subscriptions.values());
  }
  get topics() {
    return this.topicMap.topics;
  }
  hasSubscription(e, t) {
    let i3 = false;
    try {
      i3 = this.getSubscription(e).topic === t;
    } catch {
    }
    return i3;
  }
  onEnable() {
    this.cached = [], this.initialized = true;
  }
  onDisable() {
    this.cached = this.values, this.subscriptions.clear(), this.topicMap.clear();
  }
  async unsubscribeByTopic(e, t) {
    const i3 = this.topicMap.get(e);
    await Promise.all(i3.map(async (s) => await this.unsubscribeById(e, s, t)));
  }
  async unsubscribeById(e, t, i3) {
    this.logger.debug("Unsubscribing Topic"), this.logger.trace({ type: "method", method: "unsubscribe", params: { topic: e, id: t, opts: i3 } });
    try {
      const s = vt4(i3);
      await this.rpcUnsubscribe(e, t, s);
      const r = U4("USER_DISCONNECTED", `${this.name}, ${e}`);
      await this.onUnsubscribe(e, t, r), this.logger.debug("Successfully Unsubscribed Topic"), this.logger.trace({ type: "method", method: "unsubscribe", params: { topic: e, id: t, opts: i3 } });
    } catch (s) {
      throw this.logger.debug("Failed to Unsubscribe Topic"), this.logger.error(s), s;
    }
  }
  async rpcSubscribe(e, t) {
    const i3 = { method: Et4(t.protocol).subscribe, params: { topic: e } };
    this.logger.debug("Outgoing Relay Payload"), this.logger.trace({ type: "payload", direction: "outgoing", request: i3 });
    try {
      await await ut4(this.relayer.request(i3), this.subscribeTimeout);
    } catch {
      this.logger.debug("Outgoing Relay Subscribe Payload stalled"), this.relayer.events.emit(D4.connection_stalled);
    }
    return Ln2(e + this.clientId);
  }
  async rpcBatchSubscribe(e) {
    if (!e.length)
      return;
    const t = e[0].relay, i3 = { method: Et4(t.protocol).batchSubscribe, params: { topics: e.map((s) => s.topic) } };
    this.logger.debug("Outgoing Relay Payload"), this.logger.trace({ type: "payload", direction: "outgoing", request: i3 });
    try {
      return await await ut4(this.relayer.request(i3), this.subscribeTimeout);
    } catch {
      this.logger.debug("Outgoing Relay Payload stalled"), this.relayer.events.emit(D4.connection_stalled);
    }
  }
  rpcUnsubscribe(e, t, i3) {
    const s = { method: Et4(i3.protocol).unsubscribe, params: { topic: e, id: t } };
    return this.logger.debug("Outgoing Relay Payload"), this.logger.trace({ type: "payload", direction: "outgoing", request: s }), this.relayer.request(s);
  }
  onSubscribe(e, t) {
    this.setSubscription(e, De5(q2({}, t), { id: e })), this.pending.delete(t.topic);
  }
  onBatchSubscribe(e) {
    e.length && e.forEach((t) => {
      this.setSubscription(t.id, q2({}, t)), this.pending.delete(t.topic);
    });
  }
  async onUnsubscribe(e, t, i3) {
    this.events.removeAllListeners(t), this.hasSubscription(t, e) && this.deleteSubscription(t, i3), await this.relayer.messages.del(e);
  }
  async setRelayerSubscriptions(e) {
    await this.relayer.core.storage.setItem(this.storageKey, e);
  }
  async getRelayerSubscriptions() {
    return await this.relayer.core.storage.getItem(this.storageKey);
  }
  setSubscription(e, t) {
    this.subscriptions.has(e) || (this.logger.debug("Setting subscription"), this.logger.trace({ type: "method", method: "setSubscription", id: e, subscription: t }), this.addSubscription(e, t));
  }
  addSubscription(e, t) {
    this.subscriptions.set(e, q2({}, t)), this.topicMap.set(t.topic, e), this.events.emit(w5.created, t);
  }
  getSubscription(e) {
    this.logger.debug("Getting subscription"), this.logger.trace({ type: "method", method: "getSubscription", id: e });
    const t = this.subscriptions.get(e);
    if (!t) {
      const { message: i3 } = N4("NO_MATCHING_KEY", `${this.name}: ${e}`);
      throw new Error(i3);
    }
    return t;
  }
  deleteSubscription(e, t) {
    this.logger.debug("Deleting subscription"), this.logger.trace({ type: "method", method: "deleteSubscription", id: e, reason: t });
    const i3 = this.getSubscription(e);
    this.subscriptions.delete(e), this.topicMap.delete(i3.topic, e), this.events.emit(w5.deleted, De5(q2({}, i3), { reason: t }));
  }
  async persist() {
    await this.setRelayerSubscriptions(this.values), this.events.emit(w5.sync);
  }
  async reset() {
    if (this.cached.length) {
      const e = Math.ceil(this.cached.length / this.batchSubscribeTopicsLimit);
      for (let t = 0; t < e; t++) {
        const i3 = this.cached.splice(0, this.batchSubscribeTopicsLimit);
        await this.batchSubscribe(i3);
      }
    }
    this.events.emit(w5.resubscribed);
  }
  async restore() {
    try {
      const e = await this.getRelayerSubscriptions();
      if (typeof e > "u" || !e.length)
        return;
      if (this.subscriptions.size) {
        const { message: t } = N4("RESTORE_WILL_OVERRIDE", this.name);
        throw this.logger.error(t), this.logger.error(`${this.name}: ${JSON.stringify(this.values)}`), new Error(t);
      }
      this.cached = e, this.logger.debug(`Successfully Restored subscriptions for ${this.name}`), this.logger.trace({ type: "method", method: "restore", subscriptions: this.values });
    } catch (e) {
      this.logger.debug(`Failed to Restore subscriptions for ${this.name}`), this.logger.error(e);
    }
  }
  async batchSubscribe(e) {
    if (!e.length)
      return;
    const t = await this.rpcBatchSubscribe(e);
    k2(t) && this.onBatchSubscribe(t.map((i3, s) => De5(q2({}, e[s]), { id: i3 })));
  }
  async onConnect() {
    this.restartInProgress || (await this.restart(), this.onEnable());
  }
  onDisconnect() {
    this.onDisable();
  }
  async checkPending() {
    if (!this.initialized || this.relayer.transportExplicitlyClosed)
      return;
    const e = [];
    this.pending.forEach((t) => {
      e.push(t);
    }), await this.batchSubscribe(e);
  }
  registerEventListeners() {
    this.relayer.core.heartbeat.on(import_heartbeat2.HEARTBEAT_EVENTS.pulse, async () => {
      await this.checkPending();
    }), this.relayer.on(D4.connect, async () => {
      await this.onConnect();
    }), this.relayer.on(D4.disconnect, () => {
      this.onDisconnect();
    }), this.events.on(w5.created, async (e) => {
      const t = w5.created;
      this.logger.info(`Emitting ${t}`), this.logger.debug({ type: "event", event: t, data: e }), await this.persist();
    }), this.events.on(w5.deleted, async (e) => {
      const t = w5.deleted;
      this.logger.info(`Emitting ${t}`), this.logger.debug({ type: "event", event: t, data: e }), await this.persist();
    });
  }
  isInitialized() {
    if (!this.initialized) {
      const { message: e } = N4("NOT_INITIALIZED", this.name);
      throw new Error(e);
    }
  }
  async restartToComplete() {
    this.restartInProgress && await new Promise((e) => {
      const t = setInterval(() => {
        this.restartInProgress || (clearInterval(t), e());
      }, this.pollingInterval);
    });
  }
};
var Pr3 = Object.defineProperty;
var Ut3 = Object.getOwnPropertySymbols;
var xr3 = Object.prototype.hasOwnProperty;
var Or3 = Object.prototype.propertyIsEnumerable;
var Lt5 = (n4, e, t) => e in n4 ? Pr3(n4, e, { enumerable: true, configurable: true, writable: true, value: t }) : n4[e] = t;
var Ar3 = (n4, e) => {
  for (var t in e || (e = {}))
    xr3.call(e, t) && Lt5(n4, t, e[t]);
  if (Ut3)
    for (var t of Ut3(e))
      Or3.call(e, t) && Lt5(n4, t, e[t]);
  return n4;
};
var $t3 = class extends g4 {
  constructor(e) {
    super(e), this.protocol = "wc", this.version = 2, this.events = new import_events7.EventEmitter(), this.name = ut5, this.transportExplicitlyClosed = false, this.initialized = false, this.connectionAttemptInProgress = false, this.connectionStatusPollingInterval = 20, this.staleConnectionErrors = ["socket hang up", "socket stalled"], this.hasExperiencedNetworkDisruption = false, this.requestsInFlight = /* @__PURE__ */ new Map(), this.request = async (t) => {
      this.logger.debug("Publishing Request Payload");
      const i3 = t.id;
      try {
        await this.toEstablishConnection();
        const s = this.provider.request(t);
        return this.requestsInFlight.set(i3, { promise: s, request: t }), await s;
      } catch (s) {
        throw this.logger.debug("Failed to Publish Request"), this.logger.error(s), s;
      } finally {
        this.requestsInFlight.delete(i3);
      }
    }, this.onPayloadHandler = (t) => {
      this.onProviderPayload(t);
    }, this.onConnectHandler = () => {
      this.events.emit(D4.connect);
    }, this.onDisconnectHandler = () => {
      this.onProviderDisconnect();
    }, this.onProviderErrorHandler = (t) => {
      this.logger.error(t), this.events.emit(D4.error, t), this.logger.info("Fatal socket error received, closing transport"), this.transportClose();
    }, this.registerProviderListeners = () => {
      this.provider.on(P2.payload, this.onPayloadHandler), this.provider.on(P2.connect, this.onConnectHandler), this.provider.on(P2.disconnect, this.onDisconnectHandler), this.provider.on(P2.error, this.onProviderErrorHandler);
    }, this.core = e.core, this.logger = typeof e.logger < "u" && typeof e.logger != "string" ? (0, import_logger3.generateChildLogger)(e.logger, this.name) : (0, import_logger3.pino)((0, import_logger3.getDefaultLoggerOptions)({ level: e.logger || ct3 })), this.messages = new Ot5(this.logger, e.core), this.subscriber = new Nt5(this, this.logger), this.publisher = new vr3(this, this.logger), this.relayUrl = (e == null ? void 0 : e.relayUrl) || ge5, this.projectId = e.projectId, this.bundleId = Jn2(), this.provider = {};
  }
  async init() {
    this.logger.trace("Initialized"), this.registerEventListeners(), await this.createProvider(), await Promise.all([this.messages.init(), this.subscriber.init()]);
    try {
      await this.transportOpen();
    } catch {
      this.logger.warn(`Connection via ${this.relayUrl} failed, attempting to connect via failover domain ${pe3}...`), await this.restartTransport(pe3);
    }
    this.initialized = true, setTimeout(async () => {
      this.subscriber.topics.length === 0 && (this.logger.info("No topics subscribed to after init, closing transport"), await this.transportClose(), this.transportExplicitlyClosed = false);
    }, pt5);
  }
  get context() {
    return (0, import_logger3.getLoggerContext)(this.logger);
  }
  get connected() {
    return this.provider.connection.connected;
  }
  get connecting() {
    return this.provider.connection.connecting;
  }
  async publish(e, t, i3) {
    this.isInitialized(), await this.publisher.publish(e, t, i3), await this.recordMessageEvent({ topic: e, message: t, publishedAt: Date.now() });
  }
  async subscribe(e, t) {
    var i3;
    this.isInitialized();
    let s = ((i3 = this.subscriber.topicMap.get(e)) == null ? void 0 : i3[0]) || "";
    if (s)
      return s;
    let r;
    const o3 = (a3) => {
      a3.topic === e && (this.subscriber.off(w5.created, o3), r());
    };
    return await Promise.all([new Promise((a3) => {
      r = a3, this.subscriber.on(w5.created, o3);
    }), new Promise(async (a3) => {
      s = await this.subscriber.subscribe(e, t), a3();
    })]), s;
  }
  async unsubscribe(e, t) {
    this.isInitialized(), await this.subscriber.unsubscribe(e, t);
  }
  on(e, t) {
    this.events.on(e, t);
  }
  once(e, t) {
    this.events.once(e, t);
  }
  off(e, t) {
    this.events.off(e, t);
  }
  removeListener(e, t) {
    this.events.removeListener(e, t);
  }
  async transportClose() {
    this.requestsInFlight.size > 0 && (this.logger.debug("Waiting for all in-flight requests to finish before closing transport..."), this.requestsInFlight.forEach(async (e) => {
      await e.promise;
    })), this.transportExplicitlyClosed = true, this.hasExperiencedNetworkDisruption && this.connected ? await ut4(this.provider.disconnect(), 1e3, "provider.disconnect()").catch(() => this.onProviderDisconnect()) : this.connected && await this.provider.disconnect();
  }
  async transportOpen(e) {
    if (this.transportExplicitlyClosed = false, await this.confirmOnlineStateOrThrow(), !this.connectionAttemptInProgress) {
      e && e !== this.relayUrl && (this.relayUrl = e, await this.transportClose(), await this.createProvider()), this.connectionAttemptInProgress = true;
      try {
        await Promise.all([new Promise((t) => {
          if (!this.initialized)
            return t();
          this.subscriber.once(w5.resubscribed, () => {
            t();
          });
        }), new Promise(async (t, i3) => {
          try {
            await ut4(this.provider.connect(), 1e4, `Socket stalled when trying to connect to ${this.relayUrl}`);
          } catch (s) {
            i3(s);
            return;
          }
          t();
        })]);
      } catch (t) {
        this.logger.error(t);
        const i3 = t;
        if (!this.isConnectionStalled(i3.message))
          throw t;
        this.provider.events.emit(P2.disconnect);
      } finally {
        this.connectionAttemptInProgress = false, this.hasExperiencedNetworkDisruption = false;
      }
    }
  }
  async restartTransport(e) {
    await this.confirmOnlineStateOrThrow(), !this.connectionAttemptInProgress && (this.relayUrl = e || this.relayUrl, await this.transportClose(), await this.createProvider(), await this.transportOpen());
  }
  async confirmOnlineStateOrThrow() {
    if (!await rr4())
      throw new Error("No internet connection detected. Please restart your network and try again.");
  }
  isConnectionStalled(e) {
    return this.staleConnectionErrors.some((t) => e.includes(t));
  }
  async createProvider() {
    this.provider.connection && this.unregisterProviderListeners();
    const e = await this.core.crypto.signJWT(this.relayUrl);
    this.provider = new JsonRpcProvider(new f(Xn2({ sdkVersion: gt4, protocol: this.protocol, version: this.version, relayUrl: this.relayUrl, projectId: this.projectId, auth: e, useOnCloseEvent: true, bundleId: this.bundleId }))), this.registerProviderListeners();
  }
  async recordMessageEvent(e) {
    const { topic: t, message: i3 } = e;
    await this.messages.set(t, i3);
  }
  async shouldIgnoreMessageEvent(e) {
    const { topic: t, message: i3 } = e;
    if (!i3 || i3.length === 0)
      return this.logger.debug(`Ignoring invalid/empty message: ${i3}`), true;
    if (!await this.subscriber.isSubscribed(t))
      return this.logger.debug(`Ignoring message for non-subscribed topic ${t}`), true;
    const s = this.messages.has(t, i3);
    return s && this.logger.debug(`Ignoring duplicate message: ${i3}`), s;
  }
  async onProviderPayload(e) {
    if (this.logger.debug("Incoming Relay Payload"), this.logger.trace({ type: "payload", direction: "incoming", payload: e }), isJsonRpcRequest(e)) {
      if (!e.method.endsWith(lt5))
        return;
      const t = e.params, { topic: i3, message: s, publishedAt: r } = t.data, o3 = { topic: i3, message: s, publishedAt: r };
      this.logger.debug("Emitting Relayer Payload"), this.logger.trace(Ar3({ type: "event", event: t.id }, o3)), this.events.emit(t.id, o3), await this.acknowledgePayload(e), await this.onMessageEvent(o3);
    } else
      isJsonRpcResponse(e) && this.events.emit(D4.message_ack, e);
  }
  async onMessageEvent(e) {
    await this.shouldIgnoreMessageEvent(e) || (this.events.emit(D4.message, e), await this.recordMessageEvent(e));
  }
  async acknowledgePayload(e) {
    const t = formatJsonRpcResult(e.id, true);
    await this.provider.connection.send(t);
  }
  unregisterProviderListeners() {
    this.provider.off(P2.payload, this.onPayloadHandler), this.provider.off(P2.connect, this.onConnectHandler), this.provider.off(P2.disconnect, this.onDisconnectHandler), this.provider.off(P2.error, this.onProviderErrorHandler);
  }
  async registerEventListeners() {
    this.events.on(D4.connection_stalled, () => {
      this.restartTransport().catch((t) => this.logger.error(t));
    });
    let e = await rr4();
    or4(async (t) => {
      this.initialized && e !== t && (e = t, t ? await this.restartTransport().catch((i3) => this.logger.error(i3)) : (this.hasExperiencedNetworkDisruption = true, await this.transportClose().catch((i3) => this.logger.error(i3))));
    });
  }
  onProviderDisconnect() {
    this.events.emit(D4.disconnect), this.attemptToReconnect();
  }
  attemptToReconnect() {
    this.transportExplicitlyClosed || (this.logger.info("attemptToReconnect called. Connecting..."), setTimeout(async () => {
      await this.restartTransport().catch((e) => this.logger.error(e));
    }, (0, import_time5.toMiliseconds)(dt5)));
  }
  isInitialized() {
    if (!this.initialized) {
      const { message: e } = N4("NOT_INITIALIZED", this.name);
      throw new Error(e);
    }
  }
  async toEstablishConnection() {
    if (await this.confirmOnlineStateOrThrow(), !this.connected) {
      if (this.connectionAttemptInProgress)
        return await new Promise((e) => {
          const t = setInterval(() => {
            this.connected && (clearInterval(t), e());
          }, this.connectionStatusPollingInterval);
        });
      await this.restartTransport();
    }
  }
};
var zr3 = Object.defineProperty;
var Ft4 = Object.getOwnPropertySymbols;
var Nr3 = Object.prototype.hasOwnProperty;
var Ur2 = Object.prototype.propertyIsEnumerable;
var Mt4 = (n4, e, t) => e in n4 ? zr3(n4, e, { enumerable: true, configurable: true, writable: true, value: t }) : n4[e] = t;
var kt3 = (n4, e) => {
  for (var t in e || (e = {}))
    Nr3.call(e, t) && Mt4(n4, t, e[t]);
  if (Ft4)
    for (var t of Ft4(e))
      Ur2.call(e, t) && Mt4(n4, t, e[t]);
  return n4;
};
var Kt5 = class extends p3 {
  constructor(e, t, i3, s = O4, r = void 0) {
    super(e, t, i3, s), this.core = e, this.logger = t, this.name = i3, this.map = /* @__PURE__ */ new Map(), this.version = Dt3, this.cached = [], this.initialized = false, this.storagePrefix = O4, this.init = async () => {
      this.initialized || (this.logger.trace("Initialized"), await this.restore(), this.cached.forEach((o3) => {
        this.getKey && o3 !== null && !w4(o3) ? this.map.set(this.getKey(o3), o3) : Lt4(o3) ? this.map.set(o3.id, o3) : xt4(o3) && this.map.set(o3.topic, o3);
      }), this.cached = [], this.initialized = true);
    }, this.set = async (o3, a3) => {
      this.isInitialized(), this.map.has(o3) ? await this.update(o3, a3) : (this.logger.debug("Setting value"), this.logger.trace({ type: "method", method: "set", key: o3, value: a3 }), this.map.set(o3, a3), await this.persist());
    }, this.get = (o3) => (this.isInitialized(), this.logger.debug("Getting value"), this.logger.trace({ type: "method", method: "get", key: o3 }), this.getData(o3)), this.getAll = (o3) => (this.isInitialized(), o3 ? this.values.filter((a3) => Object.keys(o3).every((h5) => (0, import_lodash2.default)(a3[h5], o3[h5]))) : this.values), this.update = async (o3, a3) => {
      this.isInitialized(), this.logger.debug("Updating value"), this.logger.trace({ type: "method", method: "update", key: o3, update: a3 });
      const h5 = kt3(kt3({}, this.getData(o3)), a3);
      this.map.set(o3, h5), await this.persist();
    }, this.delete = async (o3, a3) => {
      this.isInitialized(), this.map.has(o3) && (this.logger.debug("Deleting value"), this.logger.trace({ type: "method", method: "delete", key: o3, reason: a3 }), this.map.delete(o3), await this.persist());
    }, this.logger = (0, import_logger3.generateChildLogger)(t, this.name), this.storagePrefix = s, this.getKey = r;
  }
  get context() {
    return (0, import_logger3.getLoggerContext)(this.logger);
  }
  get storageKey() {
    return this.storagePrefix + this.version + this.core.customStoragePrefix + "//" + this.name;
  }
  get length() {
    return this.map.size;
  }
  get keys() {
    return Array.from(this.map.keys());
  }
  get values() {
    return Array.from(this.map.values());
  }
  async setDataStore(e) {
    await this.core.storage.setItem(this.storageKey, e);
  }
  async getDataStore() {
    return await this.core.storage.getItem(this.storageKey);
  }
  getData(e) {
    const t = this.map.get(e);
    if (!t) {
      const { message: i3 } = N4("NO_MATCHING_KEY", `${this.name}: ${e}`);
      throw this.logger.error(i3), new Error(i3);
    }
    return t;
  }
  async persist() {
    await this.setDataStore(this.values);
  }
  async restore() {
    try {
      const e = await this.getDataStore();
      if (typeof e > "u" || !e.length)
        return;
      if (this.map.size) {
        const { message: t } = N4("RESTORE_WILL_OVERRIDE", this.name);
        throw this.logger.error(t), new Error(t);
      }
      this.cached = e, this.logger.debug(`Successfully Restored value for ${this.name}`), this.logger.trace({ type: "method", method: "restore", value: this.values });
    } catch (e) {
      this.logger.debug(`Failed to Restore value for ${this.name}`), this.logger.error(e);
    }
  }
  isInitialized() {
    if (!this.initialized) {
      const { message: e } = N4("NOT_INITIALIZED", this.name);
      throw new Error(e);
    }
  }
};
var Bt4 = class {
  constructor(e, t) {
    this.core = e, this.logger = t, this.name = Et5, this.version = wt5, this.events = new import_events7.default(), this.initialized = false, this.storagePrefix = O4, this.ignoredPayloadTypes = [_2], this.registeredMethods = [], this.init = async () => {
      this.initialized || (await this.pairings.init(), await this.cleanup(), this.registerRelayerEvents(), this.registerExpirerEvents(), this.initialized = true, this.logger.trace("Initialized"));
    }, this.register = ({ methods: i3 }) => {
      this.isInitialized(), this.registeredMethods = [.../* @__PURE__ */ new Set([...this.registeredMethods, ...i3])];
    }, this.create = async () => {
      this.isInitialized();
      const i3 = Vn2(), s = await this.core.crypto.setSymKey(i3), r = pt4(import_time5.FIVE_MINUTES), o3 = { protocol: ht4 }, a3 = { topic: s, expiry: r, relay: o3, active: false }, h5 = Rt4({ protocol: this.core.protocol, version: this.core.version, topic: s, symKey: i3, relay: o3, expiryTimestamp: r });
      return await this.pairings.set(s, a3), await this.core.relayer.subscribe(s), this.core.expirer.set(s, r), { topic: s, uri: h5 };
    }, this.pair = async (i3) => {
      this.isInitialized(), this.isValidPair(i3);
      const { topic: s, symKey: r, relay: o3, expiryTimestamp: a3 } = Pt4(i3.uri);
      let h5;
      if (this.pairings.keys.includes(s) && (h5 = this.pairings.get(s), h5.active))
        throw new Error(`Pairing already exists: ${s}. Please try again with a new connection URI.`);
      const l2 = a3 || pt4(import_time5.FIVE_MINUTES), d5 = { topic: s, relay: o3, expiry: l2, active: false };
      return await this.pairings.set(s, d5), this.core.expirer.set(s, l2), i3.activatePairing && await this.activate({ topic: s }), this.events.emit(V4.create, d5), this.core.crypto.keychain.has(s) || (await this.core.crypto.setSymKey(r, s), await this.core.relayer.subscribe(s, { relay: o3 })), d5;
    }, this.activate = async ({ topic: i3 }) => {
      this.isInitialized();
      const s = pt4(import_time5.THIRTY_DAYS);
      await this.pairings.update(i3, { active: true, expiry: s }), this.core.expirer.set(i3, s);
    }, this.ping = async (i3) => {
      this.isInitialized(), await this.isValidPing(i3);
      const { topic: s } = i3;
      if (this.pairings.keys.includes(s)) {
        const r = await this.sendRequest(s, "wc_pairingPing", {}), { done: o3, resolve: a3, reject: h5 } = at4();
        this.events.once(yt4("pairing_ping", r), ({ error: l2 }) => {
          l2 ? h5(l2) : a3();
        }), await o3();
      }
    }, this.updateExpiry = async ({ topic: i3, expiry: s }) => {
      this.isInitialized(), await this.pairings.update(i3, { expiry: s });
    }, this.updateMetadata = async ({ topic: i3, metadata: s }) => {
      this.isInitialized(), await this.pairings.update(i3, { peerMetadata: s });
    }, this.getPairings = () => (this.isInitialized(), this.pairings.values), this.disconnect = async (i3) => {
      this.isInitialized(), await this.isValidDisconnect(i3);
      const { topic: s } = i3;
      this.pairings.keys.includes(s) && (await this.sendRequest(s, "wc_pairingDelete", U4("USER_DISCONNECTED")), await this.deletePairing(s));
    }, this.sendRequest = async (i3, s, r) => {
      const o3 = formatJsonRpcRequest(s, r), a3 = await this.core.crypto.encode(i3, o3), h5 = $5[s].req;
      return this.core.history.set(i3, o3), this.core.relayer.publish(i3, a3, h5), o3.id;
    }, this.sendResult = async (i3, s, r) => {
      const o3 = formatJsonRpcResult(i3, r), a3 = await this.core.crypto.encode(s, o3), h5 = await this.core.history.get(s, i3), l2 = $5[h5.request.method].res;
      await this.core.relayer.publish(s, a3, l2), await this.core.history.resolve(o3);
    }, this.sendError = async (i3, s, r) => {
      const o3 = formatJsonRpcError(i3, r), a3 = await this.core.crypto.encode(s, o3), h5 = await this.core.history.get(s, i3), l2 = $5[h5.request.method] ? $5[h5.request.method].res : $5.unregistered_method.res;
      await this.core.relayer.publish(s, a3, l2), await this.core.history.resolve(o3);
    }, this.deletePairing = async (i3, s) => {
      await this.core.relayer.unsubscribe(i3), await Promise.all([this.pairings.delete(i3, U4("USER_DISCONNECTED")), this.core.crypto.deleteSymKey(i3), s ? Promise.resolve() : this.core.expirer.del(i3)]);
    }, this.cleanup = async () => {
      const i3 = this.pairings.getAll().filter((s) => mt4(s.expiry));
      await Promise.all(i3.map((s) => this.deletePairing(s.topic)));
    }, this.onRelayEventRequest = (i3) => {
      const { topic: s, payload: r } = i3;
      switch (r.method) {
        case "wc_pairingPing":
          return this.onPairingPingRequest(s, r);
        case "wc_pairingDelete":
          return this.onPairingDeleteRequest(s, r);
        default:
          return this.onUnknownRpcMethodRequest(s, r);
      }
    }, this.onRelayEventResponse = async (i3) => {
      const { topic: s, payload: r } = i3, o3 = (await this.core.history.get(s, r.id)).request.method;
      switch (o3) {
        case "wc_pairingPing":
          return this.onPairingPingResponse(s, r);
        default:
          return this.onUnknownRpcMethodResponse(o3);
      }
    }, this.onPairingPingRequest = async (i3, s) => {
      const { id: r } = s;
      try {
        this.isValidPing({ topic: i3 }), await this.sendResult(r, i3, true), this.events.emit(V4.ping, { id: r, topic: i3 });
      } catch (o3) {
        await this.sendError(r, i3, o3), this.logger.error(o3);
      }
    }, this.onPairingPingResponse = (i3, s) => {
      const { id: r } = s;
      setTimeout(() => {
        isJsonRpcResult(s) ? this.events.emit(yt4("pairing_ping", r), {}) : isJsonRpcError(s) && this.events.emit(yt4("pairing_ping", r), { error: s.error });
      }, 500);
    }, this.onPairingDeleteRequest = async (i3, s) => {
      const { id: r } = s;
      try {
        this.isValidDisconnect({ topic: i3 }), await this.deletePairing(i3), this.events.emit(V4.delete, { id: r, topic: i3 });
      } catch (o3) {
        await this.sendError(r, i3, o3), this.logger.error(o3);
      }
    }, this.onUnknownRpcMethodRequest = async (i3, s) => {
      const { id: r, method: o3 } = s;
      try {
        if (this.registeredMethods.includes(o3))
          return;
        const a3 = U4("WC_METHOD_UNSUPPORTED", o3);
        await this.sendError(r, i3, a3), this.logger.error(a3);
      } catch (a3) {
        await this.sendError(r, i3, a3), this.logger.error(a3);
      }
    }, this.onUnknownRpcMethodResponse = (i3) => {
      this.registeredMethods.includes(i3) || this.logger.error(U4("WC_METHOD_UNSUPPORTED", i3));
    }, this.isValidPair = (i3) => {
      var s;
      if (!Gt4(i3)) {
        const { message: o3 } = N4("MISSING_OR_INVALID", `pair() params: ${i3}`);
        throw new Error(o3);
      }
      if (!Kt4(i3.uri)) {
        const { message: o3 } = N4("MISSING_OR_INVALID", `pair() uri: ${i3.uri}`);
        throw new Error(o3);
      }
      const r = Pt4(i3.uri);
      if (!((s = r == null ? void 0 : r.relay) != null && s.protocol)) {
        const { message: o3 } = N4("MISSING_OR_INVALID", "pair() uri#relay-protocol");
        throw new Error(o3);
      }
      if (!(r != null && r.symKey)) {
        const { message: o3 } = N4("MISSING_OR_INVALID", "pair() uri#symKey");
        throw new Error(o3);
      }
      if (r != null && r.expiryTimestamp && (0, import_time5.toMiliseconds)(r == null ? void 0 : r.expiryTimestamp) < Date.now()) {
        const { message: o3 } = N4("EXPIRED", "pair() URI has expired. Please try again with a new connection URI.");
        throw new Error(o3);
      }
    }, this.isValidPing = async (i3) => {
      if (!Gt4(i3)) {
        const { message: r } = N4("MISSING_OR_INVALID", `ping() params: ${i3}`);
        throw new Error(r);
      }
      const { topic: s } = i3;
      await this.isValidPairingTopic(s);
    }, this.isValidDisconnect = async (i3) => {
      if (!Gt4(i3)) {
        const { message: r } = N4("MISSING_OR_INVALID", `disconnect() params: ${i3}`);
        throw new Error(r);
      }
      const { topic: s } = i3;
      await this.isValidPairingTopic(s);
    }, this.isValidPairingTopic = async (i3) => {
      if (!g5(i3, false)) {
        const { message: s } = N4("MISSING_OR_INVALID", `pairing topic should be a string: ${i3}`);
        throw new Error(s);
      }
      if (!this.pairings.keys.includes(i3)) {
        const { message: s } = N4("NO_MATCHING_KEY", `pairing topic doesn't exist: ${i3}`);
        throw new Error(s);
      }
      if (mt4(this.pairings.get(i3).expiry)) {
        await this.deletePairing(i3);
        const { message: s } = N4("EXPIRED", `pairing topic: ${i3}`);
        throw new Error(s);
      }
    }, this.core = e, this.logger = (0, import_logger3.generateChildLogger)(t, this.name), this.pairings = new Kt5(this.core, this.logger, this.name, this.storagePrefix);
  }
  get context() {
    return (0, import_logger3.getLoggerContext)(this.logger);
  }
  isInitialized() {
    if (!this.initialized) {
      const { message: e } = N4("NOT_INITIALIZED", this.name);
      throw new Error(e);
    }
  }
  registerRelayerEvents() {
    this.core.relayer.on(D4.message, async (e) => {
      const { topic: t, message: i3 } = e;
      if (!this.pairings.keys.includes(t) || this.ignoredPayloadTypes.includes(this.core.crypto.getPayloadType(i3)))
        return;
      const s = await this.core.crypto.decode(t, i3);
      try {
        isJsonRpcRequest(s) ? (this.core.history.set(t, s), this.onRelayEventRequest({ topic: t, payload: s })) : isJsonRpcResponse(s) && (await this.core.history.resolve(s), await this.onRelayEventResponse({ topic: t, payload: s }), this.core.history.delete(t, s.id));
      } catch (r) {
        this.logger.error(r);
      }
    });
  }
  registerExpirerEvents() {
    this.core.expirer.on(v4.expired, async (e) => {
      const { topic: t } = ft4(e.target);
      t && this.pairings.keys.includes(t) && (await this.deletePairing(t, true), this.events.emit(V4.expire, { topic: t }));
    });
  }
};
var Vt3 = class extends h3 {
  constructor(e, t) {
    super(e, t), this.core = e, this.logger = t, this.records = /* @__PURE__ */ new Map(), this.events = new import_events7.EventEmitter(), this.name = vt5, this.version = It5, this.cached = [], this.initialized = false, this.storagePrefix = O4, this.init = async () => {
      this.initialized || (this.logger.trace("Initialized"), await this.restore(), this.cached.forEach((i3) => this.records.set(i3.id, i3)), this.cached = [], this.registerEventListeners(), this.initialized = true);
    }, this.set = (i3, s, r) => {
      if (this.isInitialized(), this.logger.debug("Setting JSON-RPC request history record"), this.logger.trace({ type: "method", method: "set", topic: i3, request: s, chainId: r }), this.records.has(s.id))
        return;
      const o3 = { id: s.id, topic: i3, request: { method: s.method, params: s.params || null }, chainId: r, expiry: pt4(import_time5.THIRTY_DAYS) };
      this.records.set(o3.id, o3), this.events.emit(R5.created, o3);
    }, this.resolve = async (i3) => {
      if (this.isInitialized(), this.logger.debug("Updating JSON-RPC response history record"), this.logger.trace({ type: "method", method: "update", response: i3 }), !this.records.has(i3.id))
        return;
      const s = await this.getRecord(i3.id);
      typeof s.response > "u" && (s.response = isJsonRpcError(i3) ? { error: i3.error } : { result: i3.result }, this.records.set(s.id, s), this.events.emit(R5.updated, s));
    }, this.get = async (i3, s) => (this.isInitialized(), this.logger.debug("Getting record"), this.logger.trace({ type: "method", method: "get", topic: i3, id: s }), await this.getRecord(s)), this.delete = (i3, s) => {
      this.isInitialized(), this.logger.debug("Deleting record"), this.logger.trace({ type: "method", method: "delete", id: s }), this.values.forEach((r) => {
        if (r.topic === i3) {
          if (typeof s < "u" && r.id !== s)
            return;
          this.records.delete(r.id), this.events.emit(R5.deleted, r);
        }
      });
    }, this.exists = async (i3, s) => (this.isInitialized(), this.records.has(s) ? (await this.getRecord(s)).topic === i3 : false), this.on = (i3, s) => {
      this.events.on(i3, s);
    }, this.once = (i3, s) => {
      this.events.once(i3, s);
    }, this.off = (i3, s) => {
      this.events.off(i3, s);
    }, this.removeListener = (i3, s) => {
      this.events.removeListener(i3, s);
    }, this.logger = (0, import_logger3.generateChildLogger)(t, this.name);
  }
  get context() {
    return (0, import_logger3.getLoggerContext)(this.logger);
  }
  get storageKey() {
    return this.storagePrefix + this.version + this.core.customStoragePrefix + "//" + this.name;
  }
  get size() {
    return this.records.size;
  }
  get keys() {
    return Array.from(this.records.keys());
  }
  get values() {
    return Array.from(this.records.values());
  }
  get pending() {
    const e = [];
    return this.values.forEach((t) => {
      if (typeof t.response < "u")
        return;
      const i3 = { topic: t.topic, request: formatJsonRpcRequest(t.request.method, t.request.params, t.id), chainId: t.chainId };
      return e.push(i3);
    }), e;
  }
  async setJsonRpcRecords(e) {
    await this.core.storage.setItem(this.storageKey, e);
  }
  async getJsonRpcRecords() {
    return await this.core.storage.getItem(this.storageKey);
  }
  getRecord(e) {
    this.isInitialized();
    const t = this.records.get(e);
    if (!t) {
      const { message: i3 } = N4("NO_MATCHING_KEY", `${this.name}: ${e}`);
      throw new Error(i3);
    }
    return t;
  }
  async persist() {
    await this.setJsonRpcRecords(this.values), this.events.emit(R5.sync);
  }
  async restore() {
    try {
      const e = await this.getJsonRpcRecords();
      if (typeof e > "u" || !e.length)
        return;
      if (this.records.size) {
        const { message: t } = N4("RESTORE_WILL_OVERRIDE", this.name);
        throw this.logger.error(t), new Error(t);
      }
      this.cached = e, this.logger.debug(`Successfully Restored records for ${this.name}`), this.logger.trace({ type: "method", method: "restore", records: this.values });
    } catch (e) {
      this.logger.debug(`Failed to Restore records for ${this.name}`), this.logger.error(e);
    }
  }
  registerEventListeners() {
    this.events.on(R5.created, (e) => {
      const t = R5.created;
      this.logger.info(`Emitting ${t}`), this.logger.debug({ type: "event", event: t, record: e }), this.persist();
    }), this.events.on(R5.updated, (e) => {
      const t = R5.updated;
      this.logger.info(`Emitting ${t}`), this.logger.debug({ type: "event", event: t, record: e }), this.persist();
    }), this.events.on(R5.deleted, (e) => {
      const t = R5.deleted;
      this.logger.info(`Emitting ${t}`), this.logger.debug({ type: "event", event: t, record: e }), this.persist();
    }), this.core.heartbeat.on(import_heartbeat2.HEARTBEAT_EVENTS.pulse, () => {
      this.cleanup();
    });
  }
  cleanup() {
    try {
      this.records.forEach((e) => {
        (0, import_time5.toMiliseconds)(e.expiry || 0) - Date.now() <= 0 && (this.logger.info(`Deleting expired history log: ${e.id}`), this.delete(e.topic, e.id));
      });
    } catch (e) {
      this.logger.warn(e);
    }
  }
  isInitialized() {
    if (!this.initialized) {
      const { message: e } = N4("NOT_INITIALIZED", this.name);
      throw new Error(e);
    }
  }
};
var qt4 = class extends E3 {
  constructor(e, t) {
    super(e, t), this.core = e, this.logger = t, this.expirations = /* @__PURE__ */ new Map(), this.events = new import_events7.EventEmitter(), this.name = Ct3, this.version = Rt5, this.cached = [], this.initialized = false, this.storagePrefix = O4, this.init = async () => {
      this.initialized || (this.logger.trace("Initialized"), await this.restore(), this.cached.forEach((i3) => this.expirations.set(i3.target, i3)), this.cached = [], this.registerEventListeners(), this.initialized = true);
    }, this.has = (i3) => {
      try {
        const s = this.formatTarget(i3);
        return typeof this.getExpiration(s) < "u";
      } catch {
        return false;
      }
    }, this.set = (i3, s) => {
      this.isInitialized();
      const r = this.formatTarget(i3), o3 = { target: r, expiry: s };
      this.expirations.set(r, o3), this.checkExpiry(r, o3), this.events.emit(v4.created, { target: r, expiration: o3 });
    }, this.get = (i3) => {
      this.isInitialized();
      const s = this.formatTarget(i3);
      return this.getExpiration(s);
    }, this.del = (i3) => {
      if (this.isInitialized(), this.has(i3)) {
        const s = this.formatTarget(i3), r = this.getExpiration(s);
        this.expirations.delete(s), this.events.emit(v4.deleted, { target: s, expiration: r });
      }
    }, this.on = (i3, s) => {
      this.events.on(i3, s);
    }, this.once = (i3, s) => {
      this.events.once(i3, s);
    }, this.off = (i3, s) => {
      this.events.off(i3, s);
    }, this.removeListener = (i3, s) => {
      this.events.removeListener(i3, s);
    }, this.logger = (0, import_logger3.generateChildLogger)(t, this.name);
  }
  get context() {
    return (0, import_logger3.getLoggerContext)(this.logger);
  }
  get storageKey() {
    return this.storagePrefix + this.version + this.core.customStoragePrefix + "//" + this.name;
  }
  get length() {
    return this.expirations.size;
  }
  get keys() {
    return Array.from(this.expirations.keys());
  }
  get values() {
    return Array.from(this.expirations.values());
  }
  formatTarget(e) {
    if (typeof e == "string")
      return lt4(e);
    if (typeof e == "number")
      return dt4(e);
    const { message: t } = N4("UNKNOWN_TYPE", `Target type: ${typeof e}`);
    throw new Error(t);
  }
  async setExpirations(e) {
    await this.core.storage.setItem(this.storageKey, e);
  }
  async getExpirations() {
    return await this.core.storage.getItem(this.storageKey);
  }
  async persist() {
    await this.setExpirations(this.values), this.events.emit(v4.sync);
  }
  async restore() {
    try {
      const e = await this.getExpirations();
      if (typeof e > "u" || !e.length)
        return;
      if (this.expirations.size) {
        const { message: t } = N4("RESTORE_WILL_OVERRIDE", this.name);
        throw this.logger.error(t), new Error(t);
      }
      this.cached = e, this.logger.debug(`Successfully Restored expirations for ${this.name}`), this.logger.trace({ type: "method", method: "restore", expirations: this.values });
    } catch (e) {
      this.logger.debug(`Failed to Restore expirations for ${this.name}`), this.logger.error(e);
    }
  }
  getExpiration(e) {
    const t = this.expirations.get(e);
    if (!t) {
      const { message: i3 } = N4("NO_MATCHING_KEY", `${this.name}: ${e}`);
      throw this.logger.error(i3), new Error(i3);
    }
    return t;
  }
  checkExpiry(e, t) {
    const { expiry: i3 } = t;
    (0, import_time5.toMiliseconds)(i3) - Date.now() <= 0 && this.expire(e, t);
  }
  expire(e, t) {
    this.expirations.delete(e), this.events.emit(v4.expired, { target: e, expiration: t });
  }
  checkExpirations() {
    this.core.relayer.connected && this.expirations.forEach((e, t) => this.checkExpiry(t, e));
  }
  registerEventListeners() {
    this.core.heartbeat.on(import_heartbeat2.HEARTBEAT_EVENTS.pulse, () => this.checkExpirations()), this.events.on(v4.created, (e) => {
      const t = v4.created;
      this.logger.info(`Emitting ${t}`), this.logger.debug({ type: "event", event: t, data: e }), this.persist();
    }), this.events.on(v4.expired, (e) => {
      const t = v4.expired;
      this.logger.info(`Emitting ${t}`), this.logger.debug({ type: "event", event: t, data: e }), this.persist();
    }), this.events.on(v4.deleted, (e) => {
      const t = v4.deleted;
      this.logger.info(`Emitting ${t}`), this.logger.debug({ type: "event", event: t, data: e }), this.persist();
    });
  }
  isInitialized() {
    if (!this.initialized) {
      const { message: e } = N4("NOT_INITIALIZED", this.name);
      throw new Error(e);
    }
  }
};
var jt3 = class extends y2 {
  constructor(e, t) {
    super(e, t), this.projectId = e, this.logger = t, this.name = Z5, this.initialized = false, this.queue = [], this.verifyDisabled = false, this.init = async (i3) => {
      if (this.verifyDisabled || $4() || !D3())
        return;
      const s = this.getVerifyUrl(i3 == null ? void 0 : i3.verifyUrl);
      this.verifyUrl !== s && this.removeIframe(), this.verifyUrl = s;
      try {
        await this.createIframe();
      } catch (r) {
        this.logger.info(`Verify iframe failed to load: ${this.verifyUrl}`), this.logger.info(r);
      }
      if (!this.initialized) {
        this.removeIframe(), this.verifyUrl = ee5;
        try {
          await this.createIframe();
        } catch (r) {
          this.logger.info(`Verify iframe failed to load: ${this.verifyUrl}`), this.logger.info(r), this.verifyDisabled = true;
        }
      }
    }, this.register = async (i3) => {
      this.initialized ? this.sendPost(i3.attestationId) : (this.addToQueue(i3.attestationId), await this.init());
    }, this.resolve = async (i3) => {
      if (this.isDevEnv)
        return "";
      const s = this.getVerifyUrl(i3 == null ? void 0 : i3.verifyUrl);
      let r;
      try {
        r = await this.fetchAttestation(i3.attestationId, s);
      } catch (o3) {
        this.logger.info(`failed to resolve attestation: ${i3.attestationId} from url: ${s}`), this.logger.info(o3), r = await this.fetchAttestation(i3.attestationId, ee5);
      }
      return r;
    }, this.fetchAttestation = async (i3, s) => {
      this.logger.info(`resolving attestation: ${i3} from url: ${s}`);
      const r = this.startAbortTimer(import_time5.ONE_SECOND * 2), o3 = await fetch(`${s}/attestation/${i3}`, { signal: this.abortController.signal });
      return clearTimeout(r), o3.status === 200 ? await o3.json() : void 0;
    }, this.addToQueue = (i3) => {
      this.queue.push(i3);
    }, this.processQueue = () => {
      this.queue.length !== 0 && (this.queue.forEach((i3) => this.sendPost(i3)), this.queue = []);
    }, this.sendPost = (i3) => {
      var s;
      try {
        if (!this.iframe)
          return;
        (s = this.iframe.contentWindow) == null || s.postMessage(i3, "*"), this.logger.info(`postMessage sent: ${i3} ${this.verifyUrl}`);
      } catch {
      }
    }, this.createIframe = async () => {
      let i3;
      const s = (r) => {
        r.data === "verify_ready" && (this.initialized = true, this.processQueue(), window.removeEventListener("message", s), i3());
      };
      await Promise.race([new Promise((r) => {
        if (document.getElementById(Z5))
          return r();
        window.addEventListener("message", s);
        const o3 = document.createElement("iframe");
        o3.id = Z5, o3.src = `${this.verifyUrl}/${this.projectId}`, o3.style.display = "none", document.body.append(o3), this.iframe = o3, i3 = r;
      }), new Promise((r, o3) => setTimeout(() => {
        window.removeEventListener("message", s), o3("verify iframe load timeout");
      }, (0, import_time5.toMiliseconds)(import_time5.FIVE_SECONDS)))]);
    }, this.removeIframe = () => {
      this.iframe && (this.iframe.remove(), this.iframe = void 0, this.initialized = false);
    }, this.getVerifyUrl = (i3) => {
      let s = i3 || F5;
      return _t3.includes(s) || (this.logger.info(`verify url: ${s}, not included in trusted list, assigning default: ${F5}`), s = F5), s;
    }, this.logger = (0, import_logger3.generateChildLogger)(t, this.name), this.verifyUrl = F5, this.abortController = new AbortController(), this.isDevEnv = te4() && import_process.default.env.IS_VITEST;
  }
  get context() {
    return (0, import_logger3.getLoggerContext)(this.logger);
  }
  startAbortTimer(e) {
    return this.abortController = new AbortController(), setTimeout(() => this.abortController.abort(), (0, import_time5.toMiliseconds)(e));
  }
};
var Gt5 = class extends v3 {
  constructor(e, t) {
    super(e, t), this.projectId = e, this.logger = t, this.context = Tt5, this.registerDeviceToken = async (i3) => {
      const { clientId: s, token: r, notificationType: o3, enableEncrypted: a3 = false } = i3, h5 = `${St5}/${this.projectId}/clients`;
      await (0, import_isomorphic_unfetch3.default)(h5, { method: "POST", headers: { "Content-Type": "application/json" }, body: JSON.stringify({ client_id: s, type: o3, token: r, always_raw: a3 }) });
    }, this.logger = (0, import_logger3.generateChildLogger)(t, this.context);
  }
};
var Lr2 = Object.defineProperty;
var Yt4 = Object.getOwnPropertySymbols;
var $r3 = Object.prototype.hasOwnProperty;
var Fr3 = Object.prototype.propertyIsEnumerable;
var Ht4 = (n4, e, t) => e in n4 ? Lr2(n4, e, { enumerable: true, configurable: true, writable: true, value: t }) : n4[e] = t;
var Jt4 = (n4, e) => {
  for (var t in e || (e = {}))
    $r3.call(e, t) && Ht4(n4, t, e[t]);
  if (Yt4)
    for (var t of Yt4(e))
      Fr3.call(e, t) && Ht4(n4, t, e[t]);
  return n4;
};
var te5 = class _te extends n3 {
  constructor(e) {
    super(e), this.protocol = le5, this.version = We5, this.name = Q5, this.events = new import_events7.EventEmitter(), this.initialized = false, this.on = (i3, s) => this.events.on(i3, s), this.once = (i3, s) => this.events.once(i3, s), this.off = (i3, s) => this.events.off(i3, s), this.removeListener = (i3, s) => this.events.removeListener(i3, s), this.projectId = e == null ? void 0 : e.projectId, this.relayUrl = (e == null ? void 0 : e.relayUrl) || ge5, this.customStoragePrefix = e != null && e.customStoragePrefix ? `:${e.customStoragePrefix}` : "";
    const t = typeof (e == null ? void 0 : e.logger) < "u" && typeof (e == null ? void 0 : e.logger) != "string" ? e.logger : (0, import_logger3.pino)((0, import_logger3.getDefaultLoggerOptions)({ level: (e == null ? void 0 : e.logger) || Qe3.logger }));
    this.logger = (0, import_logger3.generateChildLogger)(t, this.name), this.heartbeat = new import_heartbeat2.HeartBeat(), this.crypto = new xt5(this, this.logger, e == null ? void 0 : e.keychain), this.history = new Vt3(this, this.logger), this.expirer = new qt4(this, this.logger), this.storage = e != null && e.storage ? e.storage : new h(Jt4(Jt4({}, Ze4), e == null ? void 0 : e.storageOptions)), this.relayer = new $t3({ core: this, logger: this.logger, relayUrl: this.relayUrl, projectId: this.projectId }), this.pairing = new Bt4(this, this.logger), this.verify = new jt3(this.projectId || "", this.logger), this.echoClient = new Gt5(this.projectId || "", this.logger);
  }
  static async init(e) {
    const t = new _te(e);
    await t.initialize();
    const i3 = await t.crypto.getClientId();
    return await t.storage.setItem(yt5, i3), t;
  }
  get context() {
    return (0, import_logger3.getLoggerContext)(this.logger);
  }
  async start() {
    this.initialized || await this.initialize();
  }
  async initialize() {
    this.logger.trace("Initialized");
    try {
      await this.crypto.init(), await this.history.init(), await this.expirer.init(), await this.relayer.init(), await this.heartbeat.init(), await this.pairing.init(), this.initialized = true, this.logger.info("Core Initialization Success");
    } catch (e) {
      throw this.logger.warn(`Core Initialization Failure at epoch ${Date.now()}`, e), this.logger.error(e.message), e;
    }
  }
};
var Mr3 = te5;

// node_modules/@walletconnect/web3wallet/node_modules/@walletconnect/sign-client/dist/index.es.js
var import_logger4 = __toESM(require_cjs3());
var import_events8 = __toESM(require_events());
var import_time6 = __toESM(require_cjs());
var J3 = "wc";
var F6 = 2;
var X5 = "client";
var G6 = `${J3}@${F6}:${X5}:`;
var M4 = { name: X5, logger: "error", controller: false, relayUrl: "wss://relay.walletconnect.com" };
var H4 = "WALLETCONNECT_DEEPLINK_CHOICE";
var oe2 = "proposal";
var ae3 = "Proposal expired";
var ce5 = "session";
var L5 = import_time6.SEVEN_DAYS;
var le6 = "engine";
var R6 = { wc_sessionPropose: { req: { ttl: import_time6.FIVE_MINUTES, prompt: true, tag: 1100 }, res: { ttl: import_time6.FIVE_MINUTES, prompt: false, tag: 1101 } }, wc_sessionSettle: { req: { ttl: import_time6.FIVE_MINUTES, prompt: false, tag: 1102 }, res: { ttl: import_time6.FIVE_MINUTES, prompt: false, tag: 1103 } }, wc_sessionUpdate: { req: { ttl: import_time6.ONE_DAY, prompt: false, tag: 1104 }, res: { ttl: import_time6.ONE_DAY, prompt: false, tag: 1105 } }, wc_sessionExtend: { req: { ttl: import_time6.ONE_DAY, prompt: false, tag: 1106 }, res: { ttl: import_time6.ONE_DAY, prompt: false, tag: 1107 } }, wc_sessionRequest: { req: { ttl: import_time6.FIVE_MINUTES, prompt: true, tag: 1108 }, res: { ttl: import_time6.FIVE_MINUTES, prompt: false, tag: 1109 } }, wc_sessionEvent: { req: { ttl: import_time6.FIVE_MINUTES, prompt: true, tag: 1110 }, res: { ttl: import_time6.FIVE_MINUTES, prompt: false, tag: 1111 } }, wc_sessionDelete: { req: { ttl: import_time6.ONE_DAY, prompt: false, tag: 1112 }, res: { ttl: import_time6.ONE_DAY, prompt: false, tag: 1113 } }, wc_sessionPing: { req: { ttl: import_time6.THIRTY_SECONDS, prompt: false, tag: 1114 }, res: { ttl: import_time6.THIRTY_SECONDS, prompt: false, tag: 1115 } } };
var U6 = { min: import_time6.FIVE_MINUTES, max: import_time6.SEVEN_DAYS };
var I2 = { idle: "IDLE", active: "ACTIVE" };
var pe4 = "request";
var he6 = ["wc_sessionPropose", "wc_sessionRequest", "wc_authRequest"];
var as3 = Object.defineProperty;
var cs3 = Object.defineProperties;
var ls3 = Object.getOwnPropertyDescriptors;
var de6 = Object.getOwnPropertySymbols;
var ps3 = Object.prototype.hasOwnProperty;
var hs3 = Object.prototype.propertyIsEnumerable;
var ue6 = (w7, r, e) => r in w7 ? as3(w7, r, { enumerable: true, configurable: true, writable: true, value: e }) : w7[r] = e;
var g7 = (w7, r) => {
  for (var e in r || (r = {}))
    ps3.call(r, e) && ue6(w7, e, r[e]);
  if (de6)
    for (var e of de6(r))
      hs3.call(r, e) && ue6(w7, e, r[e]);
  return w7;
};
var D5 = (w7, r) => cs3(w7, ls3(r));
var ds3 = class extends w3 {
  constructor(r) {
    super(r), this.name = le6, this.events = new import_events8.default(), this.initialized = false, this.ignoredPayloadTypes = [_2], this.requestQueue = { state: I2.idle, queue: [] }, this.sessionRequestQueue = { state: I2.idle, queue: [] }, this.requestQueueDelay = import_time6.ONE_SECOND, this.init = async () => {
      this.initialized || (await this.cleanup(), this.registerRelayerEvents(), this.registerExpirerEvents(), this.registerPairingEvents(), this.client.core.pairing.register({ methods: Object.keys(R6) }), this.initialized = true, setTimeout(() => {
        this.sessionRequestQueue.queue = this.getPendingSessionRequests(), this.processSessionRequestQueue();
      }, (0, import_time6.toMiliseconds)(this.requestQueueDelay)));
    }, this.connect = async (e) => {
      await this.isInitialized();
      const s = D5(g7({}, e), { requiredNamespaces: e.requiredNamespaces || {}, optionalNamespaces: e.optionalNamespaces || {} });
      await this.isValidConnect(s);
      const { pairingTopic: t, requiredNamespaces: i3, optionalNamespaces: n4, sessionProperties: o3, relays: a3 } = s;
      let c3 = t, p6, d5 = false;
      if (c3 && (d5 = this.client.core.pairing.pairings.get(c3).active), !c3 || !d5) {
        const { topic: T2, uri: _4 } = await this.client.core.pairing.create();
        c3 = T2, p6 = _4;
      }
      const h5 = await this.client.core.crypto.generateKeyPair(), N6 = R6.wc_sessionPropose.req.ttl || import_time6.FIVE_MINUTES, m3 = pt4(N6), f3 = g7({ requiredNamespaces: i3, optionalNamespaces: n4, relays: a3 ?? [{ protocol: ht4 }], proposer: { publicKey: h5, metadata: this.client.metadata }, expiryTimestamp: m3 }, o3 && { sessionProperties: o3 }), { reject: k4, resolve: O6, done: we2 } = at4(N6, ae3);
      if (this.events.once(yt4("session_connect"), async ({ error: T2, session: _4 }) => {
        if (T2)
          k4(T2);
        else if (_4) {
          _4.self.publicKey = h5;
          const B5 = D5(g7({}, _4), { requiredNamespaces: f3.requiredNamespaces, optionalNamespaces: f3.optionalNamespaces });
          await this.client.session.set(_4.topic, B5), await this.setExpiry(_4.topic, _4.expiry), c3 && await this.client.core.pairing.updateMetadata({ topic: c3, metadata: _4.peer.metadata }), O6(B5);
        }
      }), !c3) {
        const { message: T2 } = N4("NO_MATCHING_KEY", `connect() pairing topic: ${c3}`);
        throw new Error(T2);
      }
      const W6 = await this.sendRequest({ topic: c3, method: "wc_sessionPropose", params: f3, throwOnFailedPublish: true });
      return await this.setProposal(W6, g7({ id: W6 }, f3)), { uri: p6, approval: we2 };
    }, this.pair = async (e) => (await this.isInitialized(), await this.client.core.pairing.pair(e)), this.approve = async (e) => {
      await this.isInitialized(), await this.isValidApprove(e);
      const { id: s, relayProtocol: t, namespaces: i3, sessionProperties: n4 } = e, o3 = this.client.proposal.get(s);
      let { pairingTopic: a3, proposer: c3, requiredNamespaces: p6, optionalNamespaces: d5 } = o3;
      a3 = a3 || "";
      const h5 = await this.client.core.crypto.generateKeyPair(), N6 = c3.publicKey, m3 = await this.client.core.crypto.generateSharedKey(h5, N6);
      a3 && s && (await this.client.core.pairing.updateMetadata({ topic: a3, metadata: c3.metadata }), await this.sendResult({ id: s, topic: a3, result: { relay: { protocol: t ?? "irn" }, responderPublicKey: h5 } }), await this.client.proposal.delete(s, U4("USER_DISCONNECTED")), await this.client.core.pairing.activate({ topic: a3 }));
      const f3 = g7({ relay: { protocol: t ?? "irn" }, namespaces: i3, pairingTopic: a3, controller: { publicKey: h5, metadata: this.client.metadata }, expiry: pt4(L5) }, n4 && { sessionProperties: n4 });
      await this.client.core.relayer.subscribe(m3);
      const k4 = D5(g7({}, f3), { topic: m3, requiredNamespaces: p6, optionalNamespaces: d5, pairingTopic: a3, acknowledged: false, self: f3.controller, peer: { publicKey: c3.publicKey, metadata: c3.metadata }, controller: h5 });
      await this.client.session.set(m3, k4);
      try {
        await this.sendRequest({ topic: m3, method: "wc_sessionSettle", params: f3, throwOnFailedPublish: true });
      } catch (O6) {
        throw this.client.logger.error(O6), this.client.session.delete(m3, U4("USER_DISCONNECTED")), await this.client.core.relayer.unsubscribe(m3), O6;
      }
      return await this.setExpiry(m3, pt4(L5)), { topic: m3, acknowledged: () => new Promise((O6) => setTimeout(() => O6(this.client.session.get(m3)), 500)) };
    }, this.reject = async (e) => {
      await this.isInitialized(), await this.isValidReject(e);
      const { id: s, reason: t } = e, { pairingTopic: i3 } = this.client.proposal.get(s);
      i3 && (await this.sendError(s, i3, t), await this.client.proposal.delete(s, U4("USER_DISCONNECTED")));
    }, this.update = async (e) => {
      await this.isInitialized(), await this.isValidUpdate(e);
      const { topic: s, namespaces: t } = e, i3 = await this.sendRequest({ topic: s, method: "wc_sessionUpdate", params: { namespaces: t } }), { done: n4, resolve: o3, reject: a3 } = at4();
      return this.events.once(yt4("session_update", i3), ({ error: c3 }) => {
        c3 ? a3(c3) : o3();
      }), await this.client.session.update(s, { namespaces: t }), { acknowledged: n4 };
    }, this.extend = async (e) => {
      await this.isInitialized(), await this.isValidExtend(e);
      const { topic: s } = e, t = await this.sendRequest({ topic: s, method: "wc_sessionExtend", params: {} }), { done: i3, resolve: n4, reject: o3 } = at4();
      return this.events.once(yt4("session_extend", t), ({ error: a3 }) => {
        a3 ? o3(a3) : n4();
      }), await this.setExpiry(s, pt4(L5)), { acknowledged: i3 };
    }, this.request = async (e) => {
      await this.isInitialized(), await this.isValidRequest(e);
      const { chainId: s, request: t, topic: i3, expiry: n4 = R6.wc_sessionRequest.req.ttl } = e, o3 = payloadId(), { done: a3, resolve: c3, reject: p6 } = at4(n4, "Request expired. Please try again.");
      return this.events.once(yt4("session_request", o3), ({ error: d5, result: h5 }) => {
        d5 ? p6(d5) : c3(h5);
      }), await Promise.all([new Promise(async (d5) => {
        await this.sendRequest({ clientRpcId: o3, topic: i3, method: "wc_sessionRequest", params: { request: D5(g7({}, t), { expiryTimestamp: pt4(n4) }), chainId: s }, expiry: n4, throwOnFailedPublish: true }).catch((h5) => p6(h5)), this.client.events.emit("session_request_sent", { topic: i3, request: t, chainId: s, id: o3 }), d5();
      }), new Promise(async (d5) => {
        const h5 = await ht3(this.client.core.storage, H4);
        gt3({ id: o3, topic: i3, wcDeepLink: h5 }), d5();
      }), a3()]).then((d5) => d5[2]);
    }, this.respond = async (e) => {
      await this.isInitialized(), await this.isValidRespond(e);
      const { topic: s, response: t } = e, { id: i3 } = t;
      isJsonRpcResult(t) ? await this.sendResult({ id: i3, topic: s, result: t.result, throwOnFailedPublish: true }) : isJsonRpcError(t) && await this.sendError(i3, s, t.error), this.cleanupAfterResponse(e);
    }, this.ping = async (e) => {
      await this.isInitialized(), await this.isValidPing(e);
      const { topic: s } = e;
      if (this.client.session.keys.includes(s)) {
        const t = await this.sendRequest({ topic: s, method: "wc_sessionPing", params: {} }), { done: i3, resolve: n4, reject: o3 } = at4();
        this.events.once(yt4("session_ping", t), ({ error: a3 }) => {
          a3 ? o3(a3) : n4();
        }), await i3();
      } else
        this.client.core.pairing.pairings.keys.includes(s) && await this.client.core.pairing.ping({ topic: s });
    }, this.emit = async (e) => {
      await this.isInitialized(), await this.isValidEmit(e);
      const { topic: s, event: t, chainId: i3 } = e;
      await this.sendRequest({ topic: s, method: "wc_sessionEvent", params: { event: t, chainId: i3 } });
    }, this.disconnect = async (e) => {
      await this.isInitialized(), await this.isValidDisconnect(e);
      const { topic: s } = e;
      if (this.client.session.keys.includes(s))
        await this.sendRequest({ topic: s, method: "wc_sessionDelete", params: U4("USER_DISCONNECTED"), throwOnFailedPublish: true }), await this.deleteSession({ topic: s, emitEvent: false });
      else if (this.client.core.pairing.pairings.keys.includes(s))
        await this.client.core.pairing.disconnect({ topic: s });
      else {
        const { message: t } = N4("MISMATCHED_TOPIC", `Session or pairing topic not found: ${s}`);
        throw new Error(t);
      }
    }, this.find = (e) => (this.isInitialized(), this.client.session.getAll().filter((s) => Mt3(s, e))), this.getPendingSessionRequests = () => this.client.pendingRequest.getAll(), this.cleanupDuplicatePairings = async (e) => {
      if (e.pairingTopic)
        try {
          const s = this.client.core.pairing.pairings.get(e.pairingTopic), t = this.client.core.pairing.pairings.getAll().filter((i3) => {
            var n4, o3;
            return ((n4 = i3.peerMetadata) == null ? void 0 : n4.url) && ((o3 = i3.peerMetadata) == null ? void 0 : o3.url) === e.peer.metadata.url && i3.topic && i3.topic !== s.topic;
          });
          if (t.length === 0)
            return;
          this.client.logger.info(`Cleaning up ${t.length} duplicate pairing(s)`), await Promise.all(t.map((i3) => this.client.core.pairing.disconnect({ topic: i3.topic }))), this.client.logger.info("Duplicate pairings clean up finished");
        } catch (s) {
          this.client.logger.error(s);
        }
    }, this.deleteSession = async (e) => {
      const { topic: s, expirerHasDeleted: t = false, emitEvent: i3 = true, id: n4 = 0 } = e, { self: o3 } = this.client.session.get(s);
      await this.client.core.relayer.unsubscribe(s), await this.client.session.delete(s, U4("USER_DISCONNECTED")), this.client.core.crypto.keychain.has(o3.publicKey) && await this.client.core.crypto.deleteKeyPair(o3.publicKey), this.client.core.crypto.keychain.has(s) && await this.client.core.crypto.deleteSymKey(s), t || this.client.core.expirer.del(s), this.client.core.storage.removeItem(H4).catch((a3) => this.client.logger.warn(a3)), this.getPendingSessionRequests().forEach((a3) => {
        a3.topic === s && this.deletePendingSessionRequest(a3.id, U4("USER_DISCONNECTED"));
      }), i3 && this.client.events.emit("session_delete", { id: n4, topic: s });
    }, this.deleteProposal = async (e, s) => {
      await Promise.all([this.client.proposal.delete(e, U4("USER_DISCONNECTED")), s ? Promise.resolve() : this.client.core.expirer.del(e)]);
    }, this.deletePendingSessionRequest = async (e, s, t = false) => {
      await Promise.all([this.client.pendingRequest.delete(e, s), t ? Promise.resolve() : this.client.core.expirer.del(e)]), this.sessionRequestQueue.queue = this.sessionRequestQueue.queue.filter((i3) => i3.id !== e), t && (this.sessionRequestQueue.state = I2.idle, this.client.events.emit("session_request_expire", { id: e }));
    }, this.setExpiry = async (e, s) => {
      this.client.session.keys.includes(e) && await this.client.session.update(e, { expiry: s }), this.client.core.expirer.set(e, s);
    }, this.setProposal = async (e, s) => {
      await this.client.proposal.set(e, s), this.client.core.expirer.set(e, pt4(R6.wc_sessionPropose.req.ttl));
    }, this.setPendingSessionRequest = async (e) => {
      const { id: s, topic: t, params: i3, verifyContext: n4 } = e, o3 = i3.request.expiryTimestamp || pt4(R6.wc_sessionRequest.req.ttl);
      await this.client.pendingRequest.set(s, { id: s, topic: t, params: i3, verifyContext: n4 }), o3 && this.client.core.expirer.set(s, o3);
    }, this.sendRequest = async (e) => {
      const { topic: s, method: t, params: i3, expiry: n4, relayRpcId: o3, clientRpcId: a3, throwOnFailedPublish: c3 } = e, p6 = formatJsonRpcRequest(t, i3, a3);
      if (D3() && he6.includes(t)) {
        const N6 = Ln2(JSON.stringify(p6));
        this.client.core.verify.register({ attestationId: N6 });
      }
      const d5 = await this.client.core.crypto.encode(s, p6), h5 = R6[t].req;
      return n4 && (h5.ttl = n4), o3 && (h5.id = o3), this.client.core.history.set(s, p6), c3 ? (h5.internal = D5(g7({}, h5.internal), { throwOnFailedPublish: true }), await this.client.core.relayer.publish(s, d5, h5)) : this.client.core.relayer.publish(s, d5, h5).catch((N6) => this.client.logger.error(N6)), p6.id;
    }, this.sendResult = async (e) => {
      const { id: s, topic: t, result: i3, throwOnFailedPublish: n4 } = e, o3 = formatJsonRpcResult(s, i3), a3 = await this.client.core.crypto.encode(t, o3), c3 = await this.client.core.history.get(t, s), p6 = R6[c3.request.method].res;
      n4 ? (p6.internal = D5(g7({}, p6.internal), { throwOnFailedPublish: true }), await this.client.core.relayer.publish(t, a3, p6)) : this.client.core.relayer.publish(t, a3, p6).catch((d5) => this.client.logger.error(d5)), await this.client.core.history.resolve(o3);
    }, this.sendError = async (e, s, t) => {
      const i3 = formatJsonRpcError(e, t), n4 = await this.client.core.crypto.encode(s, i3), o3 = await this.client.core.history.get(s, e), a3 = R6[o3.request.method].res;
      this.client.core.relayer.publish(s, n4, a3), await this.client.core.history.resolve(i3);
    }, this.cleanup = async () => {
      const e = [], s = [];
      this.client.session.getAll().forEach((t) => {
        let i3 = false;
        mt4(t.expiry) && (i3 = true), this.client.core.crypto.keychain.has(t.topic) || (i3 = true), i3 && e.push(t.topic);
      }), this.client.proposal.getAll().forEach((t) => {
        mt4(t.expiryTimestamp) && s.push(t.id);
      }), await Promise.all([...e.map((t) => this.deleteSession({ topic: t })), ...s.map((t) => this.deleteProposal(t))]);
    }, this.onRelayEventRequest = async (e) => {
      this.requestQueue.queue.push(e), await this.processRequestsQueue();
    }, this.processRequestsQueue = async () => {
      if (this.requestQueue.state === I2.active) {
        this.client.logger.info("Request queue already active, skipping...");
        return;
      }
      for (this.client.logger.info(`Request queue starting with ${this.requestQueue.queue.length} requests`); this.requestQueue.queue.length > 0; ) {
        this.requestQueue.state = I2.active;
        const e = this.requestQueue.queue.shift();
        if (e)
          try {
            this.processRequest(e), await new Promise((s) => setTimeout(s, 300));
          } catch (s) {
            this.client.logger.warn(s);
          }
      }
      this.requestQueue.state = I2.idle;
    }, this.processRequest = (e) => {
      const { topic: s, payload: t } = e, i3 = t.method;
      switch (i3) {
        case "wc_sessionPropose":
          return this.onSessionProposeRequest(s, t);
        case "wc_sessionSettle":
          return this.onSessionSettleRequest(s, t);
        case "wc_sessionUpdate":
          return this.onSessionUpdateRequest(s, t);
        case "wc_sessionExtend":
          return this.onSessionExtendRequest(s, t);
        case "wc_sessionPing":
          return this.onSessionPingRequest(s, t);
        case "wc_sessionDelete":
          return this.onSessionDeleteRequest(s, t);
        case "wc_sessionRequest":
          return this.onSessionRequest(s, t);
        case "wc_sessionEvent":
          return this.onSessionEventRequest(s, t);
        default:
          return this.client.logger.info(`Unsupported request method ${i3}`);
      }
    }, this.onRelayEventResponse = async (e) => {
      const { topic: s, payload: t } = e, i3 = (await this.client.core.history.get(s, t.id)).request.method;
      switch (i3) {
        case "wc_sessionPropose":
          return this.onSessionProposeResponse(s, t);
        case "wc_sessionSettle":
          return this.onSessionSettleResponse(s, t);
        case "wc_sessionUpdate":
          return this.onSessionUpdateResponse(s, t);
        case "wc_sessionExtend":
          return this.onSessionExtendResponse(s, t);
        case "wc_sessionPing":
          return this.onSessionPingResponse(s, t);
        case "wc_sessionRequest":
          return this.onSessionRequestResponse(s, t);
        default:
          return this.client.logger.info(`Unsupported response method ${i3}`);
      }
    }, this.onRelayEventUnknownPayload = (e) => {
      const { topic: s } = e, { message: t } = N4("MISSING_OR_INVALID", `Decoded payload on topic ${s} is not identifiable as a JSON-RPC request or a response.`);
      throw new Error(t);
    }, this.onSessionProposeRequest = async (e, s) => {
      const { params: t, id: i3 } = s;
      try {
        this.isValidConnect(g7({}, s.params));
        const n4 = t.expiryTimestamp || pt4(R6.wc_sessionPropose.req.ttl), o3 = g7({ id: i3, pairingTopic: e, expiryTimestamp: n4 }, t);
        await this.setProposal(i3, o3);
        const a3 = Ln2(JSON.stringify(s)), c3 = await this.getVerifyContext(a3, o3.proposer.metadata);
        this.client.events.emit("session_proposal", { id: i3, params: o3, verifyContext: c3 });
      } catch (n4) {
        await this.sendError(i3, e, n4), this.client.logger.error(n4);
      }
    }, this.onSessionProposeResponse = async (e, s) => {
      const { id: t } = s;
      if (isJsonRpcResult(s)) {
        const { result: i3 } = s;
        this.client.logger.trace({ type: "method", method: "onSessionProposeResponse", result: i3 });
        const n4 = this.client.proposal.get(t);
        this.client.logger.trace({ type: "method", method: "onSessionProposeResponse", proposal: n4 });
        const o3 = n4.proposer.publicKey;
        this.client.logger.trace({ type: "method", method: "onSessionProposeResponse", selfPublicKey: o3 });
        const a3 = i3.responderPublicKey;
        this.client.logger.trace({ type: "method", method: "onSessionProposeResponse", peerPublicKey: a3 });
        const c3 = await this.client.core.crypto.generateSharedKey(o3, a3);
        this.client.logger.trace({ type: "method", method: "onSessionProposeResponse", sessionTopic: c3 });
        const p6 = await this.client.core.relayer.subscribe(c3);
        this.client.logger.trace({ type: "method", method: "onSessionProposeResponse", subscriptionId: p6 }), await this.client.core.pairing.activate({ topic: e });
      } else
        isJsonRpcError(s) && (await this.client.proposal.delete(t, U4("USER_DISCONNECTED")), this.events.emit(yt4("session_connect"), { error: s.error }));
    }, this.onSessionSettleRequest = async (e, s) => {
      const { id: t, params: i3 } = s;
      try {
        this.isValidSessionSettleRequest(i3);
        const { relay: n4, controller: o3, expiry: a3, namespaces: c3, sessionProperties: p6, pairingTopic: d5 } = s.params, h5 = g7({ topic: e, relay: n4, expiry: a3, namespaces: c3, acknowledged: true, pairingTopic: d5, requiredNamespaces: {}, optionalNamespaces: {}, controller: o3.publicKey, self: { publicKey: "", metadata: this.client.metadata }, peer: { publicKey: o3.publicKey, metadata: o3.metadata } }, p6 && { sessionProperties: p6 });
        await this.sendResult({ id: s.id, topic: e, result: true }), this.events.emit(yt4("session_connect"), { session: h5 }), this.cleanupDuplicatePairings(h5);
      } catch (n4) {
        await this.sendError(t, e, n4), this.client.logger.error(n4);
      }
    }, this.onSessionSettleResponse = async (e, s) => {
      const { id: t } = s;
      isJsonRpcResult(s) ? (await this.client.session.update(e, { acknowledged: true }), this.events.emit(yt4("session_approve", t), {})) : isJsonRpcError(s) && (await this.client.session.delete(e, U4("USER_DISCONNECTED")), this.events.emit(yt4("session_approve", t), { error: s.error }));
    }, this.onSessionUpdateRequest = async (e, s) => {
      const { params: t, id: i3 } = s;
      try {
        const n4 = `${e}_session_update`, o3 = sr3.get(n4);
        if (o3 && this.isRequestOutOfSync(o3, i3)) {
          this.client.logger.info(`Discarding out of sync request - ${i3}`);
          return;
        }
        this.isValidUpdate(g7({ topic: e }, t)), await this.client.session.update(e, { namespaces: t.namespaces }), await this.sendResult({ id: i3, topic: e, result: true }), this.client.events.emit("session_update", { id: i3, topic: e, params: t }), sr3.set(n4, i3);
      } catch (n4) {
        await this.sendError(i3, e, n4), this.client.logger.error(n4);
      }
    }, this.isRequestOutOfSync = (e, s) => parseInt(s.toString().slice(0, -3)) <= parseInt(e.toString().slice(0, -3)), this.onSessionUpdateResponse = (e, s) => {
      const { id: t } = s;
      isJsonRpcResult(s) ? this.events.emit(yt4("session_update", t), {}) : isJsonRpcError(s) && this.events.emit(yt4("session_update", t), { error: s.error });
    }, this.onSessionExtendRequest = async (e, s) => {
      const { id: t } = s;
      try {
        this.isValidExtend({ topic: e }), await this.setExpiry(e, pt4(L5)), await this.sendResult({ id: t, topic: e, result: true }), this.client.events.emit("session_extend", { id: t, topic: e });
      } catch (i3) {
        await this.sendError(t, e, i3), this.client.logger.error(i3);
      }
    }, this.onSessionExtendResponse = (e, s) => {
      const { id: t } = s;
      isJsonRpcResult(s) ? this.events.emit(yt4("session_extend", t), {}) : isJsonRpcError(s) && this.events.emit(yt4("session_extend", t), { error: s.error });
    }, this.onSessionPingRequest = async (e, s) => {
      const { id: t } = s;
      try {
        this.isValidPing({ topic: e }), await this.sendResult({ id: t, topic: e, result: true }), this.client.events.emit("session_ping", { id: t, topic: e });
      } catch (i3) {
        await this.sendError(t, e, i3), this.client.logger.error(i3);
      }
    }, this.onSessionPingResponse = (e, s) => {
      const { id: t } = s;
      setTimeout(() => {
        isJsonRpcResult(s) ? this.events.emit(yt4("session_ping", t), {}) : isJsonRpcError(s) && this.events.emit(yt4("session_ping", t), { error: s.error });
      }, 500);
    }, this.onSessionDeleteRequest = async (e, s) => {
      const { id: t } = s;
      try {
        this.isValidDisconnect({ topic: e, reason: s.params }), await Promise.all([new Promise((i3) => {
          this.client.core.relayer.once(D4.publish, async () => {
            i3(await this.deleteSession({ topic: e, id: t }));
          });
        }), this.sendResult({ id: t, topic: e, result: true }), this.cleanupPendingSentRequestsForTopic({ topic: e, error: U4("USER_DISCONNECTED") })]);
      } catch (i3) {
        this.client.logger.error(i3);
      }
    }, this.onSessionRequest = async (e, s) => {
      const { id: t, params: i3 } = s;
      try {
        this.isValidRequest(g7({ topic: e }, i3));
        const n4 = Ln2(JSON.stringify(formatJsonRpcRequest("wc_sessionRequest", i3, t))), o3 = this.client.session.get(e), a3 = await this.getVerifyContext(n4, o3.peer.metadata), c3 = { id: t, topic: e, params: i3, verifyContext: a3 };
        await this.setPendingSessionRequest(c3), this.addSessionRequestToSessionRequestQueue(c3), this.processSessionRequestQueue();
      } catch (n4) {
        await this.sendError(t, e, n4), this.client.logger.error(n4);
      }
    }, this.onSessionRequestResponse = (e, s) => {
      const { id: t } = s;
      isJsonRpcResult(s) ? this.events.emit(yt4("session_request", t), { result: s.result }) : isJsonRpcError(s) && this.events.emit(yt4("session_request", t), { error: s.error });
    }, this.onSessionEventRequest = async (e, s) => {
      const { id: t, params: i3 } = s;
      try {
        const n4 = `${e}_session_event_${i3.event.name}`, o3 = sr3.get(n4);
        if (o3 && this.isRequestOutOfSync(o3, t)) {
          this.client.logger.info(`Discarding out of sync request - ${t}`);
          return;
        }
        this.isValidEmit(g7({ topic: e }, i3)), this.client.events.emit("session_event", { id: t, topic: e, params: i3 }), sr3.set(n4, t);
      } catch (n4) {
        await this.sendError(t, e, n4), this.client.logger.error(n4);
      }
    }, this.addSessionRequestToSessionRequestQueue = (e) => {
      this.sessionRequestQueue.queue.push(e);
    }, this.cleanupAfterResponse = (e) => {
      this.deletePendingSessionRequest(e.response.id, { message: "fulfilled", code: 0 }), setTimeout(() => {
        this.sessionRequestQueue.state = I2.idle, this.processSessionRequestQueue();
      }, (0, import_time6.toMiliseconds)(this.requestQueueDelay));
    }, this.cleanupPendingSentRequestsForTopic = ({ topic: e, error: s }) => {
      const t = this.client.core.history.pending;
      t.length > 0 && t.filter((i3) => i3.topic === e && i3.request.method === "wc_sessionRequest").forEach((i3) => {
        this.events.emit(yt4("session_request", i3.request.id), { error: s });
      });
    }, this.processSessionRequestQueue = () => {
      if (this.sessionRequestQueue.state === I2.active) {
        this.client.logger.info("session request queue is already active.");
        return;
      }
      const e = this.sessionRequestQueue.queue[0];
      if (!e) {
        this.client.logger.info("session request queue is empty.");
        return;
      }
      try {
        this.sessionRequestQueue.state = I2.active, this.client.events.emit("session_request", e);
      } catch (s) {
        this.client.logger.error(s);
      }
    }, this.onPairingCreated = (e) => {
      if (e.active)
        return;
      const s = this.client.proposal.getAll().find((t) => t.pairingTopic === e.topic);
      s && this.onSessionProposeRequest(e.topic, formatJsonRpcRequest("wc_sessionPropose", { requiredNamespaces: s.requiredNamespaces, optionalNamespaces: s.optionalNamespaces, relays: s.relays, proposer: s.proposer, sessionProperties: s.sessionProperties }, s.id));
    }, this.isValidConnect = async (e) => {
      if (!Gt4(e)) {
        const { message: a3 } = N4("MISSING_OR_INVALID", `connect() params: ${JSON.stringify(e)}`);
        throw new Error(a3);
      }
      const { pairingTopic: s, requiredNamespaces: t, optionalNamespaces: i3, sessionProperties: n4, relays: o3 } = e;
      if (w4(s) || await this.isValidPairingTopic(s), !qt3(o3, true)) {
        const { message: a3 } = N4("MISSING_OR_INVALID", `connect() relays: ${o3}`);
        throw new Error(a3);
      }
      !w4(t) && B3(t) !== 0 && this.validateNamespaces(t, "requiredNamespaces"), !w4(i3) && B3(i3) !== 0 && this.validateNamespaces(i3, "optionalNamespaces"), w4(n4) || this.validateSessionProps(n4, "sessionProperties");
    }, this.validateNamespaces = (e, s) => {
      const t = Ht3(e, "connect()", s);
      if (t)
        throw new Error(t.message);
    }, this.isValidApprove = async (e) => {
      if (!Gt4(e))
        throw new Error(N4("MISSING_OR_INVALID", `approve() params: ${e}`).message);
      const { id: s, namespaces: t, relayProtocol: i3, sessionProperties: n4 } = e;
      await this.isValidProposalId(s);
      const o3 = this.client.proposal.get(s), a3 = ln(t, "approve()");
      if (a3)
        throw new Error(a3.message);
      const c3 = fn(o3.requiredNamespaces, t, "approve()");
      if (c3)
        throw new Error(c3.message);
      if (!g5(i3, true)) {
        const { message: p6 } = N4("MISSING_OR_INVALID", `approve() relayProtocol: ${i3}`);
        throw new Error(p6);
      }
      w4(n4) || this.validateSessionProps(n4, "sessionProperties");
    }, this.isValidReject = async (e) => {
      if (!Gt4(e)) {
        const { message: i3 } = N4("MISSING_OR_INVALID", `reject() params: ${e}`);
        throw new Error(i3);
      }
      const { id: s, reason: t } = e;
      if (await this.isValidProposalId(s), !Wt2(t)) {
        const { message: i3 } = N4("MISSING_OR_INVALID", `reject() reason: ${JSON.stringify(t)}`);
        throw new Error(i3);
      }
    }, this.isValidSessionSettleRequest = (e) => {
      if (!Gt4(e)) {
        const { message: c3 } = N4("MISSING_OR_INVALID", `onSessionSettleRequest() params: ${e}`);
        throw new Error(c3);
      }
      const { relay: s, controller: t, namespaces: i3, expiry: n4 } = e;
      if (!dn(s)) {
        const { message: c3 } = N4("MISSING_OR_INVALID", "onSessionSettleRequest() relay protocol should be a string");
        throw new Error(c3);
      }
      const o3 = Ft3(t, "onSessionSettleRequest()");
      if (o3)
        throw new Error(o3.message);
      const a3 = ln(i3, "onSessionSettleRequest()");
      if (a3)
        throw new Error(a3.message);
      if (mt4(n4)) {
        const { message: c3 } = N4("EXPIRED", "onSessionSettleRequest()");
        throw new Error(c3);
      }
    }, this.isValidUpdate = async (e) => {
      if (!Gt4(e)) {
        const { message: a3 } = N4("MISSING_OR_INVALID", `update() params: ${e}`);
        throw new Error(a3);
      }
      const { topic: s, namespaces: t } = e;
      await this.isValidSessionTopic(s);
      const i3 = this.client.session.get(s), n4 = ln(t, "update()");
      if (n4)
        throw new Error(n4.message);
      const o3 = fn(i3.requiredNamespaces, t, "update()");
      if (o3)
        throw new Error(o3.message);
    }, this.isValidExtend = async (e) => {
      if (!Gt4(e)) {
        const { message: t } = N4("MISSING_OR_INVALID", `extend() params: ${e}`);
        throw new Error(t);
      }
      const { topic: s } = e;
      await this.isValidSessionTopic(s);
    }, this.isValidRequest = async (e) => {
      if (!Gt4(e)) {
        const { message: a3 } = N4("MISSING_OR_INVALID", `request() params: ${e}`);
        throw new Error(a3);
      }
      const { topic: s, request: t, chainId: i3, expiry: n4 } = e;
      await this.isValidSessionTopic(s);
      const { namespaces: o3 } = this.client.session.get(s);
      if (!Qt3(o3, i3)) {
        const { message: a3 } = N4("MISSING_OR_INVALID", `request() chainId: ${i3}`);
        throw new Error(a3);
      }
      if (!zt3(t)) {
        const { message: a3 } = N4("MISSING_OR_INVALID", `request() ${JSON.stringify(t)}`);
        throw new Error(a3);
      }
      if (!Zt2(o3, i3, t.method)) {
        const { message: a3 } = N4("MISSING_OR_INVALID", `request() method: ${t.method}`);
        throw new Error(a3);
      }
      if (n4 && !tr4(n4, U6)) {
        const { message: a3 } = N4("MISSING_OR_INVALID", `request() expiry: ${n4}. Expiry must be a number (in seconds) between ${U6.min} and ${U6.max}`);
        throw new Error(a3);
      }
    }, this.isValidRespond = async (e) => {
      var s;
      if (!Gt4(e)) {
        const { message: n4 } = N4("MISSING_OR_INVALID", `respond() params: ${e}`);
        throw new Error(n4);
      }
      const { topic: t, response: i3 } = e;
      try {
        await this.isValidSessionTopic(t);
      } catch (n4) {
        throw (s = e == null ? void 0 : e.response) != null && s.id && this.cleanupAfterResponse(e), n4;
      }
      if (!Yt3(i3)) {
        const { message: n4 } = N4("MISSING_OR_INVALID", `respond() response: ${JSON.stringify(i3)}`);
        throw new Error(n4);
      }
    }, this.isValidPing = async (e) => {
      if (!Gt4(e)) {
        const { message: t } = N4("MISSING_OR_INVALID", `ping() params: ${e}`);
        throw new Error(t);
      }
      const { topic: s } = e;
      await this.isValidSessionOrPairingTopic(s);
    }, this.isValidEmit = async (e) => {
      if (!Gt4(e)) {
        const { message: o3 } = N4("MISSING_OR_INVALID", `emit() params: ${e}`);
        throw new Error(o3);
      }
      const { topic: s, event: t, chainId: i3 } = e;
      await this.isValidSessionTopic(s);
      const { namespaces: n4 } = this.client.session.get(s);
      if (!Qt3(n4, i3)) {
        const { message: o3 } = N4("MISSING_OR_INVALID", `emit() chainId: ${i3}`);
        throw new Error(o3);
      }
      if (!Jt3(t)) {
        const { message: o3 } = N4("MISSING_OR_INVALID", `emit() event: ${JSON.stringify(t)}`);
        throw new Error(o3);
      }
      if (!Xt3(n4, i3, t.name)) {
        const { message: o3 } = N4("MISSING_OR_INVALID", `emit() event: ${JSON.stringify(t)}`);
        throw new Error(o3);
      }
    }, this.isValidDisconnect = async (e) => {
      if (!Gt4(e)) {
        const { message: t } = N4("MISSING_OR_INVALID", `disconnect() params: ${e}`);
        throw new Error(t);
      }
      const { topic: s } = e;
      await this.isValidSessionOrPairingTopic(s);
    }, this.getVerifyContext = async (e, s) => {
      const t = { verified: { verifyUrl: s.verifyUrl || F5, validation: "UNKNOWN", origin: s.url || "" } };
      try {
        const i3 = await this.client.core.verify.resolve({ attestationId: e, verifyUrl: s.verifyUrl });
        i3 && (t.verified.origin = i3.origin, t.verified.isScam = i3.isScam, t.verified.validation = i3.origin === new URL(s.url).origin ? "VALID" : "INVALID");
      } catch (i3) {
        this.client.logger.info(i3);
      }
      return this.client.logger.info(`Verify context: ${JSON.stringify(t)}`), t;
    }, this.validateSessionProps = (e, s) => {
      Object.values(e).forEach((t) => {
        if (!g5(t, false)) {
          const { message: i3 } = N4("MISSING_OR_INVALID", `${s} must be in Record<string, string> format. Received: ${JSON.stringify(t)}`);
          throw new Error(i3);
        }
      });
    };
  }
  async isInitialized() {
    if (!this.initialized) {
      const { message: r } = N4("NOT_INITIALIZED", this.name);
      throw new Error(r);
    }
    await this.client.core.relayer.confirmOnlineStateOrThrow();
  }
  registerRelayerEvents() {
    this.client.core.relayer.on(D4.message, async (r) => {
      const { topic: e, message: s } = r;
      if (this.ignoredPayloadTypes.includes(this.client.core.crypto.getPayloadType(s)))
        return;
      const t = await this.client.core.crypto.decode(e, s);
      try {
        isJsonRpcRequest(t) ? (this.client.core.history.set(e, t), this.onRelayEventRequest({ topic: e, payload: t })) : isJsonRpcResponse(t) ? (await this.client.core.history.resolve(t), await this.onRelayEventResponse({ topic: e, payload: t }), this.client.core.history.delete(e, t.id)) : this.onRelayEventUnknownPayload({ topic: e, payload: t });
      } catch (i3) {
        this.client.logger.error(i3);
      }
    });
  }
  registerExpirerEvents() {
    this.client.core.expirer.on(v4.expired, async (r) => {
      const { topic: e, id: s } = ft4(r.target);
      if (s && this.client.pendingRequest.keys.includes(s))
        return await this.deletePendingSessionRequest(s, N4("EXPIRED"), true);
      e ? this.client.session.keys.includes(e) && (await this.deleteSession({ topic: e, expirerHasDeleted: true }), this.client.events.emit("session_expire", { topic: e })) : s && (await this.deleteProposal(s, true), this.client.events.emit("proposal_expire", { id: s }));
    });
  }
  registerPairingEvents() {
    this.client.core.pairing.events.on(V4.create, (r) => this.onPairingCreated(r));
  }
  isValidPairingTopic(r) {
    if (!g5(r, false)) {
      const { message: e } = N4("MISSING_OR_INVALID", `pairing topic should be a string: ${r}`);
      throw new Error(e);
    }
    if (!this.client.core.pairing.pairings.keys.includes(r)) {
      const { message: e } = N4("NO_MATCHING_KEY", `pairing topic doesn't exist: ${r}`);
      throw new Error(e);
    }
    if (mt4(this.client.core.pairing.pairings.get(r).expiry)) {
      const { message: e } = N4("EXPIRED", `pairing topic: ${r}`);
      throw new Error(e);
    }
  }
  async isValidSessionTopic(r) {
    if (!g5(r, false)) {
      const { message: e } = N4("MISSING_OR_INVALID", `session topic should be a string: ${r}`);
      throw new Error(e);
    }
    if (!this.client.session.keys.includes(r)) {
      const { message: e } = N4("NO_MATCHING_KEY", `session topic doesn't exist: ${r}`);
      throw new Error(e);
    }
    if (mt4(this.client.session.get(r).expiry)) {
      await this.deleteSession({ topic: r });
      const { message: e } = N4("EXPIRED", `session topic: ${r}`);
      throw new Error(e);
    }
    if (!this.client.core.crypto.keychain.has(r)) {
      const { message: e } = N4("MISSING_OR_INVALID", `session topic does not exist in keychain: ${r}`);
      throw await this.deleteSession({ topic: r }), new Error(e);
    }
  }
  async isValidSessionOrPairingTopic(r) {
    if (this.client.session.keys.includes(r))
      await this.isValidSessionTopic(r);
    else if (this.client.core.pairing.pairings.keys.includes(r))
      this.isValidPairingTopic(r);
    else if (g5(r, false)) {
      const { message: e } = N4("NO_MATCHING_KEY", `session or pairing topic doesn't exist: ${r}`);
      throw new Error(e);
    } else {
      const { message: e } = N4("MISSING_OR_INVALID", `session or pairing topic should be a string: ${r}`);
      throw new Error(e);
    }
  }
  async isValidProposalId(r) {
    if (!Bt3(r)) {
      const { message: e } = N4("MISSING_OR_INVALID", `proposal id should be a number: ${r}`);
      throw new Error(e);
    }
    if (!this.client.proposal.keys.includes(r)) {
      const { message: e } = N4("NO_MATCHING_KEY", `proposal id doesn't exist: ${r}`);
      throw new Error(e);
    }
    if (mt4(this.client.proposal.get(r).expiryTimestamp)) {
      await this.deleteProposal(r);
      const { message: e } = N4("EXPIRED", `proposal id: ${r}`);
      throw new Error(e);
    }
  }
};
var us3 = class extends Kt5 {
  constructor(r, e) {
    super(r, e, oe2, G6), this.core = r, this.logger = e;
  }
};
var ge6 = class extends Kt5 {
  constructor(r, e) {
    super(r, e, ce5, G6), this.core = r, this.logger = e;
  }
};
var gs3 = class extends Kt5 {
  constructor(r, e) {
    super(r, e, pe4, G6, (s) => s.id), this.core = r, this.logger = e;
  }
};
var Q6 = class _Q extends b2 {
  constructor(r) {
    super(r), this.protocol = J3, this.version = F6, this.name = M4.name, this.events = new import_events8.EventEmitter(), this.on = (s, t) => this.events.on(s, t), this.once = (s, t) => this.events.once(s, t), this.off = (s, t) => this.events.off(s, t), this.removeListener = (s, t) => this.events.removeListener(s, t), this.removeAllListeners = (s) => this.events.removeAllListeners(s), this.connect = async (s) => {
      try {
        return await this.engine.connect(s);
      } catch (t) {
        throw this.logger.error(t.message), t;
      }
    }, this.pair = async (s) => {
      try {
        return await this.engine.pair(s);
      } catch (t) {
        throw this.logger.error(t.message), t;
      }
    }, this.approve = async (s) => {
      try {
        return await this.engine.approve(s);
      } catch (t) {
        throw this.logger.error(t.message), t;
      }
    }, this.reject = async (s) => {
      try {
        return await this.engine.reject(s);
      } catch (t) {
        throw this.logger.error(t.message), t;
      }
    }, this.update = async (s) => {
      try {
        return await this.engine.update(s);
      } catch (t) {
        throw this.logger.error(t.message), t;
      }
    }, this.extend = async (s) => {
      try {
        return await this.engine.extend(s);
      } catch (t) {
        throw this.logger.error(t.message), t;
      }
    }, this.request = async (s) => {
      try {
        return await this.engine.request(s);
      } catch (t) {
        throw this.logger.error(t.message), t;
      }
    }, this.respond = async (s) => {
      try {
        return await this.engine.respond(s);
      } catch (t) {
        throw this.logger.error(t.message), t;
      }
    }, this.ping = async (s) => {
      try {
        return await this.engine.ping(s);
      } catch (t) {
        throw this.logger.error(t.message), t;
      }
    }, this.emit = async (s) => {
      try {
        return await this.engine.emit(s);
      } catch (t) {
        throw this.logger.error(t.message), t;
      }
    }, this.disconnect = async (s) => {
      try {
        return await this.engine.disconnect(s);
      } catch (t) {
        throw this.logger.error(t.message), t;
      }
    }, this.find = (s) => {
      try {
        return this.engine.find(s);
      } catch (t) {
        throw this.logger.error(t.message), t;
      }
    }, this.getPendingSessionRequests = () => {
      try {
        return this.engine.getPendingSessionRequests();
      } catch (s) {
        throw this.logger.error(s.message), s;
      }
    }, this.name = (r == null ? void 0 : r.name) || M4.name, this.metadata = (r == null ? void 0 : r.metadata) || Qn();
    const e = typeof (r == null ? void 0 : r.logger) < "u" && typeof (r == null ? void 0 : r.logger) != "string" ? r.logger : (0, import_logger4.pino)((0, import_logger4.getDefaultLoggerOptions)({ level: (r == null ? void 0 : r.logger) || M4.logger }));
    this.core = (r == null ? void 0 : r.core) || new Mr3(r), this.logger = (0, import_logger4.generateChildLogger)(e, this.name), this.session = new ge6(this.core, this.logger), this.proposal = new us3(this.core, this.logger), this.pendingRequest = new gs3(this.core, this.logger), this.engine = new ds3(this);
  }
  static async init(r) {
    const e = new _Q(r);
    return await e.initialize(), e;
  }
  get context() {
    return (0, import_logger4.getLoggerContext)(this.logger);
  }
  get pairing() {
    return this.core.pairing.pairings;
  }
  async initialize() {
    this.logger.trace("Initialized");
    try {
      await this.core.start(), await this.session.init(), await this.proposal.init(), await this.pendingRequest.init(), await this.engine.init(), this.core.verify.init({ verifyUrl: this.metadata.verifyUrl }), this.logger.info("SignClient Initialization Success");
    } catch (r) {
      throw this.logger.info("SignClient Initialization Failure"), this.logger.error(r.message), r;
    }
  }
};
var ws3 = ge6;
var ms3 = Q6;

// node_modules/@walletconnect/web3wallet/dist/index.es.js
var l = { exports: {} };
var h4 = typeof Reflect == "object" ? Reflect : null;
var y3 = h4 && typeof h4.apply == "function" ? h4.apply : function(t, e, s) {
  return Function.prototype.apply.call(t, e, s);
};
var f2;
h4 && typeof h4.ownKeys == "function" ? f2 = h4.ownKeys : Object.getOwnPropertySymbols ? f2 = function(t) {
  return Object.getOwnPropertyNames(t).concat(Object.getOwnPropertySymbols(t));
} : f2 = function(t) {
  return Object.getOwnPropertyNames(t);
};
function I3(n4) {
  console && console.warn && console.warn(n4);
}
var w6 = Number.isNaN || function(t) {
  return t !== t;
};
function o2() {
  o2.init.call(this);
}
l.exports = o2, l.exports.once = F7, o2.EventEmitter = o2, o2.prototype._events = void 0, o2.prototype._eventsCount = 0, o2.prototype._maxListeners = void 0;
var L6 = 10;
function g8(n4) {
  if (typeof n4 != "function")
    throw new TypeError('The "listener" argument must be of type Function. Received type ' + typeof n4);
}
Object.defineProperty(o2, "defaultMaxListeners", { enumerable: true, get: function() {
  return L6;
}, set: function(n4) {
  if (typeof n4 != "number" || n4 < 0 || w6(n4))
    throw new RangeError('The value of "defaultMaxListeners" is out of range. It must be a non-negative number. Received ' + n4 + ".");
  L6 = n4;
} }), o2.init = function() {
  (this._events === void 0 || this._events === Object.getPrototypeOf(this)._events) && (this._events = /* @__PURE__ */ Object.create(null), this._eventsCount = 0), this._maxListeners = this._maxListeners || void 0;
}, o2.prototype.setMaxListeners = function(t) {
  if (typeof t != "number" || t < 0 || w6(t))
    throw new RangeError('The value of "n" is out of range. It must be a non-negative number. Received ' + t + ".");
  return this._maxListeners = t, this;
};
function _3(n4) {
  return n4._maxListeners === void 0 ? o2.defaultMaxListeners : n4._maxListeners;
}
o2.prototype.getMaxListeners = function() {
  return _3(this);
}, o2.prototype.emit = function(t) {
  for (var e = [], s = 1; s < arguments.length; s++)
    e.push(arguments[s]);
  var i3 = t === "error", a3 = this._events;
  if (a3 !== void 0)
    i3 = i3 && a3.error === void 0;
  else if (!i3)
    return false;
  if (i3) {
    var r;
    if (e.length > 0 && (r = e[0]), r instanceof Error)
      throw r;
    var c3 = new Error("Unhandled error." + (r ? " (" + r.message + ")" : ""));
    throw c3.context = r, c3;
  }
  var u3 = a3[t];
  if (u3 === void 0)
    return false;
  if (typeof u3 == "function")
    y3(u3, this, e);
  else
    for (var v5 = u3.length, T2 = b4(u3, v5), s = 0; s < v5; ++s)
      y3(T2[s], this, e);
  return true;
};
function S2(n4, t, e, s) {
  var i3, a3, r;
  if (g8(e), a3 = n4._events, a3 === void 0 ? (a3 = n4._events = /* @__PURE__ */ Object.create(null), n4._eventsCount = 0) : (a3.newListener !== void 0 && (n4.emit("newListener", t, e.listener ? e.listener : e), a3 = n4._events), r = a3[t]), r === void 0)
    r = a3[t] = e, ++n4._eventsCount;
  else if (typeof r == "function" ? r = a3[t] = s ? [e, r] : [r, e] : s ? r.unshift(e) : r.push(e), i3 = _3(n4), i3 > 0 && r.length > i3 && !r.warned) {
    r.warned = true;
    var c3 = new Error("Possible EventEmitter memory leak detected. " + r.length + " " + String(t) + " listeners added. Use emitter.setMaxListeners() to increase limit");
    c3.name = "MaxListenersExceededWarning", c3.emitter = n4, c3.type = t, c3.count = r.length, I3(c3);
  }
  return n4;
}
o2.prototype.addListener = function(t, e) {
  return S2(this, t, e, false);
}, o2.prototype.on = o2.prototype.addListener, o2.prototype.prependListener = function(t, e) {
  return S2(this, t, e, true);
};
function M5() {
  if (!this.fired)
    return this.target.removeListener(this.type, this.wrapFn), this.fired = true, arguments.length === 0 ? this.listener.call(this.target) : this.listener.apply(this.target, arguments);
}
function C(n4, t, e) {
  var s = { fired: false, wrapFn: void 0, target: n4, type: t, listener: e }, i3 = M5.bind(s);
  return i3.listener = e, s.wrapFn = i3, i3;
}
o2.prototype.once = function(t, e) {
  return g8(e), this.on(t, C(this, t, e)), this;
}, o2.prototype.prependOnceListener = function(t, e) {
  return g8(e), this.prependListener(t, C(this, t, e)), this;
}, o2.prototype.removeListener = function(t, e) {
  var s, i3, a3, r, c3;
  if (g8(e), i3 = this._events, i3 === void 0)
    return this;
  if (s = i3[t], s === void 0)
    return this;
  if (s === e || s.listener === e)
    --this._eventsCount === 0 ? this._events = /* @__PURE__ */ Object.create(null) : (delete i3[t], i3.removeListener && this.emit("removeListener", t, s.listener || e));
  else if (typeof s != "function") {
    for (a3 = -1, r = s.length - 1; r >= 0; r--)
      if (s[r] === e || s[r].listener === e) {
        c3 = s[r].listener, a3 = r;
        break;
      }
    if (a3 < 0)
      return this;
    a3 === 0 ? s.shift() : k3(s, a3), s.length === 1 && (i3[t] = s[0]), i3.removeListener !== void 0 && this.emit("removeListener", t, c3 || e);
  }
  return this;
}, o2.prototype.off = o2.prototype.removeListener, o2.prototype.removeAllListeners = function(t) {
  var e, s, i3;
  if (s = this._events, s === void 0)
    return this;
  if (s.removeListener === void 0)
    return arguments.length === 0 ? (this._events = /* @__PURE__ */ Object.create(null), this._eventsCount = 0) : s[t] !== void 0 && (--this._eventsCount === 0 ? this._events = /* @__PURE__ */ Object.create(null) : delete s[t]), this;
  if (arguments.length === 0) {
    var a3 = Object.keys(s), r;
    for (i3 = 0; i3 < a3.length; ++i3)
      r = a3[i3], r !== "removeListener" && this.removeAllListeners(r);
    return this.removeAllListeners("removeListener"), this._events = /* @__PURE__ */ Object.create(null), this._eventsCount = 0, this;
  }
  if (e = s[t], typeof e == "function")
    this.removeListener(t, e);
  else if (e !== void 0)
    for (i3 = e.length - 1; i3 >= 0; i3--)
      this.removeListener(t, e[i3]);
  return this;
};
function E6(n4, t, e) {
  var s = n4._events;
  if (s === void 0)
    return [];
  var i3 = s[t];
  return i3 === void 0 ? [] : typeof i3 == "function" ? e ? [i3.listener || i3] : [i3] : e ? z2(i3) : b4(i3, i3.length);
}
o2.prototype.listeners = function(t) {
  return E6(this, t, true);
}, o2.prototype.rawListeners = function(t) {
  return E6(this, t, false);
}, o2.listenerCount = function(n4, t) {
  return typeof n4.listenerCount == "function" ? n4.listenerCount(t) : O5.call(n4, t);
}, o2.prototype.listenerCount = O5;
function O5(n4) {
  var t = this._events;
  if (t !== void 0) {
    var e = t[n4];
    if (typeof e == "function")
      return 1;
    if (e !== void 0)
      return e.length;
  }
  return 0;
}
o2.prototype.eventNames = function() {
  return this._eventsCount > 0 ? f2(this._events) : [];
};
function b4(n4, t) {
  for (var e = new Array(t), s = 0; s < t; ++s)
    e[s] = n4[s];
  return e;
}
function k3(n4, t) {
  for (; t + 1 < n4.length; t++)
    n4[t] = n4[t + 1];
  n4.pop();
}
function z2(n4) {
  for (var t = new Array(n4.length), e = 0; e < t.length; ++e)
    t[e] = n4[e].listener || n4[e];
  return t;
}
function F7(n4, t) {
  return new Promise(function(e, s) {
    function i3(r) {
      n4.removeListener(t, a3), s(r);
    }
    function a3() {
      typeof n4.removeListener == "function" && n4.removeListener("error", i3), e([].slice.call(arguments));
    }
    R7(n4, t, a3, { once: true }), t !== "error" && D6(n4, i3, { once: true });
  });
}
function D6(n4, t, e) {
  typeof n4.on == "function" && R7(n4, "error", t, e);
}
function R7(n4, t, e, s) {
  if (typeof n4.on == "function")
    s.once ? n4.once(t, e) : n4.on(t, e);
  else if (typeof n4.addEventListener == "function")
    n4.addEventListener(t, function i3(a3) {
      s.once && n4.removeEventListener(t, i3), e(a3);
    });
  else
    throw new TypeError('The "emitter" argument must be of type EventEmitter. Received type ' + typeof n4);
}
var x3 = "wc";
var p5 = "Web3Wallet";
var U7 = `${x3}@2:${p5}:`;
var G7 = class extends l.exports {
  constructor() {
    super();
  }
};
var P3 = class {
  constructor(t) {
    this.opts = t;
  }
};
var q3 = class {
  constructor(t) {
    this.client = t;
  }
};
var H5 = class extends q3 {
  constructor(t) {
    super(t), this.init = async () => {
      this.signClient = await ms3.init({ core: this.client.core, metadata: this.client.metadata }), this.authClient = await zr2.init({ core: this.client.core, projectId: "", metadata: this.client.metadata }), this.initializeEventListeners();
    }, this.pair = async (e) => {
      await this.client.core.pairing.pair(e);
    }, this.approveSession = async (e) => {
      const { topic: s, acknowledged: i3 } = await this.signClient.approve({ id: e.id, namespaces: e.namespaces });
      return await i3(), this.signClient.session.get(s);
    }, this.rejectSession = async (e) => await this.signClient.reject(e), this.updateSession = async (e) => await (await this.signClient.update(e)).acknowledged(), this.extendSession = async (e) => await (await this.signClient.extend(e)).acknowledged(), this.respondSessionRequest = async (e) => await this.signClient.respond(e), this.disconnectSession = async (e) => await this.signClient.disconnect(e), this.emitSessionEvent = async (e) => await this.signClient.emit(e), this.getActiveSessions = () => this.signClient.session.getAll().reduce((e, s) => (e[s.topic] = s, e), {}), this.getPendingSessionProposals = () => this.signClient.proposal.getAll(), this.getPendingSessionRequests = () => this.signClient.getPendingSessionRequests(), this.respondAuthRequest = async (e, s) => await this.authClient.respond(e, s), this.getPendingAuthRequests = () => this.authClient.requests.getAll().filter((e) => "requester" in e), this.formatMessage = (e, s) => this.authClient.formatMessage(e, s), this.registerDeviceToken = (e) => this.client.core.echoClient.registerDeviceToken(e), this.onSessionRequest = (e) => {
      this.client.events.emit("session_request", e);
    }, this.onSessionProposal = (e) => {
      this.client.events.emit("session_proposal", e);
    }, this.onSessionDelete = (e) => {
      this.client.events.emit("session_delete", e);
    }, this.onAuthRequest = (e) => {
      this.client.events.emit("auth_request", e);
    }, this.onProposalExpire = (e) => {
      this.client.events.emit("proposal_expire", e);
    }, this.onSessionRequestExpire = (e) => {
      this.client.events.emit("session_request_expire", e);
    }, this.initializeEventListeners = () => {
      this.signClient.events.on("session_proposal", this.onSessionProposal), this.signClient.events.on("session_request", this.onSessionRequest), this.signClient.events.on("session_delete", this.onSessionDelete), this.authClient.on("auth_request", this.onAuthRequest), this.signClient.events.on("proposal_expire", this.onProposalExpire), this.signClient.events.on("session_request_expire", this.onSessionRequestExpire);
    }, this.signClient = {}, this.authClient = {};
  }
};
var Q7 = { decryptMessage: async (n4) => {
  const t = { core: new Mr3({ storageOptions: n4.storageOptions, storage: n4.storage }) };
  await t.core.crypto.init();
  const e = t.core.crypto.decode(n4.topic, n4.encryptedMessage);
  return t.core = null, e;
}, getMetadata: async (n4) => {
  const t = { core: new Mr3({ storageOptions: n4.storageOptions, storage: n4.storage }), sessionStore: null };
  t.sessionStore = new ws3(t.core, t.core.logger), await t.sessionStore.init();
  const e = t.sessionStore.get(n4.topic), s = e == null ? void 0 : e.peer.metadata;
  return t.core = null, t.sessionStore = null, s;
} };
var A2 = class extends P3 {
  constructor(n4) {
    super(n4), this.events = new l.exports(), this.on = (t, e) => this.events.on(t, e), this.once = (t, e) => this.events.once(t, e), this.off = (t, e) => this.events.off(t, e), this.removeListener = (t, e) => this.events.removeListener(t, e), this.pair = async (t) => {
      try {
        return await this.engine.pair(t);
      } catch (e) {
        throw this.logger.error(e.message), e;
      }
    }, this.approveSession = async (t) => {
      try {
        return await this.engine.approveSession(t);
      } catch (e) {
        throw this.logger.error(e.message), e;
      }
    }, this.rejectSession = async (t) => {
      try {
        return await this.engine.rejectSession(t);
      } catch (e) {
        throw this.logger.error(e.message), e;
      }
    }, this.updateSession = async (t) => {
      try {
        return await this.engine.updateSession(t);
      } catch (e) {
        throw this.logger.error(e.message), e;
      }
    }, this.extendSession = async (t) => {
      try {
        return await this.engine.extendSession(t);
      } catch (e) {
        throw this.logger.error(e.message), e;
      }
    }, this.respondSessionRequest = async (t) => {
      try {
        return await this.engine.respondSessionRequest(t);
      } catch (e) {
        throw this.logger.error(e.message), e;
      }
    }, this.disconnectSession = async (t) => {
      try {
        return await this.engine.disconnectSession(t);
      } catch (e) {
        throw this.logger.error(e.message), e;
      }
    }, this.emitSessionEvent = async (t) => {
      try {
        return await this.engine.emitSessionEvent(t);
      } catch (e) {
        throw this.logger.error(e.message), e;
      }
    }, this.getActiveSessions = () => {
      try {
        return this.engine.getActiveSessions();
      } catch (t) {
        throw this.logger.error(t.message), t;
      }
    }, this.getPendingSessionProposals = () => {
      try {
        return this.engine.getPendingSessionProposals();
      } catch (t) {
        throw this.logger.error(t.message), t;
      }
    }, this.getPendingSessionRequests = () => {
      try {
        return this.engine.getPendingSessionRequests();
      } catch (t) {
        throw this.logger.error(t.message), t;
      }
    }, this.respondAuthRequest = async (t, e) => {
      try {
        return await this.engine.respondAuthRequest(t, e);
      } catch (s) {
        throw this.logger.error(s.message), s;
      }
    }, this.getPendingAuthRequests = () => {
      try {
        return this.engine.getPendingAuthRequests();
      } catch (t) {
        throw this.logger.error(t.message), t;
      }
    }, this.formatMessage = (t, e) => {
      try {
        return this.engine.formatMessage(t, e);
      } catch (s) {
        throw this.logger.error(s.message), s;
      }
    }, this.registerDeviceToken = (t) => {
      try {
        return this.engine.registerDeviceToken(t);
      } catch (e) {
        throw this.logger.error(e.message), e;
      }
    }, this.metadata = n4.metadata, this.name = n4.name || p5, this.core = n4.core, this.logger = this.core.logger, this.engine = new H5(this);
  }
  static async init(n4) {
    const t = new A2(n4);
    return await t.initialize(), t;
  }
  async initialize() {
    this.logger.trace("Initialized");
    try {
      await this.engine.init(), this.logger.info("Web3Wallet Initialization Success");
    } catch (n4) {
      throw this.logger.info("Web3Wallet Initialization Failure"), this.logger.error(n4.message), n4;
    }
  }
};
var d4 = A2;
d4.notifications = Q7;
var V5 = d4;

// node_modules/@thirdweb-dev/react/node_modules/@thirdweb-dev/wallets/dist/smart-wallet-f5e628ca.browser.esm.js
init_lib3();

// node_modules/@thirdweb-dev/react/node_modules/@thirdweb-dev/wallets/dist/wc-c6a6a61c.browser.esm.js
init_shim();
var TW_WC_PROJECT_ID = "145769e410f16970a79ff77b2d89a1e0";
var WC_RELAY_URL = "wss://relay.walletconnect.com";
var EIP155_SIGNING_METHODS = {
  PERSONAL_SIGN: "personal_sign",
  ETH_SIGN: "eth_sign",
  ETH_SIGN_TRANSACTION: "eth_signTransaction",
  ETH_SIGN_TYPED_DATA: "eth_signTypedData",
  ETH_SIGN_TYPED_DATA_V3: "eth_signTypedData_v3",
  ETH_SIGN_TYPED_DATA_V4: "eth_signTypedData_v4",
  ETH_SEND_TRANSACTION: "eth_sendTransaction",
  SWITCH_CHAIN: "wallet_switchEthereumChain"
};

// node_modules/@thirdweb-dev/react/node_modules/@thirdweb-dev/wallets/dist/smart-wallet-f5e628ca.browser.esm.js
var WalletConnectHandler = class extends eventemitter3_default {
};
var _core = /* @__PURE__ */ new WeakMap();
var _wcWallet$1 = /* @__PURE__ */ new WeakMap();
var _session = /* @__PURE__ */ new WeakMap();
var _wcMetadata = /* @__PURE__ */ new WeakMap();
var _activeProposal = /* @__PURE__ */ new WeakMap();
var _activeRequestEvent = /* @__PURE__ */ new WeakMap();
var _setupWalletConnectEventsListeners$1 = /* @__PURE__ */ new WeakSet();
var _getSignParamsMessage = /* @__PURE__ */ new WeakSet();
var WalletConnectV2Handler = class extends WalletConnectHandler {
  constructor(options) {
    super();
    _classPrivateMethodInitSpec(this, _getSignParamsMessage);
    _classPrivateMethodInitSpec(this, _setupWalletConnectEventsListeners$1);
    _classPrivateFieldInitSpec(this, _core, {
      writable: true,
      value: void 0
    });
    _classPrivateFieldInitSpec(this, _wcWallet$1, {
      writable: true,
      value: void 0
    });
    _classPrivateFieldInitSpec(this, _session, {
      writable: true,
      value: void 0
    });
    _classPrivateFieldInitSpec(this, _wcMetadata, {
      writable: true,
      value: void 0
    });
    _classPrivateFieldInitSpec(this, _activeProposal, {
      writable: true,
      value: void 0
    });
    _classPrivateFieldInitSpec(this, _activeRequestEvent, {
      writable: true,
      value: void 0
    });
    _classPrivateFieldSet(this, _wcMetadata, (options == null ? void 0 : options.walletConnectWalletMetadata) || {
      name: "Thirdweb Smart Wallet",
      description: "Thirdweb Smart Wallet",
      url: "https://thirdweb.com",
      icons: ["https://thirdweb.com/favicon.ico"]
    });
    _classPrivateFieldSet(this, _core, new Mr({
      projectId: (options == null ? void 0 : options.walletConenctV2ProjectId) || TW_WC_PROJECT_ID,
      relayUrl: (options == null ? void 0 : options.walletConnectV2RelayUrl) || WC_RELAY_URL
    }));
  }
  async init() {
    _classPrivateFieldSet(this, _wcWallet$1, await V5.init({
      core: _classPrivateFieldGet(this, _core),
      metadata: _classPrivateFieldGet(this, _wcMetadata)
    }));
    const sessions = _classPrivateFieldGet(this, _wcWallet$1).getActiveSessions();
    const keys = Object.keys(sessions);
    if (keys[0]) {
      _classPrivateFieldSet(this, _session, sessions[keys[0]]);
    }
    _classPrivateMethodGet(this, _setupWalletConnectEventsListeners$1, _setupWalletConnectEventsListeners2$1).call(this);
  }
  async connectApp(wcUri) {
    if (!_classPrivateFieldGet(this, _wcWallet$1)) {
      throw new Error("Please, init the wallet before connecting an app.");
    }
    await _classPrivateFieldGet(this, _wcWallet$1).core.pairing.pair({
      uri: wcUri
    });
  }
  async approveSession(wallet) {
    var _a;
    if (!_classPrivateFieldGet(this, _wcWallet$1)) {
      throw new Error("Please, init the wallet before making session requests.");
    }
    if (!_classPrivateFieldGet(this, _activeProposal)) {
      throw new Error("Please, pass a valid proposal.");
    }
    const account = await wallet.getAddress();
    const {
      id,
      params
    } = _classPrivateFieldGet(this, _activeProposal);
    const {
      requiredNamespaces,
      relays
    } = params;
    const namespaces = {};
    Object.keys(requiredNamespaces).forEach((key) => {
      var _a2;
      const accounts = [];
      const namespace = requiredNamespaces[key];
      if (namespace) {
        (_a2 = namespace.chains) == null ? void 0 : _a2.map((chain) => {
          accounts.push(`${chain}:${account}`);
        });
        namespaces[key] = {
          accounts,
          methods: namespace.methods,
          events: namespace.events
        };
      }
    });
    _classPrivateFieldSet(this, _session, await _classPrivateFieldGet(this, _wcWallet$1).approveSession({
      id,
      relayProtocol: (_a = relays[0]) == null ? void 0 : _a.protocol,
      namespaces
    }));
    this.emit("session_approved");
  }
  async rejectSession() {
    if (!_classPrivateFieldGet(this, _wcWallet$1)) {
      throw new Error("Please, init the wallet before making session requests.");
    }
    if (!_classPrivateFieldGet(this, _activeProposal)) {
      throw new Error("Please, pass a valid proposal.");
    }
    const {
      id
    } = _classPrivateFieldGet(this, _activeProposal);
    await _classPrivateFieldGet(this, _wcWallet$1).rejectSession({
      id,
      reason: {
        message: "User rejected methods.",
        code: 5002
      }
    });
  }
  async approveEIP155Request(wallet) {
    var _a, _b;
    if (!_classPrivateFieldGet(this, _activeRequestEvent)) {
      return;
    }
    const {
      topic,
      params,
      id
    } = _classPrivateFieldGet(this, _activeRequestEvent);
    const {
      request
    } = params;
    let response;
    switch (request.method) {
      case EIP155_SIGNING_METHODS.PERSONAL_SIGN:
      case EIP155_SIGNING_METHODS.ETH_SIGN:
        const message = _classPrivateMethodGet(this, _getSignParamsMessage, _getSignParamsMessage2).call(this, request.params);
        const signedMessage = await wallet.signMessage(message || "");
        response = formatJsonRpcResult(id, signedMessage);
        break;
      case EIP155_SIGNING_METHODS.ETH_SEND_TRANSACTION:
        const signer = await wallet.getSigner();
        const sendTransaction = request.params[0];
        const tx = await signer.sendTransaction(sendTransaction);
        const {
          transactionHash
        } = await tx.wait();
        response = formatJsonRpcResult(id, transactionHash);
        break;
      case EIP155_SIGNING_METHODS.ETH_SIGN_TRANSACTION:
        const signerSign = await wallet.getSigner();
        const signTransaction = request.params[0];
        const signature = await signerSign.signTransaction(signTransaction);
        response = formatJsonRpcResult(id, signature);
      default:
        const error = {
          id,
          jsonrpc: "2.0",
          error: {
            message: "Invalid event.",
            code: 1002
          }
        };
        return (_a = _classPrivateFieldGet(this, _wcWallet$1)) == null ? void 0 : _a.respondSessionRequest({
          topic,
          response: error
        });
    }
    return (_b = _classPrivateFieldGet(this, _wcWallet$1)) == null ? void 0 : _b.respondSessionRequest({
      topic,
      response
    });
  }
  async rejectEIP155Request() {
    var _a;
    if (!_classPrivateFieldGet(this, _activeRequestEvent)) {
      return;
    }
    const {
      topic,
      id
    } = _classPrivateFieldGet(this, _activeRequestEvent);
    const response = {
      id,
      jsonrpc: "2.0",
      error: {
        message: "User rejected methods.",
        code: 5002
      }
    };
    return (_a = _classPrivateFieldGet(this, _wcWallet$1)) == null ? void 0 : _a.respondSessionRequest({
      topic,
      response
    });
  }
  getActiveSessions() {
    if (!_classPrivateFieldGet(this, _wcWallet$1)) {
      throw new Error("Please, init the wallet before getting sessions.");
    }
    const sessions = _classPrivateFieldGet(this, _wcWallet$1).getActiveSessions();
    const sessionKeys = Object.keys(sessions);
    if (!sessions || sessionKeys.length === 0) {
      return [];
    }
    const thisSessions = [];
    for (const sessionKey of sessionKeys) {
      const session = sessions[sessionKey];
      if (session) {
        const topic = session.topic;
        const peerMeta = session.peer.metadata;
        thisSessions.push({
          topic,
          peer: {
            metadata: peerMeta
          }
        });
      }
    }
    return thisSessions;
  }
  disconnectSession() {
    var _a;
    if (!_classPrivateFieldGet(this, _wcWallet$1)) {
      throw new Error("Please, init the wallet before disconnecting sessions.");
    }
    if (!_classPrivateFieldGet(this, _session)) {
      return Promise.resolve();
    }
    const params = {
      topic: _classPrivateFieldGet(this, _session).topic,
      reason: {
        message: "User disconnected.",
        code: 6e3
      }
    };
    return (_a = _classPrivateFieldGet(this, _wcWallet$1)) == null ? void 0 : _a.disconnectSession(params);
  }
};
function _setupWalletConnectEventsListeners2$1() {
  if (!_classPrivateFieldGet(this, _wcWallet$1)) {
    throw new Error("Please, init the wallet before making session requests.");
  }
  _classPrivateFieldGet(this, _wcWallet$1).on("session_proposal", (proposal) => {
    _classPrivateFieldSet(this, _activeProposal, proposal);
    this.emit("session_proposal", {
      proposer: {
        metadata: proposal.params.proposer.metadata
      }
    });
  });
  _classPrivateFieldGet(this, _wcWallet$1).on("session_delete", (session) => {
    _classPrivateFieldSet(this, _session, void 0);
    _classPrivateFieldSet(this, _activeProposal, void 0);
    this.emit("session_delete", {
      topic: session.topic
    });
  });
  _classPrivateFieldGet(this, _wcWallet$1).on("session_request", async (requestEvent) => {
    if (!_classPrivateFieldGet(this, _session)) {
      return;
    }
    const {
      params: requestParams
    } = requestEvent;
    const {
      request
    } = requestParams;
    const {
      params
    } = request;
    switch (request.method) {
      case EIP155_SIGNING_METHODS.ETH_SIGN:
      case EIP155_SIGNING_METHODS.PERSONAL_SIGN:
        _classPrivateFieldSet(this, _activeRequestEvent, requestEvent);
        const message = params[0];
        const decodedMessage = new TextDecoder().decode(utils_exports.arrayify(message));
        const paramsCopy = [...params];
        paramsCopy[0] = decodedMessage;
        this.emit("session_request", {
          topic: _classPrivateFieldGet(this, _session).topic,
          params: paramsCopy,
          peer: {
            metadata: _classPrivateFieldGet(this, _session).peer.metadata
          },
          method: request.method
        });
        return;
      case EIP155_SIGNING_METHODS.ETH_SEND_TRANSACTION:
      case EIP155_SIGNING_METHODS.ETH_SIGN_TRANSACTION:
        _classPrivateFieldSet(this, _activeRequestEvent, requestEvent);
        this.emit("session_request", {
          topic: _classPrivateFieldGet(this, _session).topic,
          params: requestEvent.params.request.params,
          peer: {
            metadata: _classPrivateFieldGet(this, _session).peer.metadata
          },
          method: request.method
        });
        return;
      default:
        throw new Error(`WCV2.Method not supported: ${request.method}`);
    }
  });
}
function _getSignParamsMessage2(params) {
  const message = params.filter((p6) => !utils_exports.isAddress(p6))[0] || "";
  if (utils_exports.isHexString(message)) {
    return utils_exports.toUtf8String(message);
  }
  return message;
}
var NoOpWalletConnectHandler = class extends WalletConnectHandler {
  init() {
    return Promise.resolve();
  }
  // eslint-disable-next-line @typescript-eslint/no-unused-vars
  connectApp(uri) {
    return Promise.resolve();
  }
  approveSession(wallet) {
    return Promise.resolve();
  }
  rejectSession() {
    return Promise.resolve();
  }
  approveEIP155Request(wallet) {
    return Promise.resolve();
  }
  rejectEIP155Request() {
    return Promise.resolve();
  }
  getActiveSessions() {
    return [];
  }
  // eslint-disable-next-line @typescript-eslint/no-unused-vars
  disconnectSession() {
    return Promise.resolve();
  }
};
var _wcWallet = /* @__PURE__ */ new WeakMap();
var _setupWalletConnectEventsListeners = /* @__PURE__ */ new WeakSet();
var SmartWallet = class _SmartWallet extends AbstractClientWallet {
  get walletName() {
    return "Smart Wallet";
  }
  constructor(options) {
    super(_SmartWallet.id, {
      ...options
    });
    _classPrivateMethodInitSpec(this, _setupWalletConnectEventsListeners);
    _defineProperty(this, "enableConnectApp", false);
    _classPrivateFieldInitSpec(this, _wcWallet, {
      writable: true,
      value: void 0
    });
    this.enableConnectApp = (options == null ? void 0 : options.enableConnectApp) || false;
    _classPrivateFieldSet(this, _wcWallet, this.enableConnectApp ? new WalletConnectV2Handler({
      walletConnectWalletMetadata: options == null ? void 0 : options.walletConnectWalletMetadata,
      walletConenctV2ProjectId: options == null ? void 0 : options.walletConenctV2ProjectId,
      walletConnectV2RelayUrl: options == null ? void 0 : options.walletConnectV2RelayUrl
    }) : new NoOpWalletConnectHandler());
  }
  async getConnector() {
    if (!this.connector) {
      if (this.enableConnectApp) {
        await _classPrivateFieldGet(this, _wcWallet).init();
        _classPrivateMethodGet(this, _setupWalletConnectEventsListeners, _setupWalletConnectEventsListeners2).call(this);
      }
      const {
        SmartWalletConnector
      } = await import("./thirdweb-dev-wallets-evm-connectors-smart-wallet.browser.esm-XET74337.js");
      this.connector = new SmartWalletConnector(this.options);
    }
    return this.connector;
  }
  getPersonalWallet() {
    var _a;
    return (_a = this.connector) == null ? void 0 : _a.personalWallet;
  }
  /**
   * Check whether the connected signer can execute a given transaction using the smart wallet.
   * @param transaction the transaction to execute using the smart wallet.
   * @returns whether the connected signer can execute the transaction using the smart wallet.
   */
  async hasPermissionToExecute(transaction) {
    const connector = await this.getConnector();
    return connector.hasPermissionToExecute(transaction);
  }
  /**
   * Execute a single transaction
   * @param transactions
   * @returns the transaction receipt
   */
  async execute(transaction) {
    const connector = await this.getConnector();
    return connector.execute(transaction);
  }
  /**
   * Execute multiple transactions in a single batch
   * @param transactions
   * @returns the transaction receipt
   */
  async executeBatch(transactions) {
    const connector = await this.getConnector();
    return connector.executeBatch(transactions);
  }
  /**
   * Manually deploy the smart wallet contract. If already deployed this will throw an error.
   * Note that this is not necessary as the smart wallet will be deployed automatically on the first transaction the user makes.
   * @returns the transaction receipt
   */
  async deploy() {
    const connector = await this.getConnector();
    return connector.deploy();
  }
  /**
   * Manually deploy the smart wallet contract. If already deployed this will do nothing.
   * Note that this is not necessary as the smart wallet will be deployed automatically on the first transaction the user makes.
   * @returns the transaction receipt
   */
  async deployIfNeeded() {
    const connector = await this.getConnector();
    return connector.deployIfNeeded();
  }
  /**
   * Check if the smart wallet contract is deployed
   * @returns true if the smart wallet contract is deployed
   */
  async isDeployed() {
    const connector = await this.getConnector();
    return connector.isDeployed();
  }
  /**
   * Create and add a session key to the smart wallet.
   * @param keyAddress the address of the session key to add.
   * @param permissions the permissions to grant to the session key.
   */
  async createSessionKey(keyAddress, permissions) {
    const connector = await this.getConnector();
    return connector.grantPermissions(keyAddress, permissions);
  }
  /**
   * Remove a session key from the smart wallet.
   * @param keyAddress the address of the session key to remove.
   */
  async revokeSessionKey(keyAddress) {
    const connector = await this.getConnector();
    return connector.revokePermissions(keyAddress);
  }
  /**
   * Add another admin to the smart wallet.
   * @param adminAddress the address of the admin to add.
   */
  async addAdmin(adminAddress) {
    const connector = await this.getConnector();
    return connector.addAdmin(adminAddress);
  }
  /**
   * Remove an admin from the smart wallet.
   * @param adminAddress the address of the admin to remove.
   */
  async removeAdmin(adminAddress) {
    const connector = await this.getConnector();
    return connector.removeAdmin(adminAddress);
  }
  /**
   * Get all the admins and session keys active on the smart wallet.
   */
  async getAllActiveSigners() {
    const connector = await this.getConnector();
    return connector.getAllActiveSigners();
  }
  /**
   * Get the underlying account contract of the smart wallet.
   * @returns the account contract of the smart wallet.
   */
  async getAccountContract() {
    const connector = await this.getConnector();
    return connector.getAccountContract();
  }
  /**
   * Get the underlying account factory contract of the smart wallet.
   * @returns the account factory contract.
   */
  async getFactoryContract() {
    const connector = await this.getConnector();
    return connector.getFactoryContract();
  }
  autoConnect(params) {
    return this.connect(params);
  }
  // wcv2
  async connectApp(uri) {
    var _a;
    if (!this.enableConnectApp) {
      throw new Error("enableConnectApp is set to false in this wallet config");
    }
    (_a = _classPrivateFieldGet(this, _wcWallet)) == null ? void 0 : _a.connectApp(uri);
  }
  async approveSession() {
    await _classPrivateFieldGet(this, _wcWallet).approveSession(this);
    this.emit("message", {
      type: "session_approved"
    });
  }
  rejectSession() {
    return _classPrivateFieldGet(this, _wcWallet).rejectSession();
  }
  approveRequest() {
    return _classPrivateFieldGet(this, _wcWallet).approveEIP155Request(this);
  }
  rejectRequest() {
    return _classPrivateFieldGet(this, _wcWallet).rejectEIP155Request();
  }
  getActiveSessions() {
    if (!_classPrivateFieldGet(this, _wcWallet)) {
      throw new Error("Please, init the wallet before making session requests.");
    }
    return _classPrivateFieldGet(this, _wcWallet).getActiveSessions();
  }
  disconnectSession() {
    var _a;
    return (_a = _classPrivateFieldGet(this, _wcWallet)) == null ? void 0 : _a.disconnectSession();
  }
  isWCReceiverEnabled() {
    return this.enableConnectApp;
  }
};
function _setupWalletConnectEventsListeners2() {
  if (!_classPrivateFieldGet(this, _wcWallet)) {
    throw new Error("Please, init the wallet before making session requests.");
  }
  _classPrivateFieldGet(this, _wcWallet).on("session_proposal", (proposal) => {
    this.emit("message", {
      type: "session_proposal",
      data: proposal
    });
  });
  _classPrivateFieldGet(this, _wcWallet).on("session_delete", () => {
    this.emit("message", {
      type: "session_delete"
    });
  });
  _classPrivateFieldGet(this, _wcWallet).on("switch_chain", (request) => {
    const chainId = request.params[0].chainId;
    this.emit("message", {
      type: "switch_chain",
      data: {
        chainId
      }
    });
    _classPrivateFieldGet(this, _wcWallet).disconnectSession();
  });
  _classPrivateFieldGet(this, _wcWallet).on("session_request", (request) => {
    this.emit("message", {
      type: "session_request",
      data: request
    });
  });
}
_defineProperty(SmartWallet, "meta", {
  name: "Smart Wallet",
  iconURL: "ipfs://QmeAJVqn17aDNQhjEU3kcWVZCFBrfta8LzaDGkS8Egdiyk/smart-wallet.svg"
});
_defineProperty(SmartWallet, "id", walletIds.smartWallet);

// node_modules/@thirdweb-dev/react/node_modules/@thirdweb-dev/wallets/dist/getInjectedCoinbaseProvider-980f40a9.browser.esm.js
init_shim();
function getInjectedCoinbaseProvider() {
  var _a;
  function getReady(ethereum) {
    const isCoinbaseWallet = !!(ethereum == null ? void 0 : ethereum.isCoinbaseWallet);
    if (isCoinbaseWallet) {
      return ethereum;
    }
    if (ethereum && "overrideIsMetaMask" in ethereum) {
      if ("providerMap" in ethereum) {
        if (ethereum.providerMap instanceof Map) {
          if (ethereum.providerMap.has("CoinbaseWallet")) {
            return ethereum;
          }
        }
      }
    }
  }
  if (assertWindowEthereum(globalThis.window)) {
    if ((_a = globalThis.window.ethereum) == null ? void 0 : _a.providers) {
      return globalThis.window.ethereum.providers.find(getReady);
    }
    return getReady(globalThis.window.ethereum);
  }
}

// node_modules/@thirdweb-dev/react/node_modules/@thirdweb-dev/wallets/evm/wallets/paper-wallet/dist/thirdweb-dev-wallets-evm-wallets-paper-wallet.browser.esm.js
init_shim();
init_lib3();
var PaperWallet = class _PaperWallet extends AbstractClientWallet {
  get walletName() {
    return "Paper Wallet";
  }
  constructor(options) {
    var _a;
    super(_PaperWallet.id, {
      ...options
    });
    if (options.paperClientId && options.paperClientId === "uninitialized") {
      this.paperClientId = "00000000-0000-0000-0000-000000000000";
      this.chain = options.chain;
      return;
    }
    if (options.advancedOptions && ((_a = options.advancedOptions) == null ? void 0 : _a.recoveryShareManagement) === "USER_MANAGED") {
      if (options.paperClientId && !this.isClientIdLegacyPaper(options.paperClientId) || !options.paperClientId && options.clientId && !this.isClientIdLegacyPaper(options.clientId)) {
        throw new Error('RecoveryShareManagement option "USER_MANAGED" is not supported with thirdweb client ID');
      }
    }
    if (!options.clientId && !options.paperClientId) {
      throw new Error("clientId or paperClientId is required");
    }
    if (options.paperClientId && !this.isClientIdLegacyPaper(options.paperClientId)) {
      throw new Error("paperClientId must be a legacy paper client ID");
    }
    if (options.clientId && this.isClientIdLegacyPaper(options.clientId)) {
      throw new Error("clientId must be a thirdweb client ID");
    }
    this.paperClientId = options.paperClientId ?? options.clientId;
    this.chain = options.chain;
  }
  isClientIdLegacyPaper(clientId) {
    return clientId.indexOf("-") > 0 && clientId.length === 36;
  }
  async getConnector() {
    var _a, _b, _c;
    if (!this.connector) {
      const {
        PaperWalletConnector
      } = await import("./thirdweb-dev-wallets-evm-connectors-paper.browser.esm-N6AN633T.js");
      this.connector = new PaperWalletConnector({
        clientId: this.paperClientId,
        chain: this.chain,
        chains: this.chains,
        advancedOptions: {
          recoveryShareManagement: (_b = (_a = this.options) == null ? void 0 : _a.advancedOptions) == null ? void 0 : _b.recoveryShareManagement
        },
        styles: (_c = this.options) == null ? void 0 : _c.styles
      });
    }
    return this.connector;
  }
  getConnectParams() {
    const connectParams = super.getConnectParams();
    if (!connectParams) {
      return void 0;
    }
    if (typeof connectParams.googleLogin === "object") {
      return {
        ...connectParams,
        googleLogin: true
      };
    }
    return connectParams;
  }
  async getEmail() {
    const connector = await this.getConnector();
    return connector.getEmail();
  }
  async getPaperSDK() {
    const connector = await this.getConnector();
    return connector.getPaperSDK();
  }
};
_defineProperty(PaperWallet, "id", walletIds.paper);
_defineProperty(PaperWallet, "meta", {
  name: "Paper Wallet",
  iconURL: "ipfs://QmNrLXtPoFrh4yjZbXui39zUMozS1oetpgU8dvZhFAxfRa/paper-logo-icon.svg"
});

// node_modules/@thirdweb-dev/react/node_modules/@thirdweb-dev/wallets/evm/wallets/blocto/dist/thirdweb-dev-wallets-evm-wallets-blocto.browser.esm.js
init_shim();
init_lib3();
var BloctoWallet = class _BloctoWallet extends AbstractClientWallet {
  constructor(options) {
    super(_BloctoWallet.id, options);
    _defineProperty(this, "name", "Blocto");
  }
  async initConnector() {
    var _a, _b, _c;
    const {
      BloctoConnector
    } = await import("./thirdweb-dev-wallets-evm-connectors-blocto.browser.esm-AU3XWRHD.js");
    const bloctoConnector = new BloctoConnector({
      chains: this.chains,
      options: {
        appId: (_a = this.options) == null ? void 0 : _a.appId,
        chainId: (_c = (_b = this.options) == null ? void 0 : _b.chain) == null ? void 0 : _c.chainId
      }
    });
    this.connector = new WagmiAdapter(bloctoConnector);
    return this.connector;
  }
  async getConnector() {
    if (!this.connector) {
      return await this.initConnector();
    }
    return Promise.resolve(this.connector);
  }
};
_defineProperty(BloctoWallet, "id", walletIds.blocto);
_defineProperty(BloctoWallet, "meta", {
  name: "Blocto",
  iconURL: "data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iNjAiIGhlaWdodD0iNjAiIHZpZXdCb3g9IjAgMCA2MCA2MCIgZmlsbD0ibm9uZSIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIj4KPGcgY2xpcC1wYXRoPSJ1cmwoI2NsaXAwXzIyMzNfMjM4NykiPgo8cmVjdCB3aWR0aD0iNjAiIGhlaWdodD0iNjAiIHJ4PSIxMiIgZmlsbD0id2hpdGUiLz4KPHBhdGggZD0iTTMyLjkwMjggMTguMzA2M0MyOC4zOTExIDE4LjMwNjMgMjMuOTg3MyAyMC4wNDU5IDIwLjY5NTIgMjMuMTMxOUMxNy4wODQzIDI2LjUxNzYgMTQuNzk5MiAzMS41MTc3IDEzLjQ4OTMgMzYuMjIxMkMxMi42MzE0IDM5LjI5OTIgMTIuMjAxNiA0Mi40OTE1IDEyLjIwMTYgNDUuNjg1M0MxMi4yMDE2IDQ2LjY1MTEgMTIuMjQxMiA0Ny42MDg5IDEyLjMxNzQgNDguNTU1NkMxMi40MTA5IDQ5LjcwNjkgMTMuNTMyMSA1MC41MDQ2IDE0LjY0ODUgNTAuMjAzM0MxNS42MjIyIDQ5Ljk0MTYgMTYuNjQ2NiA0OS44MDA1IDE3LjcwMjggNDkuODAwNUMxOS44NzIyIDQ5LjgwMDUgMjEuOTA1MiA1MC4zOTA0IDIzLjY0OCA1MS40MjEyQzIzLjY5MDggNTEuNDQ2NiAyMy43MzIgNTEuNDcxOSAyMy43NzQ4IDUxLjQ5NTdDMjYuNjA3MSA1My4xODQ2IDI5Ljk0ODQgNTQuMTEyMyAzMy41MTE3IDUzLjk5MzRDNDIuODA2MiA1My42ODU3IDUwLjM5OSA0Ni4xMjMgNTAuNzQxNiAzNi44MzAxQzUxLjExNTggMjYuNjYzNSA0Mi45ODY5IDE4LjMwNDcgMzIuOTA0NCAxOC4zMDQ3TDMyLjkwMjggMTguMzA2M1pNMzIuOTAyOCA0NC4zMTJDMjguMzk3NSA0NC4zMTIgMjQuNzQ1NCA0MC42NTk5IDI0Ljc0NTQgMzYuMTU2MkMyNC43NDU0IDMxLjY1MjUgMjguMzk3NSAyNy45OTg3IDMyLjkwMjggMjcuOTk4N0MzNy40MDgxIDI3Ljk5ODcgNDEuMDYwMiAzMS42NTA5IDQxLjA2MDIgMzYuMTU2MkM0MS4wNjAyIDQwLjY2MTQgMzcuNDA4MSA0NC4zMTIgMzIuOTAyOCA0NC4zMTJaIiBmaWxsPSIjMTRBQUZGIi8+CjxwYXRoIGQ9Ik0yNS41NjM2IDEyLjY4MjZDMjUuNTYzNiAxNS4wMzQ0IDI0LjMzMTUgMTcuMjE2NCAyMi4zMDggMTguNDE1M0MyMS4wMzc3IDE5LjE2ODYgMTkuODQ2OCAyMC4wNTgyIDE4Ljc2ODQgMjEuMDcxNUMxNi4zNzU1IDIzLjMxMzkgMTQuNTg5OCAyNi4wNjUzIDEzLjI2NzMgMjguNzkyOUMxMy4wMDcyIDI5LjMzMDQgMTIuMiAyOS4xNDAyIDEyLjIgMjguNTQyM1YxMi42ODI2QzEyLjIgOC45OTI0MiAxNS4xOTI0IDYgMTguODgyNiA2QzIyLjU3MjggNiAyNS41NjUyIDguOTkyNDIgMjUuNTY1MiAxMi42ODI2SDI1LjU2MzZaIiBmaWxsPSIjMDA3NUZGIi8+CjwvZz4KPGRlZnM+CjxjbGlwUGF0aCBpZD0iY2xpcDBfMjIzM18yMzg3Ij4KPHJlY3Qgd2lkdGg9IjYwIiBoZWlnaHQ9IjYwIiBmaWxsPSJ3aGl0ZSIvPgo8L2NsaXBQYXRoPgo8L2RlZnM+Cjwvc3ZnPgo=",
  urls: {
    android: "https://play.google.com/store/apps/details?id=com.portto.blocto",
    ios: "https://apps.apple.com/app/blocto/id1481181682"
  }
});

// node_modules/@thirdweb-dev/react/node_modules/@thirdweb-dev/wallets/evm/wallets/coinbase-wallet/dist/thirdweb-dev-wallets-evm-wallets-coinbase-wallet.browser.esm.js
init_shim();
var import_buffer = __toESM(require_buffer());
init_lib3();
{
  window.Buffer = import_buffer.Buffer;
}
var CoinbaseWallet = class _CoinbaseWallet extends AbstractClientWallet {
  get walletName() {
    return "Coinbase Wallet";
  }
  constructor(options) {
    super(_CoinbaseWallet.id, options);
    this.headlessMode = (options == null ? void 0 : options.headlessMode) || false;
    this.theme = (options == null ? void 0 : options.theme) || this.dappMetadata.isDarkMode === false ? "light" : "dark";
  }
  async getConnector() {
    if (!this.connector) {
      const {
        CoinbaseWalletConnector
      } = await import("./thirdweb-dev-wallets-evm-connectors-coinbase-wallet.browser.esm-A4X63ZVY.js");
      const cbConnector = new CoinbaseWalletConnector({
        chains: this.chains,
        options: {
          appName: this.dappMetadata.name,
          reloadOnDisconnect: false,
          darkMode: this.theme === "dark",
          headlessMode: this.headlessMode
        }
      });
      cbConnector.on("connect", () => {
      });
      this.coinbaseConnector = cbConnector;
      this.connector = new WagmiAdapter(cbConnector);
    }
    return this.connector;
  }
  async getQrUrl() {
    await this.getConnector();
    if (!this.coinbaseConnector) {
      throw new Error("Coinbase connector not initialized");
    }
    return this.coinbaseConnector.getQrUrl();
  }
};
_defineProperty(CoinbaseWallet, "meta", {
  iconURL: "ipfs://QmcJBHopbwfJcLqJpX2xEufSS84aLbF7bHavYhaXUcrLaH/coinbase.svg",
  name: "Coinbase Wallet",
  urls: {
    chrome: "https://chrome.google.com/webstore/detail/coinbase-wallet-extension/hnfanknocfeofbddgcijnmhnfnkdnaad",
    android: "https://play.google.com/store/apps/details?id=org.toshi",
    ios: "https://apps.apple.com/us/app/coinbase-wallet-nfts-crypto/id1278383455"
  }
});
_defineProperty(CoinbaseWallet, "id", walletIds.coinbase);

// node_modules/@thirdweb-dev/react/node_modules/@thirdweb-dev/wallets/evm/wallets/embedded-wallet/dist/thirdweb-dev-wallets-evm-wallets-embedded-wallet.browser.esm.js
init_shim();

// node_modules/@thirdweb-dev/react/node_modules/@thirdweb-dev/wallets/evm/connectors/embedded-wallet/dist/thirdweb-dev-wallets-evm-connectors-embedded-wallet.browser.esm.js
init_shim();
init_lib3();

// node_modules/@thirdweb-dev/react/node_modules/@thirdweb-dev/wallets/dist/embedded-wallet-82928b32.browser.esm.js
init_shim();
init_lib3();
var import_utils5 = __toESM(require_utils());
var EMBEDDED_WALLET_PATH = "/sdk/2022-08-12/embedded-wallet";
var GET_IFRAME_BASE_URL = () => `${n().replace("withpaper.com", "ews.thirdweb.com")}`;
var WALLET_USER_ID_LOCAL_STORAGE_NAME = (clientId) => `thirdwebEwsWalletUserId-${clientId}`;
var AUTH_TOKEN_LOCAL_STORAGE_PREFIX = "walletToken";
var AUTH_TOKEN_LOCAL_STORAGE_NAME = (clientId) => {
  return `${AUTH_TOKEN_LOCAL_STORAGE_PREFIX}-${clientId}`;
};
var DEVICE_SHARE_LOCAL_STORAGE_PREFIX = "a";
var DEVICE_SHARE_LOCAL_STORAGE_NAME = (clientId, userId) => `${DEVICE_SHARE_LOCAL_STORAGE_PREFIX}-${clientId}-${userId}`;
var UserStatus = function(UserStatus2) {
  UserStatus2["LOGGED_OUT"] = "Logged Out";
  UserStatus2["LOGGED_IN_WALLET_INITIALIZED"] = "Logged In, Wallet Initialized";
  return UserStatus2;
}({});
var UserWalletStatus = function(UserWalletStatus2) {
  UserWalletStatus2["LOGGED_OUT"] = "Logged Out";
  UserWalletStatus2["LOGGED_IN_WALLET_UNINITIALIZED"] = "Logged In, Wallet Uninitialized";
  UserWalletStatus2["LOGGED_IN_NEW_DEVICE"] = "Logged In, New Device";
  UserWalletStatus2["LOGGED_IN_WALLET_INITIALIZED"] = "Logged In, Wallet Initialized";
  return UserWalletStatus2;
}({});
var data = /* @__PURE__ */ new Map();
var LocalStorage = class {
  constructor(_ref) {
    let {
      clientId
    } = _ref;
    this.isSupported = !!window.localStorage;
    this.clientId = clientId;
  }
  async getItem(key) {
    if (this.isSupported) {
      return window.localStorage.getItem(key);
    } else {
      return data.get(key) ?? null;
    }
  }
  async setItem(key, value) {
    if (this.isSupported) {
      return window.localStorage.setItem(key, value);
    } else {
      data.set(key, value);
    }
  }
  async removeItem(key) {
    const item = await this.getItem(key);
    if (this.isSupported && item) {
      window.localStorage.removeItem(key);
      return true;
    }
    return false;
  }
  async saveAuthCookie(cookie) {
    await this.setItem(AUTH_TOKEN_LOCAL_STORAGE_NAME(this.clientId), cookie);
  }
  async getAuthCookie() {
    return this.getItem(AUTH_TOKEN_LOCAL_STORAGE_NAME(this.clientId));
  }
  async removeAuthCookie() {
    return this.removeItem(AUTH_TOKEN_LOCAL_STORAGE_NAME(this.clientId));
  }
  async saveDeviceShare(share, userId) {
    await this.saveWalletUserId(userId);
    await this.setItem(DEVICE_SHARE_LOCAL_STORAGE_NAME(this.clientId, userId), share);
  }
  async getDeviceShare() {
    const userId = await this.getWalletUserId();
    if (userId) {
      return this.getItem(DEVICE_SHARE_LOCAL_STORAGE_NAME(this.clientId, userId));
    }
    return null;
  }
  async removeDeviceShare() {
    const userId = await this.getWalletUserId();
    if (userId) {
      return this.removeItem(DEVICE_SHARE_LOCAL_STORAGE_NAME(this.clientId, userId));
    }
    return false;
  }
  async getWalletUserId() {
    return this.getItem(WALLET_USER_ID_LOCAL_STORAGE_NAME(this.clientId));
  }
  async saveWalletUserId(userId) {
    await this.setItem(WALLET_USER_ID_LOCAL_STORAGE_NAME(this.clientId), userId);
  }
  async removeWalletUserId() {
    return this.removeItem(WALLET_USER_ID_LOCAL_STORAGE_NAME(this.clientId));
  }
};
function sleep(seconds) {
  return new Promise((resolve) => {
    setTimeout(resolve, seconds * 1e3);
  });
}
var iframeBaseStyle = {
  height: "100%",
  width: "100%",
  border: "none",
  backgroundColor: "transparent",
  colorScheme: "light",
  position: "fixed",
  top: "0px",
  right: "0px",
  zIndex: "2147483646",
  display: "none"
};
var isIframeLoaded = /* @__PURE__ */ new Map();
var IframeCommunicator = class {
  constructor(_ref) {
    let {
      link,
      iframeId,
      container = document.body,
      iframeStyles,
      onIframeInitialize
    } = _ref;
    _defineProperty(this, "POLLING_INTERVAL_SECONDS", 1.4);
    this.iframeBaseUrl = GET_IFRAME_BASE_URL();
    let iframe = document.getElementById(iframeId);
    const hrefLink = new URL(link);
    const sdkVersion = "1.3.5";
    hrefLink.searchParams.set("sdkVersion", sdkVersion);
    if (!iframe || iframe.src !== hrefLink.href) {
      if (!iframe) {
        iframe = document.createElement("iframe");
        const mergedIframeStyles = {
          ...iframeBaseStyle,
          ...iframeStyles
        };
        Object.assign(iframe.style, mergedIframeStyles);
        iframe.setAttribute("id", iframeId);
        iframe.setAttribute("fetchpriority", "high");
        container.appendChild(iframe);
      }
      iframe.src = hrefLink.href;
      iframe.setAttribute("data-version", sdkVersion);
      const onIframeLoaded = (event) => {
        if (event.data.eventType === "ewsIframeLoaded") {
          window.removeEventListener("message", onIframeLoaded);
          if (!iframe) {
            console.warn("thirdweb Iframe not found");
            return;
          }
          this.onIframeLoadHandler(iframe, onIframeInitialize)();
        }
      };
      window.addEventListener("message", onIframeLoaded);
    }
    this.iframe = iframe;
  }
  async onIframeLoadedInitVariables() {
    return {};
  }
  onIframeLoadHandler(iframe, onIframeInitialize) {
    return async () => {
      const promise = new Promise(async (res, rej) => {
        var _a;
        const channel = new MessageChannel();
        channel.port1.onmessage = (event) => {
          const {
            data: data2
          } = event;
          channel.port1.close();
          if (!data2.success) {
            return rej(new Error(data2.error));
          }
          isIframeLoaded.set(iframe.src, true);
          if (onIframeInitialize) {
            onIframeInitialize();
          }
          return res(true);
        };
        const INIT_IFRAME_EVENT = "initIframe";
        (_a = iframe == null ? void 0 : iframe.contentWindow) == null ? void 0 : _a.postMessage(
          // ? We initialise the iframe with a bunch
          // of useful information so that we don't have to pass it
          // through in each of the future call. This would be where we do it.
          {
            eventType: INIT_IFRAME_EVENT,
            data: await this.onIframeLoadedInitVariables()
          },
          this.iframeBaseUrl,
          [channel.port2]
        );
      });
      await promise;
    };
  }
  async call(_ref2) {
    let {
      procedureName,
      params,
      showIframe = false
    } = _ref2;
    while (!isIframeLoaded.get(this.iframe.src)) {
      await sleep(this.POLLING_INTERVAL_SECONDS);
    }
    if (showIframe) {
      this.iframe.style.display = "block";
      await sleep(5e-3);
    }
    const promise = new Promise((res, rej) => {
      var _a;
      const channel = new MessageChannel();
      channel.port1.onmessage = async (event) => {
        const {
          data: data2
        } = event;
        channel.port1.close();
        if (showIframe) {
          await sleep(0.1);
          this.iframe.style.display = "none";
        }
        if (!data2.success) {
          rej(new Error(data2.error));
        } else {
          res(data2.data);
        }
      };
      (_a = this.iframe.contentWindow) == null ? void 0 : _a.postMessage({
        eventType: procedureName,
        data: params
      }, this.iframeBaseUrl, [channel.port2]);
    });
    return promise;
  }
  /**
   * This has to be called by any iframe that will be removed from the DOM.
   * Use to make sure that we reset the global loaded state of the particular iframe.src
   */
  destroy() {
    isIframeLoaded.delete(this.iframe.src);
  }
};
var EmbeddedWalletIframeCommunicator = class extends IframeCommunicator {
  constructor(_ref) {
    let {
      clientId,
      customizationOptions
    } = _ref;
    super({
      iframeId: EMBEDDED_WALLET_IFRAME_ID,
      link: createEmbeddedWalletIframeLink({
        clientId,
        path: EMBEDDED_WALLET_PATH,
        queryParams: customizationOptions
      }).href,
      container: document.body
    });
    this.clientId = clientId;
  }
  async onIframeLoadedInitVariables() {
    const localStorage2 = new LocalStorage({
      clientId: this.clientId
    });
    return {
      authCookie: await localStorage2.getAuthCookie(),
      deviceShareStored: await localStorage2.getDeviceShare(),
      walletUserId: await localStorage2.getWalletUserId(),
      clientId: this.clientId
    };
  }
};
function createEmbeddedWalletIframeLink(_ref2) {
  var _a;
  let {
    clientId,
    path,
    queryParams
  } = _ref2;
  const embeddedWalletUrl = new URL(`${path}`, GET_IFRAME_BASE_URL());
  if (queryParams) {
    for (const queryKey of Object.keys(queryParams)) {
      embeddedWalletUrl.searchParams.set(queryKey, ((_a = queryParams[queryKey]) == null ? void 0 : _a.toString()) || "");
    }
  }
  embeddedWalletUrl.searchParams.set("clientId", clientId);
  return embeddedWalletUrl;
}
var EMBEDDED_WALLET_IFRAME_ID = "thirdweb-embedded-wallet-iframe";
var AbstractLogin = class {
  /**
   * Used to manage the user's auth states. This should not be instantiated directly.
   * Call {@link EmbeddedWalletSdk.auth} instead.
   *
   */
  constructor(_ref) {
    let {
      querier,
      preLogin,
      postLogin,
      clientId
    } = _ref;
    this.LoginQuerier = querier;
    this.preLogin = preLogin;
    this.postLogin = postLogin;
    this.clientId = clientId;
  }
  async sendEmailLoginOtp(_ref2) {
    let {
      email
    } = _ref2;
    await this.preLogin();
    const result = await this.LoginQuerier.call({
      procedureName: "sendThirdwebEmailLoginOtp",
      params: {
        email
      }
    });
    return result;
  }
};
var BaseLogin = class extends AbstractLogin {
  constructor() {
    super(...arguments);
    _defineProperty(this, "closeWindow", (_ref) => {
      let {
        isWindowOpenedByFn,
        win,
        closeOpenedWindow
      } = _ref;
      if (isWindowOpenedByFn) {
        win == null ? void 0 : win.close();
      } else {
        if (win && closeOpenedWindow) {
          closeOpenedWindow(win);
        } else if (win) {
          win.close();
        }
      }
    });
  }
  async getGoogleLoginUrl() {
    const result = await this.LoginQuerier.call({
      procedureName: "getHeadlessGoogleLoginLink",
      params: void 0
    });
    return result;
  }
  async loginWithModal() {
    await this.preLogin();
    const result = await this.LoginQuerier.call({
      procedureName: "loginWithThirdwebModal",
      params: void 0,
      showIframe: true
    });
    return this.postLogin(result);
  }
  async loginWithEmailOtp(_ref2) {
    let {
      email
    } = _ref2;
    await this.preLogin();
    const result = await this.LoginQuerier.call({
      procedureName: "loginWithThirdwebModal",
      params: {
        email
      },
      showIframe: true
    });
    return this.postLogin(result);
  }
  async loginWithGoogle(args) {
    await this.preLogin();
    let win = args == null ? void 0 : args.openedWindow;
    let isWindowOpenedByFn = false;
    if (!win) {
      win = window.open("", "Login", "width=350, height=500");
      isWindowOpenedByFn = true;
    }
    if (!win) {
      throw new Error("Something went wrong opening pop-up");
    }
    await this.preLogin();
    const {
      loginLink
    } = await this.getGoogleLoginUrl();
    win.location.href = loginLink;
    const result = await new Promise((resolve, reject) => {
      const pollTimer = window.setInterval(async () => {
        if (!win) {
          return;
        }
        if (win.closed) {
          clearInterval(pollTimer);
          window.removeEventListener("message", messageListener);
          reject(new Error("User closed login window"));
        }
      }, 1e3);
      const messageListener = async (event) => {
        if (event.origin !== GET_IFRAME_BASE_URL()) {
          return;
        }
        if (typeof event.data !== "object") {
          reject(new Error("Invalid event data"));
          return;
        }
        switch (event.data.eventType) {
          case "userLoginSuccess": {
            window.removeEventListener("message", messageListener);
            clearInterval(pollTimer);
            this.closeWindow({
              isWindowOpenedByFn,
              win,
              closeOpenedWindow: args == null ? void 0 : args.closeOpenedWindow
            });
            if (event.data.authResult) {
              resolve(event.data.authResult);
            }
            break;
          }
          case "userLoginFailed": {
            window.removeEventListener("message", messageListener);
            clearInterval(pollTimer);
            this.closeWindow({
              isWindowOpenedByFn,
              win,
              closeOpenedWindow: args == null ? void 0 : args.closeOpenedWindow
            });
            reject(new Error(event.data.error));
            break;
          }
          case "injectDeveloperClientId": {
            win == null ? void 0 : win.postMessage({
              eventType: "injectDeveloperClientIdResult",
              developerClientId: this.clientId
            }, GET_IFRAME_BASE_URL());
            break;
          }
        }
      };
      window.addEventListener("message", messageListener);
    });
    return this.postLogin({
      storedToken: {
        ...result.storedToken,
        shouldStoreCookieString: true
      },
      walletDetails: {
        ...result.walletDetails,
        isIframeStorageEnabled: false
      }
    });
  }
  async verifyEmailLoginOtp(_ref3) {
    let {
      email,
      otp
    } = _ref3;
    const result = await this.LoginQuerier.call({
      procedureName: "verifyThirdwebEmailLoginOtp",
      params: {
        email,
        otp
      }
    });
    return this.postLogin(result);
  }
};
var Auth = class {
  /**
   * Used to manage the user's auth states. This should not be instantiated directly.
   * Call {@link EmbeddedWalletSdk.auth} instead.
   *
   * @param {string} params.clientId the clientId from your thirdweb dashboard
   */
  constructor(_ref) {
    let {
      clientId,
      querier,
      onAuthSuccess
    } = _ref;
    this.clientId = clientId;
    this.AuthQuerier = querier;
    this.localStorage = new LocalStorage({
      clientId
    });
    this.onAuthSuccess = onAuthSuccess;
    this.BaseLogin = new BaseLogin({
      postLogin: async (result) => {
        return this.postLogin(result);
      },
      preLogin: async () => {
        await this.preLogin();
      },
      querier,
      clientId
    });
  }
  async preLogin() {
    await this.logout();
  }
  async postLogin(_ref2) {
    let {
      storedToken,
      walletDetails
    } = _ref2;
    if (storedToken.shouldStoreCookieString) {
      await this.localStorage.saveAuthCookie(storedToken.cookieString);
    }
    const initializedUser = await this.onAuthSuccess({
      storedToken,
      walletDetails
    });
    return initializedUser;
  }
  /**
   * @description
   * Used to log the user into their thirdweb wallet on your platform via a myriad of auth providers
   *
   * @example
   * const thirdwebEmbeddedWallet = new EmbeddedWalletSdk({clientId: "YOUR_CLIENT_ID", chain: "Polygon"})
   * try {
   *   const user = await thirdwebEmbeddedWallet.auth.loginWithModal();
   *   // user is now logged in
   * } catch (e) {
   *   // User closed modal or something else went wrong during the authentication process
   *   console.error(e)
   * }
   *
   * @param {(userWalletId: string) => Promise<string | undefined>} args.getRecoveryCode Only present when using RecoveryShareManagement.USER_MANAGED recovery share management. A function that returns the recovery code for a given userWalletId.
   *
   * @returns {{user: InitializedUser}} An InitializedUser object. See {@link EmbeddedWalletSdk.getUser} for more
   */
  async loginWithModal() {
    await this.preLogin();
    return this.BaseLogin.loginWithModal();
  }
  /**
   * @description
   * Used to log the user into their thirdweb wallet using email OTP
   *
   * @example
   *  // Basic Flow
   *  const thirdwebEmbeddedWallet = new EmbeddedWalletSdk({clientId: "", chain: "Polygon"});
   *  try {
   *    // prompts user to enter the code they received
   *    const user = await thirdwebEmbeddedWallet.auth.loginWithThirdwebEmailOtp({ email : "you@example.com" });
   *    // user is now logged in
   *  } catch (e) {
   *    // User closed the OTP modal or something else went wrong during the authentication process
   *    console.error(e)
   *  }
   *
   * @param {string} props.email We will send the email an OTP that needs to be entered in order for them to be logged in.
   * @returns {{user: InitializedUser}} An InitializedUser object. See {@link EmbeddedWalletSdk.getUser} for more
   */
  async loginWithEmailOtp(args) {
    return this.BaseLogin.loginWithEmailOtp(args);
  }
  async loginWithGoogle(args) {
    return this.BaseLogin.loginWithGoogle(args);
  }
  /**
   * A headless way to initiate login with google.
   * @returns {{user: InitializedUser}} An InitializedUser object. See {@link EmbeddedWalletSdk.getUser} for more
    */
  /**
   * @description
   * A headless way to send the users at {email} an OTP code.
   * You need to then call {@link Auth.verifyEmailLoginOtp} in order to complete the login process
   *
   * @example
   *  const thirdwebEmbeddedWallet = new EmbeddedWalletSdk({clientId: "", chain: "Polygon"});
   *  // sends user an OTP code
   * try {
   *    await thirdwebEmbeddedWallet.auth.sendEmailLoginOtp({ email : "you@example.com" });
   * } catch(e) {
   *    // Error Sending user's email an OTP code
   *    console.error(e);
   * }
   *
   * // Then when your user is ready to verify their OTP
   * try {
   *    const user = await thirdwebEmbeddedWallet.auth.verifyEmailLoginOtp({ email: "you@example.com", otp: "6-DIGIT_CODE_HERE" });
   * } catch(e) {
   *    // Error verifying the OTP code
   *    console.error(e)
   * }
   *
   * @param {string} props.email We will send the email an OTP that needs to be entered in order for them to be logged in.
   * @returns {{ isNewUser: boolean }} IsNewUser indicates if the user is a new user to your platform
   */
  async sendEmailLoginOtp(_ref3) {
    let {
      email
    } = _ref3;
    return this.BaseLogin.sendEmailLoginOtp({
      email
    });
  }
  /**
   *  @description
   * Used to verify the otp that the user receives from thirdweb
   *
   * See {@link Auth.sendEmailLoginOtp} for how the headless call flow looks like. Simply swap out the calls to `loginWithThirdwebEmailOtp` with `verifyThirdwebEmailLoginOtp`
   *
   * @param {string} props.email We will send the email an OTP that needs to be entered in order for them to be logged in.
   * @param {string} props.otp The code that the user received in their email
   * @returns {{user: InitializedUser}} An InitializedUser object containing the user's status, wallet, authDetails, and more
   */
  async verifyEmailLoginOtp(args) {
    return this.BaseLogin.verifyEmailLoginOtp(args);
  }
  /**
   * @description
   * Logs any existing user out of their wallet.
   * @returns {{success: boolean}} true if a user is successfully logged out. false if there's no user currently logged in.
   */
  async logout() {
    const {
      success
    } = await this.AuthQuerier.call({
      procedureName: "logout",
      params: void 0
    });
    const isRemoveAuthCookie = await this.localStorage.removeAuthCookie();
    const isRemoveUserId = await this.localStorage.removeWalletUserId();
    return {
      success: success || isRemoveAuthCookie || isRemoveUserId
    };
  }
};
var EthersSigner = class _EthersSigner extends Signer {
  constructor(_ref) {
    var _a;
    let {
      provider,
      clientId,
      querier
    } = _ref;
    super();
    _defineProperty(this, "DEFAULT_ETHEREUM_CHAIN_ID", 5);
    this.clientId = clientId;
    this.querier = querier;
    this.endpoint = (_a = provider.connection) == null ? void 0 : _a.url;
    (0, import_utils5.defineReadOnly)(this, "provider", provider);
  }
  async getAddress() {
    const {
      address
    } = await this.querier.call({
      procedureName: "getAddress",
      params: void 0
    });
    return address;
  }
  async signMessage(message) {
    var _a, _b;
    const {
      signedMessage
    } = await this.querier.call({
      procedureName: "signMessage",
      params: {
        message,
        chainId: ((_b = await ((_a = this.provider) == null ? void 0 : _a.getNetwork())) == null ? void 0 : _b.chainId) ?? this.DEFAULT_ETHEREUM_CHAIN_ID,
        rpcEndpoint: this.endpoint
      }
    });
    return signedMessage;
  }
  async signTransaction(transaction) {
    var _a, _b;
    const {
      signedTransaction
    } = await this.querier.call({
      procedureName: "signTransaction",
      params: {
        transaction,
        chainId: ((_b = await ((_a = this.provider) == null ? void 0 : _a.getNetwork())) == null ? void 0 : _b.chainId) ?? this.DEFAULT_ETHEREUM_CHAIN_ID,
        rpcEndpoint: this.endpoint
      }
    });
    return signedTransaction;
  }
  async _signTypedData(domain, types, message) {
    var _a, _b;
    const {
      signedTypedData
    } = await this.querier.call({
      procedureName: "signTypedDataV4",
      params: {
        domain,
        types,
        message,
        chainId: ((_b = await ((_a = this.provider) == null ? void 0 : _a.getNetwork())) == null ? void 0 : _b.chainId) ?? this.DEFAULT_ETHEREUM_CHAIN_ID,
        rpcEndpoint: this.endpoint
      }
    });
    return signedTypedData;
  }
  connect(provider) {
    return new _EthersSigner({
      clientId: this.clientId,
      provider,
      querier: this.querier
    });
  }
};
var EmbeddedWallet = class {
  /**
   * Not meant to be initialized directly. Call {@link .initializeUser} to get an instance
   * @param param0
   */
  constructor(_ref) {
    let {
      clientId,
      chain,
      querier
    } = _ref;
    this.clientId = clientId;
    this.chain = chain;
    this.walletManagerQuerier = querier;
    this.localStorage = new LocalStorage({
      clientId
    });
  }
  /**
   * @internal
   * Used to set-up the user device in the case that they are using incognito
   * @param {string} param.deviceShareStored the value that is saved for the user's device share.
   * We save this into the localStorage on the site itself if we could not save it within the iframe's localStorage.
   * This happens in incognito mostly
   * @param {string} param.walletAddress User's wallet address
   * @param {boolean} param.isIframeStorageEnabled Tells us if we were able to store values in the localStorage in our iframe.
   * We need to store it under the dev's domain localStorage if we weren't able to store things in the iframe
   * @returns {{ walletAddress : string }} The user's wallet details
   */
  async postWalletSetUp(_ref2) {
    let {
      deviceShareStored,
      walletAddress,
      isIframeStorageEnabled,
      walletUserId
    } = _ref2;
    if (!isIframeStorageEnabled) {
      await this.localStorage.saveDeviceShare(deviceShareStored, walletUserId);
    }
    return {
      walletAddress
    };
  }
  /**
   * @internal
   * Gets the various status states of the user
   * @example
   *  const userStatus = await Paper.getUserWalletStatus();
   *  switch (userStatus.status) {
   *  case UserWalletStatus.LOGGED_OUT: {
   *    // User is logged out, call one of the auth methods on Paper.auth to authenticate the user
   *    break;
   *  }
   *  case UserWalletStatus.LOGGED_IN_WALLET_UNINITIALIZED: {
   *    // User is logged in, but does not have a wallet associated with it
   *    // you also have access to the user's details
   *    userStatus.user.authDetails;
   *    break;
   *  }
   *  case UserWalletStatus.LOGGED_IN_NEW_DEVICE: {
   *    // User is logged in and created a wallet already, but is missing the device shard
   *    // You have access to:
   *    userStatus.user.authDetails;
   *    userStatus.user.walletAddress;
   *    break;
   *  }
   *  case UserWalletStatus.LOGGED_IN_WALLET_INITIALIZED: {
   *    // user is logged in and wallet is all set up.
   *    // You have access to:
   *    userStatus.user.authDetails;
   *    userStatus.user.walletAddress;
   *    userStatus.user.wallet;
   *    break;
   *  }
   *}
   * @returns {GetUserWalletStatusFnReturnType} an object to containing various information on the user statuses
   */
  async getUserWalletStatus() {
    const userStatus = await this.walletManagerQuerier.call({
      procedureName: "getUserStatus",
      params: void 0
    });
    if (userStatus.status === UserWalletStatus.LOGGED_IN_WALLET_INITIALIZED) {
      return {
        status: UserWalletStatus.LOGGED_IN_WALLET_INITIALIZED,
        user: {
          ...userStatus.user,
          wallet: this
        }
      };
    }
    return userStatus;
  }
  /**
   * @description
   * Switches the chain that the user wallet is currently on.
   * @example
   * // user wallet will be set to Polygon
   * const Paper = new ThirdwebEmbeddedWalletSdk({clientId: "", chain: "Polygon"});
   * const user = await Paper.initializeUser();
   * // Switch the user wallet to Mumbai
   * await user.wallet.setChain({ chain: "Mumbai" });
   * @param {Chain} params.chain The chain that we are changing the user wallet too
   */
  async setChain(_ref3) {
    let {
      chain
    } = _ref3;
    this.chain = chain;
  }
  /**
   * Returns an Ethers.Js compatible signer that you can use in conjunction with the rest of dApp
   * @example
   * const Paper = new ThirdwebEmbeddedWalletSdk({clientId: "", chain: "Polygon"});
   * const user = await Paper.getUser();
   * if (user.status === UserStatus.LOGGED_IN_WALLET_INITIALIZED) {
   *    // returns a signer on the Polygon mainnet
   *    const signer = await user.getEthersJsSigner();
   *    // returns a signer on the specified RPC endpoints
   *    const signer = await user.getEthersJsSigner({rpcEndpoint: "https://eth-rpc.gateway.pokt.network"});
   * }
   * @param {Networkish} network.rpcEndpoint the rpc url where calls will be routed through
   * @throws If attempting to call the function without the user wallet initialize on their current device. This should never happen if call {@link ThirdwebEmbeddedWalletSdk.initializeUser} before accessing this function
   * @returns A signer that is compatible with Ether.js. Defaults to the public rpc on the chain specified when initializing the {@link ThirdwebEmbeddedWalletSdk} instance
   */
  async getEthersJsSigner(network) {
    const signer = new EthersSigner({
      clientId: this.clientId,
      provider: getDefaultProvider((network == null ? void 0 : network.rpcEndpoint) ?? o[this.chain]),
      querier: this.walletManagerQuerier
    });
    return signer;
  }
};
var EmbeddedWalletSdk = class {
  /**
   * Used to manage the Auth state of the user.
   */
  isClientIdLegacyPaper(clientId) {
    if (clientId.indexOf("-") > 0 && clientId.length === 36) {
      return true;
    } else {
      return false;
    }
  }
  /**
   * @example
   * const thirdwebEmbeddedWallet = new EmbeddedWalletSdk({ clientId: "", chain: "Goerli" });
   * @param {string} initParams.clientId the clientId found on the {@link https://thirdweb.com/dashboard/settings dashboard settings}
   * @param {Chain} initParams.chain sets the default chain that the EmbeddedWallet will live on.
   * @param {CustomizationOptionsType} initParams.styles sets the default style override for any modal that pops up asking for user's details when creating wallet or logging in.
   */
  constructor(_ref) {
    let {
      clientId,
      chain,
      styles
    } = _ref;
    if (this.isClientIdLegacyPaper(clientId)) {
      throw new Error("You are using a legacy clientId. Please use the clientId found on the thirdweb dashboard settings page");
    }
    this.clientId = clientId;
    this.querier = new EmbeddedWalletIframeCommunicator({
      clientId,
      customizationOptions: styles
    });
    this.wallet = new EmbeddedWallet({
      clientId,
      chain,
      querier: this.querier
    });
    this.auth = new Auth({
      clientId,
      querier: this.querier,
      onAuthSuccess: async (authResult) => {
        await this.wallet.postWalletSetUp({
          ...authResult.walletDetails,
          walletUserId: authResult.storedToken.authDetails.userWalletId
        });
        await this.querier.call({
          procedureName: "initIframe",
          params: {
            deviceShareStored: authResult.walletDetails.deviceShareStored,
            clientId: this.clientId,
            walletUserId: authResult.storedToken.authDetails.userWalletId,
            authCookie: authResult.storedToken.cookieString
          }
        });
        return {
          user: {
            status: UserStatus.LOGGED_IN_WALLET_INITIALIZED,
            authDetails: authResult.storedToken.authDetails,
            wallet: this.wallet,
            walletAddress: authResult.walletDetails.walletAddress
          }
        };
      }
    });
  }
  /**
   * Gets the usr if they are logged in
   * @example
   *  const user = await thirdwebEmbeddedWallet.getUser();
   *  switch (user.status) {
   *     case UserStatus.LOGGED_OUT: {
   *       // User is logged out, call one of the auth methods on thirdwebEmbeddedWallet.auth to authenticate the user
   *       break;
   *     }
   *     case UserStatus.LOGGED_IN_WALLET_INITIALIZED: {
   *       // user is logged in and wallet is all set up.
   *       // You have access to:
   *       user.status;
   *       user.authDetails;
   *       user.walletAddress;
   *       user.wallet;
   *       break;
   *     }
   *}
   * @returns {GetUser} an object to containing various information on the user statuses
   */
  async getUser() {
    const userStatus = await this.wallet.getUserWalletStatus();
    switch (userStatus.status) {
      case UserWalletStatus.LOGGED_IN_NEW_DEVICE:
      case UserWalletStatus.LOGGED_IN_WALLET_UNINITIALIZED:
        await this.auth.logout();
        return this.getUser();
      case UserWalletStatus.LOGGED_OUT:
        return {
          status: UserStatus.LOGGED_OUT
        };
      case UserWalletStatus.LOGGED_IN_WALLET_INITIALIZED:
        return {
          status: UserStatus.LOGGED_IN_WALLET_INITIALIZED,
          ...userStatus.user
        };
    }
  }
};

// node_modules/@thirdweb-dev/react/node_modules/@thirdweb-dev/wallets/evm/connectors/embedded-wallet/dist/thirdweb-dev-wallets-evm-connectors-embedded-wallet.browser.esm.js
var import_utils6 = __toESM(require_utils());
var _embeddedWalletSdk = /* @__PURE__ */ new WeakMap();
var _signer = /* @__PURE__ */ new WeakMap();
var EmbeddedWalletConnector = class extends Connector {
  constructor(options) {
    super();
    _defineProperty(this, "id", walletIds.paper);
    _defineProperty(this, "name", "Paper Wallet");
    _defineProperty(this, "ready", true);
    _defineProperty(this, "user", null);
    _classPrivateFieldInitSpec(this, _embeddedWalletSdk, {
      writable: true,
      value: void 0
    });
    _classPrivateFieldInitSpec(this, _signer, {
      writable: true,
      value: void 0
    });
    _defineProperty(this, "onAccountsChanged", async (accounts) => {
      if (accounts.length === 0) {
        await this.onDisconnect();
      } else {
        this.emit("change", {
          account: utils_exports.getAddress(accounts[0])
        });
      }
    });
    _defineProperty(this, "onChainChanged", (chainId) => {
      const id = normalizeChainId(chainId);
      const unsupported = this.options.chains.findIndex((c3) => c3.chainId === id) === -1;
      this.emit("change", {
        chain: {
          id,
          unsupported
        }
      });
    });
    _defineProperty(this, "onDisconnect", async () => {
      this.emit("disconnect");
    });
    this.options = options;
  }
  getEmbeddedWalletSDK() {
    if (!_classPrivateFieldGet(this, _embeddedWalletSdk)) {
      _classPrivateFieldSet(this, _embeddedWalletSdk, new EmbeddedWalletSdk({
        clientId: this.options.clientId,
        chain: "Ethereum",
        styles: this.options.styles
      }));
    }
    return _classPrivateFieldGet(this, _embeddedWalletSdk);
  }
  async connect(options) {
    const thirdwebSDK = await this.getEmbeddedWalletSDK();
    if (!thirdwebSDK) {
      throw new Error("EmbeddedWallet SDK not initialized");
    }
    const user = await thirdwebSDK.getUser();
    switch (user.status) {
      case UserStatus.LOGGED_OUT: {
        let authResult;
        switch (options == null ? void 0 : options.loginType) {
          case "headless_google_oauth": {
            authResult = await thirdwebSDK.auth.loginWithGoogle({
              closeOpenedWindow: options.closeOpenedWindow,
              openedWindow: options.openedWindow
            });
            break;
          }
          case "headless_email_otp_verification": {
            authResult = await thirdwebSDK.auth.verifyEmailLoginOtp({
              email: options.email,
              otp: options.otp
            });
            break;
          }
          case "ui_email_otp": {
            authResult = await thirdwebSDK.auth.loginWithEmailOtp({
              email: options.email
            });
            break;
          }
          default: {
            authResult = await thirdwebSDK.auth.loginWithModal();
            break;
          }
        }
        this.user = authResult.user;
        break;
      }
      case UserStatus.LOGGED_IN_WALLET_INITIALIZED: {
        if ((options == null ? void 0 : options.loginType) === "headless_google_oauth") {
          if (options.closeOpenedWindow && options.openedWindow) {
            options.closeOpenedWindow(options.openedWindow);
          }
        }
        this.user = user;
        break;
      }
    }
    if (!this.user) {
      throw new Error("Error connecting User");
    }
    if (options == null ? void 0 : options.chainId) {
      this.switchChain(options.chainId);
    }
    this.setupListeners();
    return this.getAddress();
  }
  async disconnect() {
    const paper = await _classPrivateFieldGet(this, _embeddedWalletSdk);
    await (paper == null ? void 0 : paper.auth.logout());
    _classPrivateFieldSet(this, _signer, void 0);
    this.user = null;
  }
  async getAddress() {
    const signer = await this.getSigner();
    return signer.getAddress();
  }
  async isConnected() {
    try {
      const addr = await this.getAddress();
      return !!addr;
    } catch (e) {
      return false;
    }
  }
  async getProvider() {
    const signer = await this.getSigner();
    if (!signer.provider) {
      throw new Error("Provider not found");
    }
    return signer.provider;
  }
  async getSigner() {
    var _a;
    if (_classPrivateFieldGet(this, _signer)) {
      return _classPrivateFieldGet(this, _signer);
    }
    if (!this.user) {
      const embeddedWalletSdk = await this.getEmbeddedWalletSDK();
      const user = await embeddedWalletSdk.getUser();
      switch (user.status) {
        case UserStatus.LOGGED_IN_WALLET_INITIALIZED: {
          this.user = user;
          break;
        }
      }
    }
    const signer = await ((_a = this.user) == null ? void 0 : _a.wallet.getEthersJsSigner({
      rpcEndpoint: this.options.chain.rpc[0] || ""
      // TODO: handle chain.rpc being empty array
    }));
    if (!signer) {
      throw new Error("Signer not found");
    }
    _classPrivateFieldSet(this, _signer, signer);
    return signer;
  }
  async isAuthorized() {
    return false;
  }
  async switchChain(chainId) {
    var _a, _b;
    const chain = this.options.chains.find((c3) => c3.chainId === chainId);
    if (!chain) {
      throw new Error("Chain not configured");
    }
    await ((_a = this.user) == null ? void 0 : _a.wallet.setChain({
      chain: "Ethereum"
    }));
    _classPrivateFieldSet(this, _signer, await ((_b = this.user) == null ? void 0 : _b.wallet.getEthersJsSigner({
      rpcEndpoint: chain.rpc[0] || ""
      // TODO: handle chain.rpc being empty array
    })));
    this.emit("change", {
      chain: {
        id: chainId,
        unsupported: false
      }
    });
  }
  async setupListeners() {
    const provider = await this.getProvider();
    if (provider.on) {
      provider.on("accountsChanged", this.onAccountsChanged);
      provider.on("chainChanged", this.onChainChanged);
      provider.on("disconnect", this.onDisconnect);
    }
  }
  updateChains(chains) {
    this.options.chains = chains;
  }
  async getEmail() {
    await this.getSigner();
    if (!this.user) {
      throw new Error("No user found, Paper Wallet is not connected");
    }
    return this.user.authDetails.email;
  }
};

// node_modules/@thirdweb-dev/react/node_modules/@thirdweb-dev/wallets/evm/wallets/embedded-wallet/dist/thirdweb-dev-wallets-evm-wallets-embedded-wallet.browser.esm.js
init_lib3();
var import_utils7 = __toESM(require_utils());
var EmbeddedWallet2 = class _EmbeddedWallet extends AbstractClientWallet {
  get walletName() {
    return "Embedded Wallet";
  }
  constructor(options) {
    super(_EmbeddedWallet.id, {
      ...options
    });
    this.chain = options.chain;
  }
  async getConnector() {
    var _a, _b;
    if (!this.connector) {
      this.connector = new EmbeddedWalletConnector({
        clientId: ((_a = this.options) == null ? void 0 : _a.clientId) ?? "",
        chain: this.chain,
        chains: this.chains,
        styles: (_b = this.options) == null ? void 0 : _b.styles
      });
    }
    return this.connector;
  }
  getConnectParams() {
    const connectParams = super.getConnectParams();
    if (!connectParams) {
      return void 0;
    }
    if (connectParams.loginType === "headless_google_oauth") {
      return {
        loginType: connectParams.loginType,
        chainId: connectParams.chainId
      };
    }
    return connectParams;
  }
  async getEmail() {
    const connector = await this.getConnector();
    return connector.getEmail();
  }
  async getEmbeddedWalletSDK() {
    const connector = await this.getConnector();
    return connector.getEmbeddedWalletSDK();
  }
};
_defineProperty(EmbeddedWallet2, "id", walletIds.embeddedWallet);
_defineProperty(EmbeddedWallet2, "meta", {
  name: "Embedded Wallet",
  iconURL: "ipfs://QmNx2evQa6tcQs9VTd3YaDm31ckfStvgRGKFGELahUmrbV/emailIcon.svg"
});

// node_modules/@thirdweb-dev/react/node_modules/@thirdweb-dev/wallets/evm/wallets/frame/dist/thirdweb-dev-wallets-evm-wallets-frame.browser.esm.js
init_shim();
init_lib3();
var FrameWallet = class _FrameWallet extends AbstractClientWallet {
  get walletName() {
    return "Frame Wallet";
  }
  constructor(options) {
    super(_FrameWallet.id, options);
  }
  async getConnector() {
    if (!this.connector) {
      const {
        FrameConnector
      } = await import("./thirdweb-dev-wallets-evm-connectors-frame.browser.esm-XXSWFHRO.js");
      this.connector = new WagmiAdapter(new FrameConnector({
        chains: this.chains,
        connectorStorage: this.walletStorage,
        options: {
          shimDisconnect: true
        }
      }));
    }
    return this.connector;
  }
};
_defineProperty(FrameWallet, "id", walletIds.frame);

// node_modules/@thirdweb-dev/react/node_modules/@thirdweb-dev/wallets/evm/wallets/injected/dist/thirdweb-dev-wallets-evm-wallets-injected.browser.esm.js
init_shim();
init_lib3();
var InjectedWallet = class _InjectedWallet extends AbstractClientWallet {
  get walletName() {
    return "Injected Wallet";
  }
  constructor(options) {
    super(_InjectedWallet.id, options);
  }
  async getConnector() {
    if (!this.connector) {
      const {
        InjectedConnector
      } = await import("./thirdweb-dev-wallets-evm-connectors-injected.browser.esm-KYMOR6AO.js");
      this.connector = new WagmiAdapter(new InjectedConnector({
        chains: this.chains,
        connectorStorage: this.walletStorage,
        options: {
          shimDisconnect: true
        }
      }));
    }
    return this.connector;
  }
};
_defineProperty(InjectedWallet, "id", "injected");

// node_modules/@thirdweb-dev/react/node_modules/@thirdweb-dev/wallets/evm/wallets/local-wallet/dist/thirdweb-dev-wallets-evm-wallets-local-wallet.browser.esm.js
init_shim();
init_lib3();
var STORAGE_KEY_WALLET_DATA = "localWalletData";
var _storage2 = /* @__PURE__ */ new WeakMap();
var _saveData = /* @__PURE__ */ new WeakSet();
var LocalWallet = class _LocalWallet extends AbstractClientWallet {
  get walletName() {
    return "Local Wallet";
  }
  constructor(options) {
    super(_LocalWallet.id, options);
    _classPrivateMethodInitSpec(this, _saveData);
    _classPrivateFieldInitSpec(this, _storage2, {
      writable: true,
      value: void 0
    });
    this.options = options || {};
    _classPrivateFieldSet(this, _storage2, (options == null ? void 0 : options.storage) || createAsyncLocalStorage(walletIds.localWallet));
  }
  async getConnector() {
    if (!this.connector) {
      const {
        LocalWalletConnector
      } = await import("./thirdweb-dev-wallets-evm-connectors-local-wallet.browser.esm-HZI2KT7N.js");
      if (!this.ethersWallet) {
        throw new Error("wallet is not initialized");
      }
      const defaults = this.options.chain ? [...defaultChains, this.options.chain] : defaultChains;
      this.connector = new LocalWalletConnector({
        chain: this.options.chain || c1,
        ethersWallet: this.ethersWallet,
        chains: this.options.chains || defaults,
        clientId: this.options.clientId,
        secretKey: this.options.secretKey
      });
    }
    return this.connector;
  }
  /**
   * load saved wallet data from storage or generate a new one and save it.
   */
  async loadOrCreate(options) {
    if (await this.getSavedData(options.storage)) {
      await this.load(options);
    } else {
      await this.generate();
      await this.save(options);
    }
  }
  /**
   * creates a new random wallet
   * @returns the address of the newly created wallet
   */
  async generate() {
    if (this.ethersWallet) {
      throw new Error("wallet is already initialized");
    }
    const random = utils_exports.randomBytes(32);
    this.ethersWallet = new Wallet(random);
    return this.ethersWallet.address;
  }
  /**
   * create local wallet from an "encryptedJson", "privateKey" or "mnemonic"
   * @returns
   */
  async import(options) {
    if (this.ethersWallet) {
      throw new Error("wallet is already initialized");
    }
    if ("encryptedJson" in options) {
      this.ethersWallet = await Wallet.fromEncryptedJson(options.encryptedJson, options.password);
      return this.ethersWallet.address;
    }
    if ("privateKey" in options) {
      if (!options.encryption && !isValidPrivateKey(options.privateKey)) {
        throw new Error("invalid private key");
      }
      const privateKey = await getDecryptor(options.encryption)(options.privateKey);
      if (options.encryption && (privateKey === "" || !isValidPrivateKey(privateKey))) {
        throw new Error("invalid password");
      }
      this.ethersWallet = new Wallet(privateKey);
      return this.ethersWallet.address;
    }
    if ("mnemonic" in options) {
      if (!options.encryption && !utils_exports.isValidMnemonic(options.mnemonic)) {
        throw new Error("invalid mnemonic");
      }
      const mnemonic = await getDecryptor(options.encryption)(options.mnemonic);
      if (options.encryption && (mnemonic === "" || !utils_exports.isValidMnemonic(mnemonic))) {
        throw new Error("invalid password");
      }
      this.ethersWallet = Wallet.fromMnemonic(mnemonic);
      return this.ethersWallet.address;
    }
    throw new Error("invalid import strategy");
  }
  /**
   * initialize the wallet from saved data on storage
   * @param password - password used for encrypting the wallet
   */
  async load(options) {
    if (this.ethersWallet) {
      throw new Error("wallet is already initialized");
    }
    const walletData = await this.getSavedData(options.storage);
    if (!walletData) {
      throw new Error("No Saved wallet found in storage");
    }
    if (walletData.strategy !== options.strategy) {
      throw new Error(`Saved wallet data is not ${options.strategy}, it is ${walletData.strategy}`);
    }
    if (options.strategy === "encryptedJson") {
      return this.import({
        encryptedJson: walletData.data,
        password: options.password
      });
    }
    if (walletData.isEncrypted && !options.encryption) {
      throw new Error("Saved wallet data is encrypted, but no password is provided");
    }
    if (!walletData.isEncrypted && options.encryption) {
      throw new Error("Saved wallet data is not encrypted, but encryption config is provided");
    }
    if (options.strategy === "privateKey") {
      return this.import({
        privateKey: walletData.data,
        encryption: options.encryption
      });
    }
    if (options.strategy === "mnemonic") {
      return this.import({
        mnemonic: walletData.data,
        encryption: options.encryption
      });
    }
    throw new Error("invalid load strategy");
  }
  /**
   * Save the wallet data to storage
   */
  async save(options) {
    const wallet = this.ethersWallet;
    if (!wallet) {
      throw new Error("Wallet is not initialized");
    }
    if (options.strategy === "encryptedJson") {
      const encryptedData = await wallet.encrypt(options.password, {
        scrypt: {
          N: 1 << 32
        }
      });
      await _classPrivateMethodGet(this, _saveData, _saveData2).call(this, {
        address: wallet.address,
        data: encryptedData,
        strategy: "encryptedJson",
        isEncrypted: true
      }, options.storage);
    }
    if (options.strategy === "privateKey") {
      const privateKey = await getEncryptor(options.encryption)(wallet.privateKey);
      await _classPrivateMethodGet(this, _saveData, _saveData2).call(this, {
        address: wallet.address,
        data: privateKey,
        strategy: "privateKey",
        isEncrypted: !!options.encryption
      }, options.storage);
    }
    if (options.strategy === "mnemonic") {
      if (!wallet.mnemonic) {
        throw new Error("mnemonic can not be computed if wallet is created from a private key or generated using generate()");
      }
      const mnemonic = await getEncryptor(options.encryption)(wallet.mnemonic.phrase);
      await _classPrivateMethodGet(this, _saveData, _saveData2).call(this, {
        address: wallet.address,
        data: mnemonic,
        strategy: "mnemonic",
        isEncrypted: !!options.encryption
      }, options.storage);
    }
  }
  /**
   * @returns true if initialized wallet's data is saved in storage
   */
  async isSaved() {
    try {
      const data2 = await this.getSavedData();
      const address = await this.getAddress();
      if ((data2 == null ? void 0 : data2.address) === address) {
        return true;
      }
      return false;
    } catch (e) {
      return false;
    }
  }
  /**
   * deletes the saved wallet data from storage
   */
  async deleteSaved() {
    await _classPrivateFieldGet(this, _storage2).removeItem(STORAGE_KEY_WALLET_DATA);
  }
  /**
   * encrypts the wallet with given password and returns the encrypted wallet
   * @param password - password for encrypting the wallet data
   */
  async export(options) {
    const wallet = this.ethersWallet;
    if (!wallet) {
      throw new Error("Wallet is not initialized");
    }
    if (options.strategy === "encryptedJson") {
      return wallet.encrypt(options.password, {
        scrypt: {
          N: 1 << 32
        }
      });
    }
    if (options.strategy === "privateKey") {
      return getEncryptor(options.encryption)(wallet.privateKey);
    }
    if (options.strategy === "mnemonic") {
      if (!wallet.mnemonic) {
        throw new Error("mnemonic can not be computed if wallet is created from a private key or generated using generate()");
      }
      return getEncryptor(options.encryption)(wallet.mnemonic.phrase);
    }
    throw new Error("Invalid export strategy");
  }
  /**
   * Get the saved wallet data from storage
   */
  async getSavedData(storage) {
    const _storage3 = storage || _classPrivateFieldGet(this, _storage2);
    try {
      const savedDataStr = await _storage3.getItem(STORAGE_KEY_WALLET_DATA);
      if (!savedDataStr) {
        return null;
      }
      const savedData = JSON.parse(savedDataStr);
      if (!savedData) {
        return null;
      }
      return savedData;
    } catch (e) {
      return null;
    }
  }
  async disconnect() {
    await super.disconnect();
    this.ethersWallet = void 0;
  }
};
async function _saveData2(data2, storage) {
  const _storage3 = storage || _classPrivateFieldGet(this, _storage2);
  await _storage3.setItem(STORAGE_KEY_WALLET_DATA, JSON.stringify(data2));
}
_defineProperty(LocalWallet, "id", walletIds.localWallet);
_defineProperty(LocalWallet, "meta", {
  name: "Local Wallet",
  iconURL: "ipfs://QmbQzSNGvmNYZzem9jZRuYeLe9K2W4pqbdnVUp7Y6edQ8Y/local-wallet.svg"
});
async function defaultEncrypt(message, password) {
  const cryptoJS = (await import("./crypto-js-25VMCEAW.js")).default;
  return cryptoJS.AES.encrypt(message, password).toString();
}
async function defaultDecrypt(message, password) {
  const cryptoJS = (await import("./crypto-js-25VMCEAW.js")).default;
  return cryptoJS.AES.decrypt(message, password).toString(cryptoJS.enc.Utf8);
}
function getDecryptor(encryption) {
  const noop = async (msg) => msg;
  return encryption ? (msg) => (encryption.decrypt || defaultDecrypt)(msg, encryption.password) : noop;
}
function getEncryptor(encryption) {
  const noop = async (msg) => msg;
  return encryption ? (msg) => (encryption.encrypt || defaultEncrypt)(msg, encryption.password) : noop;
}
function isValidPrivateKey(value) {
  return !!value.match(/^(0x)?[0-9a-f]{64}$/i);
}

// node_modules/@thirdweb-dev/react/node_modules/@thirdweb-dev/wallets/evm/wallets/signer/dist/thirdweb-dev-wallets-evm-wallets-signer.browser.esm.js
init_shim();
init_lib3();
var _storage = /* @__PURE__ */ new WeakMap();
var SignerWallet = class extends AbstractClientWallet {
  constructor(options) {
    super("signerWallet", options);
    _classPrivateFieldInitSpec(this, _storage, {
      writable: true,
      value: void 0
    });
    this.options = options;
    this.signer = options.signer;
    _classPrivateFieldSet(this, _storage, (options == null ? void 0 : options.storage) || createAsyncLocalStorage(walletIds.localWallet));
  }
  async getConnector() {
    if (!this.connector) {
      const {
        SignerConnector
      } = await import("./thirdweb-dev-wallets-evm-connectors-signer.browser.esm-IAYUUZ4L.js");
      if (!this.signer) {
        this.signer = this.options.signer;
      }
      const defaults = this.options.chain ? [...defaultChains, this.options.chain] : defaultChains;
      this.connector = new SignerConnector({
        chain: this.options.chain || c1,
        signer: this.signer,
        chains: this.options.chains || defaults,
        clientId: this.options.clientId,
        secretKey: this.options.secretKey
      });
    }
    return this.connector;
  }
};

// node_modules/@thirdweb-dev/react/node_modules/@thirdweb-dev/wallets/evm/wallets/magic/dist/thirdweb-dev-wallets-evm-wallets-magic.browser.esm.js
init_shim();
init_lib3();
var MagicLink = class _MagicLink extends AbstractClientWallet {
  get walletName() {
    return "Magic Link";
  }
  constructor(options) {
    super(_MagicLink.id, options);
    this.options = options;
  }
  async initializeConnector() {
    const {
      MagicAuthConnector
    } = await import("./thirdweb-dev-wallets-evm-connectors-magic.browser.esm-BGPJSIT6.js");
    const magicConnector = new MagicAuthConnector({
      chains: this.chains,
      options: this.options
    });
    this.magicConnector = magicConnector;
    this.connector = new WagmiAdapter(magicConnector);
    return this.connector;
  }
  async getConnector() {
    if (!this.connector) {
      return await this.initializeConnector();
    }
    return this.connector;
  }
  getMagic() {
    if (!this.magicConnector) {
      throw new Error("Magic connector is not initialized");
    }
    return this.magicConnector.getMagicSDK();
  }
  async autoConnect(options) {
    var _a;
    await this.initializeConnector();
    await ((_a = this.magicConnector) == null ? void 0 : _a.initializeMagicSDK(options));
    const magic = this.getMagic();
    {
      const url = new URL(window.location.href);
      const isMagicRedirect = url.searchParams.get("magic_credential");
      if (isMagicRedirect) {
        try {
          this.oAuthRedirectResult = await magic.oauth.getRedirectResult();
        } catch {
        }
      }
    }
    const isLoggedIn = await magic.user.isLoggedIn();
    if (isLoggedIn) {
      return super.autoConnect(options);
    }
    throw new Error("Magic user is not logged in");
  }
  async disconnect() {
    this.oAuthRedirectResult = void 0;
    const magic = this.getMagic();
    await magic.user.logout();
    return super.disconnect();
  }
  async connect(options) {
    if ("email" in options && this.options.emailLogin === false) {
      throw new Error("Email login is disabled");
    }
    if ("phoneNumber" in options && this.options.smsLogin === false) {
      throw new Error("SMS login is disabled");
    }
    return super.connect(options);
  }
};
_defineProperty(MagicLink, "meta", {
  iconURL: "ipfs://QmUMBFZGXxBpgDmZzZAHhbcCL5nYvZnVaYLTajsNjLcxMU/1-Icon_Magic_Color.svg",
  name: "Magic Link"
});
_defineProperty(MagicLink, "id", walletIds.magicLink);

// node_modules/@thirdweb-dev/react/node_modules/@thirdweb-dev/wallets/evm/wallets/metamask/dist/thirdweb-dev-wallets-evm-wallets-metamask.browser.esm.js
init_shim();
init_lib3();
var MetaMaskWallet = class _MetaMaskWallet extends AbstractClientWallet {
  get walletName() {
    return "MetaMask";
  }
  constructor(options) {
    super(_MetaMaskWallet.id, options);
    this.isInjected = !!getInjectedMetamaskProvider();
  }
  async getConnector() {
    var _a, _b, _c;
    if (!this.connector) {
      if (this.isInjected) {
        const {
          MetaMaskConnector
        } = await import("./thirdweb-dev-wallets-evm-connectors-metamask.browser.esm-POS6R54Y.js");
        const metamaskConnector = new MetaMaskConnector({
          chains: this.chains,
          connectorStorage: this.walletStorage,
          options: {
            shimDisconnect: true
          }
        });
        this.metamaskConnector = metamaskConnector;
        this.connector = new WagmiAdapter(metamaskConnector);
      } else {
        const {
          WalletConnectConnector
        } = await import("./thirdweb-dev-wallets-evm-connectors-wallet-connect.browser.esm-ELOCCCCX.js");
        const walletConnectConnector = new WalletConnectConnector({
          chains: this.chains,
          options: {
            projectId: ((_a = this.options) == null ? void 0 : _a.projectId) || TW_WC_PROJECT_ID,
            // TODO,
            storage: this.walletStorage,
            qrcode: (_b = this.options) == null ? void 0 : _b.qrcode,
            dappMetadata: this.dappMetadata,
            qrModalOptions: (_c = this.options) == null ? void 0 : _c.qrModalOptions
          }
        });
        walletConnectConnector.getProvider().then((provider) => {
          provider.signer.client.on("session_request_sent", () => {
            this.emit("wc_session_request_sent");
          });
        });
        this.walletConnectConnector = walletConnectConnector;
        this.connector = new WagmiAdapter(walletConnectConnector);
      }
    }
    return this.connector;
  }
  /**
   * connect to wallet with QR code
   *
   * @example
   * ```typescript
   * metamask.connectWithQrCode({
   *  chainId: 1,
   *  onQrCodeUri(qrCodeUri) {
   *    // render the QR code with `qrCodeUri`
   *  },
   *  onConnected(accountAddress)  {
   *    // update UI to show connected state
   *  },
   * })
   * ```
   */
  async connectWithQrCode(options) {
    await this.getConnector();
    const wcConnector = this.walletConnectConnector;
    if (!wcConnector) {
      throw new Error("WalletConnect connector not found");
    }
    const wcProvider = await wcConnector.getProvider();
    wcProvider.on("display_uri", (uri) => {
      options.onQrCodeUri(uri);
    });
    this.connect({
      chainId: options.chainId
    }).then(options.onConnected);
  }
  async switchAccount() {
    if (!this.metamaskConnector) {
      throw new Error("Can not switch Account");
    }
    await this.metamaskConnector.switchAccount();
  }
};
_defineProperty(MetaMaskWallet, "meta", {
  name: "MetaMask",
  iconURL: "ipfs://QmZZHcw7zcXursywnLDAyY6Hfxzqop5GKgwoq8NB9jjrkN/metamask.svg",
  urls: {
    chrome: "https://chrome.google.com/webstore/detail/metamask/nkbihfbeogaeaoehlefnkodbefgpgknn",
    android: "https://play.google.com/store/apps/details?id=io.metamask",
    ios: "https://apps.apple.com/us/app/metamask-blockchain-wallet/id1438144202"
  }
});
_defineProperty(MetaMaskWallet, "id", walletIds.metamask);

// node_modules/@thirdweb-dev/react/node_modules/@thirdweb-dev/wallets/evm/wallets/phantom/dist/thirdweb-dev-wallets-evm-wallets-phantom.browser.esm.js
init_shim();
init_lib3();
var PhantomWallet = class _PhantomWallet extends AbstractClientWallet {
  get walletName() {
    return "Phantom";
  }
  constructor(options) {
    super(_PhantomWallet.id, options);
    this.isInjected = !!getInjectedPhantomProvider();
  }
  async getConnector() {
    if (!this.connector) {
      const {
        PhantomConnector
      } = await import("./thirdweb-dev-wallets-evm-connectors-phantom.browser.esm-6YERZUWA.js");
      const phantomConnector = new PhantomConnector({
        chains: this.chains,
        connectorStorage: this.walletStorage,
        options: {
          shimDisconnect: true
        }
      });
      this.phantomConnector = phantomConnector;
      this.connector = new WagmiAdapter(phantomConnector);
    }
    return this.connector;
  }
};
_defineProperty(PhantomWallet, "meta", {
  name: "Phantom",
  iconURL: "ipfs://bafybeibkpca5nwxpsjrtuxmz2ckb5lyc2sl2abg5f7dnvxku637vvffjti",
  urls: {
    chrome: "https://chrome.google.com/webstore/detail/phantom/bfnaelmomeimhlpmgjnjophhpkkoljpa"
    // not specifiying theme because they can't be used to connect
    // android: "https://play.google.com/store/apps/details?id=app.phantom",
    // ios: "https://apps.apple.com/us/app/phantom-crypto-wallet/id1598432977",
  }
});
_defineProperty(PhantomWallet, "id", walletIds.phantom);

// node_modules/@thirdweb-dev/react/node_modules/@thirdweb-dev/wallets/evm/wallets/rainbow-wallet/dist/thirdweb-dev-wallets-evm-wallets-rainbow-wallet.browser.esm.js
init_shim();
init_lib3();
var RainbowWallet = class _RainbowWallet extends AbstractClientWallet {
  get walletName() {
    return "Rainbow Wallet";
  }
  constructor(options) {
    super(_RainbowWallet.id, options);
    this.isInjected = !!getInjectedRainbowProvider();
  }
  async getConnector() {
    var _a, _b, _c;
    if (!this.connector) {
      if (this.isInjected) {
        const {
          RainbowConnector
        } = await import("./thirdweb-dev-wallets-evm-connectors-rainbow.browser.esm-U7VOA3LI.js");
        const rainbowConnector = new RainbowConnector({
          chains: this.chains,
          connectorStorage: this.walletStorage,
          options: {
            shimDisconnect: true
          }
        });
        this.rainbowConnector = rainbowConnector;
        this.connector = new WagmiAdapter(rainbowConnector);
      } else {
        const {
          WalletConnectConnector
        } = await import("./thirdweb-dev-wallets-evm-connectors-wallet-connect.browser.esm-ELOCCCCX.js");
        const walletConnectConnector = new WalletConnectConnector({
          chains: this.chains,
          options: {
            projectId: ((_a = this.options) == null ? void 0 : _a.projectId) || TW_WC_PROJECT_ID,
            // TODO,
            storage: this.walletStorage,
            qrcode: (_b = this.options) == null ? void 0 : _b.qrcode,
            dappMetadata: this.dappMetadata,
            qrModalOptions: (_c = this.options) == null ? void 0 : _c.qrModalOptions
          }
        });
        walletConnectConnector.getProvider().then((provider) => {
          provider.signer.client.on("session_request_sent", () => {
            this.emit("wc_session_request_sent");
          });
        });
        this.walletConnectConnector = walletConnectConnector;
        this.connector = new WagmiAdapter(walletConnectConnector);
      }
    }
    return this.connector;
  }
  /**
   * connect to wallet with QR code
   *
   * @example
   * ```typescript
   * rainbow.connectWithQrCode({
   *  chainId: 1,
   *  onQrCodeUri(qrCodeUri) {
   *    // render the QR code with `qrCodeUri`
   *  },
   *  onConnected(accountAddress)  {
   *    // update UI to show connected state
   *  },
   * })
   * ```
   */
  async connectWithQrCode(options) {
    await this.getConnector();
    const wcConnector = this.walletConnectConnector;
    if (!wcConnector) {
      throw new Error("WalletConnect connector not found");
    }
    const wcProvider = await wcConnector.getProvider();
    wcProvider.on("display_uri", (uri) => {
      options.onQrCodeUri(uri);
    });
    this.connect({
      chainId: options.chainId
    }).then(options.onConnected);
  }
};
_defineProperty(RainbowWallet, "meta", {
  name: "Rainbow Wallet",
  iconURL: "ipfs://QmSZn47p4DVVBfzvg9BAX2EqwnPxkT1YAE7rUnrtd9CybQ/rainbow-logo.png",
  urls: {
    chrome: "https://chrome.google.com/webstore/detail/rainbow/opfgelmcmbiajamepnmloijbpoleiama",
    android: "https://rnbwapp.com/e/Va41HWS6Oxb",
    ios: "https://rnbwapp.com/e/OeMdmkJ6Oxb"
  }
});
_defineProperty(RainbowWallet, "id", walletIds.rainbow);

// node_modules/@thirdweb-dev/react/node_modules/@thirdweb-dev/wallets/evm/wallets/safe/dist/thirdweb-dev-wallets-evm-wallets-safe.browser.esm.js
init_shim();
init_lib3();
var SafeWallet = class _SafeWallet extends AbstractClientWallet {
  get walletName() {
    return "Safe Wallet";
  }
  constructor(options) {
    super(_SafeWallet.id, {
      ...options
    });
  }
  async getConnector() {
    if (!this.connector) {
      const {
        SafeConnector
      } = await import("./thirdweb-dev-wallets-evm-connectors-safe.browser.esm-NSWPICCB.js");
      this.connector = new SafeConnector();
    }
    return this.connector;
  }
  // eslint-disable-next-line @typescript-eslint/no-unused-vars
  async updateChains(chains) {
  }
  getPersonalWallet() {
    var _a;
    return (_a = this.connector) == null ? void 0 : _a.personalWallet;
  }
  autoConnect(params) {
    return this.connect(params);
  }
};
_defineProperty(SafeWallet, "meta", {
  name: "Safe",
  iconURL: "ipfs://QmbbyxDDmmLQh8DzzeUR6X6B75bESsNUFmbdvS3ZsQ2pN1/SafeToken.svg"
});
_defineProperty(SafeWallet, "id", walletIds.safe);

// node_modules/@thirdweb-dev/react/node_modules/@thirdweb-dev/wallets/evm/wallets/trust/dist/thirdweb-dev-wallets-evm-wallets-trust.browser.esm.js
init_shim();
init_lib3();
var TrustWallet = class _TrustWallet extends AbstractClientWallet {
  get walletName() {
    return "Trust Wallet";
  }
  constructor(options) {
    var _a;
    super(_TrustWallet.id, options);
    if (assertWindowEthereum(globalThis.window)) {
      this.isInjected = !!((_a = globalThis.window.ethereum) == null ? void 0 : _a.isTrust);
    } else {
      this.isInjected = false;
    }
  }
  async getConnector() {
    var _a, _b, _c;
    if (!this.connector) {
      if (this.isInjected) {
        const {
          TrustConnector
        } = await import("./thirdweb-dev-wallets-evm-connectors-trust.browser.esm-FO6LRWGJ.js");
        const trustConnector = new TrustConnector({
          chains: this.chains,
          connectorStorage: this.walletStorage,
          options: {
            shimDisconnect: true
          }
        });
        this.trustConnector = trustConnector;
        this.connector = new WagmiAdapter(trustConnector);
      } else {
        const {
          WalletConnectConnector
        } = await import("./thirdweb-dev-wallets-evm-connectors-wallet-connect.browser.esm-ELOCCCCX.js");
        const walletConnectConnector = new WalletConnectConnector({
          chains: this.chains,
          options: {
            projectId: ((_a = this.options) == null ? void 0 : _a.projectId) || TW_WC_PROJECT_ID,
            // TODO,
            storage: this.walletStorage,
            qrcode: (_b = this.options) == null ? void 0 : _b.qrcode,
            dappMetadata: this.dappMetadata,
            qrModalOptions: (_c = this.options) == null ? void 0 : _c.qrModalOptions
          }
        });
        walletConnectConnector.getProvider().then((provider) => {
          provider.signer.client.on("session_request_sent", () => {
            this.emit("wc_session_request_sent");
          });
        });
        this.walletConnectConnector = walletConnectConnector;
        this.connector = new WagmiAdapter(walletConnectConnector);
      }
    }
    return this.connector;
  }
  /**
   * connect to wallet with QR code
   *
   * @example
   * ```typescript
   * trust.connectWithQrCode({
   *  chainId: 1,
   *  onQrCodeUri(qrCodeUri) {
   *    // render the QR code with `qrCodeUri`
   *  },
   *  onConnected(accountAddress)  {
   *    // update UI to show connected state
   *  },
   * })
   * ```
   */
  async connectWithQrCode(options) {
    await this.getConnector();
    const wcConnector = this.walletConnectConnector;
    if (!wcConnector) {
      throw new Error("WalletConnect connector not found");
    }
    const wcProvider = await wcConnector.getProvider();
    wcProvider.on("display_uri", (uri) => {
      options.onQrCodeUri(uri);
    });
    this.connect({
      chainId: options.chainId
    }).then(options.onConnected);
  }
};
_defineProperty(TrustWallet, "meta", {
  name: "Trust Wallet",
  iconURL: "ipfs://QmNigQbXk7wKZwDcgN38Znj1ZZQ3JEG3DD6fUKLBU8SUTP/trust%20wallet.svg",
  urls: {
    chrome: "https://chrome.google.com/webstore/detail/trust-wallet/egjidjbpglichdcondbcbdnbeeppgdph",
    android: "https://play.google.com/store/apps/details?id=com.wallet.crypto.trustapp",
    ios: "https://apps.apple.com/us/app/trust-crypto-bitcoin-wallet/id1288339409"
  }
});
_defineProperty(TrustWallet, "id", walletIds.trust);

// node_modules/@thirdweb-dev/react/node_modules/@thirdweb-dev/wallets/evm/wallets/wallet-connect/dist/thirdweb-dev-wallets-evm-wallets-wallet-connect.browser.esm.js
init_shim();
init_lib3();
var _walletConnectConnector = /* @__PURE__ */ new WeakMap();
var _provider = /* @__PURE__ */ new WeakMap();
var _maybeThrowError = /* @__PURE__ */ new WeakMap();
var _onConnect = /* @__PURE__ */ new WeakMap();
var _onDisconnect = /* @__PURE__ */ new WeakMap();
var _onChange = /* @__PURE__ */ new WeakMap();
var _onMessage = /* @__PURE__ */ new WeakMap();
var _onSessionRequestSent = /* @__PURE__ */ new WeakMap();
var _setupListeners = /* @__PURE__ */ new WeakSet();
var _removeListeners = /* @__PURE__ */ new WeakSet();
var WalletConnect = class _WalletConnect extends AbstractClientWallet {
  get walletName() {
    return "WalletConnect";
  }
  constructor(options) {
    super((options == null ? void 0 : options.walletId) || _WalletConnect.id, options);
    _classPrivateMethodInitSpec(this, _removeListeners);
    _classPrivateMethodInitSpec(this, _setupListeners);
    _classPrivateFieldInitSpec(this, _walletConnectConnector, {
      writable: true,
      value: void 0
    });
    _classPrivateFieldInitSpec(this, _provider, {
      writable: true,
      value: void 0
    });
    _classPrivateFieldInitSpec(this, _maybeThrowError, {
      writable: true,
      value: (error) => {
        if (error) {
          throw error;
        }
      }
    });
    _classPrivateFieldInitSpec(this, _onConnect, {
      writable: true,
      value: (data2) => {
        _classPrivateFieldSet(this, _provider, data2.provider);
        if (!_classPrivateFieldGet(this, _provider)) {
          throw new Error("WalletConnect provider not found after connecting.");
        }
      }
    });
    _classPrivateFieldInitSpec(this, _onDisconnect, {
      writable: true,
      value: () => {
        _classPrivateMethodGet(this, _removeListeners, _removeListeners2).call(this);
      }
    });
    _classPrivateFieldInitSpec(this, _onChange, {
      writable: true,
      value: async (payload) => {
        if (payload.chain)
          ;
        else if (payload.account)
          ;
      }
    });
    _classPrivateFieldInitSpec(this, _onMessage, {
      writable: true,
      value: (payload) => {
        switch (payload.type) {
          case "display_uri":
            this.emit("display_uri", payload.data);
            break;
        }
      }
    });
    _classPrivateFieldInitSpec(this, _onSessionRequestSent, {
      writable: true,
      value: () => {
        this.emit("wc_session_request_sent");
      }
    });
    this.projectId = (options == null ? void 0 : options.projectId) || TW_WC_PROJECT_ID;
    this.qrcode = (options == null ? void 0 : options.qrcode) === false ? false : true;
  }
  async getConnector() {
    var _a;
    if (!this.connector) {
      const {
        WalletConnectConnector
      } = await import("./thirdweb-dev-wallets-evm-connectors-wallet-connect.browser.esm-ELOCCCCX.js");
      _classPrivateFieldSet(this, _walletConnectConnector, new WalletConnectConnector({
        chains: this.chains,
        options: {
          qrcode: this.qrcode,
          projectId: this.projectId,
          dappMetadata: this.dappMetadata,
          storage: this.walletStorage,
          qrModalOptions: (_a = this.options) == null ? void 0 : _a.qrModalOptions
        }
      }));
      this.connector = new WagmiAdapter(_classPrivateFieldGet(this, _walletConnectConnector));
      _classPrivateFieldSet(this, _provider, await _classPrivateFieldGet(this, _walletConnectConnector).getProvider());
      _classPrivateMethodGet(this, _setupListeners, _setupListeners2).call(this);
    }
    return this.connector;
  }
  async connectWithQrCode(options) {
    await this.getConnector();
    const wcConnector = _classPrivateFieldGet(this, _walletConnectConnector);
    if (!wcConnector) {
      throw new Error("WalletConnect connector not found");
    }
    const wcProvider = await wcConnector.getProvider();
    wcProvider.on("display_uri", (uri) => {
      options.onQrCodeUri(uri);
    });
    this.connect({
      chainId: options.chainId
    }).then(options.onConnected);
  }
};
function _setupListeners2() {
  var _a;
  if (!_classPrivateFieldGet(this, _walletConnectConnector)) {
    return;
  }
  _classPrivateMethodGet(this, _removeListeners, _removeListeners2).call(this);
  _classPrivateFieldGet(this, _walletConnectConnector).on("connect", _classPrivateFieldGet(this, _onConnect));
  _classPrivateFieldGet(this, _walletConnectConnector).on("disconnect", _classPrivateFieldGet(this, _onDisconnect));
  _classPrivateFieldGet(this, _walletConnectConnector).on("change", _classPrivateFieldGet(this, _onChange));
  _classPrivateFieldGet(this, _walletConnectConnector).on("message", _classPrivateFieldGet(this, _onMessage));
  (_a = _classPrivateFieldGet(this, _provider)) == null ? void 0 : _a.signer.client.on("session_request_sent", _classPrivateFieldGet(this, _onSessionRequestSent));
}
function _removeListeners2() {
  var _a;
  if (!_classPrivateFieldGet(this, _walletConnectConnector)) {
    return;
  }
  _classPrivateFieldGet(this, _walletConnectConnector).removeListener("connect", _classPrivateFieldGet(this, _onConnect));
  _classPrivateFieldGet(this, _walletConnectConnector).removeListener("disconnect", _classPrivateFieldGet(this, _onDisconnect));
  _classPrivateFieldGet(this, _walletConnectConnector).removeListener("change", _classPrivateFieldGet(this, _onChange));
  _classPrivateFieldGet(this, _walletConnectConnector).removeListener("message", _classPrivateFieldGet(this, _onMessage));
  (_a = _classPrivateFieldGet(this, _provider)) == null ? void 0 : _a.signer.client.removeListener("session_request_sent", _classPrivateFieldGet(this, _onSessionRequestSent));
}
_defineProperty(WalletConnect, "id", walletIds.walletConnect);
_defineProperty(WalletConnect, "meta", {
  name: "WalletConnect",
  iconURL: "ipfs://QmX58KPRaTC9JYZ7KriuBzeoEaV2P9eZcA3qbFnTHZazKw/wallet-connect.svg"
});

// node_modules/@thirdweb-dev/react/node_modules/@thirdweb-dev/wallets/evm/wallets/zerion/dist/thirdweb-dev-wallets-evm-wallets-zerion.browser.esm.js
init_shim();
init_lib3();
var ZerionWallet = class _ZerionWallet extends AbstractClientWallet {
  get walletName() {
    return "Zerion Wallet";
  }
  constructor(options) {
    var _a;
    super(_ZerionWallet.id, options);
    if (assertWindowEthereum(globalThis.window)) {
      this.isInjected = !!((_a = globalThis.window.ethereum) == null ? void 0 : _a.isZerion);
    } else {
      this.isInjected = false;
    }
  }
  async getConnector() {
    var _a, _b, _c;
    if (!this.connector) {
      if (this.isInjected) {
        const {
          ZerionConnector
        } = await import("./thirdweb-dev-wallets-evm-connectors-zerion.browser.esm-ECMKFTQZ.js");
        const zerionConnector = new ZerionConnector({
          chains: this.chains,
          connectorStorage: this.walletStorage,
          options: {
            shimDisconnect: true
          }
        });
        this.zerionConnector = zerionConnector;
        this.connector = new WagmiAdapter(zerionConnector);
      } else {
        const {
          WalletConnectConnector
        } = await import("./thirdweb-dev-wallets-evm-connectors-wallet-connect.browser.esm-ELOCCCCX.js");
        const walletConnectConnector = new WalletConnectConnector({
          chains: this.chains,
          options: {
            projectId: ((_a = this.options) == null ? void 0 : _a.projectId) || TW_WC_PROJECT_ID,
            // TODO,
            storage: this.walletStorage,
            qrcode: (_b = this.options) == null ? void 0 : _b.qrcode,
            dappMetadata: this.dappMetadata,
            qrModalOptions: (_c = this.options) == null ? void 0 : _c.qrModalOptions
          }
        });
        walletConnectConnector.getProvider().then((provider) => {
          provider.signer.client.on("session_request_sent", () => {
            this.emit("wc_session_request_sent");
          });
        });
        this.walletConnectConnector = walletConnectConnector;
        this.connector = new WagmiAdapter(walletConnectConnector);
      }
    }
    return this.connector;
  }
  async connectWithQrCode(options) {
    await this.getConnector();
    const wcConnector = this.walletConnectConnector;
    if (!wcConnector) {
      throw new Error("WalletConnect connector not found");
    }
    const wcProvider = await wcConnector.getProvider();
    wcProvider.on("display_uri", (uri) => {
      options.onQrCodeUri(uri);
    });
    this.connect({
      chainId: options.chainId
    }).then(options.onConnected);
  }
};
_defineProperty(ZerionWallet, "id", "zerion");
_defineProperty(ZerionWallet, "meta", {
  name: "Zerion Wallet",
  iconURL: "ipfs://Qmb1LhNtMUkzbgk1V8ZiUSRXjMJGRkS5HH3R71KyRgjdBG/zerion.png",
  urls: {
    chrome: "https://zerion.io/extension",
    android: "https://link.zerion.io/901o6IN0jqb",
    ios: "https://link.zerion.io/a11o6IN0jqb"
  }
});

// node_modules/@thirdweb-dev/react/node_modules/@thirdweb-dev/wallets/dist/thirdweb-dev-wallets.browser.esm.js
init_shim();

// node_modules/@thirdweb-dev/react/node_modules/@thirdweb-dev/wallets/evm/wallets/ethers/dist/thirdweb-dev-wallets-evm-wallets-ethers.browser.esm.js
init_shim();
init_lib3();

// node_modules/@thirdweb-dev/react/node_modules/@thirdweb-dev/wallets/evm/wallets/private-key/dist/thirdweb-dev-wallets-evm-wallets-private-key.browser.esm.js
init_shim();
init_lib3();

// node_modules/@thirdweb-dev/react/node_modules/@thirdweb-dev/wallets/evm/wallets/wallet-connect-v1/dist/thirdweb-dev-wallets-evm-wallets-wallet-connect-v1.browser.esm.js
init_shim();
init_lib3();

// node_modules/@thirdweb-dev/react/node_modules/@thirdweb-dev/wallets/dist/auth-e91a1229.browser.esm.js
init_shim();
var RecoveryShareManagement = function(RecoveryShareManagement2) {
  RecoveryShareManagement2["USER_MANAGED"] = "USER_MANAGED";
  RecoveryShareManagement2["AWS_MANAGED"] = "AWS_MANAGED";
  return RecoveryShareManagement2;
}({});
var AuthProvider = function(AuthProvider2) {
  AuthProvider2["COGNITO"] = "Cognito";
  return AuthProvider2;
}({});

// node_modules/@thirdweb-dev/react/node_modules/@thirdweb-dev/wallets/dist/thirdweb-dev-wallets.browser.esm.js
init_lib3();
var import_buffer2 = __toESM(require_buffer());
var import_utils8 = __toESM(require_utils());

export {
  V5 as V,
  SmartWallet,
  getInjectedCoinbaseProvider,
  PaperWallet,
  BloctoWallet,
  CoinbaseWallet,
  EmbeddedWallet2 as EmbeddedWallet,
  FrameWallet,
  InjectedWallet,
  LocalWallet,
  SignerWallet,
  MagicLink,
  MetaMaskWallet,
  PhantomWallet,
  RainbowWallet,
  SafeWallet,
  TrustWallet,
  WalletConnect,
  ZerionWallet
};
//# sourceMappingURL=chunk-QRSXBYV7.js.map
