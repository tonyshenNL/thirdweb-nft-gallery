import {
  getValidPublicRPCUrl
} from "./chunk-34RJ67NV.js";
import {
  BloctoSDK
} from "./chunk-QR54PQLD.js";
import {
  _classPrivateMethodGet,
  _classPrivateMethodInitSpec
} from "./chunk-DVVEOT7N.js";
import {
  walletIds
} from "./chunk-3FKSJEH3.js";
import {
  ConnectorNotFoundError,
  SwitchChainError,
  UserRejectedRequestError
} from "./chunk-522SDZSD.js";
import {
  WagmiConnector
} from "./chunk-5MPA7Y63.js";
import {
  normalizeChainId
} from "./chunk-M374DORU.js";
import {
  _classPrivateFieldGet,
  _classPrivateFieldInitSpec,
  _classPrivateFieldSet
} from "./chunk-7YNDDNAN.js";
import {
  _defineProperty
} from "./chunk-M52NFQDC.js";
import "./chunk-VP554X2I.js";
import "./chunk-F44DUYBV.js";
import "./chunk-LMS4WD7T.js";
import {
  init_lib7 as init_lib,
  utils_exports
} from "./chunk-FSHZLPV2.js";
import {
  lib_exports19 as lib_exports
} from "./chunk-LXGF3WSV.js";
import "./chunk-HBS2L7KZ.js";
import "./chunk-JCGZRZHH.js";
import {
  init_shim
} from "./chunk-DLIX7YGU.js";
import "./chunk-EUIKE2YQ.js";

// node_modules/@thirdweb-dev/react/node_modules/@thirdweb-dev/wallets/evm/connectors/blocto/dist/thirdweb-dev-wallets-evm-connectors-blocto.browser.esm.js
init_shim();
init_lib();
var _provider = /* @__PURE__ */ new WeakMap();
var _onAccountsChangedBind = /* @__PURE__ */ new WeakMap();
var _onChainChangedBind = /* @__PURE__ */ new WeakMap();
var _onDisconnectBind = /* @__PURE__ */ new WeakMap();
var _isUserRejectedRequestError = /* @__PURE__ */ new WeakSet();
var _handleConnectReset = /* @__PURE__ */ new WeakSet();
var BloctoConnector = class extends WagmiConnector {
  constructor(_ref) {
    let {
      chains,
      options = {}
    } = _ref;
    super({
      chains,
      options
    });
    _classPrivateMethodInitSpec(this, _handleConnectReset);
    _classPrivateMethodInitSpec(this, _isUserRejectedRequestError);
    _defineProperty(this, "id", walletIds.blocto);
    _defineProperty(this, "name", "Blocto");
    _defineProperty(this, "ready", true);
    _classPrivateFieldInitSpec(this, _provider, {
      writable: true,
      value: void 0
    });
    _classPrivateFieldInitSpec(this, _onAccountsChangedBind, {
      writable: true,
      value: void 0
    });
    _classPrivateFieldInitSpec(this, _onChainChangedBind, {
      writable: true,
      value: void 0
    });
    _classPrivateFieldInitSpec(this, _onDisconnectBind, {
      writable: true,
      value: void 0
    });
    _classPrivateFieldSet(this, _onAccountsChangedBind, this.onAccountsChanged.bind(this));
    _classPrivateFieldSet(this, _onChainChangedBind, this.onChainChanged.bind(this));
    _classPrivateFieldSet(this, _onDisconnectBind, this.onDisconnect.bind(this));
  }
  async connect(config) {
    try {
      const provider = await this.getProvider(config);
      this.setupListeners();
      this.emit("message", {
        type: "connecting"
      });
      const accounts = await provider.request({
        method: "eth_requestAccounts"
      });
      const account = utils_exports.getAddress(accounts[0]);
      const id = await this.getChainId();
      const unsupported = this.isChainUnsupported(id);
      return {
        account,
        chain: {
          id,
          unsupported
        },
        provider
      };
    } catch (error) {
      _classPrivateMethodGet(this, _handleConnectReset, _handleConnectReset2).call(this);
      if (_classPrivateMethodGet(this, _isUserRejectedRequestError, _isUserRejectedRequestError2).call(this, error)) {
        throw new UserRejectedRequestError(error);
      }
      throw error;
    }
  }
  async disconnect() {
    const provider = await this.getProvider();
    await provider.request({
      method: "wallet_disconnect"
    });
    this.removeListeners();
    _classPrivateMethodGet(this, _handleConnectReset, _handleConnectReset2).call(this);
  }
  async getAccount() {
    const provider = await this.getProvider();
    const accounts = await provider.request({
      method: "eth_accounts"
    });
    const [address] = accounts || [];
    if (!address) {
      throw new Error("No accounts found");
    }
    return address;
  }
  async getChainId() {
    const provider = await this.getProvider();
    const chainId = await provider.request({
      method: "eth_chainId"
    });
    return normalizeChainId(chainId);
  }
  getProvider() {
    var _a, _b, _c;
    let {
      chainId
    } = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
    if (!_classPrivateFieldGet(this, _provider)) {
      const _chainId = chainId ?? this.options.chainId ?? ((_a = this.chains[0]) == null ? void 0 : _a.chainId) ?? 1;
      const _rpc = (_b = this.chains.find((x) => x.chainId === _chainId)) == null ? void 0 : _b.rpc[0];
      _classPrivateFieldSet(this, _provider, (_c = new BloctoSDK({
        ethereum: {
          chainId: _chainId,
          rpc: _rpc
        },
        appId: this.options.appId
      })) == null ? void 0 : _c.ethereum);
    }
    if (!_classPrivateFieldGet(this, _provider)) {
      throw new ConnectorNotFoundError();
    }
    return Promise.resolve(_classPrivateFieldGet(this, _provider));
  }
  async getSigner() {
    let {
      chainId
    } = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
    const [provider, account] = await Promise.all([this.getProvider(), this.getAccount()]);
    return new lib_exports.Web3Provider(provider, chainId).getSigner(account);
  }
  async isAuthorized() {
    var _a, _b;
    return !!((_b = (_a = _classPrivateFieldGet(this, _provider)) == null ? void 0 : _a._blocto) == null ? void 0 : _b.sessionKey);
  }
  async switchChain(chainId) {
    const provider = await this.getProvider();
    const id = utils_exports.hexValue(chainId);
    const chain = this.chains.find((x) => x.chainId === chainId);
    if (!chain) {
      throw new SwitchChainError(new Error("chain not found on connector."));
    }
    const isBloctoSupportChain = provider._blocto.supportNetworkList[`${chainId}`];
    if (!isBloctoSupportChain) {
      throw new SwitchChainError(new Error(`Blocto unsupported chain: ${id}`));
    }
    try {
      await provider.request({
        method: "wallet_addEthereumChain",
        params: [{
          chainId: id,
          rpcUrls: getValidPublicRPCUrl(chain)
          // no client id on purpose here
        }]
      });
      await provider.request({
        method: "wallet_switchEthereumChain",
        params: [{
          chainId: id
        }]
      });
      return chain;
    } catch (error) {
      if (_classPrivateMethodGet(this, _isUserRejectedRequestError, _isUserRejectedRequestError2).call(this, error)) {
        throw new UserRejectedRequestError(error);
      }
      throw new SwitchChainError(error);
    }
  }
  onAccountsChanged() {
  }
  async onChainChanged(chain) {
    const id = normalizeChainId(chain);
    const unsupported = this.isChainUnsupported(id);
    const account = await this.getAccount();
    this.emit("change", {
      chain: {
        id,
        unsupported
      },
      account
    });
  }
  onDisconnect() {
    this.emit("disconnect");
  }
  async setupListeners() {
    const provider = await this.getProvider();
    provider.on("accountsChanged", _classPrivateFieldGet(this, _onAccountsChangedBind));
    provider.on("chainChanged", _classPrivateFieldGet(this, _onChainChangedBind));
    provider.on("disconnect", _classPrivateFieldGet(this, _onDisconnectBind));
  }
  async removeListeners() {
    const provider = await this.getProvider();
    provider.off("accountsChanged", _classPrivateFieldGet(this, _onAccountsChangedBind));
    provider.off("chainChanged", _classPrivateFieldGet(this, _onChainChangedBind));
    provider.off("disconnect", _classPrivateFieldGet(this, _onDisconnectBind));
  }
};
function _isUserRejectedRequestError2(error) {
  return /(user rejected)/i.test(error.message);
}
function _handleConnectReset2() {
  _classPrivateFieldSet(this, _provider, void 0);
}
export {
  BloctoConnector
};
//# sourceMappingURL=thirdweb-dev-wallets-evm-connectors-blocto.browser.esm-AU3XWRHD.js.map
