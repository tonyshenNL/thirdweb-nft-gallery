import {
  Y,
  bt
} from "./chunk-TMYSOPUX.js";
import {
  WagmiConnector
} from "./chunk-5MPA7Y63.js";
import {
  normalizeChainId
} from "./chunk-M374DORU.js";
import {
  _classPrivateFieldGet,
  _classPrivateFieldInitSpec,
  _classPrivateFieldSet
} from "./chunk-7YNDDNAN.js";
import {
  _defineProperty
} from "./chunk-M52NFQDC.js";
import "./chunk-F44DUYBV.js";
import "./chunk-LMS4WD7T.js";
import {
  ethers_exports,
  init_lib7 as init_lib,
  utils_exports
} from "./chunk-FSHZLPV2.js";
import "./chunk-LXGF3WSV.js";
import "./chunk-HBS2L7KZ.js";
import "./chunk-JCGZRZHH.js";
import {
  init_shim
} from "./chunk-DLIX7YGU.js";
import "./chunk-EUIKE2YQ.js";

// node_modules/@thirdweb-dev/react/node_modules/@thirdweb-dev/wallets/evm/connectors/magic/dist/thirdweb-dev-wallets-evm-connectors-magic.browser.esm.js
init_shim();
init_lib();
var IS_SERVER = false;
var MagicBaseConnector = class extends WagmiConnector {
  constructor(config) {
    super(config);
    _defineProperty(this, "id", "magic-link");
    _defineProperty(this, "name", "Magic Link");
    _defineProperty(this, "ready", !IS_SERVER);
    this.magicOptions = config.options;
  }
  async getAccount() {
    const provider = new ethers_exports.providers.Web3Provider(await this.getProvider());
    const signer = provider.getSigner();
    const account = await signer.getAddress();
    if (account.startsWith("0x")) {
      return account;
    }
    return `0x${account}`;
  }
  async getProvider() {
    if (this.provider) {
      return this.provider;
    }
    const magic = this.getMagicSDK();
    this.provider = magic.rpcProvider;
    return this.provider;
  }
  async getSigner() {
    const provider = new ethers_exports.providers.Web3Provider(await this.getProvider());
    const signer = await provider.getSigner();
    return signer;
  }
  async isAuthorized() {
    const magic = this.getMagicSDK();
    try {
      return await magic.user.isLoggedIn();
    } catch (e) {
      return false;
    }
  }
  onAccountsChanged(accounts) {
    if (accounts.length === 0) {
      this.emit("disconnect");
    } else {
      if (accounts[0]) {
        this.emit("change", {
          account: utils_exports.getAddress(accounts[0])
        });
      }
    }
  }
  onChainChanged(chainId) {
    const id = normalizeChainId(chainId);
    const unsupported = this.isChainUnsupported(id);
    this.emit("change", {
      chain: {
        id,
        unsupported
      }
    });
  }
  onDisconnect() {
    this.emit("disconnect");
  }
  async disconnect() {
    const magic = this.getMagicSDK();
    await magic.user.logout();
  }
};
var _connectedChainId = /* @__PURE__ */ new WeakMap();
var _type = /* @__PURE__ */ new WeakMap();
var MagicAuthConnector = class extends MagicBaseConnector {
  constructor(config) {
    var _a, _b;
    super(config);
    _classPrivateFieldInitSpec(this, _connectedChainId, {
      writable: true,
      value: void 0
    });
    _classPrivateFieldInitSpec(this, _type, {
      writable: true,
      value: void 0
    });
    this.magicSdkConfiguration = config.options.magicSdkConfiguration;
    _classPrivateFieldSet(this, _type, config.options.type);
    this.oauthProviders = ((_a = config.options.oauthOptions) == null ? void 0 : _a.providers) || [];
    this.oauthRedirectURI = (_b = config.options.oauthOptions) == null ? void 0 : _b.redirectURI;
  }
  async connect(options) {
    if (!this.magicOptions.apiKey) {
      throw new Error("Magic API Key is not provided.");
    }
    try {
      if (options.chainId) {
        this.initializeMagicSDK({
          chainId: options.chainId
        });
      }
      const provider = await this.getProvider();
      this.setupListeners();
      this.emit("message", {
        type: "connecting"
      });
      const isAuthenticated = await this.isAuthorized();
      let chainId;
      try {
        chainId = await this.getChainId();
      } catch (e) {
        chainId = 0;
      }
      _classPrivateFieldSet(this, _connectedChainId, chainId);
      if (isAuthenticated) {
        return {
          provider,
          chain: {
            id: chainId,
            unsupported: false
          },
          account: await this.getAccount()
        };
      }
      const magic = this.getMagicSDK();
      if (_classPrivateFieldGet(this, _type) === "connect") {
        if ("email" in options || "phoneNumber" in options) {
          console.warn("Passing email or phoneNumber is not required for Magic Connect");
        }
        await magic.wallet.connectWithUI();
      } else {
        if ("oauthProvider" in options) {
          await magic.oauth.loginWithRedirect({
            provider: options.oauthProvider,
            redirectURI: this.oauthRedirectURI || window.location.href
          });
          await new Promise((res) => {
            setTimeout(res, 1e4);
          });
        } else if ("email" in options) {
          await magic.auth.loginWithMagicLink({
            email: options.email,
            showUI: true
          });
        } else if ("phoneNumber" in options) {
          await magic.auth.loginWithSMS({
            phoneNumber: options.phoneNumber
          });
        } else {
          throw new Error("Invalid options: Either provide and email, phoneNumber or oauthProvider when using Magic Auth");
        }
      }
      const signer = await this.getSigner();
      let account = await signer.getAddress();
      if (!account.startsWith("0x")) {
        account = `0x${account}`;
      }
      return {
        account,
        chain: {
          id: chainId,
          unsupported: false
        },
        provider
      };
    } catch (error) {
      console.error(error);
      throw new Error("Something went wrong");
    }
  }
  async getChainId() {
    var _a;
    const networkOptions = (_a = this.magicSdkConfiguration) == null ? void 0 : _a.network;
    if (typeof networkOptions === "object") {
      const chainID = networkOptions.chainId;
      if (chainID) {
        return normalizeChainId(chainID);
      }
    }
    throw new Error("Chain ID is not defined");
  }
  initializeMagicSDK() {
    let {
      chainId
    } = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
    const options = {
      ...this.magicSdkConfiguration,
      extensions: [new Y()]
    };
    if (chainId) {
      const chain = this.chains.find((c) => c.chainId === chainId);
      if (chain) {
        options.network = {
          rpcUrl: chain.rpc[0] || "",
          // TODO handle empty RPC array
          chainId: chain.chainId
        };
      }
    }
    this.magicSDK = new bt(this.magicOptions.apiKey, options);
    this.provider = this.magicSDK.rpcProvider;
    return this.magicSDK;
  }
  getMagicSDK() {
    if (!this.magicSDK) {
      return this.initializeMagicSDK();
    }
    return this.magicSDK;
  }
  async setupListeners() {
    const provider = await this.getProvider();
    provider.on("accountsChanged", this.onAccountsChanged);
    provider.on("chainChanged", this.onChainChanged);
    provider.on("disconnect", this.onDisconnect);
  }
  async switchChain(chainId) {
    const chain = this.chains.find((c) => c.chainId === chainId);
    if (!chain) {
      throw new Error("Chain not found");
    }
    if (_classPrivateFieldGet(this, _connectedChainId) !== chainId) {
      this.initializeMagicSDK({
        chainId
      });
    }
    return chain;
  }
};
export {
  MagicAuthConnector,
  MagicBaseConnector
};
//# sourceMappingURL=thirdweb-dev-wallets-evm-connectors-magic.browser.esm-BGPJSIT6.js.map
