import {
  require_axios,
  require_dist,
  require_src,
  require_src2,
  require_src3
} from "./chunk-VQFCD3LF.js";
import "./chunk-J3675CHT.js";
import {
  CHAIN_ID_TO_GNOSIS_SERVER_URL
} from "./chunk-OKRZ7UBF.js";
import {
  Connector
} from "./chunk-YVNWQO32.js";
import {
  _defineProperty
} from "./chunk-M52NFQDC.js";
import "./chunk-SXLQGVQL.js";
import "./chunk-YVVOYWOS.js";
import "./chunk-VP554X2I.js";
import "./chunk-OJYKRRB6.js";
import "./chunk-QJWU7UES.js";
import "./chunk-LMS4WD7T.js";
import {
  ethers_exports,
  init_lib as init_lib3,
  init_lib7 as init_lib5,
  lib_exports as lib_exports3
} from "./chunk-FSHZLPV2.js";
import {
  init_lib13 as init_lib4,
  init_lib3 as init_lib,
  init_lib7 as init_lib2,
  lib_exports12 as lib_exports4,
  lib_exports3 as lib_exports,
  lib_exports7 as lib_exports2
} from "./chunk-LXGF3WSV.js";
import "./chunk-HBS2L7KZ.js";
import "./chunk-JCGZRZHH.js";
import {
  init_shim
} from "./chunk-DLIX7YGU.js";
import {
  __commonJS,
  __toCommonJS,
  __toESM
} from "./chunk-EUIKE2YQ.js";

// node_modules/@thirdweb-dev/react/node_modules/@safe-global/safe-ethers-adapters/dist/src/service.js
var require_service = __commonJS({
  "node_modules/@thirdweb-dev/react/node_modules/@safe-global/safe-ethers-adapters/dist/src/service.js"(exports) {
    "use strict";
    init_shim();
    var __importDefault = exports && exports.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.SafeService = void 0;
    var bignumber_1 = (init_lib(), __toCommonJS(lib_exports));
    var axios_1 = __importDefault(require_axios());
    var SafeService2 = class {
      constructor(serviceUrl, network) {
        this.serviceUrl = serviceUrl;
        this.network = network !== null && network !== void 0 ? network : axios_1.default;
      }
      /**
       * Estimates a Safe transaction
       *
       * @param safe - Address of the Safe for which this transaction should be estimated
       * @param safeTx - Safe transaction that should be estimated for execution
       * @returns A big number representing the safeTxGas for the passed Safe transaction
       */
      async estimateSafeTx(safe, safeTx) {
        const url = `${this.serviceUrl}/api/v1/safes/${safe}/multisig-transactions/estimations/`;
        const resp = await this.network.post(url, safeTx);
        return bignumber_1.BigNumber.from(resp.data.safeTxGas);
      }
      /**
       * Load details for a Safe transaction
       *
       * @param safeTxHash - Hash of the Safe transaction
       * @returns A `SafeTxDetails` object that contains the details of a Safe transaction
       */
      async getSafeTxDetails(safeTxHash) {
        const url = `${this.serviceUrl}/api/v1/multisig-transactions/${safeTxHash}`;
        const resp = await this.network.get(url);
        return resp.data;
      }
      /**
       * Propose a new Safe transaction to the service
       *
       * @param safeAddress - Address of the Safe for which this transaction should be proposed
       * @param safeTxHash - Hash of the Safe transaction
       * @param safeTx - Safe transaction that should be proposed
       * @param signature - Signature of an owner or a delegate of an owner of the specified Safe to authorize the proposal
       * @returns The hash of the Safe transaction that has been proposed
       */
      async proposeTx(safeAddress, safeTxHash, safeTx, signature) {
        const url = `${this.serviceUrl}/api/v1/safes/${safeAddress}/multisig-transactions/`;
        const data = {
          ...safeTx.data,
          contractTransactionHash: safeTxHash,
          sender: signature.signer,
          signature: signature.data
        };
        const resp = await this.network.post(url, data);
        return resp.data;
      }
    };
    exports.SafeService = SafeService2;
  }
});

// node_modules/@thirdweb-dev/react/node_modules/@safe-global/safe-ethers-adapters/dist/src/utils.js
var require_utils = __commonJS({
  "node_modules/@thirdweb-dev/react/node_modules/@safe-global/safe-ethers-adapters/dist/src/utils.js"(exports) {
    "use strict";
    init_shim();
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.mapReceipt = exports.createLibInterface = exports.createLibAddress = exports.createLibDeployment = void 0;
    var abi_1 = (init_lib3(), __toCommonJS(lib_exports3));
    var address_1 = (init_lib2(), __toCommonJS(lib_exports2));
    var safe_deployments_1 = require_dist();
    exports.createLibDeployment = (0, safe_deployments_1.getCreateCallDeployment)();
    exports.createLibAddress = exports.createLibDeployment.defaultAddress;
    exports.createLibInterface = new abi_1.Interface(exports.createLibDeployment.abi);
    var mapStatus = (receipt) => {
      const success = receipt.logs.find((log) => log.topics[0] === "0x442e715f626346e8c54381002da614f62bee8d27386535b2521ec8540898556e");
      return !!success ? 1 : 0;
    };
    var mapContractAddress = (receipt, safeTx) => {
      if (safeTx.to.toLowerCase() === exports.createLibAddress.toLowerCase()) {
        const creationLog = receipt.logs.find((log) => log.topics[0] === "0x4db17dd5e4732fb6da34a148104a592783ca119a1e7bb8829eba6cbadef0b511");
        if (creationLog)
          return (0, address_1.getAddress)("0x" + creationLog.data.slice(creationLog.data.length - 40));
      }
      return receipt.contractAddress;
    };
    var mapReceipt = (receipt, safeTx) => {
      receipt.status = mapStatus(receipt);
      receipt.contractAddress = mapContractAddress(receipt, safeTx);
      return receipt;
    };
    exports.mapReceipt = mapReceipt;
  }
});

// node_modules/@thirdweb-dev/react/node_modules/@safe-global/safe-ethers-adapters/dist/src/signer.js
var require_signer = __commonJS({
  "node_modules/@thirdweb-dev/react/node_modules/@safe-global/safe-ethers-adapters/dist/src/signer.js"(exports) {
    "use strict";
    init_shim();
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.SafeEthersSigner = void 0;
    var abstract_signer_1 = (init_lib4(), __toCommonJS(lib_exports4));
    var bignumber_1 = (init_lib(), __toCommonJS(lib_exports));
    var safe_core_sdk_types_1 = require_src();
    var utils_1 = require_utils();
    var sleep = (duration) => new Promise((resolve) => setTimeout(resolve, duration));
    var SafeEthersSigner2 = class extends abstract_signer_1.VoidSigner {
      /**
       * Creates an instance of the SafeEthersSigner.
       * @param safe - Safe that should be used
       * @param service - Services to which the transactions should be proposed to
       * @param provider - (Optional) Provider that should be used for blockchain interactions. By default the provider from the signer is used.
       * @param options - (Optional) Additional options (e.g. polling delay when waiting for a transaction to be mined)
       * @returns The SafeEthersSigner instance
       */
      constructor(safe, service, provider, options) {
        super(safe.getAddress(), provider);
        this.service = service;
        this.safe = safe;
        this.options = options;
      }
      async buildTransactionResponse(safeTxHash, safeTx) {
        const connectedSafe = await this.safe;
        const connectedService = this.service;
        return {
          to: safeTx.to,
          value: bignumber_1.BigNumber.from(safeTx.value),
          data: safeTx.data,
          operation: safeTx.operation,
          gasLimit: bignumber_1.BigNumber.from(safeTx.safeTxGas),
          gasPrice: bignumber_1.BigNumber.from(0),
          nonce: safeTx.nonce,
          chainId: await connectedSafe.getChainId(),
          hash: safeTxHash,
          from: this.address,
          confirmations: 0,
          wait: async (confirmations) => {
            var _a, _b;
            while (true) {
              try {
                const txDetails = await connectedService.getSafeTxDetails(safeTxHash);
                if (txDetails.transactionHash) {
                  this._checkProvider("sendTransaction");
                  const receipt = await this.provider.waitForTransaction(txDetails.transactionHash, confirmations);
                  return (0, utils_1.mapReceipt)(receipt, safeTx);
                }
              } catch (e) {
              }
              await sleep((_b = (_a = this.options) === null || _a === void 0 ? void 0 : _a.pollingDelay) !== null && _b !== void 0 ? _b : 5e3);
            }
          }
        };
      }
      /**
       * Populates all fields in a transaction, signs it and sends it to the Safe transaction service
       *
       * @param transaction - The transaction what should be send
       * @returns A promise that resolves to a SafeTransactionReponse, that contains all the information of the transaction.
       */
      async sendTransaction(transaction) {
        var _a, _b, _c;
        const tx = await transaction;
        let operation = safe_core_sdk_types_1.OperationType.Call;
        let to = await tx.to;
        let data = (_b = (_a = await tx.data) === null || _a === void 0 ? void 0 : _a.toString()) !== null && _b !== void 0 ? _b : "0x";
        let value = bignumber_1.BigNumber.from((_c = await tx.value) !== null && _c !== void 0 ? _c : 0);
        if (!to) {
          to = utils_1.createLibAddress;
          data = utils_1.createLibInterface.encodeFunctionData("performCreate", [value, data]);
          value = bignumber_1.BigNumber.from(0);
          operation = safe_core_sdk_types_1.OperationType.DelegateCall;
        }
        const baseTx = {
          to,
          data,
          value: value.toString(),
          operation
        };
        const safeTxGas = await this.service.estimateSafeTx(this.address, baseTx);
        const connectedSafe = await this.safe;
        const safeTransactionData = {
          ...baseTx,
          safeTxGas: safeTxGas.toNumber()
        };
        const safeTx = await connectedSafe.createTransaction({ safeTransactionData });
        const safeTxHash = await connectedSafe.getTransactionHash(safeTx);
        const signature = await connectedSafe.signTransactionHash(safeTxHash);
        await this.service.proposeTx(this.address, safeTxHash, safeTx, signature);
        return this.buildTransactionResponse(safeTxHash, safeTx.data);
      }
    };
    exports.SafeEthersSigner = SafeEthersSigner2;
  }
});

// node_modules/@thirdweb-dev/react/node_modules/@safe-global/safe-ethers-adapters/dist/src/index.js
var require_src4 = __commonJS({
  "node_modules/@thirdweb-dev/react/node_modules/@safe-global/safe-ethers-adapters/dist/src/index.js"(exports) {
    "use strict";
    init_shim();
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      o[k2] = m[k];
    });
    var __exportStar = exports && exports.__exportStar || function(m, exports2) {
      for (var p in m)
        if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports2, p))
          __createBinding(exports2, m, p);
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    __exportStar(require_service(), exports);
    __exportStar(require_signer(), exports);
  }
});

// node_modules/@thirdweb-dev/react/node_modules/@thirdweb-dev/wallets/evm/connectors/safe/dist/thirdweb-dev-wallets-evm-connectors-safe.browser.esm.js
init_shim();
init_lib5();
var import_safe_ethers_adapters = __toESM(require_src4());
var import_safe_core_sdk = __toESM(require_src2());
var import_safe_ethers_lib = __toESM(require_src3());
var CHAIN_ID_TO_SIGN_MESSAGE_LIB_ADDRESS = {
  // mainnet
  1: "0xA65387F16B013cf2Af4605Ad8aA5ec25a2cbA3a2",
  // polygon
  137: "0xA65387F16B013cf2Af4605Ad8aA5ec25a2cbA3a2",
  // bsc
  56: "0xA65387F16B013cf2Af4605Ad8aA5ec25a2cbA3a2",
  // arbitrum
  42161: "0xA65387F16B013cf2Af4605Ad8aA5ec25a2cbA3a2",
  // aurora
  1313161554: "0xA65387F16B013cf2Af4605Ad8aA5ec25a2cbA3a2",
  // avalanche
  43114: "0x98FFBBF51bb33A056B08ddf711f289936AafF717",
  // optimism
  10: "0x98FFBBF51bb33A056B08ddf711f289936AafF717",
  // base goerli
  84531: "0x98FFBBF51bb33A056B08ddf711f289936AafF717",
  // celo
  42220: "0x98FFBBF51bb33A056B08ddf711f289936AafF717",
  // goerli
  5: "0x58FCe385Ed16beB4BCE49c8DF34c7d6975807520",
  // gnosis chain
  100: "0x58FCe385Ed16beB4BCE49c8DF34c7d6975807520"
};
var SIGN_MESSAGE_LIB_ABI = [{
  anonymous: false,
  inputs: [{
    indexed: true,
    internalType: "bytes32",
    name: "msgHash",
    type: "bytes32"
  }],
  name: "SignMsg",
  type: "event"
}, {
  inputs: [{
    internalType: "bytes",
    name: "message",
    type: "bytes"
  }],
  name: "getMessageHash",
  outputs: [{
    internalType: "bytes32",
    name: "",
    type: "bytes32"
  }],
  stateMutability: "view",
  type: "function"
}, {
  inputs: [{
    internalType: "bytes",
    name: "_data",
    type: "bytes"
  }],
  name: "signMessage",
  outputs: [],
  stateMutability: "nonpayable",
  type: "function"
}];
var __IS_SERVER__ = false;
var SafeConnector = class _SafeConnector extends Connector {
  // config
  // private options: SafeOptions;
  constructor() {
    super();
    _defineProperty(this, "supportedChains", _SafeConnector.supportedChains);
    _defineProperty(this, "id", "safe-wallet");
    _defineProperty(this, "ready", !__IS_SERVER__);
    _defineProperty(this, "name", "Safe Wallet");
    {
      this.ready = true;
    }
  }
  async connect(args) {
    if (!(args.chain.chainId in CHAIN_ID_TO_GNOSIS_SERVER_URL)) {
      throw new Error("Chain not supported by Safe");
    }
    this.safeSigner = await this.createSafeSigner(args);
    return await this.getAddress();
  }
  async createSafeSigner(params) {
    this.personalWallet = params.personalWallet;
    const signer = await params.personalWallet.getSigner();
    const safeAddress = params.safeAddress;
    const safeChainId = params.chain.chainId;
    if (!signer) {
      throw new Error("cannot create Gnosis Safe signer without a personal signer");
    }
    const signerChainId = await signer.getChainId();
    if (signerChainId !== safeChainId) {
      throw new Error("chainId of personal signer has to match safe chainId");
    }
    if (!safeAddress) {
      throw new Error("safeAddress is required");
    }
    if (!safeChainId) {
      throw new Error("safeChainId is required");
    }
    const serverUrl = CHAIN_ID_TO_GNOSIS_SERVER_URL[safeChainId];
    const signMessageLibAddress = CHAIN_ID_TO_SIGN_MESSAGE_LIB_ADDRESS[safeChainId];
    if (!serverUrl || !signMessageLibAddress) {
      throw new Error("Chain not supported");
    }
    const ethAdapter = new import_safe_ethers_lib.default({
      ethers: ethers_exports,
      signerOrProvider: signer
    });
    const safe = await import_safe_core_sdk.default.create({
      ethAdapter,
      safeAddress
    });
    const service = new import_safe_ethers_adapters.SafeService(serverUrl);
    const safeSigner = new import_safe_ethers_adapters.SafeEthersSigner(safe, service, signer.provider);
    safeSigner.signMessage = async (message) => {
      var _a;
      const contract = new ethers_exports.BaseContract(signMessageLibAddress, SIGN_MESSAGE_LIB_ABI);
      const data = contract.interface.encodeFunctionData("signMessage", [ethers_exports.utils.hashMessage(message)]);
      const to = signMessageLibAddress;
      const value = "0";
      const operation = 1;
      const safeTxGas = 5e4;
      const baseGas = 5e4;
      const gasPrice = 0;
      const gasToken = ethers_exports.constants.AddressZero;
      const refundReceiver = ethers_exports.constants.AddressZero;
      const safeTx = await safe.createTransaction({
        safeTransactionData: {
          to,
          value,
          operation,
          data,
          baseGas,
          safeTxGas,
          gasPrice,
          gasToken,
          refundReceiver
        }
      });
      const safeTxHash = await safe.getTransactionHash(safeTx);
      const safeSignature = await safe.signTransactionHash(safeTxHash);
      await service.proposeTx(safe.getAddress(), safeTxHash, safeTx, safeSignature);
      while (true) {
        try {
          const txDetails = await service.getSafeTxDetails(safeTxHash);
          if (txDetails.transactionHash) {
            await ((_a = signer.provider) == null ? void 0 : _a.waitForTransaction(txDetails.transactionHash));
            break;
          }
        } catch (e) {
        }
        await new Promise((resolve) => setTimeout(resolve, 5e3));
      }
      return "0x";
    };
    this.previousConnector = params.personalWallet;
    return safeSigner;
  }
  async disconnect() {
    this.safeSigner = void 0;
    this.previousConnector = void 0;
    return void 0;
  }
  async getAddress() {
    const signer = await this.getSigner();
    return await signer.getAddress();
  }
  async getChainId() {
    return (await this.getSigner()).getChainId();
  }
  async getProvider() {
    const provider = (await this.getSigner()).provider;
    if (!provider) {
      throw new Error("No provider available");
    }
    return provider;
  }
  async getSigner() {
    if (!this.safeSigner) {
      throw new Error("not connected - please call connect() first");
    }
    return this.safeSigner;
  }
  async isConnected() {
    try {
      const account = await this.getAddress();
      return !!account;
    } catch (e) {
      return false;
    }
  }
  onAccountsChanged(accounts) {
    if (accounts.length === 0) {
      this.emit("disconnect");
    } else {
      if (accounts[0]) {
        this.emit("change", {
          account: ethers_exports.utils.getAddress(accounts[0])
        });
      }
    }
  }
  onDisconnect() {
    this.emit("disconnect");
  }
  switchChain() {
    throw new Error("Safe connector does not support switching chains");
  }
  updateChains() {
  }
  async setupListeners() {
  }
};
_defineProperty(SafeConnector, "supportedChains", Object.keys(CHAIN_ID_TO_GNOSIS_SERVER_URL));
export {
  SafeConnector
};
//# sourceMappingURL=thirdweb-dev-wallets-evm-connectors-safe.browser.esm-NSWPICCB.js.map
