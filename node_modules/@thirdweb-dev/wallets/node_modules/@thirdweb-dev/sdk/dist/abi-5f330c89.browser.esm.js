import { a8 as BigNumberTransformSchema, aa as AddressOrEnsSchema, a6 as BigNumberSchema, a7 as BigNumberishSchema, bH as hasMatchingAbi, e as AbiSchema, dr as extractFeatures, bV as detectFeatures, ch as getCreate2FactoryAddress, cw as computeDeploymentInfo, cf as isContractDeployed, cj as getInitBytecodeWithSalt } from './contract-metadata-88f06ef9.browser.esm.js';
import { z } from 'zod';
import { A as AmountSchema, C as CommonNFTOutput, b as CommonNFTInput, N as NFTInputOrUriSchema } from './QueryParams-7d9473b5.browser.esm.js';
import { utils, BigNumber } from 'ethers';
import invariant from 'tiny-invariant';
import { GENERATED_ABI } from '@thirdweb-dev/generated-abis';

const PropertiesInput = z.object({}).catchall(z.union([BigNumberTransformSchema, z.unknown()]));

/**
 * @internal
 */
const OptionalPropertiesInput = z.union([z.array(PropertiesInput), PropertiesInput]).optional();

/**
 * @internal
 */
const TokenMintInputSchema = z.object({
  toAddress: AddressOrEnsSchema,
  amount: AmountSchema
});

/**
 * @public
 */

/**
 * @internal
 */
const EditionMetadataOutputSchema = z.object({
  supply: BigNumberSchema,
  metadata: CommonNFTOutput
});

/**
 * @internal
 */
const EditionMetadataWithOwnerOutputSchema = EditionMetadataOutputSchema.extend({
  owner: z.string(),
  quantityOwned: BigNumberSchema
});

/**
 * @internal
 */
const EditionMetadataInputSchema = z.object({
  supply: BigNumberishSchema,
  metadata: CommonNFTInput
});

/**
 * @internal
 */
const EditionMetadataInputOrUriSchema = z.object({
  supply: BigNumberishSchema,
  metadata: NFTInputOrUriSchema
});

/**
 * @public
 */

let ProposalState = /*#__PURE__*/function (ProposalState) {
  ProposalState[ProposalState["Pending"] = 0] = "Pending";
  ProposalState[ProposalState["Active"] = 1] = "Active";
  ProposalState[ProposalState["Canceled"] = 2] = "Canceled";
  ProposalState[ProposalState["Defeated"] = 3] = "Defeated";
  ProposalState[ProposalState["Succeeded"] = 4] = "Succeeded";
  ProposalState[ProposalState["Queued"] = 5] = "Queued";
  ProposalState[ProposalState["Expired"] = 6] = "Expired";
  ProposalState[ProposalState["Executed"] = 7] = "Executed";
  return ProposalState;
}({});

/**
 * @internal
 * @param contractWrapper
 * @param abi
 * @returns
 */
function matchesPrebuiltAbi(contractWrapper, abi) {
  return hasMatchingAbi(AbiSchema.parse(contractWrapper.abi || []), [abi]);
}

/**
 * Return all the detected features in the abi
 * @param abi - parsed array of abi entries
 * @returns array of all detected extensions with full information on each feature
 * @internal
 * @deprecated use getAllDetectedExtensions instead
 */
function getAllDetectedFeatures(abi) {
  const features = [];
  extractFeatures(detectFeatures(abi), features);
  return features;
}

/**
 * Return all the detected extensions in the abi
 * @param abi - parsed array of abi entries
 * @returns array of all detected extensions with full information on each feature
 * @public
 */
function getAllDetectedExtensions(abi) {
  return getAllDetectedFeatures(abi).map(f => ({
    ...f,
    extensions: f.features
  }));
}

async function normalizeAmount(contractWrapper, amount) {
  const decimals = await contractWrapper.readContract.decimals();
  return utils.parseUnits(AmountSchema.parse(amount), decimals);
}

function toEther(amount) {
  return utils.formatEther(amount);
}

function toUnits(amount, decimals) {
  return utils.parseUnits(AmountSchema.parse(amount), decimals);
}

function toDisplayValue(amount, decimals) {
  return utils.formatUnits(amount, decimals);
}

/**
 *
 * @internal
 * @param provider
 * @param storage
 * @param create2Factory
 */
async function computeNativeTokenAddress(provider, storage, create2Factory) {
  if (!create2Factory) {
    create2Factory = await getCreate2FactoryAddress(provider);
  }
  return (await computeDeploymentInfo("infra", provider, storage, create2Factory, {
    contractName: "WETH9"
  })).transaction.predictedAddress;
}

/**
 * Deploy a contract at a deterministic address, using Create2 method
 * Address depends on the Create2 factory address.
 *
 * @public
 *
 * @param singer
 * @param bytecode
 * @param encodedArgs
 * @param create2FactoryAddress
 */
async function deployContractDeterministicRaw(signer, bytecode, encodedArgs, create2FactoryAddress, options, predictedAddress) {
  let gasLimit = arguments.length > 6 && arguments[6] !== undefined ? arguments[6] : 7000000;
  // Check if the implementation contract is already deployed
  invariant(signer.provider, "Provider required");
  const contractDeployed = predictedAddress ? await isContractDeployed(predictedAddress, signer.provider) : false;
  if (!contractDeployed) {
    console.debug(`deploying contract via create2 factory at: ${predictedAddress}`);
    const initBytecodeWithSalt = getInitBytecodeWithSalt(bytecode, encodedArgs);
    let tx = {
      to: create2FactoryAddress,
      data: initBytecodeWithSalt
    };
    try {
      await signer.estimateGas(tx);
    } catch (e) {
      console.debug("error estimating gas while deploying prebuilt: ", e);
      tx.gasLimit = BigNumber.from(gasLimit);
    }
    await (await signer.sendTransaction(tx)).wait();
  }
}

function getCachedAbiForContract(address) {
  if (address in GENERATED_ABI) {
    return GENERATED_ABI[address];
  }
  return undefined;
}

export { EditionMetadataOutputSchema as E, OptionalPropertiesInput as O, ProposalState as P, TokenMintInputSchema as T, EditionMetadataWithOwnerOutputSchema as a, EditionMetadataInputSchema as b, EditionMetadataInputOrUriSchema as c, toUnits as d, toDisplayValue as e, getAllDetectedFeatures as f, getCachedAbiForContract as g, getAllDetectedExtensions as h, computeNativeTokenAddress as i, deployContractDeterministicRaw as j, matchesPrebuiltAbi as m, normalizeAmount as n, toEther as t };
