'use strict';

var contractMetadata = require('./contract-metadata-1b4bcf9e.cjs.prod.js');
var zod = require('zod');
var QueryParams = require('./QueryParams-6754e8c0.cjs.prod.js');
var ethers = require('ethers');
var invariant = require('tiny-invariant');
var generatedAbis = require('@thirdweb-dev/generated-abis');

function _interopDefault (e) { return e && e.__esModule ? e : { 'default': e }; }

var invariant__default = /*#__PURE__*/_interopDefault(invariant);

const PropertiesInput = zod.z.object({}).catchall(zod.z.union([contractMetadata.BigNumberTransformSchema, zod.z.unknown()]));

/**
 * @internal
 */
const OptionalPropertiesInput = zod.z.union([zod.z.array(PropertiesInput), PropertiesInput]).optional();

/**
 * @internal
 */
const TokenMintInputSchema = zod.z.object({
  toAddress: contractMetadata.AddressOrEnsSchema,
  amount: QueryParams.AmountSchema
});

/**
 * @public
 */

/**
 * @internal
 */
const EditionMetadataOutputSchema = zod.z.object({
  supply: contractMetadata.BigNumberSchema,
  metadata: QueryParams.CommonNFTOutput
});

/**
 * @internal
 */
const EditionMetadataWithOwnerOutputSchema = EditionMetadataOutputSchema.extend({
  owner: zod.z.string(),
  quantityOwned: contractMetadata.BigNumberSchema
});

/**
 * @internal
 */
const EditionMetadataInputSchema = zod.z.object({
  supply: contractMetadata.BigNumberishSchema,
  metadata: QueryParams.CommonNFTInput
});

/**
 * @internal
 */
const EditionMetadataInputOrUriSchema = zod.z.object({
  supply: contractMetadata.BigNumberishSchema,
  metadata: QueryParams.NFTInputOrUriSchema
});

/**
 * @public
 */

let ProposalState = /*#__PURE__*/function (ProposalState) {
  ProposalState[ProposalState["Pending"] = 0] = "Pending";
  ProposalState[ProposalState["Active"] = 1] = "Active";
  ProposalState[ProposalState["Canceled"] = 2] = "Canceled";
  ProposalState[ProposalState["Defeated"] = 3] = "Defeated";
  ProposalState[ProposalState["Succeeded"] = 4] = "Succeeded";
  ProposalState[ProposalState["Queued"] = 5] = "Queued";
  ProposalState[ProposalState["Expired"] = 6] = "Expired";
  ProposalState[ProposalState["Executed"] = 7] = "Executed";
  return ProposalState;
}({});

/**
 * @internal
 * @param contractWrapper
 * @param abi
 * @returns
 */
function matchesPrebuiltAbi(contractWrapper, abi) {
  return contractMetadata.hasMatchingAbi(contractMetadata.AbiSchema.parse(contractWrapper.abi || []), [abi]);
}

/**
 * Return all the detected features in the abi
 * @param abi - parsed array of abi entries
 * @returns array of all detected extensions with full information on each feature
 * @internal
 * @deprecated use getAllDetectedExtensions instead
 */
function getAllDetectedFeatures(abi) {
  const features = [];
  contractMetadata.extractFeatures(contractMetadata.detectFeatures(abi), features);
  return features;
}

/**
 * Return all the detected extensions in the abi
 * @param abi - parsed array of abi entries
 * @returns array of all detected extensions with full information on each feature
 * @public
 */
function getAllDetectedExtensions(abi) {
  return getAllDetectedFeatures(abi).map(f => ({
    ...f,
    extensions: f.features
  }));
}

async function normalizeAmount(contractWrapper, amount) {
  const decimals = await contractWrapper.readContract.decimals();
  return ethers.utils.parseUnits(QueryParams.AmountSchema.parse(amount), decimals);
}

function toEther(amount) {
  return ethers.utils.formatEther(amount);
}

function toUnits(amount, decimals) {
  return ethers.utils.parseUnits(QueryParams.AmountSchema.parse(amount), decimals);
}

function toDisplayValue(amount, decimals) {
  return ethers.utils.formatUnits(amount, decimals);
}

/**
 *
 * @internal
 * @param provider
 * @param storage
 * @param create2Factory
 */
async function computeNativeTokenAddress(provider, storage, create2Factory) {
  if (!create2Factory) {
    create2Factory = await contractMetadata.getCreate2FactoryAddress(provider);
  }
  return (await contractMetadata.computeDeploymentInfo("infra", provider, storage, create2Factory, {
    contractName: "WETH9"
  })).transaction.predictedAddress;
}

/**
 * Deploy a contract at a deterministic address, using Create2 method
 * Address depends on the Create2 factory address.
 *
 * @public
 *
 * @param singer
 * @param bytecode
 * @param encodedArgs
 * @param create2FactoryAddress
 */
async function deployContractDeterministicRaw(signer, bytecode, encodedArgs, create2FactoryAddress, options, predictedAddress) {
  let gasLimit = arguments.length > 6 && arguments[6] !== undefined ? arguments[6] : 7000000;
  // Check if the implementation contract is already deployed
  invariant__default["default"](signer.provider, "Provider required");
  const contractDeployed = predictedAddress ? await contractMetadata.isContractDeployed(predictedAddress, signer.provider) : false;
  if (!contractDeployed) {
    console.debug(`deploying contract via create2 factory at: ${predictedAddress}`);
    const initBytecodeWithSalt = contractMetadata.getInitBytecodeWithSalt(bytecode, encodedArgs);
    let tx = {
      to: create2FactoryAddress,
      data: initBytecodeWithSalt
    };
    try {
      await signer.estimateGas(tx);
    } catch (e) {
      console.debug("error estimating gas while deploying prebuilt: ", e);
      tx.gasLimit = ethers.BigNumber.from(gasLimit);
    }
    await (await signer.sendTransaction(tx)).wait();
  }
}

function getCachedAbiForContract(address) {
  if (address in generatedAbis.GENERATED_ABI) {
    return generatedAbis.GENERATED_ABI[address];
  }
  return undefined;
}

exports.EditionMetadataInputOrUriSchema = EditionMetadataInputOrUriSchema;
exports.EditionMetadataInputSchema = EditionMetadataInputSchema;
exports.EditionMetadataOutputSchema = EditionMetadataOutputSchema;
exports.EditionMetadataWithOwnerOutputSchema = EditionMetadataWithOwnerOutputSchema;
exports.OptionalPropertiesInput = OptionalPropertiesInput;
exports.ProposalState = ProposalState;
exports.TokenMintInputSchema = TokenMintInputSchema;
exports.computeNativeTokenAddress = computeNativeTokenAddress;
exports.deployContractDeterministicRaw = deployContractDeterministicRaw;
exports.getAllDetectedExtensions = getAllDetectedExtensions;
exports.getAllDetectedFeatures = getAllDetectedFeatures;
exports.getCachedAbiForContract = getCachedAbiForContract;
exports.matchesPrebuiltAbi = matchesPrebuiltAbi;
exports.normalizeAmount = normalizeAmount;
exports.toDisplayValue = toDisplayValue;
exports.toEther = toEther;
exports.toUnits = toUnits;
